[{"docID": "t5_2qhmr","qSentId": 53658,"question": "The Genetic Algorithm - Explained","aSentId": 53659,"answer": "Great post! Nice insight into the encoding aspect. This is somewhat obscure...\n\nWhat are the goals/interests of your blog? Are you following a roadmap? I recently started a similar one and wanted to match similarities.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53658,"question": "The Genetic Algorithm - Explained","aSentId": 53661,"answer": "What's there is pretty good!  \n\nWhat I think is missing is the connection between what the genome itself is for a problem and how it connects to a fitness function to get scored.\n\nA great explanation of one example is in Melanie Mitchell's \"Complexity, a Guided Tour\".  The scenario is a robot in a room that has walls and cans to pick up.  The genome has a position for each the robot senses (wall to north and west, no can at my location), and in each location is an action:  move N,W,S,E, try to pick up can.  A genome then gets scored by simulating the robot a number of turns using its genome.  It gets points for picking up cans and loses points for hitting walls.\n\nIt would be helpful to see some how the genome in a GA is the connection between the inputs and outputs of a model.  A simpler example might be using a GA to solve a linear regression.  The genome represents the coefficients, and the score could be SSE or R^2.  It's not the most efficient way to solve a linear regression but it's an easy example to illustrate.\n\n","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53658,"question": "The Genetic Algorithm - Explained","aSentId": 53663,"answer": "Great figures! It would be neat to also include a figure about mutation.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53667,"question": "The 'must have' library of any computer scientist","aSentId": 53668,"answer": "That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\nClassics are tomes which have had a major influence on computer science. I have about half the books there, and even if they have dated, the principles themselves don't.\n\nFor example, the Smalltalk-80 \"blue book\" was responsible for introducing object-oriented programming to the world at large. I just wish more languages had been influenced by that than by C++.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53669,"question": "That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\nClassics are tomes which have had a major influence on computer science. I have about half the books there, and even if they have dated, the principles themselves don't.\n\nFor example, the Smalltalk-80 \"blue book\" was responsible for introducing object-oriented programming to the world at large. I just wish more languages had been influenced by that than by C++.","aSentId": 53670,"answer": "Agreed. Beautiful books are bought because they contain all the information that many books that came after them collectively contain, but they are antiques, not essentials. \n\nI have a few of the books listed there. Sometimes I enjoy rediscovering the core principles through the generations of their descendent influence on my own. It makes me feel smarter in a way that I know is continuously fooling my self, because the core information already exists, and it is only a reduction of terms that leads to revealing it. \n\nBut this kind of hunt opened a question to me of \"what kind of information does not exist in any book and can not be derived from any book\" - the kind of information that can not be found through data comparison and the simplification of terms - that still has to do with computation? \n\nAnd then I found something creative, in that. \n\nI still want the entire list of books, but that's mostly materialism. I read my old books the same way I read my new books, and then for some reason, I'm surprised when wikipedia/hackernews/reddit agrees with me. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53669,"question": "That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\nClassics are tomes which have had a major influence on computer science. I have about half the books there, and even if they have dated, the principles themselves don't.\n\nFor example, the Smalltalk-80 \"blue book\" was responsible for introducing object-oriented programming to the world at large. I just wish more languages had been influenced by that than by C++.","aSentId": 53672,"answer": "&gt; That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\n\nYou are absolutely right. Sorry for my poor phrasing.\n","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53667,"question": "The 'must have' library of any computer scientist","aSentId": 53674,"answer": "The results are based on a poll? Books ranging from 1958 to 1995 with some books about obsolete operating systems and programming languages that hardly anybody uses anymore. One book about \"human interface guidelines\", is that even CompSci? No book written by Donald Knuth or Sedgewick?\n\nNot completely disagreeing, but my choice of books would have been a lot different.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53667,"question": "The 'must have' library of any computer scientist","aSentId": 53676,"answer": "I'd say it's libc/glibc, boost and similar, but hey, whatever rocks your socks is fine by me. :-)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53680,"question": "/r/ConTalks - A new place to share interesting programming and tech talks, come join us!","aSentId": 53681,"answer": "I like it! Kinda sounds like a place for con-artists to share tricks though ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53682,"question": "I like it! Kinda sounds like a place for con-artists to share tricks though ","aSentId": 53683,"answer": "Subscribed, you should make a better description in the sidebar though. I hope it does well.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53684,"question": "Subscribed, you should make a better description in the sidebar though. I hope it does well.","aSentId": 53685,"answer": "Will do, I just created it on Sunday. I will put some effort into the sidebar/styling/wiki this week.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53682,"question": "I like it! Kinda sounds like a place for con-artists to share tricks though ","aSentId": 53687,"answer": "Haha, all the good names were taken.  r/techtalks, r/devtalks, etc.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53688,"question": "Haha, all the good names were taken.  r/techtalks, r/devtalks, etc.","aSentId": 53689,"answer": "Was r/conftalks taken? I guess someone might still think it's for CONFidence artists...","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53690,"question": "Was r/conftalks taken? I guess someone might still think it's for CONFidence artists...","aSentId": 53691,"answer": "haha, conftalks is still open, I was kind of following how all the conferences call themselves like DockerCon, LinuxCon, DefCon, etc.\n\n","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53682,"question": "I like it! Kinda sounds like a place for con-artists to share tricks though ","aSentId": 53693,"answer": "After you mentioned it, I looked around for a subreddit like that.\nThe closest thing I could find was /r/Scams/\nIf you could actually get the Con Artist community to participate that would be pretty interesting.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53696,"question": "What are the current/future applications of operating systems particularly on devices like robots and drones, or other items like ovens etc?","aSentId": 53697,"answer": "Drones need to have some kind of Real Time system on board. If your UAV is heading towards a tree, you need to stop it *now*. Linux is not a Real Time kernel. Multirotors, in particular, need constant input to keep their flight stabilized. If Linux decides to write a log entry at the wrong time, it could easily send it spinning out of control.\n\nWhat you can do is have a hybrid approach where the control system is handled by a Real Time system, while additional smarts run on a secondary system running Linux. For instance, you might have OpenCV running with an attached camera to recognize objects.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53698,"question": "Drones need to have some kind of Real Time system on board. If your UAV is heading towards a tree, you need to stop it *now*. Linux is not a Real Time kernel. Multirotors, in particular, need constant input to keep their flight stabilized. If Linux decides to write a log entry at the wrong time, it could easily send it spinning out of control.\n\nWhat you can do is have a hybrid approach where the control system is handled by a Real Time system, while additional smarts run on a secondary system running Linux. For instance, you might have OpenCV running with an attached camera to recognize objects.","aSentId": 53699,"answer": "Well there is the RT kernel right?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53700,"question": "Well there is the RT kernel right?","aSentId": 53701,"answer": "One issue with the RT kernel is that it doesn't get updates nearly as frequently as it should. The most recent one is still on v3.14. Some features are pretty buggy too. I've had my system lock up USB devices randomly when I enable threadirqs. \n\nThe main issue is that companies aren't too keen on investing a lot of energy into it. So it doesn't get nearly as much funding as it needs to be successful. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53698,"question": "Drones need to have some kind of Real Time system on board. If your UAV is heading towards a tree, you need to stop it *now*. Linux is not a Real Time kernel. Multirotors, in particular, need constant input to keep their flight stabilized. If Linux decides to write a log entry at the wrong time, it could easily send it spinning out of control.\n\nWhat you can do is have a hybrid approach where the control system is handled by a Real Time system, while additional smarts run on a secondary system running Linux. For instance, you might have OpenCV running with an attached camera to recognize objects.","aSentId": 53703,"answer": "Let's be honest. Arm and Intel have a better architecture than a Motorola 6800. Therefore more languages, more libraries and faster development times.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53704,"question": "Let's be honest. Arm and Intel have a better architecture than a Motorola 6800. Therefore more languages, more libraries and faster development times.","aSentId": 53705,"answer": "What does the Motorola 6800 -- a chip released in 1975 -- have to do with this conversation?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53696,"question": "What are the current/future applications of operating systems particularly on devices like robots and drones, or other items like ovens etc?","aSentId": 53707,"answer": "While it is true that RTOS is key for many modular functions the really key organizational level is the network rather than any individual chip running an OS. So it's not really a question of \"THE\" OS because there could and should in most cases be multiple different types of software running on a distributed network of chips operating in their own sub-systems. \n\nThe control happens at the network level and CAN is the closest thing to an open machine network. Unfortunately even CAN is not really open. It's somewhat open but also very fractured because licensees tend to add proprietary features to keep their products incompatible with others. \n\nBut that's basically the answer: for devices the systemic control is so crucial it is integrated into the network architecture itself. Diverse firmware including familiar OS's operate within that heterogenous network. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53696,"question": "What are the current/future applications of operating systems particularly on devices like robots and drones, or other items like ovens etc?","aSentId": 53709,"answer": "&gt;why do we need OSes on drones\n\nCheck out /r/multicopter for a glance at the hobbyist culture around \"drones\" (most of them prefer \"multirotor\" or \"RC aircraft\"). It's remarkably similar to the open-source/hacker culture in many ways. Anyway, some of the potential applications of these aircraft will require custom software and that's easier to write if there's an OS abstracting some of the hardware away. Generally the actual flight controls are handled in hardware while systems like cameras and navigation can be done in software.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53712,"question": "Best APSP algorithm (undirected and directed graph)? Wikipedia says Thorup (undirected), however his paper says his algorithm is SSSP","aSentId": 53713,"answer": "The idea is that you run Thorup's algorithm V times, once for each vertex as the single source. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53714,"question": "The idea is that you run Thorup's algorithm V times, once for each vertex as the single source. ","aSentId": 53715,"answer": "Oh, that makes sense, I didn't realize that. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53717,"question": "Europeans: Which universities offer Undergrad Compsci programs in English?","aSentId": 53718,"answer": "Well there's the whole of the UK...","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53719,"question": "Well there's the whole of the UK...","aSentId": 53720,"answer": "Except for the some of the deliberately-awkward parts of Wales, and whatever it is they speak in Glasgow.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53719,"question": "Well there's the whole of the UK...","aSentId": 53722,"answer": "I thought they spoke British there :)?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53719,"question": "Well there's the whole of the UK...","aSentId": 53724,"answer": "Yes!  Come to Southampton,  I lost my last American (massive assumption on OP's nationality here) and need somebody else to torment with \"British Custom: Fact or Fiction\".\n\n(I'll give you the first one,  we don't really expect you to tip the bathroom cleaner with a penny on the sink)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53726,"question": "Using Computer Vision to Improve EEG Signals","aSentId": 53727,"answer": "/r/uiuc represent","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53729,"question": "What is garbage collection?","aSentId": 53730,"answer": "Rather than manually freeing memory, languages with garbage collection automatically free memory from now unused objects or other data.\n\nMost high level languages have it, lower level don't (C is the notable one here).\n\nIt can cause a momentary \"lag\" if collection happens at an inopportune time, e.g. during a smooth animation.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53729,"question": "What is garbage collection?","aSentId": 53732,"answer": "It tends to be language-specific, e.g. many languages specifically require the implementation to collect garbage automatically. It doesn't absolutely need to be, though, for instance there are GC libraries like boehm which you can use in conjunction with C/C++, and I think in principle e.g. a C/C++ implementation could ignore all calls to free() and instead collect garbage whenever it feels like doing so (although that would be somewhat redundant -- if the user has already explicitly specified when to free(), then that is most likely the best point in time to actually do it).\n\nGCs can do recycling, for instance javas VM will allocate a certain amount (e.g. a big array) of memory when initially started (but it can be expanded at runtime, if necessary) and then allocate memory from that space it has pre-allocated as the program running requires it. When an object is collected by the garbage-collector, that piece of data in the array is simply flagged as unused, and may be re-used for something else later (or parts of it may be.) Occasionally something called a \"compactification\" may have to happen, to avoid the memory becoming too fragmented.\n\nAlso, I think pretty much all functional languages require the implementation to provide a GC, or at least I have never seen a functional language that allowed the user to do explicit memory management (malloc() and free() are kind-of inherently side-effecty, so I think it's not obvious whether it would be possible to fit those well into the fabric of a functional language)\n\nGC has various advantages and disadvantages -- the advantages are that the user does not have to think about resource ownership (at least for memory -- for other resources, the user may still have to), and memory leaks don't occur as easily. On the downside, you are required to run some algorithm alongside your program that analyzes your heap constantly to figure out if any objects are not needed anymore, and if so, it frees them. This takes up CPU cycles, and makes your program less deterministic (you lose control over when memory is freed and when the garbage-collector does its job.) there are different garbage-collectors, some which emphasize throughput, some which emphasize low-latency. Some may even require to completely stop your program for an amount of time to analyze what is garbage and what is not. When performing some sort of operations where you create a lot of objects (e.g. maybe parsing XML or somesuch into a tree of nodes) the GC may drastically impact performance, compared to a solution where you pre-allocate the memory as precisely as possible beforehand. That's why e.g. many games do not rely on GC, and instead pre-allocate all the memory they need at load-time, and then use specialized allocator strategies (like linear allocators.)\n\nAnother, slightly more subtle issue that may arise from relying too much on garbage-collection is that many languages that rely on GC don't provide good primitives for managing resources and ownership, and/or people rely on the GC managing resources that it was not designed to handle or cannot handle optimally. One example is that many people embed lua in their program, a small and garbage-collected scripting-language. luas garbage-collector will look at the size of objects and the memory-pressure to figure out when and what it should collect. However, if you (as almost everyone does) create objects that have the bulk of their substance either on the C-side of things, or maybe even somewhere else entirely (for instance in GPU memory, in the case of graphical objects such as textures) the GC will only see them as maybe a single pointer, and thus not consider them particularly important to collect. That can mean that you may end up having gigabyte-sized objects lumping around in main memory or even video RAM, only because the garbage-collector doesn't think it's worth it to free them up in a timely manner. I'm not aware of a real solution for this kind of issue, one just has to be aware of it and be careful. In other languages (e.g. rust, modern(!) c++, et al) the language/runtime may give you better primitives to handle cases like this, ownership, et al, and/or the user may be more aware/exposed to these issues.\n\nSo in summary, GCs have various advantages and disadvantages, and are more and less appropriate depending on circumstances and the language they are used in.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53733,"question": "It tends to be language-specific, e.g. many languages specifically require the implementation to collect garbage automatically. It doesn't absolutely need to be, though, for instance there are GC libraries like boehm which you can use in conjunction with C/C++, and I think in principle e.g. a C/C++ implementation could ignore all calls to free() and instead collect garbage whenever it feels like doing so (although that would be somewhat redundant -- if the user has already explicitly specified when to free(), then that is most likely the best point in time to actually do it).\n\nGCs can do recycling, for instance javas VM will allocate a certain amount (e.g. a big array) of memory when initially started (but it can be expanded at runtime, if necessary) and then allocate memory from that space it has pre-allocated as the program running requires it. When an object is collected by the garbage-collector, that piece of data in the array is simply flagged as unused, and may be re-used for something else later (or parts of it may be.) Occasionally something called a \"compactification\" may have to happen, to avoid the memory becoming too fragmented.\n\nAlso, I think pretty much all functional languages require the implementation to provide a GC, or at least I have never seen a functional language that allowed the user to do explicit memory management (malloc() and free() are kind-of inherently side-effecty, so I think it's not obvious whether it would be possible to fit those well into the fabric of a functional language)\n\nGC has various advantages and disadvantages -- the advantages are that the user does not have to think about resource ownership (at least for memory -- for other resources, the user may still have to), and memory leaks don't occur as easily. On the downside, you are required to run some algorithm alongside your program that analyzes your heap constantly to figure out if any objects are not needed anymore, and if so, it frees them. This takes up CPU cycles, and makes your program less deterministic (you lose control over when memory is freed and when the garbage-collector does its job.) there are different garbage-collectors, some which emphasize throughput, some which emphasize low-latency. Some may even require to completely stop your program for an amount of time to analyze what is garbage and what is not. When performing some sort of operations where you create a lot of objects (e.g. maybe parsing XML or somesuch into a tree of nodes) the GC may drastically impact performance, compared to a solution where you pre-allocate the memory as precisely as possible beforehand. That's why e.g. many games do not rely on GC, and instead pre-allocate all the memory they need at load-time, and then use specialized allocator strategies (like linear allocators.)\n\nAnother, slightly more subtle issue that may arise from relying too much on garbage-collection is that many languages that rely on GC don't provide good primitives for managing resources and ownership, and/or people rely on the GC managing resources that it was not designed to handle or cannot handle optimally. One example is that many people embed lua in their program, a small and garbage-collected scripting-language. luas garbage-collector will look at the size of objects and the memory-pressure to figure out when and what it should collect. However, if you (as almost everyone does) create objects that have the bulk of their substance either on the C-side of things, or maybe even somewhere else entirely (for instance in GPU memory, in the case of graphical objects such as textures) the GC will only see them as maybe a single pointer, and thus not consider them particularly important to collect. That can mean that you may end up having gigabyte-sized objects lumping around in main memory or even video RAM, only because the garbage-collector doesn't think it's worth it to free them up in a timely manner. I'm not aware of a real solution for this kind of issue, one just has to be aware of it and be careful. In other languages (e.g. rust, modern(!) c++, et al) the language/runtime may give you better primitives to handle cases like this, ownership, et al, and/or the user may be more aware/exposed to these issues.\n\nSo in summary, GCs have various advantages and disadvantages, and are more and less appropriate depending on circumstances and the language they are used in.","aSentId": 53734,"answer": "It's not entirely accurate that the user doesn't have to think about memory allocation in GC languages.  For instance, a list implemented as an array of references and a start and end index (to allow constant time indexing most of the time) would have a persistent memory leak if filled and then emptied without nulling out references (until the list itself was gced). If you had a list of memory intensive elements, like, say, images, you can quickly run out of memory.\n\nMemory management is much easier in Java or similar, but still necessary. The advantage is that you only have to worry about it with long-lived references.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53735,"question": "It's not entirely accurate that the user doesn't have to think about memory allocation in GC languages.  For instance, a list implemented as an array of references and a start and end index (to allow constant time indexing most of the time) would have a persistent memory leak if filled and then emptied without nulling out references (until the list itself was gced). If you had a list of memory intensive elements, like, say, images, you can quickly run out of memory.\n\nMemory management is much easier in Java or similar, but still necessary. The advantage is that you only have to worry about it with long-lived references.","aSentId": 53736,"answer": "The principle is that the GC cannot collect if your code can access the value. Whether you use nilling, or any other specific strategy to ensure you don't hang onto unneeded garbage is very language specific (eg. functional languages that use immutable data structures tend to have strong scoping rules and in practice not letting a value escape scope usually suffices to ensure that it can be collected, explicitly shadowing a binding or assigning an STM value with nil is rare).","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53729,"question": "What is garbage collection?","aSentId": 53738,"answer": "The other comments here cover the basics of the idea so I will only tack on a few other ideas worth keeping in mind, when looking at the broader scope of GC.\n\nThe first issue is whether your heap is managed or native. Some things like the Boehm GC are made to be embedded in existing C programs and can do some conservative collection work for you but is largely limited, beyond that, since it doesn't really know what your program is doing and can't do things like move objects, etc. Managed heaps (like Java, for example) give much more control to the GC so you will see type-safe collectors which can freely move objects around or come up with exotic object layouts to enhance locality or object size.\n\nRecently, there has been more work done in the areas of real-time collection, concurrent collection (especially if you have hardware assistance), incremental collection, and aggressive re-localizing of related objects. As the cost of memory access increases, this can produce some substantial performance benefits (some of which could not be statically determined by a human doing it themselves).\n\nI worked in the area for several years and it was very interesting what becomes possible once you look beyond just the \"free unused memory\" concerns commonly associated with GC.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53741,"question": "Computer science podcasts?","aSentId": 53742,"answer": "If people will forgive me, I am co-host of [The Type Theory Podcast](http://typetheorypodcast.com) with David Christiansen (of Idris) and Darin Morrison.\n\nWe interview researchers in type theory about their work. Our guests so far have been Peter Dybjer, Edwin Brady and Dan Licata.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53743,"question": "If people will forgive me, I am co-host of [The Type Theory Podcast](http://typetheorypodcast.com) with David Christiansen (of Idris) and Darin Morrison.\n\nWe interview researchers in type theory about their work. Our guests so far have been Peter Dybjer, Edwin Brady and Dan Licata.","aSentId": 53744,"answer": "I really want to learn about type theory. Are there any introductory resources that you recommend?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53745,"question": "I really want to learn about type theory. Are there any introductory resources that you recommend?","aSentId": 53746,"answer": "My friend Darryl has collected some good resources here: http://purelytheoretical.com/sywtltt.html\n\nHe emphasizes what I'd consider the \"Pfenning School\" of type theory, which is strongly based on proof-theoretic/intensional conceptions of type theory, but deeply associated with Martin-L\u00f6f's meaning-theoretic approach. I'd recommend checking out at least all the resources on that page, particularly the Pfenning stuff; be sure to read \"Programming in Martin-L\u00f6f's Type Theory\" too, but don't worry if not all of it is clear.\n\nI can also provide resources on \"extensional\" type theory, which is pretty much out of style right now. But it's useful to learn, since it is really the only kind which is satisfactorily justified with respect to a primitive/intuitive semantics. But it might be better to learn that stuff after having gone through the resources above.\n\nAlso feel free to PM or email me with questions at any time.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53747,"question": "My friend Darryl has collected some good resources here: http://purelytheoretical.com/sywtltt.html\n\nHe emphasizes what I'd consider the \"Pfenning School\" of type theory, which is strongly based on proof-theoretic/intensional conceptions of type theory, but deeply associated with Martin-L\u00f6f's meaning-theoretic approach. I'd recommend checking out at least all the resources on that page, particularly the Pfenning stuff; be sure to read \"Programming in Martin-L\u00f6f's Type Theory\" too, but don't worry if not all of it is clear.\n\nI can also provide resources on \"extensional\" type theory, which is pretty much out of style right now. But it's useful to learn, since it is really the only kind which is satisfactorily justified with respect to a primitive/intuitive semantics. But it might be better to learn that stuff after having gone through the resources above.\n\nAlso feel free to PM or email me with questions at any time.","aSentId": 53748,"answer": "Could you explain (like I'm five) what type theory is used for? Is my understanding correct that it allows for more concise and formally verifiable programming by using more abstractions and thus helps to avoid certain classes of bugs? My (probably unfounded) preconception of this area is that adding more abstractions has very quickly diminishing returns because the problems just become \"vertically\" more complex (similar to how the binary system is much more concise than the unary system but ternary does not make a big difference compared to binary). ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53749,"question": "Could you explain (like I'm five) what type theory is used for? Is my understanding correct that it allows for more concise and formally verifiable programming by using more abstractions and thus helps to avoid certain classes of bugs? My (probably unfounded) preconception of this area is that adding more abstractions has very quickly diminishing returns because the problems just become \"vertically\" more complex (similar to how the binary system is much more concise than the unary system but ternary does not make a big difference compared to binary). ","aSentId": 53750,"answer": "I would be very interested in this as well. I suspect a lot of problems I've worked on have a type-theoretical interpretation. I'd like to understand that perspective better, but the resources I've been able to find are quite abstruse. It makes me wish there were a \"Head First: Type Theory\" edition to help me understand better what kinds of real-world problems can be modeled this way, and the kinds of models it is an alternative to.\n\nEdit: Finding [this blog post](http://languagengine.co/blog/so-you-want-to-write-a-type-checker/) really helpful. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53751,"question": "I would be very interested in this as well. I suspect a lot of problems I've worked on have a type-theoretical interpretation. I'd like to understand that perspective better, but the resources I've been able to find are quite abstruse. It makes me wish there were a \"Head First: Type Theory\" edition to help me understand better what kinds of real-world problems can be modeled this way, and the kinds of models it is an alternative to.\n\nEdit: Finding [this blog post](http://languagengine.co/blog/so-you-want-to-write-a-type-checker/) really helpful. ","aSentId": 53752,"answer": "I've considered writing a head-first sort of website. I'm slowly building parts of it. Give me time! :)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53749,"question": "Could you explain (like I'm five) what type theory is used for? Is my understanding correct that it allows for more concise and formally verifiable programming by using more abstractions and thus helps to avoid certain classes of bugs? My (probably unfounded) preconception of this area is that adding more abstractions has very quickly diminishing returns because the problems just become \"vertically\" more complex (similar to how the binary system is much more concise than the unary system but ternary does not make a big difference compared to binary). ","aSentId": 53754,"answer": "Type theory is one of those things that crosses over between multiple fields. Philosophically, type theory provides a means of justifying where logic comes from, using what's called \"meaning explanations\". Mathematically, it's a means both of making formal arguments and a rich object of study in and of itself. For programming, it provides the basis for systems that integrate strong verification with software development, like Coq, Agda, and Idris.\n\nI don't think it makes programs more concise, but it does make the static semantics much more expressive.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53755,"question": "Type theory is one of those things that crosses over between multiple fields. Philosophically, type theory provides a means of justifying where logic comes from, using what's called \"meaning explanations\". Mathematically, it's a means both of making formal arguments and a rich object of study in and of itself. For programming, it provides the basis for systems that integrate strong verification with software development, like Coq, Agda, and Idris.\n\nI don't think it makes programs more concise, but it does make the static semantics much more expressive.","aSentId": 53756,"answer": "I cannot emphasize these words enough:\n\n&gt; ***justifying where logic comes from***\n\nThat is the core of what TT is about. Justifying a logic, explaining what makes sense and why.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53747,"question": "My friend Darryl has collected some good resources here: http://purelytheoretical.com/sywtltt.html\n\nHe emphasizes what I'd consider the \"Pfenning School\" of type theory, which is strongly based on proof-theoretic/intensional conceptions of type theory, but deeply associated with Martin-L\u00f6f's meaning-theoretic approach. I'd recommend checking out at least all the resources on that page, particularly the Pfenning stuff; be sure to read \"Programming in Martin-L\u00f6f's Type Theory\" too, but don't worry if not all of it is clear.\n\nI can also provide resources on \"extensional\" type theory, which is pretty much out of style right now. But it's useful to learn, since it is really the only kind which is satisfactorily justified with respect to a primitive/intuitive semantics. But it might be better to learn that stuff after having gone through the resources above.\n\nAlso feel free to PM or email me with questions at any time.","aSentId": 53758,"answer": "Even as a type theory enthusiast, I feel like you're using a lot of lingo - could you elaborate on intensional vs. extensional, and the Pfenning school vs. the Martin-L\u00f6f school?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53759,"question": "Even as a type theory enthusiast, I feel like you're using a lot of lingo - could you elaborate on intensional vs. extensional, and the Pfenning school vs. the Martin-L\u00f6f school?","aSentId": 53760,"answer": "Intensional vs. extensional type theory has to do with the way equality works in the theory.  When giving a new construction in type theory, one must define the following:\n\n1. Formation rules, which define how to build the type being added - you can see this as defining sensible statements vs nonsense\n2. Introduction rules, which define how to construct elements of the type\n3. Elimination rules, which explain how to use elements of the type (think \"induction principle\" or \"recursion operator\"\n4. Equality rules, which explain which elements of the type are the same, as well as how the elimination rules compute\n\nFor pair types, for instance, the formation rules states that AxB is a type if A and B are types, the introduction rule says that if x is in A and y is in B, then (x,y) is in AxB the elimination rules assign types to the left and right projections, and the equality rules tell that the left and right projects actually project the contents out.\n\nThere's a special type, called the identity type, with the following rules. A ternary operator Id, a binary operator refl, and a quaternary operator J are added to the theory such that:\n\n1. If A is a type and x and y are elements of A, then Id(A, x, y) is a type\n2. If Id(A, x, x) is a type, then refl(A, x) is an element of Id(A, x, x)\n3. \n    1. If the following hold:\n\n        1. C is some context that can use two terms and a proof of their equality (that is, if x and y are elements of A and prf is an element of Id(A, x, y) then C(x, y, prf) is a type)\n        2. t is a demonstration of C(x, x, refl(A,x,x))\n        3. p is an element of Id(A, x, y)\n\n  2. then we know that J(t, x, y, p) is an element of C(x,y,p)\n4. J(t,x,x,refl(x)) is equal to t\n\nAll this complicated stuff is defining reflexivity and substitution for a new notion of equality that's inside the theory itself. The previous notion of equality (explained in computation/equality rules) is at the meta level - you can use it when constructing derivations in type theory, but the theory itself was blind to it. Also, we can construct elements of Id(A, x, y) that are not equal in the meta sense, usually by doing some kind of fancy induction. The identity type is often called \"propositional equality\" because it can be proven, and the meta-level equality is often called \"judgmental equality\" because it's part of the judgments of the system.\n\nThis system I've described so far is called \"intensional type theory\" because it relies on the \"intensions\" or the \"sense\" of terms, rather than their underlying meanings. To paraphrase Frege, in intensional type theory, the system isn't aware that the morning star is the evening star, even if we prove it by constructing an element of Id(Star, morning, evening). In extensional type theory, we try to talk about the \"extensions\" of terms; or in other words their referents. Proving that the morning star is the evening star should make them _actuallly equal_.\n\nTraditional extensional type theory adds a rule called \"equality reflection\" where an element of Id(A, x, y) justifies a meta-level equality between x and y. This completely changes the character of the type theory. For one, you get an equality between functions that is closer to the mathematical one - two functions are equal if they compute the same answers, rather than if they implement the same algorithm. Also, you lose the ability for an algorithm to check whether a particular term inhabits some type, so you need to start working with whole derivations, which means that a programming language based on extensional type theory is very different from one based on intensional type theory, which can resemble traditional functional programming languages such as ML.\n\nDid this make sense?\n\n(edit: \"fixed\" some Markdown stuff to make it more clear, and removed an extraneous \"if\", and added a better description of what Id, refl, and J are. Markdown is really horrible for nested lists!)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53761,"question": "Intensional vs. extensional type theory has to do with the way equality works in the theory.  When giving a new construction in type theory, one must define the following:\n\n1. Formation rules, which define how to build the type being added - you can see this as defining sensible statements vs nonsense\n2. Introduction rules, which define how to construct elements of the type\n3. Elimination rules, which explain how to use elements of the type (think \"induction principle\" or \"recursion operator\"\n4. Equality rules, which explain which elements of the type are the same, as well as how the elimination rules compute\n\nFor pair types, for instance, the formation rules states that AxB is a type if A and B are types, the introduction rule says that if x is in A and y is in B, then (x,y) is in AxB the elimination rules assign types to the left and right projections, and the equality rules tell that the left and right projects actually project the contents out.\n\nThere's a special type, called the identity type, with the following rules. A ternary operator Id, a binary operator refl, and a quaternary operator J are added to the theory such that:\n\n1. If A is a type and x and y are elements of A, then Id(A, x, y) is a type\n2. If Id(A, x, x) is a type, then refl(A, x) is an element of Id(A, x, x)\n3. \n    1. If the following hold:\n\n        1. C is some context that can use two terms and a proof of their equality (that is, if x and y are elements of A and prf is an element of Id(A, x, y) then C(x, y, prf) is a type)\n        2. t is a demonstration of C(x, x, refl(A,x,x))\n        3. p is an element of Id(A, x, y)\n\n  2. then we know that J(t, x, y, p) is an element of C(x,y,p)\n4. J(t,x,x,refl(x)) is equal to t\n\nAll this complicated stuff is defining reflexivity and substitution for a new notion of equality that's inside the theory itself. The previous notion of equality (explained in computation/equality rules) is at the meta level - you can use it when constructing derivations in type theory, but the theory itself was blind to it. Also, we can construct elements of Id(A, x, y) that are not equal in the meta sense, usually by doing some kind of fancy induction. The identity type is often called \"propositional equality\" because it can be proven, and the meta-level equality is often called \"judgmental equality\" because it's part of the judgments of the system.\n\nThis system I've described so far is called \"intensional type theory\" because it relies on the \"intensions\" or the \"sense\" of terms, rather than their underlying meanings. To paraphrase Frege, in intensional type theory, the system isn't aware that the morning star is the evening star, even if we prove it by constructing an element of Id(Star, morning, evening). In extensional type theory, we try to talk about the \"extensions\" of terms; or in other words their referents. Proving that the morning star is the evening star should make them _actuallly equal_.\n\nTraditional extensional type theory adds a rule called \"equality reflection\" where an element of Id(A, x, y) justifies a meta-level equality between x and y. This completely changes the character of the type theory. For one, you get an equality between functions that is closer to the mathematical one - two functions are equal if they compute the same answers, rather than if they implement the same algorithm. Also, you lose the ability for an algorithm to check whether a particular term inhabits some type, so you need to start working with whole derivations, which means that a programming language based on extensional type theory is very different from one based on intensional type theory, which can resemble traditional functional programming languages such as ML.\n\nDid this make sense?\n\n(edit: \"fixed\" some Markdown stuff to make it more clear, and removed an extraneous \"if\", and added a better description of what Id, refl, and J are. Markdown is really horrible for nested lists!)","aSentId": 53762,"answer": "I'm not done reading yet, but in points number 3 and 4 it looks like something is missing.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53763,"question": "I'm not done reading yet, but in points number 3 and 4 it looks like something is missing.","aSentId": 53764,"answer": "Thanks, I fixed it up a bit. It's still ugly, but apparently I'm too dumb to figure out how to nest bulleted and numbered lists inside each other in Markdown.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53765,"question": "Thanks, I fixed it up a bit. It's still ugly, but apparently I'm too dumb to figure out how to nest bulleted and numbered lists inside each other in Markdown.","aSentId": 53766,"answer": "It's still not clear what J refers to?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53767,"question": "It's still not clear what J refers to?","aSentId": 53768,"answer": "J is the name of the elimination operator for Id. Let me update the post.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53769,"question": "J is the name of the elimination operator for Id. Let me update the post.","aSentId": 53770,"answer": "I'm too tired to process this 100%, but so far my biggest take-away is that I really want to smush together theoretic and metatheoretic equality, even if it makes everything undecidable.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53771,"question": "I'm too tired to process this 100%, but so far my biggest take-away is that I really want to smush together theoretic and metatheoretic equality, even if it makes everything undecidable.","aSentId": 53772,"answer": "It's certainly a valid design choice! The NuPRL system at Cornell is the most advanced development of this idea, and they've written a ton about it.\n\nThere are also other possibilities, like homotopy type theory, that treat equalities in yet other ways. Check out the latest episode of our podcast (with Dan Licata) for some info on that.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53761,"question": "Intensional vs. extensional type theory has to do with the way equality works in the theory.  When giving a new construction in type theory, one must define the following:\n\n1. Formation rules, which define how to build the type being added - you can see this as defining sensible statements vs nonsense\n2. Introduction rules, which define how to construct elements of the type\n3. Elimination rules, which explain how to use elements of the type (think \"induction principle\" or \"recursion operator\"\n4. Equality rules, which explain which elements of the type are the same, as well as how the elimination rules compute\n\nFor pair types, for instance, the formation rules states that AxB is a type if A and B are types, the introduction rule says that if x is in A and y is in B, then (x,y) is in AxB the elimination rules assign types to the left and right projections, and the equality rules tell that the left and right projects actually project the contents out.\n\nThere's a special type, called the identity type, with the following rules. A ternary operator Id, a binary operator refl, and a quaternary operator J are added to the theory such that:\n\n1. If A is a type and x and y are elements of A, then Id(A, x, y) is a type\n2. If Id(A, x, x) is a type, then refl(A, x) is an element of Id(A, x, x)\n3. \n    1. If the following hold:\n\n        1. C is some context that can use two terms and a proof of their equality (that is, if x and y are elements of A and prf is an element of Id(A, x, y) then C(x, y, prf) is a type)\n        2. t is a demonstration of C(x, x, refl(A,x,x))\n        3. p is an element of Id(A, x, y)\n\n  2. then we know that J(t, x, y, p) is an element of C(x,y,p)\n4. J(t,x,x,refl(x)) is equal to t\n\nAll this complicated stuff is defining reflexivity and substitution for a new notion of equality that's inside the theory itself. The previous notion of equality (explained in computation/equality rules) is at the meta level - you can use it when constructing derivations in type theory, but the theory itself was blind to it. Also, we can construct elements of Id(A, x, y) that are not equal in the meta sense, usually by doing some kind of fancy induction. The identity type is often called \"propositional equality\" because it can be proven, and the meta-level equality is often called \"judgmental equality\" because it's part of the judgments of the system.\n\nThis system I've described so far is called \"intensional type theory\" because it relies on the \"intensions\" or the \"sense\" of terms, rather than their underlying meanings. To paraphrase Frege, in intensional type theory, the system isn't aware that the morning star is the evening star, even if we prove it by constructing an element of Id(Star, morning, evening). In extensional type theory, we try to talk about the \"extensions\" of terms; or in other words their referents. Proving that the morning star is the evening star should make them _actuallly equal_.\n\nTraditional extensional type theory adds a rule called \"equality reflection\" where an element of Id(A, x, y) justifies a meta-level equality between x and y. This completely changes the character of the type theory. For one, you get an equality between functions that is closer to the mathematical one - two functions are equal if they compute the same answers, rather than if they implement the same algorithm. Also, you lose the ability for an algorithm to check whether a particular term inhabits some type, so you need to start working with whole derivations, which means that a programming language based on extensional type theory is very different from one based on intensional type theory, which can resemble traditional functional programming languages such as ML.\n\nDid this make sense?\n\n(edit: \"fixed\" some Markdown stuff to make it more clear, and removed an extraneous \"if\", and added a better description of what Id, refl, and J are. Markdown is really horrible for nested lists!)","aSentId": 53774,"answer": "This made a lot of sense, thanks for the explanation!","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53775,"question": "This made a lot of sense, thanks for the explanation!","aSentId": 53776,"answer": "You're welcome :-)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53761,"question": "Intensional vs. extensional type theory has to do with the way equality works in the theory.  When giving a new construction in type theory, one must define the following:\n\n1. Formation rules, which define how to build the type being added - you can see this as defining sensible statements vs nonsense\n2. Introduction rules, which define how to construct elements of the type\n3. Elimination rules, which explain how to use elements of the type (think \"induction principle\" or \"recursion operator\"\n4. Equality rules, which explain which elements of the type are the same, as well as how the elimination rules compute\n\nFor pair types, for instance, the formation rules states that AxB is a type if A and B are types, the introduction rule says that if x is in A and y is in B, then (x,y) is in AxB the elimination rules assign types to the left and right projections, and the equality rules tell that the left and right projects actually project the contents out.\n\nThere's a special type, called the identity type, with the following rules. A ternary operator Id, a binary operator refl, and a quaternary operator J are added to the theory such that:\n\n1. If A is a type and x and y are elements of A, then Id(A, x, y) is a type\n2. If Id(A, x, x) is a type, then refl(A, x) is an element of Id(A, x, x)\n3. \n    1. If the following hold:\n\n        1. C is some context that can use two terms and a proof of their equality (that is, if x and y are elements of A and prf is an element of Id(A, x, y) then C(x, y, prf) is a type)\n        2. t is a demonstration of C(x, x, refl(A,x,x))\n        3. p is an element of Id(A, x, y)\n\n  2. then we know that J(t, x, y, p) is an element of C(x,y,p)\n4. J(t,x,x,refl(x)) is equal to t\n\nAll this complicated stuff is defining reflexivity and substitution for a new notion of equality that's inside the theory itself. The previous notion of equality (explained in computation/equality rules) is at the meta level - you can use it when constructing derivations in type theory, but the theory itself was blind to it. Also, we can construct elements of Id(A, x, y) that are not equal in the meta sense, usually by doing some kind of fancy induction. The identity type is often called \"propositional equality\" because it can be proven, and the meta-level equality is often called \"judgmental equality\" because it's part of the judgments of the system.\n\nThis system I've described so far is called \"intensional type theory\" because it relies on the \"intensions\" or the \"sense\" of terms, rather than their underlying meanings. To paraphrase Frege, in intensional type theory, the system isn't aware that the morning star is the evening star, even if we prove it by constructing an element of Id(Star, morning, evening). In extensional type theory, we try to talk about the \"extensions\" of terms; or in other words their referents. Proving that the morning star is the evening star should make them _actuallly equal_.\n\nTraditional extensional type theory adds a rule called \"equality reflection\" where an element of Id(A, x, y) justifies a meta-level equality between x and y. This completely changes the character of the type theory. For one, you get an equality between functions that is closer to the mathematical one - two functions are equal if they compute the same answers, rather than if they implement the same algorithm. Also, you lose the ability for an algorithm to check whether a particular term inhabits some type, so you need to start working with whole derivations, which means that a programming language based on extensional type theory is very different from one based on intensional type theory, which can resemble traditional functional programming languages such as ML.\n\nDid this make sense?\n\n(edit: \"fixed\" some Markdown stuff to make it more clear, and removed an extraneous \"if\", and added a better description of what Id, refl, and J are. Markdown is really horrible for nested lists!)","aSentId": 53778,"answer": "Great explanation, thank you! ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53779,"question": "Great explanation, thank you! ","aSentId": 53780,"answer": "You're welcome :-)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53747,"question": "My friend Darryl has collected some good resources here: http://purelytheoretical.com/sywtltt.html\n\nHe emphasizes what I'd consider the \"Pfenning School\" of type theory, which is strongly based on proof-theoretic/intensional conceptions of type theory, but deeply associated with Martin-L\u00f6f's meaning-theoretic approach. I'd recommend checking out at least all the resources on that page, particularly the Pfenning stuff; be sure to read \"Programming in Martin-L\u00f6f's Type Theory\" too, but don't worry if not all of it is clear.\n\nI can also provide resources on \"extensional\" type theory, which is pretty much out of style right now. But it's useful to learn, since it is really the only kind which is satisfactorily justified with respect to a primitive/intuitive semantics. But it might be better to learn that stuff after having gone through the resources above.\n\nAlso feel free to PM or email me with questions at any time.","aSentId": 53783,"answer": "&gt; My friend Darryl\n\noh sure, use my fakeperson name! :|","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53745,"question": "I really want to learn about type theory. Are there any introductory resources that you recommend?","aSentId": 53785,"answer": "This came up somewhat recently: http://purelytheoretical.com/sywtltt.html","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53786,"question": "This came up somewhat recently: http://purelytheoretical.com/sywtltt.html","aSentId": 53787,"answer": "is it too self serving to upvote this? oh well, I'm doing it anyway. :)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53743,"question": "If people will forgive me, I am co-host of [The Type Theory Podcast](http://typetheorypodcast.com) with David Christiansen (of Idris) and Darin Morrison.\n\nWe interview researchers in type theory about their work. Our guests so far have been Peter Dybjer, Edwin Brady and Dan Licata.","aSentId": 53789,"answer": "Neat. Sup man","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53741,"question": "Computer science podcasts?","aSentId": 53791,"answer": "I cohost [Linear Digressions](http://lineardigressions.com), a podcast by Udacity about machine learning and data science. It's more introductory-level, but covers some fun concepts.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53741,"question": "Computer science podcasts?","aSentId": 53793,"answer": "My choice, videolectures:\n\nhttp://videolectures.net/Top/Computer_Science/","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53800,"question": "How do I use a while loop to enter new values?","aSentId": 53801,"answer": "Please post code when you ask for assistance. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53802,"question": "Please post code when you ask for assistance. ","aSentId": 53803,"answer": "posted","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53800,"question": "How do I use a while loop to enter new values?","aSentId": 53805,"answer": "I am not sure what you are asking for exactly. You should post your code. If you are repeating a loop 4 times a simple while(x++&lt;5) or for(x=0;x&lt;4;x++) will work fine.\n\nIf you are on cin then your feedback will be based on what you are doing in that loop. If you are entering different answers, do you mean that you enter 3 into cin, then 4, then 5, and it is the same output? Then something is wrong with whatever method you are using. Is your output inside of the loop or outside, if it is outside the loop then you are probably overwriting your input variable, which you could either do an if statement to choose your variable, or just move your output into the while loop.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53806,"question": "I am not sure what you are asking for exactly. You should post your code. If you are repeating a loop 4 times a simple while(x++&lt;5) or for(x=0;x&lt;4;x++) will work fine.\n\nIf you are on cin then your feedback will be based on what you are doing in that loop. If you are entering different answers, do you mean that you enter 3 into cin, then 4, then 5, and it is the same output? Then something is wrong with whatever method you are using. Is your output inside of the loop or outside, if it is outside the loop then you are probably overwriting your input variable, which you could either do an if statement to choose your variable, or just move your output into the while loop.","aSentId": 53807,"answer": "posted. sorry I didn't post earlier","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53800,"question": "How do I use a while loop to enter new values?","aSentId": 53809,"answer": "nm I got it, a friend helped me. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53810,"question": "nm I got it, a friend helped me. ","aSentId": 53811,"answer": "Also for future reference, if you solve your own problem it can't hurt to post your solution. \n\nhttp://xkcd.com/979/\n\nAlso, this post probably belonged in /r/learnprogramming, but don't quote me on that. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53814,"question": "Things I need to know before majoring in Comp Sci","aSentId": 53815,"answer": " The idea of going to school is for them to teach you what you need to know. Any knowledge of the field beforehand just gives you a slight advantage. Since you are familiar with some topics, others may come to you naturally. If anything I would advise looking into a specific field, for example programming, so you have a better idea of which classes you'd like to take. I can say from experience that changing majors later on can really slow down your progress and end up costing you a lot of money. I would highly recommend going through with it, you will learn a lot of interesting things and having that degree will help you find a job much more quickly. I wish you the best of luck! ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53814,"question": "Things I need to know before majoring in Comp Sci","aSentId": 53817,"answer": "Having a few programming languages under your belt might give you an advantage in the intro level courses, but its not absolutely required that you know how to program before starting a comp sci degree.\n\nMore importantly, in my mind, is math. How are you at calculus?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53818,"question": "Having a few programming languages under your belt might give you an advantage in the intro level courses, but its not absolutely required that you know how to program before starting a comp sci degree.\n\nMore importantly, in my mind, is math. How are you at calculus?","aSentId": 53819,"answer": "I agree with the math portion. Less so with fundamental calculus, more with algebra and problem solving. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53820,"question": "I agree with the math portion. Less so with fundamental calculus, more with algebra and problem solving. ","aSentId": 53821,"answer": "I only bring it up because I did perfectly fine in my core classes and things like linear algebra, but I bombed out on the upper level calculus courses. For my college, at least, comp sci was treated as an engineering degree so you were required to take certain engineering calculus courses. They weren't necessarily related to computer science, but they had to be completed to finish the degree.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53822,"question": "I only bring it up because I did perfectly fine in my core classes and things like linear algebra, but I bombed out on the upper level calculus courses. For my college, at least, comp sci was treated as an engineering degree so you were required to take certain engineering calculus courses. They weren't necessarily related to computer science, but they had to be completed to finish the degree.","aSentId": 53823,"answer": "Completely understandable. I go to a smaller university, where there isn't an engineering faculty. The program considered more \"mathy\". So there were 3 levels of calculus courses. I took the hardest set and found they didn't really help tonnes; because they were guided to pure maths majors.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53822,"question": "I only bring it up because I did perfectly fine in my core classes and things like linear algebra, but I bombed out on the upper level calculus courses. For my college, at least, comp sci was treated as an engineering degree so you were required to take certain engineering calculus courses. They weren't necessarily related to computer science, but they had to be completed to finish the degree.","aSentId": 53825,"answer": "At my uni they had versions of these upper level math courses that were targeted for engineers and not math majors. IE,  the prof basically said on day one, \"We don't necessarily expect you to understand all the inner workings and theory, we just want to add some mathematical tools to your toolbox to solve some difficult problems.  When you are confronted with a difficult problem, you will be able to go through your toolbox, based on the form and polynomial level of the problem and decide if any of the approaches will help reduce or solve the problem,  and then execute on those steps.\"\n\nThis was a great paradigm for me to get through those difficult and boring classes without really fealing like I had to grasp everything. Ridiculous equations like heat transfer became just a \"ok try step1 one, nope, try thing 2, nope, ahh thing 3 (Fourier series) worked, cool.\"","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53822,"question": "I only bring it up because I did perfectly fine in my core classes and things like linear algebra, but I bombed out on the upper level calculus courses. For my college, at least, comp sci was treated as an engineering degree so you were required to take certain engineering calculus courses. They weren't necessarily related to computer science, but they had to be completed to finish the degree.","aSentId": 53827,"answer": "Which Calc were you required to go up to? Some schools is Calc 2 (mine), some Calc 3, and some Calc 3 and DFQ. Personally I dont think Calc 3 would be that killer, but DFQ just seems like it would be a huge pain... Also at my uni, Both Calcs are required to take any of the other math classes (Discrete, Linear) or theory classes (algorithms, theory of computation)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53818,"question": "Having a few programming languages under your belt might give you an advantage in the intro level courses, but its not absolutely required that you know how to program before starting a comp sci degree.\n\nMore importantly, in my mind, is math. How are you at calculus?","aSentId": 53829,"answer": "I am ok at Calculus. I just started this school year, so I am not as experienced. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53818,"question": "Having a few programming languages under your belt might give you an advantage in the intro level courses, but its not absolutely required that you know how to program before starting a comp sci degree.\n\nMore importantly, in my mind, is math. How are you at calculus?","aSentId": 53831,"answer": "second this, mostly because most programs i've seen require calc as part of the requirements although most of the math behind undergrad comp sci comes from discrete math/combinatorics, linear algebra, etc.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53814,"question": "Things I need to know before majoring in Comp Sci","aSentId": 53833,"answer": "For the most part you'll be fine, especially if you can google well.  But if you want exposure to the more formal aspects of a CS degree, just get a few books on the following:\n\n* Algorithms\n* Computer Architecture\n* Programming Language theory (just a very basic intro book)\n* Networks (just the basics)\n\nIf you understand those things pretty well then you won't have any issues.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53843,"question": "How do CS people feel about all the attention that Jony Ive is getting? It's as if the most important thing at Apple is what the product looks like.","aSentId": 53844,"answer": "If he is good at what he does, and what he does has helped propel apple to being one of the largest companies in the world, why shouldn't he be getting attention for it?  ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53843,"question": "How do CS people feel about all the attention that Jony Ive is getting? It's as if the most important thing at Apple is what the product looks like.","aSentId": 53846,"answer": "People buy Apple products because of the look and Apple's fantastic marketing, not because they are technically better in any way.  This is working for them.  They just had a fantastic last quarter.   I just wish they would put some money into keeping iOS up with Android and making Macbooks with WiFi that works all the time.  ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53843,"question": "How do CS people feel about all the attention that Jony Ive is getting? It's as if the most important thing at Apple is what the product looks like.","aSentId": 53848,"answer": "Apple has always been a hardware company at its core. Look, feel, and performance will always be important metrics. The iPhone revolution was one of user experience and status. The technology had been around for a while.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53850,"question": "You may recall a few years ago when Steve Jobs died. Everyone in the world went on a grief orgy that lasted for weeks if not months. A week after Jobs died, Dennis Ritchie died. The news barely made the papers. Yet Ritchie gave us the C programming language and the Unix OS, literally giving us our modern world of computing; and Jobs sold shiny gadgets.\n\nWhat excites the crowds and what's truly important are totally different things. What separates the mega pop star from the sometimes more talented starving artists playing on the street for spare change from passersby? Not always easy to say.","aSentId": 53851,"answer": "He died, how did I miss that?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53854,"question": "Help! I need help deciding on a research topic!","aSentId": 53855,"answer": "(I'm currently a fifth year student, working on my master) \n\nAt my university there is a lot of interest in using video games for education in the classroom. \n\nhttps://getkahoot.com/ was made by a professor here.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53858,"question": "Need suggestion for randomized algorithm.","aSentId": 53859,"answer": "Lol is this guy serious? \n\nAs best I can tell, you're looking for someone to explain to you algorithms with a stochastic component. There are many different algorithms in this class, and it's an incredibly wide subject area. Just google harder.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53860,"question": "Lol is this guy serious? \n\nAs best I can tell, you're looking for someone to explain to you algorithms with a stochastic component. There are many different algorithms in this class, and it's an incredibly wide subject area. Just google harder.","aSentId": 53861,"answer": "If you look at my keyword and really understand the topic, you answer maybe different. Sorry but you reply is not helpful at all.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53858,"question": "Need suggestion for randomized algorithm.","aSentId": 53863,"answer": "I don't understand what you are looking for.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53864,"question": "I don't understand what you are looking for.","aSentId": 53865,"answer": "Please look at my keywords, it is self-explanation.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53866,"question": "Please look at my keywords, it is self-explanation.","aSentId": 53867,"answer": "No, it is not.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53869,"question": "Help with Discrete Math?","aSentId": 53870,"answer": "If they were both even, we could divide each by two, and get an equivalent fraction. Repeat until at least one is odd.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53871,"question": "If they were both even, we could divide each by two, and get an equivalent fraction. Repeat until at least one is odd.","aSentId": 53872,"answer": "Thank you! Makes a lot more sense now.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53874,"question": "[Q] Average case efficiency of sequential search","aSentId": 53875,"answer": "&gt;Cavg(n) = ... + n-(1-p)\n\nIs this supposed to be Cavg(n) = ... + n*(1-p)? Otherwise I'm afraid I don't understand either.\n","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53876,"question": "&gt;Cavg(n) = ... + n-(1-p)\n\nIs this supposed to be Cavg(n) = ... + n*(1-p)? Otherwise I'm afraid I don't understand either.\n","aSentId": 53877,"answer": "Yeah. I'm sorry that was a typo. It is indeed n*(1-p). Could you throw some light on how?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53878,"question": "Yeah. I'm sorry that was a typo. It is indeed n*(1-p). Could you throw some light on how?","aSentId": 53879,"answer": "Okey, so the question is the *average* number of *comparisons* for sequentially searching through an array.\n\nThere are two cases to consider:\n\n1. The list does not contain our element\n2. The list does contain our element\n\nThe probability for case 1 is (1-p) and in this case we have to do n comparisons, this accounts for the last term \n&gt; n*(1-p).\n\nThat leaves case 2, which is accounted for by the sum. \n&gt;(1*p/n + 2*p/n + ... + n*p/n)\n\nI find it a bit unnatural to have the term \"p\" inside the parenthesis, as p is the probability of this case. So lets move it outside.\n&gt; (1/n + 2/n + ... + n/n)*p\n\n1/n is the probability that any element is the element we are looking for, so let's move that out of the parenthesis as well.\n&gt; (1 + 2 + ... + n)*p/n\n\nNow we are left with the sum of the n first natural numbers. This accounts for all the different cases for where our first match with the element we are looking for is. If the first match is the first element, we have to do one comparison. If it is the second number we have to do two comparisons. We have to look through all the elements we have to do n comparisons. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53880,"question": "Okey, so the question is the *average* number of *comparisons* for sequentially searching through an array.\n\nThere are two cases to consider:\n\n1. The list does not contain our element\n2. The list does contain our element\n\nThe probability for case 1 is (1-p) and in this case we have to do n comparisons, this accounts for the last term \n&gt; n*(1-p).\n\nThat leaves case 2, which is accounted for by the sum. \n&gt;(1*p/n + 2*p/n + ... + n*p/n)\n\nI find it a bit unnatural to have the term \"p\" inside the parenthesis, as p is the probability of this case. So lets move it outside.\n&gt; (1/n + 2/n + ... + n/n)*p\n\n1/n is the probability that any element is the element we are looking for, so let's move that out of the parenthesis as well.\n&gt; (1 + 2 + ... + n)*p/n\n\nNow we are left with the sum of the n first natural numbers. This accounts for all the different cases for where our first match with the element we are looking for is. If the first match is the first element, we have to do one comparison. If it is the second number we have to do two comparisons. We have to look through all the elements we have to do n comparisons. ","aSentId": 53881,"answer": "What I find hard to understand is that why we take that p/n part? \nProbability of an search being successful is no. of instances of key value/ total number of value (=n).\n\nWhy do we take that p/n part? Also, why do we multiply p/n with number of comparisions it has to make in that condition?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53882,"question": "What I find hard to understand is that why we take that p/n part? \nProbability of an search being successful is no. of instances of key value/ total number of value (=n).\n\nWhy do we take that p/n part? Also, why do we multiply p/n with number of comparisions it has to make in that condition?","aSentId": 53883,"answer": "We have to weigh the different outcomes according to their probability. The average number of comparisons is the sum of all the different outcomes multiplied with their probability. What they are really asking for the expected value. If there are m different possible outcomes denoted rj = {r1, r2, ..., rm}, and each outcome has the probability pj = {p1, p2, ..., pm} then the expected number of comparisons is:\n\nE(R) = sum from j = 1 to m of rj*pj\n\nWe have the following cases:\n\nCase 1: The element is not in the list.\n\nr1 = n, p1 = 1-p\n\nCase 2.1: Element is in the list ***AND*** first element matches\n\nNow the number of comparisons, r2.1 = 1. However the probability of case 2.1 is the probability that the element is in the list (p) AND the probability that it is the first element in the list (1/n). From high school math you should remember that this is p*1/n\n\netc.\n\nEdit: I actually realized myself that this problem might have been easier if it had been formulated in terms of expected value. Also, I really wish reddit had better support for mathematical notation.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53884,"question": "We have to weigh the different outcomes according to their probability. The average number of comparisons is the sum of all the different outcomes multiplied with their probability. What they are really asking for the expected value. If there are m different possible outcomes denoted rj = {r1, r2, ..., rm}, and each outcome has the probability pj = {p1, p2, ..., pm} then the expected number of comparisons is:\n\nE(R) = sum from j = 1 to m of rj*pj\n\nWe have the following cases:\n\nCase 1: The element is not in the list.\n\nr1 = n, p1 = 1-p\n\nCase 2.1: Element is in the list ***AND*** first element matches\n\nNow the number of comparisons, r2.1 = 1. However the probability of case 2.1 is the probability that the element is in the list (p) AND the probability that it is the first element in the list (1/n). From high school math you should remember that this is p*1/n\n\netc.\n\nEdit: I actually realized myself that this problem might have been easier if it had been formulated in terms of expected value. Also, I really wish reddit had better support for mathematical notation.","aSentId": 53885,"answer": "Thanks a lot, helped a lot.\n\nOne last thing, which probability concept is that which leads to it becoming p*1/n? I'm really rusty on mathematics, I guess. Any suggestions on what concepts I need to brush up?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53874,"question": "[Q] Average case efficiency of sequential search","aSentId": 53887,"answer": "the average case comparisons is (n+1)/2 for linear search under the assumption that we find the element with p = 1.\n\nCavg(n) = p / n { 1 + 2 + ... + n } + n - (1 - p)\n\n= p / n { n(n+1)/2 } + n - (1 - p)\n\n= p (n + 1) / 2 + n - (1 - p)","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53888,"question": "the average case comparisons is (n+1)/2 for linear search under the assumption that we find the element with p = 1.\n\nCavg(n) = p / n { 1 + 2 + ... + n } + n - (1 - p)\n\n= p / n { n(n+1)/2 } + n - (1 - p)\n\n= p (n + 1) / 2 + n - (1 - p)","aSentId": 53889,"answer": "I am unable to grasp how Cavg(n) is calculated and what that p/n part represents. ","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53891,"question": "Chunked sequences: a fast sequence data structure for parallel algorithms (PDF)","aSentId": 53892,"answer": "I'm a bit confused. Does this paper prove a new sequence data structure that out performs existing ones? If so why isn't it commonly used?","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53894,"question": "Resources for becoming more familiar with graduate material?","aSentId": 53895,"answer": "I think you also need to take a Statistics and Probability course too. After taking that course during my undergraduate studies it helped me a lot with so many courses including Machine Learning.\n\nSo basically go with Linear Algebra, Discrete Math and Probability for Engineers. You can easily access them on Coursera.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53896,"question": "I think you also need to take a Statistics and Probability course too. After taking that course during my undergraduate studies it helped me a lot with so many courses including Machine Learning.\n\nSo basically go with Linear Algebra, Discrete Math and Probability for Engineers. You can easily access them on Coursera.","aSentId": 53897,"answer": "Stats is already a piece of cake for me personally, But for future reference I will definetly keep that in mind.","corpus": "reddit"},{"docID": "t5_2qhmr","qSentId": 53894,"question": "Resources for becoming more familiar with graduate material?","aSentId": 53899,"answer": "If 15 minutes is your threshold of pain, getting \"graduate\" level understanding of something is maybe not a realistic goal.","corpus": "reddit"}]