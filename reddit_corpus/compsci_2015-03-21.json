[{"docID": "t5_2qhmr", "qSentId": 35765, "question": "The math behind an Enigma machine?", "aSentId": 35766, "answer": "Here's a good place to start - [Understanding the Enigma Machine with 30 lines of ruby](http://red-badger.com/blog/2015/02/23/understanding-the-enigma-machine-with-30-lines-of-ruby-star-of-the-2014-film-the-imitation-game/)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35765, "question": "The math behind an Enigma machine?", "aSentId": 35768, "answer": "Look for \"numberphile enigma machine\" on YouTube. They've got a good series on it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35769, "question": "Look for \"numberphile enigma machine\" on YouTube. They've got a good series on it.", "aSentId": 35770, "answer": "That was what got me interested in doing this in the first place.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35765, "question": "The math behind an Enigma machine?", "aSentId": 35772, "answer": "Was there much math behind enigma? I know there are a lot of math behind cracking it, but creating the cipher is pretty straight forward, no?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35774, "question": "How does the book \"Software Foundations\" by Pierce compares to his other book \"Types and Programming Languages\"?", "aSentId": 35775, "answer": "Types and Programming Languages (TAPL) is a type-theoretic account of programming languages by exploring the simply-typed lambda calculus and its various extensions into polymorphism (System F), subtyping, recursive types, and higher-order systems.  Implementations of said systems are secondary to their mathematical accounts.\n\nSoftware Foundations (SF) is (1) an introduction to formal reasoning with the Coq proof assistant and (2) an exploration of the mathematical foundations of computer programs using Coq.  Because Coq combines proofs and programs, a substantial portion of the book involves understanding how to formulate mathematics in this paradigm and its relationship with \"paper\" mathematics.  The type-theoretic account of programming languages is less complete than TAPL with an introduction to the simply-typed lambda calculus and subtyping but no treatment of more complicated type systems (in particular, System F).  SF also includes treatments of other non-type theoretic topics such as Hoare Logic and provably correct optimizations.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35774, "question": "How does the book \"Software Foundations\" by Pierce compares to his other book \"Types and Programming Languages\"?", "aSentId": 35777, "answer": "TAPL is a traditional textbook; it's typeset and published as a normal book, so it's mostly text and normal written exercises, though there are some programming exercises and a supplementary set of source files to use with the programming exercises. There are proofs in the text and some in the exercises, but they're not the bulk of it. It's a very good book, and well worth studying as an introduction/overview.\n\nSoftware Foundations is not a traditional textbook; it was written by Pierce and many others in the form of a literate program. The whole thing is a series of examples and exercises intermixed with text as comments. It teaches you interactively how to do formal proofs in the Coq system and then walks you through various proofs relating to programming languages and type theory. Doing proofs in Coq is not quite like doing standard informal proofs; you can get a long way just playing around without really understanding, but if you put a lot of effort into understanding what you're doing, you can get a really solid understanding.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35779, "question": "Question about distributed and multithreaded prime number generation", "aSentId": 35780, "answer": "Are you trying to generate a random large prime number or what?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35781, "question": "Are you trying to generate a random large prime number or what?", "aSentId": 35782, "answer": "We would like to generate all primes up to some value\n\nEdit: actually thinking about it, getting one single prime might be easier due to less network communication, if so that would be fine too", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35783, "question": "We would like to generate all primes up to some value\n\nEdit: actually thinking about it, getting one single prime might be easier due to less network communication, if so that would be fine too", "aSentId": 35784, "answer": "If you want one random prime number it can easily be done by generating a random number with a certain about on bits using a big integer library, if even add one to make it odd, implement and run a rabin-miller test 30~ times, if tests pass every time its probably prime  , if not then you add two and repeat til you get a prime number. Using this you can easily get probably prime numbers with 1000+ digits. Its used in RSA encryption to generate large primes. It can be done easily on any modern pc fairly quickly so it wouldnt really interest you if you want to combine multiple computers to do a single task.\n\n\nMaybe you can make a bitcoin miner and see how much power you can generate using all of those computers or something like that.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35785, "question": "If you want one random prime number it can easily be done by generating a random number with a certain about on bits using a big integer library, if even add one to make it odd, implement and run a rabin-miller test 30~ times, if tests pass every time its probably prime  , if not then you add two and repeat til you get a prime number. Using this you can easily get probably prime numbers with 1000+ digits. Its used in RSA encryption to generate large primes. It can be done easily on any modern pc fairly quickly so it wouldnt really interest you if you want to combine multiple computers to do a single task.\n\n\nMaybe you can make a bitcoin miner and see how much power you can generate using all of those computers or something like that.", "aSentId": 35786, "answer": "Just to clarify, you're saying to create some large random number then run the tests on it to see if it's prime? That could work decently. Sadly we can't do anything with bitcoins", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35787, "question": "Just to clarify, you're saying to create some large random number then run the tests on it to see if it's prime? That could work decently. Sadly we can't do anything with bitcoins", "aSentId": 35788, "answer": "Its how they generate large prime numbers for RSA encryption quickly . You dont need more than 1 PC to do it. So id stick with finding all primes up to a certain number if you wanted to use multiple computers.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35779, "question": "Question about distributed and multithreaded prime number generation", "aSentId": 35790, "answer": "You can use a eratosthenes seive, then use the threads to delete the values?\n\nIm not sure of any others. Eratosthenes is what I would use. \n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35791, "question": "You can use a eratosthenes seive, then use the threads to delete the values?\n\nIm not sure of any others. Eratosthenes is what I would use. \n", "aSentId": 35792, "answer": "I feel like that wouldn't work too well though. With one computer and threads I could see it working. But once I have multiple computers (at least 600 cpu cores and possibly cuda cores from 30 gtx 680's) I can't see it working too well", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35793, "question": "I feel like that wouldn't work too well though. With one computer and threads I could see it working. But once I have multiple computers (at least 600 cpu cores and possibly cuda cores from 30 gtx 680's) I can't see it working too well", "aSentId": 35794, "answer": "Why not? Couldnt you just use the network as a single processor,  with each processor acting like a thread? Then use some sort of recursive function on each computer to break the problem into threads. Then your main point would just act like a mutex. \n\nIm not sure though, ive never used multiple processors", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35779, "question": "Question about distributed and multithreaded prime number generation", "aSentId": 35796, "answer": "I doubt you're going to get better performance unless you are certain you are getting multiple processors working.  Otherwise it will be slower due to context switching overhead", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35800, "question": "Finite State Automaton : Markov Chain:: Pushdown Automaton : ???", "aSentId": 35801, "answer": "Probabilistic pushdown automaton ?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35800, "question": "Finite State Automaton : Markov Chain:: Pushdown Automaton : ???", "aSentId": 35803, "answer": "Markov Chain with a stack?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35800, "question": "Finite State Automaton : Markov Chain:: Pushdown Automaton : ???", "aSentId": 35805, "answer": "Thank for the answers, everybody!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35809, "question": "Should CS freshman with intro classes should try to contact professor for any research assistance opportunity in undergrad level?", "aSentId": 35810, "answer": "That's going to vary a ton based on the college and the type of research that the professor is doing. I am a sophomore in a CS program, and I did research during the summer after my freshman year, having only taken 2 CS courses. However, there were other research projects that required a lot more experience/specific knowledge. The best thing to do is probably to look at the department website - it'll tell you if there are already organized opportunities to get involved with research, and will probably have links to prof's research interests, which will give you a better idea of who you might enjoy working with. Then, you can contact them individually and see what kinds of skills they expect research assistants to have, and if they are looking for help (now, or in the future).  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35809, "question": "Should CS freshman with intro classes should try to contact professor for any research assistance opportunity in undergrad level?", "aSentId": 35812, "answer": "Everyone is making this way too complicated than it actually is.\n\nTo answer your actual question: if you are interested in doing research, then yes - you should absolutely contact professors and see what kinds of stuff they have.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35813, "question": "Everyone is making this way too complicated than it actually is.\n\nTo answer your actual question: if you are interested in doing research, then yes - you should absolutely contact professors and see what kinds of stuff they have.", "aSentId": 35814, "answer": "Mhm. If there's a professor whose research is interesting, or even just a professor you like, ask if there's anything you can help with. Worst case scenario: you don't have the experience they need yet, and they tell you how to get it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35815, "question": "Mhm. If there's a professor whose research is interesting, or even just a professor you like, ask if there's anything you can help with. Worst case scenario: you don't have the experience they need yet, and they tell you how to get it.", "aSentId": 35816, "answer": "Exactly this. I asked my professor what I needed to learn. He instructed me to teach myself Python and its Anaconda distribution and once I can do stuff with random big data then I'm ready to start.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35813, "question": "Everyone is making this way too complicated than it actually is.\n\nTo answer your actual question: if you are interested in doing research, then yes - you should absolutely contact professors and see what kinds of stuff they have.", "aSentId": 35818, "answer": "This", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35809, "question": "Should CS freshman with intro classes should try to contact professor for any research assistance opportunity in undergrad level?", "aSentId": 35820, "answer": "Because this will depend, as other replies have said, on the institute and professors, your best bet is to check with people in your department.  You could chat with advising. Or go through the Calendar and see which profs are into areas that interest you and approach them directly. \nAs a grad student I have had undergrads in my research group. Some even from 2nd year. But not all research groups will be the same.\n In my undergrad I did research (but not until 3rd and 4th year).  I know that the fact that I was published before applying for grad school helped with my application, something that would have been more difficult on my own. If you're interested in grad school, starting to work with research groups beforehand will benefit you. It will look good on your cv. But it will also help you figure out what really interests you. \n\ntldr: go talk to profs or grad students at your school", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35824, "question": "Big-O, Big-Omega, Big-Theta; Do I understand them correctly?", "aSentId": 35825, "answer": "&gt; Big-Theta: Description of average or expected running time.\n\nThis is not correct (though the bit that follows afterwards is).   Big-O, Big-\u03a9 and Big-\u0398 just describe classes of functions.  In the context of algorithms (until you learn otherwise) they almost always refer to the *worst case* exclusively.  As your definitions state: Big-O is for upper bounds, Big-\u03a9 is for lower bounds, and Big-\u0398 is for their intersection (note that this is not a single value, \u0398(n^(3)) = \u0398(3n^(3)) = \u0398(n^(3)/3) etc).\n\nAs an example:  \n\n* Sorting requires \u03a9(nlogn) comparisons - *any* algorithm requires **at least** c\\*nlogn comparisons *in the worst case* (for some constant c)\n* Merge sort makes O(nlogn) comparisons - *any* run of the algorithm takes **at most** d\\*nlogn comparisons (for some constant d) in any case - especially the worst case.\n* Therefore, Merge sort is \u0398(nlogn) - it takes nlogn comparisions and this is \"the best\" it can do.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35826, "question": "&gt; Big-Theta: Description of average or expected running time.\n\nThis is not correct (though the bit that follows afterwards is).   Big-O, Big-\u03a9 and Big-\u0398 just describe classes of functions.  In the context of algorithms (until you learn otherwise) they almost always refer to the *worst case* exclusively.  As your definitions state: Big-O is for upper bounds, Big-\u03a9 is for lower bounds, and Big-\u0398 is for their intersection (note that this is not a single value, \u0398(n^(3)) = \u0398(3n^(3)) = \u0398(n^(3)/3) etc).\n\nAs an example:  \n\n* Sorting requires \u03a9(nlogn) comparisons - *any* algorithm requires **at least** c\\*nlogn comparisons *in the worst case* (for some constant c)\n* Merge sort makes O(nlogn) comparisons - *any* run of the algorithm takes **at most** d\\*nlogn comparisons (for some constant d) in any case - especially the worst case.\n* Therefore, Merge sort is \u0398(nlogn) - it takes nlogn comparisions and this is \"the best\" it can do.", "aSentId": 35827, "answer": "A good way to think of Big-\u0398 is f = \u0398(g) if and only if f=O(g) and f=\u03a9(g)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35826, "question": "&gt; Big-Theta: Description of average or expected running time.\n\nThis is not correct (though the bit that follows afterwards is).   Big-O, Big-\u03a9 and Big-\u0398 just describe classes of functions.  In the context of algorithms (until you learn otherwise) they almost always refer to the *worst case* exclusively.  As your definitions state: Big-O is for upper bounds, Big-\u03a9 is for lower bounds, and Big-\u0398 is for their intersection (note that this is not a single value, \u0398(n^(3)) = \u0398(3n^(3)) = \u0398(n^(3)/3) etc).\n\nAs an example:  \n\n* Sorting requires \u03a9(nlogn) comparisons - *any* algorithm requires **at least** c\\*nlogn comparisons *in the worst case* (for some constant c)\n* Merge sort makes O(nlogn) comparisons - *any* run of the algorithm takes **at most** d\\*nlogn comparisons (for some constant d) in any case - especially the worst case.\n* Therefore, Merge sort is \u0398(nlogn) - it takes nlogn comparisions and this is \"the best\" it can do.", "aSentId": 35829, "answer": "There are absolutely sorting algorithms that operate faster that O(nlog n). \n\nThey're not classical sorting algorithms, but bucket sort/radix sort operate in O(N+m+n) time where the N is the number of buckets(basically the base eg. 2 would be with binary), m is the number of bits your number occupies, or rather the number of digits in your largest number, and n is the number of numbers to sort. \n\nObviously there are limitations as you must know the upper limit your algorithm is going to work with, in addition to making sure all your numbers occupy the same number of bits when the operation is run. (eg 0000015 rather than 15)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35830, "question": "There are absolutely sorting algorithms that operate faster that O(nlog n). \n\nThey're not classical sorting algorithms, but bucket sort/radix sort operate in O(N+m+n) time where the N is the number of buckets(basically the base eg. 2 would be with binary), m is the number of bits your number occupies, or rather the number of digits in your largest number, and n is the number of numbers to sort. \n\nObviously there are limitations as you must know the upper limit your algorithm is going to work with, in addition to making sure all your numbers occupy the same number of bits when the operation is run. (eg 0000015 rather than 15)", "aSentId": 35831, "answer": "This is a non sequitur, he was talking about n log n comparisons.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35832, "question": "This is a non sequitur, he was talking about n log n comparisons.", "aSentId": 35833, "answer": "He said that sorting had a best case of nlogn... Most people don't know about non-comparison based sorting  so I don't think it's non-sequitur", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35830, "question": "There are absolutely sorting algorithms that operate faster that O(nlog n). \n\nThey're not classical sorting algorithms, but bucket sort/radix sort operate in O(N+m+n) time where the N is the number of buckets(basically the base eg. 2 would be with binary), m is the number of bits your number occupies, or rather the number of digits in your largest number, and n is the number of numbers to sort. \n\nObviously there are limitations as you must know the upper limit your algorithm is going to work with, in addition to making sure all your numbers occupy the same number of bits when the operation is run. (eg 0000015 rather than 15)", "aSentId": 35835, "answer": "This is dependent on the structure of the data that you are sorting.  Comparison-based sorting is arguably the most general form of sorting as the only requirement you have is that elements can be compared (somewhat critical if you want the end result to make any sense)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35836, "question": "This is dependent on the structure of the data that you are sorting.  Comparison-based sorting is arguably the most general form of sorting as the only requirement you have is that elements can be compared (somewhat critical if you want the end result to make any sense)", "aSentId": 35837, "answer": "While it is dependent on the data being sorted, it can still be useful in MANY cases where the you only have linear time to sort, and the number of elements is staggeringly large, but uniform.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35838, "question": "While it is dependent on the data being sorted, it can still be useful in MANY cases where the you only have linear time to sort, and the number of elements is staggeringly large, but uniform.", "aSentId": 35839, "answer": "Of course it can be useful in many cases.  But just as it is important to mention non-comparison sorting, it is very important to highlight that it is an **integer** sorting algorithm (or &lt;insert suitable data structure&gt; sorting algorithm) - the \"speed up\" arises from the exploitation of the structure used to represent the data.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35840, "question": "Of course it can be useful in many cases.  But just as it is important to mention non-comparison sorting, it is very important to highlight that it is an **integer** sorting algorithm (or &lt;insert suitable data structure&gt; sorting algorithm) - the \"speed up\" arises from the exploitation of the structure used to represent the data.", "aSentId": 35841, "answer": "While what you're saying is correct, it is absolutely possible to serialize virtually any data into a string of integers that are ripe for this sort of comparison. Heck you can even even use that serialization as a key to a hashmap that links straight to the correct node in whatever data structure you're working with.\n\nComparison based sorting algorithms are also limited to comparable types, although they have the advantage of working with real numbers, rather that simply serialized integers.\n\nIt is true however that in most cases quicksort will be sufficiently quick, but there is a place in this world for all sorts of alternative solutions.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35842, "question": "While what you're saying is correct, it is absolutely possible to serialize virtually any data into a string of integers that are ripe for this sort of comparison. Heck you can even even use that serialization as a key to a hashmap that links straight to the correct node in whatever data structure you're working with.\n\nComparison based sorting algorithms are also limited to comparable types, although they have the advantage of working with real numbers, rather that simply serialized integers.\n\nIt is true however that in most cases quicksort will be sufficiently quick, but there is a place in this world for all sorts of alternative solutions.", "aSentId": 35843, "answer": "Yes, but you've got to be sure your serialization is order-preserving.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35844, "question": "Yes, but you've got to be sure your serialization is order-preserving.", "aSentId": 35845, "answer": "And so continues the fun pleasures of CS problems", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35824, "question": "Big-O, Big-Omega, Big-Theta; Do I understand them correctly?", "aSentId": 35847, "answer": "You will never *really* understand it without using the definition as a limit and applying calculus. For instance, how would you relate 2^(log(n)^2) to n^2 ? \n\nUgh edit: that's a square inside the exponent but outside the log", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35848, "question": "You will never *really* understand it without using the definition as a limit and applying calculus. For instance, how would you relate 2^(log(n)^2) to n^2 ? \n\nUgh edit: that's a square inside the exponent but outside the log", "aSentId": 35849, "answer": "Do you have any example of a function that looks like that? You've got me curious", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35850, "question": "Do you have any example of a function that looks like that? You've got me curious", "aSentId": 35851, "answer": "Going the other direction, it is possible to show that sorting algorithms require \u03a9(log(n!)) comparisons.  Show that \u03a9(log(n!)) = \u03a9(nlogn)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35852, "question": "Going the other direction, it is possible to show that sorting algorithms require \u03a9(log(n!)) comparisons.  Show that \u03a9(log(n!)) = \u03a9(nlogn)", "aSentId": 35853, "answer": "Well not all sorting algorithms use comparisons, but you're basically right", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35850, "question": "Do you have any example of a function that looks like that? You've got me curious", "aSentId": 35855, "answer": "Look up the complexity class QuasiP", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35848, "question": "You will never *really* understand it without using the definition as a limit and applying calculus. For instance, how would you relate 2^(log(n)^2) to n^2 ? \n\nUgh edit: that's a square inside the exponent but outside the log", "aSentId": 35857, "answer": "This is exactly what I want to learn. It annoys me that everyone just explains it in layman's terms.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35824, "question": "Big-O, Big-Omega, Big-Theta; Do I understand them correctly?", "aSentId": 35859, "answer": "Forget about running times for a while; think solely in terms of functions and their growth. \u03a9 and O mean lower and upper bound. \u0398 means a lower and upper bound. For example, if you know that 3n^2 &lt;= f(n) &lt;= 10n^2 for large n, then f is \u0398(n^(2)).\n\nIn complexity, we are interested how fast an algorithm can be, in terms of input size. However, the input size does not always determine how fast the algorithm will be. For example, a sorting algorithm might be fast on a list of 100 items that is already sorted, but slow on a shuffled list of the same size. So you cannot define \"running time\" as a function that assigns running time to n, because it's not uniquely defined. Instead, you can define \"worst running time\", \"best running time\" and \"average running time\". Those functions assign to each n the maximal, minimal or average time that is taken by the algorithm over all inputs of size n.\n\nFor example, suppose you have a sorting algorithm that takes 3n+10 time in best case, 9\\*n\\*log(n)-n on average and n^(2)/2 in worst case. You can use O, \u03a9 and \u0398 to describe the growth of those functions: \u0398(n) best case, \u0398(n log n) average case, \u0398(n^(2)) worst case, O(n^(5)) worst case, \u03a9(log n) best case, \u03a9(n) average case etc.\n\nIn particular, \u0398 need not mean average case. Also, you can use this notation when you speak about other resources used by algorithm (how much memory it uses, how many random bits it requires etc.)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35860, "question": "Forget about running times for a while; think solely in terms of functions and their growth. \u03a9 and O mean lower and upper bound. \u0398 means a lower and upper bound. For example, if you know that 3n^2 &lt;= f(n) &lt;= 10n^2 for large n, then f is \u0398(n^(2)).\n\nIn complexity, we are interested how fast an algorithm can be, in terms of input size. However, the input size does not always determine how fast the algorithm will be. For example, a sorting algorithm might be fast on a list of 100 items that is already sorted, but slow on a shuffled list of the same size. So you cannot define \"running time\" as a function that assigns running time to n, because it's not uniquely defined. Instead, you can define \"worst running time\", \"best running time\" and \"average running time\". Those functions assign to each n the maximal, minimal or average time that is taken by the algorithm over all inputs of size n.\n\nFor example, suppose you have a sorting algorithm that takes 3n+10 time in best case, 9\\*n\\*log(n)-n on average and n^(2)/2 in worst case. You can use O, \u03a9 and \u0398 to describe the growth of those functions: \u0398(n) best case, \u0398(n log n) average case, \u0398(n^(2)) worst case, O(n^(5)) worst case, \u03a9(log n) best case, \u03a9(n) average case etc.\n\nIn particular, \u0398 need not mean average case. Also, you can use this notation when you speak about other resources used by algorithm (how much memory it uses, how many random bits it requires etc.)", "aSentId": 35861, "answer": "You have several mistakes in this comment:\n\n&gt; O and \u03a9 mean lower and upper bound.\n\nTo be clearer, O and \u03a9 mean upper and lower bound respectively.\n\n&gt; For example, if you know that 3n^2 &lt;= f(n) &lt;= 10n^2 for large n, then f is \u0398( n^3 ).\n\nf is in \u0398( n^2 ). Since f(n) is in \u03a9( n^2 ) and f(n) is in O( n^2 ), by definition f(n) is in \u0398( n^2 )\n\nAlso, your last example is very hard to follow and took me several minutes to understand what you were saying, so OP if you don't get that example yet, don't worry. The upper and lower bounds are not tight bounds (i.e. we can be more precise) and you would not want to express those bounds with what is above, because since they're so off they are basically meaningless.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35862, "question": "You have several mistakes in this comment:\n\n&gt; O and \u03a9 mean lower and upper bound.\n\nTo be clearer, O and \u03a9 mean upper and lower bound respectively.\n\n&gt; For example, if you know that 3n^2 &lt;= f(n) &lt;= 10n^2 for large n, then f is \u0398( n^3 ).\n\nf is in \u0398( n^2 ). Since f(n) is in \u03a9( n^2 ) and f(n) is in O( n^2 ), by definition f(n) is in \u0398( n^2 )\n\nAlso, your last example is very hard to follow and took me several minutes to understand what you were saying, so OP if you don't get that example yet, don't worry. The upper and lower bounds are not tight bounds (i.e. we can be more precise) and you would not want to express those bounds with what is above, because since they're so off they are basically meaningless.\n", "aSentId": 35863, "answer": "I've fixed the typos, thanks.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35867, "question": "HUMAN SWARMS enable groups of online users to harness their Collective Intelligence", "aSentId": 35868, "answer": "This is a very interesting idea and it might outperform simple voting schemes at certain types of predictions and/or decision making by allowing users to more dynamically represent their preferences, and by allowing them to be influenced by the preferences of others.  More uncertain people can choose to follow the group consensus, more certain people can try and drive the boat.  \n\nStill, this type of swarm intelligence seems like it will only work for certain kinds of things.  If there is a question that there is a common misconception about, the swarm will likely instantiate the misconception, even if one member of the group is an expert and knows the truth about it.  Also, while this can answer discrete questions, it's hard to imagine doing any task that requires planning, like using the swarm to write a novel by having the group select the next word one at a time.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35869, "question": "This is a very interesting idea and it might outperform simple voting schemes at certain types of predictions and/or decision making by allowing users to more dynamically represent their preferences, and by allowing them to be influenced by the preferences of others.  More uncertain people can choose to follow the group consensus, more certain people can try and drive the boat.  \n\nStill, this type of swarm intelligence seems like it will only work for certain kinds of things.  If there is a question that there is a common misconception about, the swarm will likely instantiate the misconception, even if one member of the group is an expert and knows the truth about it.  Also, while this can answer discrete questions, it's hard to imagine doing any task that requires planning, like using the swarm to write a novel by having the group select the next word one at a time.", "aSentId": 35870, "answer": "I agree.  This is very cool, but has constraints.... the swarm will reflect the emergent wisdom of the population.  If the population holds flawed views or misconceptions, those views may very well emerge.  But that's what makes these swarms really interesting because they have unique personalities, flaws and all.  Each is true emergent intelligence.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35871, "question": "I agree.  This is very cool, but has constraints.... the swarm will reflect the emergent wisdom of the population.  If the population holds flawed views or misconceptions, those views may very well emerge.  But that's what makes these swarms really interesting because they have unique personalities, flaws and all.  Each is true emergent intelligence.", "aSentId": 35872, "answer": "Right, this won't solve everything, but at the very least you can get a group of people to pick a restaurant, which is a currently unsolved problem which I am having right now.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35874, "question": "High-content math and algorithm training videos", "aSentId": 35875, "answer": "i wish there was a 1.5x or 2x button like there is on youtube...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35876, "question": "i wish there was a 1.5x or 2x button like there is on youtube...", "aSentId": 35877, "answer": "You can still find the mp4 with inspect element...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35874, "question": "High-content math and algorithm training videos", "aSentId": 35879, "answer": "Would this be worth watching as a comp sci undergrad with just basic knowledge?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35880, "question": "Would this be worth watching as a comp sci undergrad with just basic knowledge?", "aSentId": 35881, "answer": "Sure, I think the Big Oh series would be instructive, and the Currying video too. I'm planning to make more algorithmic vids, any suggestions?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35882, "question": "Sure, I think the Big Oh series would be instructive, and the Currying video too. I'm planning to make more algorithmic vids, any suggestions?", "aSentId": 35883, "answer": "as I said I just have very basic knowledge of CS so Im not the right person to ask", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35882, "question": "Sure, I think the Big Oh series would be instructive, and the Currying video too. I'm planning to make more algorithmic vids, any suggestions?", "aSentId": 35885, "answer": "you should do some on Computational Theory", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35880, "question": "Would this be worth watching as a comp sci undergrad with just basic knowledge?", "aSentId": 35887, "answer": "I think so..undergrad also here. Big O comes up all the time", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35888, "question": "I think so..undergrad also here. Big O comes up all the time", "aSentId": 35889, "answer": "discrete math sorta stuff", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35874, "question": "High-content math and algorithm training videos", "aSentId": 35891, "answer": "your posture is all kyphotic i just want to crack your back.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35894, "question": "Finding Values In Arrays", "aSentId": 35895, "answer": "/r/javahelp is a better place for this", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35896, "question": "/r/javahelp is a better place for this", "aSentId": 35897, "answer": "Thank you! I didn't know that was a section! Got redirected here by a user on a forum lol", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35900, "question": "Honest Question, what does it feel like to be really good at a programming language?", "aSentId": 35901, "answer": "You stop thinking about how you code and focus on what you want to code.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35902, "question": "You stop thinking about how you code and focus on what you want to code.", "aSentId": 35903, "answer": "that really resonated with me, I want to be able to do this. Should I just keep studying java and learn C?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35904, "question": "that really resonated with me, I want to be able to do this. Should I just keep studying java and learn C?", "aSentId": 35905, "answer": "Look at programming languages like tools. Your tools should work for *you*, and you shouldn't jump ship on a tool because you don't understand it.\n\nI like thinking of languages in terms of pencils, pens, and paintbrushes. Once you master a language, you can figure out what it's good for and what you can do with it.\n\nYour ultimate goal is to get to the point where you go, \"I want to paint a picture,\" without any thought of the paintbrushes or their quirks and limitations.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35906, "question": "Look at programming languages like tools. Your tools should work for *you*, and you shouldn't jump ship on a tool because you don't understand it.\n\nI like thinking of languages in terms of pencils, pens, and paintbrushes. Once you master a language, you can figure out what it's good for and what you can do with it.\n\nYour ultimate goal is to get to the point where you go, \"I want to paint a picture,\" without any thought of the paintbrushes or their quirks and limitations.", "aSentId": 35907, "answer": "That being said, if you want to paint a house, you need to use a different set of tools.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35908, "question": "That being said, if you want to paint a house, you need to use a different set of tools.", "aSentId": 35909, "answer": "different sets of tools", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35910, "question": "different sets of tools", "aSentId": 35911, "answer": "I suppose it would depend on the house.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35900, "question": "Honest Question, what does it feel like to be really good at a programming language?", "aSentId": 35913, "answer": "Coding becomes like walking, and languages become like shoes; problems become destinations, and implementations become paths.\n\nAnd then you really start to think about what path is most scenic, what shortcuts are available, what destinations are most desirable, and what shoes are most comfortable to the path.\n\nYou don't really think about putting one foot in front of the other.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35914, "question": "Coding becomes like walking, and languages become like shoes; problems become destinations, and implementations become paths.\n\nAnd then you really start to think about what path is most scenic, what shortcuts are available, what destinations are most desirable, and what shoes are most comfortable to the path.\n\nYou don't really think about putting one foot in front of the other.", "aSentId": 35915, "answer": "This is by far the most beautifully accurate reply.\n\nThe act of choosing shoes and walks and such are based on a wealth of knowledge about how the shoes work and how the walk will be (in whatever weather you are going to have).  So you really need to follow all your thoughts about how something works and don't just stick with the analogies (though they are useful) then what would be a huge problem to somebody else is obvious to you!\n\nYou will stop thinking about how on earth do I do X and start thinking about all the different ways you can do X and working out which gives you the most benefit in maintainability / memory footprint / computation time / development time.\n\nAnd then you finally get to work on another problem you just don't know how to solve.  And its exhilarating.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35916, "question": "This is by far the most beautifully accurate reply.\n\nThe act of choosing shoes and walks and such are based on a wealth of knowledge about how the shoes work and how the walk will be (in whatever weather you are going to have).  So you really need to follow all your thoughts about how something works and don't just stick with the analogies (though they are useful) then what would be a huge problem to somebody else is obvious to you!\n\nYou will stop thinking about how on earth do I do X and start thinking about all the different ways you can do X and working out which gives you the most benefit in maintainability / memory footprint / computation time / development time.\n\nAnd then you finally get to work on another problem you just don't know how to solve.  And its exhilarating.", "aSentId": 35917, "answer": "Thanks :D", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35900, "question": "Honest Question, what does it feel like to be really good at a programming language?", "aSentId": 35919, "answer": "It's like riding a bicycle after you've been riding for a while.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35920, "question": "It's like riding a bicycle after you've been riding for a while.", "aSentId": 35921, "answer": "like a muscle ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35924, "question": "It feels like being able to make magic. Never stop learning. ", "aSentId": 35925, "answer": "We conjure the spirits of the computer with our spells?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35924, "question": "It feels like being able to make magic. Never stop learning. ", "aSentId": 35927, "answer": "Boom Pow its like Magic!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35932, "question": "Confused as to how to learn Algorithms analysis given that I know Java and C++ fairly well.", "aSentId": 35933, "answer": "I'm not sure what you're confused about. Algorithms classes usually don't have any programming involved so it doesn't matter which languages you know. You'll be doing mostly proofs, and sometimes looking at or writing pseudocode.\n\nAre you asking what books to get to help you study? Are you taking a class in algorithm analysis, or are you just learning this on your own?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35934, "question": "I'm not sure what you're confused about. Algorithms classes usually don't have any programming involved so it doesn't matter which languages you know. You'll be doing mostly proofs, and sometimes looking at or writing pseudocode.\n\nAre you asking what books to get to help you study? Are you taking a class in algorithm analysis, or are you just learning this on your own?", "aSentId": 35935, "answer": "&gt; I'm not sure what you're confused about.\n\nDitto.What's the actual question here?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35936, "question": "&gt; I'm not sure what you're confused about.\n\nDitto.What's the actual question here?", "aSentId": 35937, "answer": "What will I be doing in an algorithm analysis course that is different from a math course, and different from a programming course?  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35934, "question": "I'm not sure what you're confused about. Algorithms classes usually don't have any programming involved so it doesn't matter which languages you know. You'll be doing mostly proofs, and sometimes looking at or writing pseudocode.\n\nAre you asking what books to get to help you study? Are you taking a class in algorithm analysis, or are you just learning this on your own?", "aSentId": 35939, "answer": "My algorithm course involved implementing different algorithms which accomplished the same goal (sorting, shortest path, etc) and then writing papers and analysis comparing/contrasting them. So I would say programming ability was important.\n\n\nI'm also not sure what OP is worried about. Is he struggling in his course, or has he yet top begin and looking to get a head start (Apologies if OP is female). I'm betting it's the latter.\n\nAlgorithm analysis mostly deals with how to find the mathematical limits of processor operations compounded by programming constructs like loops and recursion. Realizing that different data sets will be better processed with different data structures used with different algorithms.\n\nSo OP, can you answer why merge sort is better than bubble sort? When is heap sort better than merge sort? When is it worse?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35940, "question": "My algorithm course involved implementing different algorithms which accomplished the same goal (sorting, shortest path, etc) and then writing papers and analysis comparing/contrasting them. So I would say programming ability was important.\n\n\nI'm also not sure what OP is worried about. Is he struggling in his course, or has he yet top begin and looking to get a head start (Apologies if OP is female). I'm betting it's the latter.\n\nAlgorithm analysis mostly deals with how to find the mathematical limits of processor operations compounded by programming constructs like loops and recursion. Realizing that different data sets will be better processed with different data structures used with different algorithms.\n\nSo OP, can you answer why merge sort is better than bubble sort? When is heap sort better than merge sort? When is it worse?", "aSentId": 35941, "answer": "Bubble sort is inefficient for large amounts of data, and cannot be used all of the time, however, I cannot give a proof-type answer.  Just from what I've read, and learned, I've understood that Bubble Sort makes more passes over data than some algorithms, and this makes it inefficient.  \n\nYour other questions are also familiar as well, but I cannot answer them in a proof-type format.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35942, "question": "Bubble sort is inefficient for large amounts of data, and cannot be used all of the time, however, I cannot give a proof-type answer.  Just from what I've read, and learned, I've understood that Bubble Sort makes more passes over data than some algorithms, and this makes it inefficient.  \n\nYour other questions are also familiar as well, but I cannot answer them in a proof-type format.  ", "aSentId": 35943, "answer": "So you haven't started this course yet? Correct?\n\nThe instructor should give you the means necessary to \"prove algorithms.\" This usually has to do with \"loop invariants.\" The instructor should explain what those are and how to prove them.\n\nI feel you're worried about not knowing what you'll be learning. I'm guessing school has been a breeze for you.  Maybe not every subject was easy, but most have been simple? So you've always been able to get to the point of the course easily.  Eventually that will change, maybe with this course.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35944, "question": "So you haven't started this course yet? Correct?\n\nThe instructor should give you the means necessary to \"prove algorithms.\" This usually has to do with \"loop invariants.\" The instructor should explain what those are and how to prove them.\n\nI feel you're worried about not knowing what you'll be learning. I'm guessing school has been a breeze for you.  Maybe not every subject was easy, but most have been simple? So you've always been able to get to the point of the course easily.  Eventually that will change, maybe with this course.", "aSentId": 35945, "answer": "Haven't really started, but I am enrolled.  It's the first few days of the course, so we're not doing much.\n\nYes, I'm worried about what I will be learning, and school has been a breeze up until this course.  I've managed to get A's in a lot of my programming courses, but Algorithm Analysis, (and Automata Theory) are the difficult courses in the CS curriculum.  \n\nSo I am worried about what I will be learning, so I am trying to prepare as much as possible.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35946, "question": "Haven't really started, but I am enrolled.  It's the first few days of the course, so we're not doing much.\n\nYes, I'm worried about what I will be learning, and school has been a breeze up until this course.  I've managed to get A's in a lot of my programming courses, but Algorithm Analysis, (and Automata Theory) are the difficult courses in the CS curriculum.  \n\nSo I am worried about what I will be learning, so I am trying to prepare as much as possible.  ", "aSentId": 35947, "answer": "If you haven't started the course yet, why are you so concerned about \"proofs\" in an algorithms course? Does your course require you to even do such a thing? Can you given an example question you've seen so far?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35946, "question": "Haven't really started, but I am enrolled.  It's the first few days of the course, so we're not doing much.\n\nYes, I'm worried about what I will be learning, and school has been a breeze up until this course.  I've managed to get A's in a lot of my programming courses, but Algorithm Analysis, (and Automata Theory) are the difficult courses in the CS curriculum.  \n\nSo I am worried about what I will be learning, so I am trying to prepare as much as possible.  ", "aSentId": 35949, "answer": "&gt; and school has been a breeze up until this course\n\nYou have lots of posts in /r/cheatatmathhomework ...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35950, "question": "&gt; and school has been a breeze up until this course\n\nYou have lots of posts in /r/cheatatmathhomework ...", "aSentId": 35951, "answer": "Exactly why school has been a breeze, because I research appropriately, and solve problems.  Part of my help comes from /r/cheatatmathhomework.  \n\n\nThere are some brilliant people in that sub-reddit. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35950, "question": "&gt; and school has been a breeze up until this course\n\nYou have lots of posts in /r/cheatatmathhomework ...", "aSentId": 35953, "answer": "To be fair, getting stuck on specific problems doesn't mean you don't get the concepts or can't do the majority of the work. I'm in grad school for math, I'm good at math, but I still ask for help a lot too. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35934, "question": "I'm not sure what you're confused about. Algorithms classes usually don't have any programming involved so it doesn't matter which languages you know. You'll be doing mostly proofs, and sometimes looking at or writing pseudocode.\n\nAre you asking what books to get to help you study? Are you taking a class in algorithm analysis, or are you just learning this on your own?", "aSentId": 35955, "answer": "I'm taking a class, but it seems to be going weird.  I know data structures from programming, but the proofs aspect is what is making it seem weird.  Should I approach algorithms like a math course, too?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35956, "question": "I'm taking a class, but it seems to be going weird.  I know data structures from programming, but the proofs aspect is what is making it seem weird.  Should I approach algorithms like a math course, too?", "aSentId": 35957, "answer": "Okay, so it sounds like you're having some difficulty with the proofs? \n\nI don't know what your approach to math courses are, so I don't know if that would help you with this algorithms course. \n\nWhat is it about the proofs that's difficult for you? Is it how the proofs are constructed? Is it how the proofs are valid? Is it how to go from algorithm to proving that algorithm (is correct, is optimal, etc)?\n\nGive some examples of what you're learning and what you're having trouble with otherwise it's kind of difficult to give any advice.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35958, "question": "Okay, so it sounds like you're having some difficulty with the proofs? \n\nI don't know what your approach to math courses are, so I don't know if that would help you with this algorithms course. \n\nWhat is it about the proofs that's difficult for you? Is it how the proofs are constructed? Is it how the proofs are valid? Is it how to go from algorithm to proving that algorithm (is correct, is optimal, etc)?\n\nGive some examples of what you're learning and what you're having trouble with otherwise it's kind of difficult to give any advice.", "aSentId": 35959, "answer": "Yes! It is how to go from an algorithm to proving an algorithm that has me confused.  I've taken Discrete Mathematics, and I did proofing there, but this proofing seems weird.  It seems like I am proving algorithms that are already proved.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35960, "question": "Yes! It is how to go from an algorithm to proving an algorithm that has me confused.  I've taken Discrete Mathematics, and I did proofing there, but this proofing seems weird.  It seems like I am proving algorithms that are already proved.  ", "aSentId": 35961, "answer": "Well you are proving algorithms that are already proved, you're still learning so you practice on simple things that are already known. It's the same as in discrete math, you start with simple proofs like 'show an even plus an odd is odd' or something.\n\nA lot of the 'feeling' about how to go about proofs is just practice. At least in my class, we would have about a week of practice with a single method of proof, so you didn't have to worry about figuring out which method to use, you just sort of took the problem and applied the method to it. Then later on you would have to figure out what method would be most appropriate. Is that how your class is laid out?\n\nWhat's a problem you're having right now, maybe give a concrete example.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35962, "question": "Well you are proving algorithms that are already proved, you're still learning so you practice on simple things that are already known. It's the same as in discrete math, you start with simple proofs like 'show an even plus an odd is odd' or something.\n\nA lot of the 'feeling' about how to go about proofs is just practice. At least in my class, we would have about a week of practice with a single method of proof, so you didn't have to worry about figuring out which method to use, you just sort of took the problem and applied the method to it. Then later on you would have to figure out what method would be most appropriate. Is that how your class is laid out?\n\nWhat's a problem you're having right now, maybe give a concrete example.", "aSentId": 35963, "answer": "Alright, I know there is a merge sort algorithm that I learned in my beginner Data Structures course, and I know that it is a Divide and Conquer algorithm.  However, how am I suppose to incorporate this knowledge into a proof?\n\nDo I use the run time of the merge sort, to then write out a proof? Don't all algorithms depend on the size of the data, so we assume a worst case scenario for the data all of the time, so that we create algorithms for large amounts of data to be processed?  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35964, "question": "Alright, I know there is a merge sort algorithm that I learned in my beginner Data Structures course, and I know that it is a Divide and Conquer algorithm.  However, how am I suppose to incorporate this knowledge into a proof?\n\nDo I use the run time of the merge sort, to then write out a proof? Don't all algorithms depend on the size of the data, so we assume a worst case scenario for the data all of the time, so that we create algorithms for large amounts of data to be processed?  ", "aSentId": 35965, "answer": "Well in my class we used a proof to prove the running time of merge-sort and heap-sort. For merge-sort we used something called a recursion-tree to prove the running time, and for heap-sort we had to take use of the geometric series to prove the running time. I could probably show you some of my notes for the proofs but it might be a little difficult to follow without a teacher to go over every line lol", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35966, "question": "Well in my class we used a proof to prove the running time of merge-sort and heap-sort. For merge-sort we used something called a recursion-tree to prove the running time, and for heap-sort we had to take use of the geometric series to prove the running time. I could probably show you some of my notes for the proofs but it might be a little difficult to follow without a teacher to go over every line lol", "aSentId": 35967, "answer": "Alright, I know what all of these things are, just that they are being applied in a different setting.  Geometric Series is from Calc III, but now it is being used for algorithm analysis.  This is what I wanted to know.  \n\nSo, basically, all of the previous math I have studied up to this point, is being used to prove algorithms, correct?\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35964, "question": "Alright, I know there is a merge sort algorithm that I learned in my beginner Data Structures course, and I know that it is a Divide and Conquer algorithm.  However, how am I suppose to incorporate this knowledge into a proof?\n\nDo I use the run time of the merge sort, to then write out a proof? Don't all algorithms depend on the size of the data, so we assume a worst case scenario for the data all of the time, so that we create algorithms for large amounts of data to be processed?  ", "aSentId": 35969, "answer": "Generally, all algorithm analysis depends on input size.\n\nWhat you'll learn is that merge sort is O( n * lg(n) ) while bubble sort is O( n^2 ) . Where lg(n) == log(n)/log(2) : it's comp sci notation.\n\nWhy is this? Because merge sort divides the data set by two in its sorting process. This means that it takes double the data size for it to have an extra cycle of dividing and combining. While bubble sort has to sort every element by comparing it to every other element, so for every n elements you have to compare each to another (n-1) elements. And you can probably see how n(n-1) is bounded by the n^2 in that result.\n\nEdit: if something is wrong here, forgive me. It's been like four years since my algorithms course, and I'm a little drunk. #balmerPeak. But I think I got the idea across fine.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35974, "question": "Need a good introduction to algorithms book aside from the current book that everyone already uses. Is that the only one, or are there other alternatives to use?", "aSentId": 35975, "answer": "Not sure which text you're referring to, but we used Kleinberg and Tardos' Algorithm Design in my intro to algos class. I found it was pretty clear with good exposition and great problems. But it might be good to find something like CLRS which has solutions online. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35976, "question": "Not sure which text you're referring to, but we used Kleinberg and Tardos' Algorithm Design in my intro to algos class. I found it was pretty clear with good exposition and great problems. But it might be good to find something like CLRS which has solutions online. ", "aSentId": 35977, "answer": "I TA under Tardos and I really like this book. Compared to other algorithms books, this one focuses on the high-level attributes of an algorithm rather than the specifics of its implementation. In the exercises, there is a good balance of reductions and direct implementations. There is also a breadth of algorithm types covered. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35980, "question": "How to choose an honours thesis?", "aSentId": 35981, "answer": "Asking the supervisor for topic suggestions would be an excellent first step.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35980, "question": "How to choose an honours thesis?", "aSentId": 35983, "answer": "I'd like to see some real numbers regarding NoSQL performance vs RDBMS's - with real world examples and relationships in both.  Just a thought though.\n\nOr maybe create a new SQL language, yeah!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35985, "question": "Any good reads on Formal Language Theory/Chomsky Hierarchy?", "aSentId": 35986, "answer": "If you can find it, the first edition of Introduction to Automata Theory, Languages, and Computation, by Hopcroft and Ullman, is the essential reference for advanced topics in formal language. It's not too big, and it goes into lots of details for deterministic context free languages, undecidability, AFLs and trios, etc. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35987, "question": "If you can find it, the first edition of Introduction to Automata Theory, Languages, and Computation, by Hopcroft and Ullman, is the essential reference for advanced topics in formal language. It's not too big, and it goes into lots of details for deterministic context free languages, undecidability, AFLs and trios, etc. ", "aSentId": 35988, "answer": "Any suggested place to purchase? Looks pretty cool.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35985, "question": "Any good reads on Formal Language Theory/Chomsky Hierarchy?", "aSentId": 35990, "answer": "I enjoyed reading Shallit's \"A Second Course in Formal Languages and Automata Theory\". I think it is well-written and it treated a lot of topics that did not get attention when I took ToC, including but not limited to:\n\n * combinatorics on words\n * language homomorphisms\n * Moore automata\n * Ogden's lemma\n * Parikh's theorem\n * Kolmogorov complexity\n\nMy copy is also rather small and lightweight; it would definitely fit in a backpack!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35991, "question": "I enjoyed reading Shallit's \"A Second Course in Formal Languages and Automata Theory\". I think it is well-written and it treated a lot of topics that did not get attention when I took ToC, including but not limited to:\n\n * combinatorics on words\n * language homomorphisms\n * Moore automata\n * Ogden's lemma\n * Parikh's theorem\n * Kolmogorov complexity\n\nMy copy is also rather small and lightweight; it would definitely fit in a backpack!", "aSentId": 35992, "answer": "Do you have a suggested buyer? Was hoping to find a copy for under 50$.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35994, "question": "Looking for a computer tutor for Computer Graphics", "aSentId": 35995, "answer": "Have your spoken to your professor / department?  I know my school had a tutoring center and professors who were lenient on due dates for students who had medical absences. \n\nI imagine an in person tutor would be more effective. \n\nSorry for the criticism,  there must already be a reason you're resorting to asking Reddit,  it's just not clear from your post :) ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35996, "question": "Have your spoken to your professor / department?  I know my school had a tutoring center and professors who were lenient on due dates for students who had medical absences. \n\nI imagine an in person tutor would be more effective. \n\nSorry for the criticism,  there must already be a reason you're resorting to asking Reddit,  it's just not clear from your post :) ", "aSentId": 35997, "answer": "Sadly, our university does not offer this and we tend to have to learn it ourself :(", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 35994, "question": "Looking for a computer tutor for Computer Graphics", "aSentId": 35999, "answer": "There's a relatively new sub that might interest you: /r/GraphicsProgramming", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 36000, "question": "There's a relatively new sub that might interest you: /r/GraphicsProgramming", "aSentId": 36001, "answer": "Thanks", "corpus": "reddit"}]