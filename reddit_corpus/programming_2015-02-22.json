[{"docID": "t5_2fwo", "qSentId": 39740, "question": "UNIX V5, OpenBSD, Plan 9, FreeBSD, and GNU coreutils implementations of echo.c", "aSentId": 39741, "answer": "What can the GNU implementation do that the UNIX one can't?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39742, "question": "What can the GNU implementation do that the UNIX one can't?", "aSentId": 39743, "answer": "It can display help and version information, it is the only version that will correctly detect write errors, and it has the additional -e flag, which enables the interpretation of escape sequences like \\n or \\x2f. (And for me, the last one is actually a pretty major feature that I use quite often)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39744, "question": "It can display help and version information, it is the only version that will correctly detect write errors, and it has the additional -e flag, which enables the interpretation of escape sequences like \\n or \\x2f. (And for me, the last one is actually a pretty major feature that I use quite often)", "aSentId": 39745, "answer": "Good. I assumed there were actual features that were needed. I doubt they would make the code longer for the sake of making it longer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39744, "question": "It can display help and version information, it is the only version that will correctly detect write errors, and it has the additional -e flag, which enables the interpretation of escape sequences like \\n or \\x2f. (And for me, the last one is actually a pretty major feature that I use quite often)", "aSentId": 39747, "answer": "Not just help and version information, but help and version information in your preferred language.  The names of the authors also have a reasonable chance to print correctly even if they contain non-ascii characters.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39742, "question": "What can the GNU implementation do that the UNIX one can't?", "aSentId": 39749, "answer": "Make a pot of coffee.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39740, "question": "UNIX V5, OpenBSD, Plan 9, FreeBSD, and GNU coreutils implementations of echo.c", "aSentId": 39751, "answer": "&gt;gnu echo is pretty bad. Is that a goto? I can't believe that code is running on my machine.\n\nI get the impression that this guy heard somewhere \"oh goto is bad blabla complicated stuff I don't understand\" and proceeded to blindly parrot it. One of the main reasons people avoid goto is because it was often overused making the whole code a spaghetti disaster, not because \"no matter what it's automatically bad\". There are select cases in which goto is the optimal solution. In a code this short they obviously didn't use goto out of lazyness and even if they did, so what? The code is so short that one goto is not going to make it unreadable. \n\nAnd why is longer automatically mean \"bloated oh god trash code\"? The GNU one offers -e which can be useful, and implementing it makes the code a bit longer. Why is this a problem? ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39752, "question": "&gt;gnu echo is pretty bad. Is that a goto? I can't believe that code is running on my machine.\n\nI get the impression that this guy heard somewhere \"oh goto is bad blabla complicated stuff I don't understand\" and proceeded to blindly parrot it. One of the main reasons people avoid goto is because it was often overused making the whole code a spaghetti disaster, not because \"no matter what it's automatically bad\". There are select cases in which goto is the optimal solution. In a code this short they obviously didn't use goto out of lazyness and even if they did, so what? The code is so short that one goto is not going to make it unreadable. \n\nAnd why is longer automatically mean \"bloated oh god trash code\"? The GNU one offers -e which can be useful, and implementing it makes the code a bit longer. Why is this a problem? ", "aSentId": 39753, "answer": "It's probably best not to tell him what happens to all loops when they are converted into machine code ;)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39754, "question": "It's probably best not to tell him what happens to all loops when they are converted into machine code ;)", "aSentId": 39755, "answer": "I'm actually curious what happens?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39756, "question": "I'm actually curious what happens?", "aSentId": 39757, "answer": "at the assembly level, there is only goto, basically. Rolling your own for/while loops from assembly is a pretty standard undergrad low level systems programming assignment.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39758, "question": "at the assembly level, there is only goto, basically. Rolling your own for/while loops from assembly is a pretty standard undergrad low level systems programming assignment.", "aSentId": 39759, "answer": "conditional goto*\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39758, "question": "at the assembly level, there is only goto, basically. Rolling your own for/while loops from assembly is a pretty standard undergrad low level systems programming assignment.", "aSentId": 39761, "answer": "An assignment which had the nasty side effect of making people write identically styled loops in C when we moved on from assembly.\n\nI saw lots of scary code in that class...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39762, "question": "An assignment which had the nasty side effect of making people write identically styled loops in C when we moved on from assembly.\n\nI saw lots of scary code in that class...", "aSentId": 39763, "answer": "Hah! My instructor for this was a defense industry reverse-engineer who was adjuncting for shits and giggles. Nice guy and really knowledgeable, but he demanded total coding style discipline. One of my favorite examples was him making the class use C-decl calling convention to call c from assembly from c from assembly from ... until we all got it. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39756, "question": "I'm actually curious what happens?", "aSentId": 39765, "answer": "jumps, jumps everywhere. The goto is an explicit jump.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39752, "question": "&gt;gnu echo is pretty bad. Is that a goto? I can't believe that code is running on my machine.\n\nI get the impression that this guy heard somewhere \"oh goto is bad blabla complicated stuff I don't understand\" and proceeded to blindly parrot it. One of the main reasons people avoid goto is because it was often overused making the whole code a spaghetti disaster, not because \"no matter what it's automatically bad\". There are select cases in which goto is the optimal solution. In a code this short they obviously didn't use goto out of lazyness and even if they did, so what? The code is so short that one goto is not going to make it unreadable. \n\nAnd why is longer automatically mean \"bloated oh god trash code\"? The GNU one offers -e which can be useful, and implementing it makes the code a bit longer. Why is this a problem? ", "aSentId": 39767, "answer": "A modern goto in C or any other scoped language is leagues different than the stuff Dijkstra was talking about in _Go To Statement Considered Harmful_. When he wrote that, programs looked [like this](http://www.dunnington.u-net.com/public/startrek/STTR1). Modern control flow (scoped if... else blocks, etc.) won that battle so well that people don't even remember what the battle was about. A modern equivalent of what he was talking about would be controlling logic in your program with `setjmp` and `longjmp`.\n\nSure, sometimes you can clean up code containing a goto into a nicer control structure, but 99% of all complaints about goto I see online are just blind parroting.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39768, "question": "A modern goto in C or any other scoped language is leagues different than the stuff Dijkstra was talking about in _Go To Statement Considered Harmful_. When he wrote that, programs looked [like this](http://www.dunnington.u-net.com/public/startrek/STTR1). Modern control flow (scoped if... else blocks, etc.) won that battle so well that people don't even remember what the battle was about. A modern equivalent of what he was talking about would be controlling logic in your program with `setjmp` and `longjmp`.\n\nSure, sometimes you can clean up code containing a goto into a nicer control structure, but 99% of all complaints about goto I see online are just blind parroting.", "aSentId": 39769, "answer": "On a related note,\n\n&gt; It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.\n\n-Edsger Dijkstra", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39770, "question": "On a related note,\n\n&gt; It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.\n\n-Edsger Dijkstra", "aSentId": 39771, "answer": "I started out with QBasic, and have grown up to be a fine programmer. I guess QBasic isn't quite as mutilating as the older dialects?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39772, "question": "I started out with QBasic, and have grown up to be a fine programmer. I guess QBasic isn't quite as mutilating as the older dialects?", "aSentId": 39773, "answer": "Maybe so. I started with Tandy Color BASIC and now I'm a mediocre programmer at best.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39768, "question": "A modern goto in C or any other scoped language is leagues different than the stuff Dijkstra was talking about in _Go To Statement Considered Harmful_. When he wrote that, programs looked [like this](http://www.dunnington.u-net.com/public/startrek/STTR1). Modern control flow (scoped if... else blocks, etc.) won that battle so well that people don't even remember what the battle was about. A modern equivalent of what he was talking about would be controlling logic in your program with `setjmp` and `longjmp`.\n\nSure, sometimes you can clean up code containing a goto into a nicer control structure, but 99% of all complaints about goto I see online are just blind parroting.", "aSentId": 39775, "answer": "it kind of makes me sad. seeing code like that just makes me fall in love all over again. Sure, it has flaws, and doesn't follow the paradigms that we approve of today, but ... ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39776, "question": "it kind of makes me sad. seeing code like that just makes me fall in love all over again. Sure, it has flaws, and doesn't follow the paradigms that we approve of today, but ... ", "aSentId": 39777, "answer": "Please. It's unreadable, unstructured... Properly written assembly looks more readble.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39752, "question": "&gt;gnu echo is pretty bad. Is that a goto? I can't believe that code is running on my machine.\n\nI get the impression that this guy heard somewhere \"oh goto is bad blabla complicated stuff I don't understand\" and proceeded to blindly parrot it. One of the main reasons people avoid goto is because it was often overused making the whole code a spaghetti disaster, not because \"no matter what it's automatically bad\". There are select cases in which goto is the optimal solution. In a code this short they obviously didn't use goto out of lazyness and even if they did, so what? The code is so short that one goto is not going to make it unreadable. \n\nAnd why is longer automatically mean \"bloated oh god trash code\"? The GNU one offers -e which can be useful, and implementing it makes the code a bit longer. Why is this a problem? ", "aSentId": 39779, "answer": "A lot of the commentary around these kinds of posts revolves around the mistaken assumption that more code is necessarily worse than less code. If you read the gnu echo code a lot of it is just stuff like outputting usage text, and setting up execution in the context of other GNU tools. The core bit where you execute echo's actual functionality is perfectly concise. \n\nOnce again, I am forced to conclude that most commenters on the internet are kids straight out of college who *clearly* know what's best. And I say this as someone who doesn't use Linux or the GNU userland... \n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39780, "question": "A lot of the commentary around these kinds of posts revolves around the mistaken assumption that more code is necessarily worse than less code. If you read the gnu echo code a lot of it is just stuff like outputting usage text, and setting up execution in the context of other GNU tools. The core bit where you execute echo's actual functionality is perfectly concise. \n\nOnce again, I am forced to conclude that most commenters on the internet are kids straight out of college who *clearly* know what's best. And I say this as someone who doesn't use Linux or the GNU userland... \n", "aSentId": 39781, "answer": "&gt; more code is necessarily worse than less code\n\nAlmost always, however, more complexity is worse than less complexity, if we're speaking about general rules. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39782, "question": "&gt; more code is necessarily worse than less code\n\nAlmost always, however, more complexity is worse than less complexity, if we're speaking about general rules. ", "aSentId": 39783, "answer": "More complexity is worse than less complexity _if the resulting functionality is the same_, sure. Adding a '-n' flag to echo certainly increases the code's complexity, but also adds a feature. That doesn't necessarily make it bad because it's more complex.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39784, "question": "More complexity is worse than less complexity _if the resulting functionality is the same_, sure. Adding a '-n' flag to echo certainly increases the code's complexity, but also adds a feature. That doesn't necessarily make it bad because it's more complex.", "aSentId": 39785, "answer": "But this can go against the Unix 'do one thing well' philosophy. The additional functionality could just as well have been implemented as individual commands that are composed using the shell:\n    echo 'Hello, World!' | nonewline\nI appreciate -n is a poor example as it is such a tiny thing, but by the time you've reached the GNU version with that terrible main with gotos, surely you'd start at least thinking about modularity. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39782, "question": "&gt; more code is necessarily worse than less code\n\nAlmost always, however, more complexity is worse than less complexity, if we're speaking about general rules. ", "aSentId": 39787, "answer": "I work in financial technology, and give every person who comes onto my team *The Exercise*. \n\nIt goes something like this: take a look at a specific bit of code and tell me which lines need to be removed. For each block of code that you think should be removed, justify its removal. \n\nThe first part is always easy (\"Who needs this shit? DELETE!\"). The second, however, is usually much harder (\"Subsystem XYZ needs this. Congratulations, you just refactored away our ability to trade on the open market\").\n\nAs outside observers, it's easy to throw rocks. When I see complexity, I ask why its there. Usually there's a pretty good reason for it. Despite my non-use of GNU userland, I have no reason to believe the GNU folks are idiots...they are, after all, a huge part of Linux's success as an operating system. In cases where they introduce complexity, they have probably done so for a reason, which is why I give them the benefit of the doubt -- even if it does seem to go against generally accepted rules of thumb. \n\n(Is this where the inevitable systemd flamewar will begin? Stay tuned!)\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39740, "question": "UNIX V5, OpenBSD, Plan 9, FreeBSD, and GNU coreutils implementations of echo.c", "aSentId": 39790, "answer": "If you look at the FreeBSD version of this carefully, you'll find that it has this weird code pattern to avoid using the C library.  This cut down the binary size from ~50k to ~12k, at the cost of having the source code be a little more complex.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39791, "question": "If you look at the FreeBSD version of this carefully, you'll find that it has this weird code pattern to avoid using the C library.  This cut down the binary size from ~50k to ~12k, at the cost of having the source code be a little more complex.", "aSentId": 39792, "answer": "Hah, that's a very interesting point.  I noticed they were using writev which is odd (normally), but I didn't think that this might be done specifically to avoid the libc wrapper for write and writep that take inputs and generate syscall writev calls.  Does this mean that FreeBSD only supports \"writev\" at the syscall layer?\n\nedit: been a bit, but last I checked Linux support write, writep, writev as syscalls.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39791, "question": "If you look at the FreeBSD version of this carefully, you'll find that it has this weird code pattern to avoid using the C library.  This cut down the binary size from ~50k to ~12k, at the cost of having the source code be a little more complex.", "aSentId": 39794, "answer": "&gt; This cut down the binary size from ~50k to ~12k\n\nThis was important back in the day, when:\n\n* There were separate root and ``/usr`` filesystems and root had to be small (``/bin/echo`` would be on root).\n* Programs on the root filesystem might be run at boot time when any dynamic-linking system (or the dynamic libraries themselves) might not be available, because it depended on things on ``/usr``.\n* ``echo`` might have to be part of a subset of BSD that could boot from very small media, like an 800 KB floppy, for installation, repair, or maintenance. I remember booting a V7 derivative on a [Fortune Systems 32:16](http://www.old-computers.com/museum/computer.asp?c=767) from a floppy.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39796, "question": "\n    main(argc, argv)\n    int argc;\n    char *argv[];  \n    {\n        //...\n    }\n\nI just learned 2 new things about C in the first 2 lines.\n\n1. The return type can be omitted and it looks like it defaults to `int` \n1. The  argument types can be moved to between the parentheses and the braces.", "aSentId": 39797, "answer": "That is the way arguments were originally declared. It is almost never done that way in new code these days. (And I\u2019m thinking it was officially deprecated at some point, but I\u2019m not positive.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39798, "question": "That is the way arguments were originally declared. It is almost never done that way in new code these days. (And I\u2019m thinking it was officially deprecated at some point, but I\u2019m not positive.)", "aSentId": 39799, "answer": "It is definitely deprecated. That old style declaration doesn't work at all in a modern compiler.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39800, "question": "It is definitely deprecated. That old style declaration doesn't work at all in a modern compiler.", "aSentId": 39801, "answer": "Vim is still written like that, and I'm pretty sure it needn't be compiled with an old compiler", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39796, "question": "\n    main(argc, argv)\n    int argc;\n    char *argv[];  \n    {\n        //...\n    }\n\nI just learned 2 new things about C in the first 2 lines.\n\n1. The return type can be omitted and it looks like it defaults to `int` \n1. The  argument types can be moved to between the parentheses and the braces.", "aSentId": 39803, "answer": "Both are correct. They're mostly leftovers from K&amp;R C, and not really used anymore.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39796, "question": "\n    main(argc, argv)\n    int argc;\n    char *argv[];  \n    {\n        //...\n    }\n\nI just learned 2 new things about C in the first 2 lines.\n\n1. The return type can be omitted and it looks like it defaults to `int` \n1. The  argument types can be moved to between the parentheses and the braces.", "aSentId": 39805, "answer": "Please don't do this, ever.\n\nThis is pre-standardization C. Seeing how the first standard is C89 (89 after year it was published in), it is way of writing that has been deprecated for over 25 years.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39807, "question": "&gt; The return type can be omitted and it looks like it defaults to int\n\nThe type of anything could be left off and it defaulted to int. Not just functions but local variables too:\n\n    #include &lt;stdio.h&gt;\n    \n    int main(void) {\n      auto x;\n      x = 42;\n      printf (\"x is %d\\n\", x);\n      return 0;\n    }\n\nHere I've used the rarely-used `auto` keyword (sort of the opposite of `static` -- says the variable should have the lifetime of a local variable, i.e. should be *auto*matically created and destroyed when you enter/leave the scope).\n\nThe `auto` keyword is syntactically enough for the compiler to understands that this is a variable declaration. Which means I don't need to give the type, because variables default to `int` if you don't say otherwise. (Just like the scope defaults to `auto` if you don't say otherwise, at least it defaults to that when declaring a variable inside a function.)\n\nWhy is `int` the default type? It goes back to C's heritage as a low-level language. `int` is the type that represents a native word for the machine, the kind of values that you would have in a CPU register. Those are the most natural thing for the machine to work with, so they're the default. If you want to do something more abstract like deal with an array or a struct, then you have to specify that you're not just programming the machine, you're using \"special\" add-on types provided by the language.", "aSentId": 39808, "answer": "I was extremely confused there until I realized that we were talking about C, not C++. The auto keyword in C++11 onwards is a great way to not have to write out full typenames and just have the compiler deduce them at compile time. Makes range-based for loops a  joy. Did the remove the C auto from C++?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39811, "question": "OpenBSD and plan9 stick to the \"Keep it simple\" part of the UNIX philosophy really well. ", "aSentId": 39812, "answer": "And elegantly show off the flaws of that philosophy as well when you need to echo an escape character.\n\nEdit: Or write out to a full disk.  Or run it in extremely low memory situations.\n\nEdit2: Or run it with invalid input.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39813, "question": "And elegantly show off the flaws of that philosophy as well when you need to echo an escape character.\n\nEdit: Or write out to a full disk.  Or run it in extremely low memory situations.\n\nEdit2: Or run it with invalid input.", "aSentId": 39814, "answer": "It isn't a flaw if it wasn't supposed to do that in the first place. If you wanted to echo an escape character you could use either a program made for writing escape characters or some other program that supported formatted text.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39815, "question": "It isn't a flaw if it wasn't supposed to do that in the first place. If you wanted to echo an escape character you could use either a program made for writing escape characters or some other program that supported formatted text.", "aSentId": 39816, "answer": "&gt; use either a program made for writing escape characters\n\nLike GNU echo?\n\n&gt; or some other program that supported formatted text.\n\nWhat alternate reality do you live in where nonprintable characters are the same as formatted text?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39817, "question": "&gt; use either a program made for writing escape characters\n\nLike GNU echo?\n\n&gt; or some other program that supported formatted text.\n\nWhat alternate reality do you live in where nonprintable characters are the same as formatted text?", "aSentId": 39818, "answer": "I'm talking about the Unix philosophy, not what you find today in a Linux system (which was designed *far* from following it).\n\nIn such a system, echo would echo its parameters and nothing else (like V5 echo does), since that is what is supposed to do and nothing else. If you wanted to use an escape character, you would use a separate program like say `esc` that all it does is to take an escape code and replace it with the actual character string that the escape code represents. Hence if you wanted to use, let's say, newline you'd do something like ``echo Line one`esc n`Line two``. The shell will replace the `` `esc n` `` part with the character \\n represents before calling `echo`. This way you have two programs, each one doing a single thing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39819, "question": "I'm talking about the Unix philosophy, not what you find today in a Linux system (which was designed *far* from following it).\n\nIn such a system, echo would echo its parameters and nothing else (like V5 echo does), since that is what is supposed to do and nothing else. If you wanted to use an escape character, you would use a separate program like say `esc` that all it does is to take an escape code and replace it with the actual character string that the escape code represents. Hence if you wanted to use, let's say, newline you'd do something like ``echo Line one`esc n`Line two``. The shell will replace the `` `esc n` `` part with the character \\n represents before calling `echo`. This way you have two programs, each one doing a single thing.", "aSentId": 39820, "answer": "What exactly do you gain from that?\n\nOther than your room being made slightly warmer from the CPU overhead of an extra program invocation.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39821, "question": "What exactly do you gain from that?\n\nOther than your room being made slightly warmer from the CPU overhead of an extra program invocation.", "aSentId": 39822, "answer": "That is the argument that led to other operating systems with a more coupled philosophy", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39823, "question": "That is the argument that led to other operating systems with a more coupled philosophy", "aSentId": 39824, "answer": "I prefer the philosophy of \"Make a good product, and don't obsess over philosophies that don't make sense in a particular context.\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39821, "question": "What exactly do you gain from that?\n\nOther than your room being made slightly warmer from the CPU overhead of an extra program invocation.", "aSentId": 39826, "answer": "I do not understand this.  Can you tell me how many CPU cycles are needed for each call for, say \"Hello world!\\n\" to look proper?  And explain why GNU's version saves me power.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39827, "question": "I do not understand this.  Can you tell me how many CPU cycles are needed for each call for, say \"Hello world!\\n\" to look proper?  And explain why GNU's version saves me power.", "aSentId": 39828, "answer": "It's not that there are more calls in the program (compiler optimizations and all kinds of other fun stuff makes that hard to measure.)\n\nIt's that invoking the proposed /bin/esc is way more expensive, because there's a large number of things that have to happen when starting a new process.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39813, "question": "And elegantly show off the flaws of that philosophy as well when you need to echo an escape character.\n\nEdit: Or write out to a full disk.  Or run it in extremely low memory situations.\n\nEdit2: Or run it with invalid input.", "aSentId": 39830, "answer": "It's not standardized, but `bash`, `zsh`, and `mksh` can interpret C-style escape sequences in strings when you quote them like this: `$'Hello\\x20world.\\n'`. With perfect hindsight that's how the shell should've been designed, instead of dumping this functionality an external program.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39831, "question": "It's not standardized, but `bash`, `zsh`, and `mksh` can interpret C-style escape sequences in strings when you quote them like this: `$'Hello\\x20world.\\n'`. With perfect hindsight that's how the shell should've been designed, instead of dumping this functionality an external program.", "aSentId": 39832, "answer": "On most shells, echo is a builtin.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39833, "question": "On most shells, echo is a builtin.", "aSentId": 39834, "answer": "Yes, a builtin whose behavior varies from shell to shell. The fact that you have to use a command to interpret escapes also makes certain things awkward. For example, take this script\n\n    #!/bin/sh\n\n    message=\"$(echo -e 'Hello world.\\n\\n\\n\\n')\"\n    printf \"Our cool message: '%s'\" \"$message\"\n\nFirst of all, dash's echo (the /bin/sh used in Debian) doesn't support -e. So use /bin/echo, you say. But the system's echo may or may not support -e either, so you're really no better off.\n\nSecond of all, there's a bug. The `$()` command substitution helpfully stripped all the trailing newlines from the string. In general, the `foo=$(echo -e \"$bar\")` pattern to interpret escape sequences isn't safe, because it has the side effect of stripping newlines.\n\nThis is why relying on echo is bad, and why shell programming is terrible.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39813, "question": "And elegantly show off the flaws of that philosophy as well when you need to echo an escape character.\n\nEdit: Or write out to a full disk.  Or run it in extremely low memory situations.\n\nEdit2: Or run it with invalid input.", "aSentId": 39836, "answer": "True", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39811, "question": "OpenBSD and plan9 stick to the \"Keep it simple\" part of the UNIX philosophy really well. ", "aSentId": 39838, "answer": "Yeah except their \"echo\" sucks.  How do you generate (e.g.) an escape character?  With a literal escape character in your source code?  That's horrid.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39839, "question": "Yeah except their \"echo\" sucks.  How do you generate (e.g.) an escape character?  With a literal escape character in your source code?  That's horrid.", "aSentId": 39840, "answer": "By \"source code\", do you mean \"command line\"?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39842, "question": "Any idea why the BSD version does not use getopt? ", "aSentId": 39843, "answer": "Sadly, the standardization of echo is fucked and everybody does things differently. You should probably use printf instead.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39844, "question": "Sadly, the standardization of echo is fucked and everybody does things differently. You should probably use printf instead.", "aSentId": 39845, "answer": "It's perverse how difficult something as basic as printing a string is to get right because of this. `echo` may or may not interpret escape sequences by default (builtin `echo` in `dash`, `zsh`, and `mksh` do, but `bash` and GNU `echo` don't), so whether `echo \"foo\\nbar\"` prints the newline depends on the shell. `-e`/`-E` can enable/disable escape sequences, but that's nonstandard too (`dash` doesn't support it).\n\nAnd what if you have `echo \"$string\"`, but `$string` turns out to  literally be `-E` or `-n` or `--help`? It may be parsed as a option or it may be echoed literally, it depends. You can't say `echo -- \"$string\"` either, because nobody supports `--`.\n\nSo yeah, use `printf %s \"$string\"` instead of echo if you want to print something literally without the shell mangling your shit.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39842, "question": "Any idea why the BSD version does not use getopt? ", "aSentId": 39847, "answer": "because getopt would eat args that look like options.  For example, what if it used getopt() and you tried to do something like:\n\n    echo usage: myprog -a  -n -h\n    \nI guess you'd say you'd do something like\n\n    echo usage: myprog -- -a -n -h\n    \nSince the two dashes indicate that no more options are being parsed.  But then what if you wanted echo to print two dashes?  You'd have to enter them twice like:\n\n    echo -- --\n\nSo I think getopt() complicates things.\n    \n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39848, "question": "because getopt would eat args that look like options.  For example, what if it used getopt() and you tried to do something like:\n\n    echo usage: myprog -a  -n -h\n    \nI guess you'd say you'd do something like\n\n    echo usage: myprog -- -a -n -h\n    \nSince the two dashes indicate that no more options are being parsed.  But then what if you wanted echo to print two dashes?  You'd have to enter them twice like:\n\n    echo -- --\n\nSo I think getopt() complicates things.\n    \n", "aSentId": 39849, "answer": "A good way to make a whole bunch of shellscripts shit themselves is having files called \"-a\" and \"-c\" etc. all over the place.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39850, "question": "A good way to make a whole bunch of shellscripts shit themselves is having files called \"-a\" and \"-c\" etc. all over the place.", "aSentId": 39851, "answer": "Because ./-a isn't a thing. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39852, "question": "Because ./-a isn't a thing. ", "aSentId": 39853, "answer": "And also calling scripts on * isn't a thing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39848, "question": "because getopt would eat args that look like options.  For example, what if it used getopt() and you tried to do something like:\n\n    echo usage: myprog -a  -n -h\n    \nI guess you'd say you'd do something like\n\n    echo usage: myprog -- -a -n -h\n    \nSince the two dashes indicate that no more options are being parsed.  But then what if you wanted echo to print two dashes?  You'd have to enter them twice like:\n\n    echo -- --\n\nSo I think getopt() complicates things.\n    \n", "aSentId": 39855, "answer": "yea, I really don't want to think about that with echo. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39842, "question": "Any idea why the BSD version does not use getopt? ", "aSentId": 39857, "answer": "Because it would be a violation of POSIX. POSIX says that echo doesn't take any flags and may not recognize \"--\" the way other utilities do. \"-n\" is a widely used non-standard behavior, which POSIX later changed from illegal to implementation defined, so it was implemented in the least invasive way possible.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39862, "question": "Wow the GNU one is dreadful. I get that it does more, but that code is so bad. ", "aSentId": 39863, "answer": "You can't just say that without giving some examples about why it's bad.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39862, "question": "Wow the GNU one is dreadful. I get that it does more, but that code is so bad. ", "aSentId": 39865, "answer": "What in particular makes it bad?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39869, "question": "I can't believe how verbose some of these are. In [D](http://dlang.org/) it's simply:\n\n    import std.array;\n    import std.stdio;\n\n    void main(string[] args)\n    {\n        if (args.length &gt; 1)\n        {\n            args[1..$].join(\" \").writeln;\n        }\n    }", "aSentId": 39870, "answer": "Okay, you've matched Unix 5th edition, which was similarly simple.\n\nYou aren't supporting any of the behavior of the more verbose versions.\nHow would you support \"-n\" / \"\\c\" in D?\nHow would you support GNU echo's \"-e/-E\" behavior?\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39871, "question": "Okay, you've matched Unix 5th edition, which was similarly simple.\n\nYou aren't supporting any of the behavior of the more verbose versions.\nHow would you support \"-n\" / \"\\c\" in D?\nHow would you support GNU echo's \"-e/-E\" behavior?\n", "aSentId": 39872, "answer": "With about the same amount of code as in the GNU version (maybe minus a little with the use of [std.getopt](http://dlang.org/phobos/std_getopt.html)).\n\nD, C++, Java, &lt;insert higher level language than C here&gt; make string handling a bit easier, but they don't take away the fundamental complexity of handling escape sequences and parsing command line options. I don't know what point /u/kalekold is trying to make.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39869, "question": "I can't believe how verbose some of these are. In [D](http://dlang.org/) it's simply:\n\n    import std.array;\n    import std.stdio;\n\n    void main(string[] args)\n    {\n        if (args.length &gt; 1)\n        {\n            args[1..$].join(\" \").writeln;\n        }\n    }", "aSentId": 39874, "answer": "UNIX is an OS, not a language :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39869, "question": "I can't believe how verbose some of these are. In [D](http://dlang.org/) it's simply:\n\n    import std.array;\n    import std.stdio;\n\n    void main(string[] args)\n    {\n        if (args.length &gt; 1)\n        {\n            args[1..$].join(\" \").writeln;\n        }\n    }", "aSentId": 39876, "answer": "That is the equivalent of the SYSV version at the top except that you forgot the trailing newline.  Start adding in support for the flags and checking for errors and it will look like the FreeBSD or GNU versions in a hurry.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39880, "question": "IMVU's automated tests uncover a bug in the Windows SSL layer", "aSentId": 39881, "answer": "That was interesting, it must have been horrible to debug! Did you report this bug somewhere?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39882, "question": "That was interesting, it must have been horrible to debug! Did you report this bug somewhere?", "aSentId": 39883, "answer": "If we haven't gotten around to reporting the bug to Microsoft yet, I know it's on our task board.  :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39884, "question": "If we haven't gotten around to reporting the bug to Microsoft yet, I know it's on our task board.  :)", "aSentId": 39885, "answer": "What. the. fuck.\n\nBasic security protocol says to report the bug up to the offending party immediately, almost always before going public with the issue.\nEven though this does not appear to be a classic vulnerability report, per se (you aren't announcing a remote execution exploit), given that it's related to the SSL layer, there's reason to be deferential.\n\nHere's why:\n\n1) If you misunderstood your results, they can explain what's up, and both you and they can save face.\n\n2) If you are correct, and they already know about the bug, they can accelerate efforts to fix it now that it's been \"discovered\" or ensure there is an adequate public statement in place explaining why the bug is not critical.  Not going public immediately helps give them time to release a patch or do any write-up.\n\n3) If you are correct and they haven't previously discovered the bug, they can begin the process of investigating the bug.  Not going public immediately helps give them time to release a patch or statement.\n\nSometimes a company fails to release a patch for some time. In these cases, security researchers may go public as a last-ditch response to publicly humiliate and shame the company into patching the hole.   Anytime an unpatched vulnerability is discussed, blackhats everywhere start trying to figure out how to exploit it, adding even more stress to customers and companies.  This is why it's so important to be judicious in your reveals.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39886, "question": "What. the. fuck.\n\nBasic security protocol says to report the bug up to the offending party immediately, almost always before going public with the issue.\nEven though this does not appear to be a classic vulnerability report, per se (you aren't announcing a remote execution exploit), given that it's related to the SSL layer, there's reason to be deferential.\n\nHere's why:\n\n1) If you misunderstood your results, they can explain what's up, and both you and they can save face.\n\n2) If you are correct, and they already know about the bug, they can accelerate efforts to fix it now that it's been \"discovered\" or ensure there is an adequate public statement in place explaining why the bug is not critical.  Not going public immediately helps give them time to release a patch or do any write-up.\n\n3) If you are correct and they haven't previously discovered the bug, they can begin the process of investigating the bug.  Not going public immediately helps give them time to release a patch or statement.\n\nSometimes a company fails to release a patch for some time. In these cases, security researchers may go public as a last-ditch response to publicly humiliate and shame the company into patching the hole.   Anytime an unpatched vulnerability is discussed, blackhats everywhere start trying to figure out how to exploit it, adding even more stress to customers and companies.  This is why it's so important to be judicious in your reveals.", "aSentId": 39887, "answer": "&gt;Anytime an unpatched vulnerability is discussed, blackhats everywhere start trying to figure out how to exploit it, adding even more stress to customers and companies. This is why it's so important to be judicious in your reveals.\n\nWhat if I discovered a security bug in a MS product and MS was my (or my employers) competitor? What if I believe that proprietary software is immoral?\n\nShould I then go out of my way to work for free against my own interests for a company with shady business practices?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39888, "question": "&gt;Anytime an unpatched vulnerability is discussed, blackhats everywhere start trying to figure out how to exploit it, adding even more stress to customers and companies. This is why it's so important to be judicious in your reveals.\n\nWhat if I discovered a security bug in a MS product and MS was my (or my employers) competitor? What if I believe that proprietary software is immoral?\n\nShould I then go out of my way to work for free against my own interests for a company with shady business practices?", "aSentId": 39889, "answer": "&gt;What if I discovered a security bug in a MS product and MS was my (or my employers) competitor? What if I believe that proprietary software is immoral?\n\n&gt;Should I then go out of my way to work for free against my own interests for a company with shady business practices?\n\nYes, you should.\n\nWhy? Because the difficult part is finding the bug, and reporting it is very easy. If you are not looking for bugs simply to report them, then that means you are not working for free, because the work was already done for another reason. Not to mention that a good number of companies give bounties for bugs, so you still can get paid if you actually submit the bug.\n\nIf Microsoft is your competitor, and you knowingly take malicious actions that affect hundreds of millions of computers, then no one will feel sorry for you when Microsoft's legal team goes after you for damages caused and your company loses millions. Actions that can cause the destruction of property or the loss of data are illegal. (A step above \"shady\")\n\nIf you feel that proprietary software is immoral, then you should feel remorse about leaving a security hole out there that will affect dozens of services you use and that will affect a significant number of realities and friends. If you aren't submitting the bug because it's not in your best interests, then you should rethink the situation. Submitting the bug report is actually in your best interests, because the functionality of your business likely depends on other companies that run on Microsoft products, and the loss of those services would lose your business money. Also, doing nice things for other people is often not in your best interests, but humans are strange like that; we like to help other people at our own expense.\n\nMaybe if the exploit is totally silly, or it can be fixed with a simple settings change, then you don't have to report it, but if it can be used to cause problems on computers you don't own, then it should be reported using the correct channels. All the reasons you gave are very poor reasons to hide a known problem, and publicly releasing it before you alert Microsoft and give them time to fix it is choice that will bite you in the butt in multiple ways.\n\nAlso, it seems kinda hypocritical to say that proprietary software is immoral, then try to charge money for bugs you randomly found, but maybe that's just me.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39890, "question": "&gt;What if I discovered a security bug in a MS product and MS was my (or my employers) competitor? What if I believe that proprietary software is immoral?\n\n&gt;Should I then go out of my way to work for free against my own interests for a company with shady business practices?\n\nYes, you should.\n\nWhy? Because the difficult part is finding the bug, and reporting it is very easy. If you are not looking for bugs simply to report them, then that means you are not working for free, because the work was already done for another reason. Not to mention that a good number of companies give bounties for bugs, so you still can get paid if you actually submit the bug.\n\nIf Microsoft is your competitor, and you knowingly take malicious actions that affect hundreds of millions of computers, then no one will feel sorry for you when Microsoft's legal team goes after you for damages caused and your company loses millions. Actions that can cause the destruction of property or the loss of data are illegal. (A step above \"shady\")\n\nIf you feel that proprietary software is immoral, then you should feel remorse about leaving a security hole out there that will affect dozens of services you use and that will affect a significant number of realities and friends. If you aren't submitting the bug because it's not in your best interests, then you should rethink the situation. Submitting the bug report is actually in your best interests, because the functionality of your business likely depends on other companies that run on Microsoft products, and the loss of those services would lose your business money. Also, doing nice things for other people is often not in your best interests, but humans are strange like that; we like to help other people at our own expense.\n\nMaybe if the exploit is totally silly, or it can be fixed with a simple settings change, then you don't have to report it, but if it can be used to cause problems on computers you don't own, then it should be reported using the correct channels. All the reasons you gave are very poor reasons to hide a known problem, and publicly releasing it before you alert Microsoft and give them time to fix it is choice that will bite you in the butt in multiple ways.\n\nAlso, it seems kinda hypocritical to say that proprietary software is immoral, then try to charge money for bugs you randomly found, but maybe that's just me.", "aSentId": 39891, "answer": "I get the business angle. But you haven't quite convinced me about the moral angle.\n\n&gt;If you feel that proprietary software is immoral, then you should feel remorse about leaving a security hole out there that will affect dozens of services you use and that will affect a significant number of realities and friends.\n\nI don't get the logic here. This is something I am morally against. I hope my relatives and friends can understand that I won't work for this, even if it would benefit them. Also, in the long term this is only benefiting Microsoft. There are other products on the market, and if my friends and relatives are dependent on security related work I do for their operating system, they can go use an operating system I am willing to work on. \n\n&gt; Also, doing nice things for other people is often not in your best interests, but humans are strange like that; we like to help other people at our own expense.\n\nAgreed. But Microsoft is not people. I would gladly do nice things for my family, my neighbors, or some random person I met on the street. I am not doing nice things for a multinational company which sole aim is making profit for its investors.\n\n&gt;Also, it seems kinda hypocritical to say that proprietary software is immoral, then try to charge money for bugs you randomly found, but maybe that's just me.\n\nWell, in this case it is some person publishing the bug he found instead of reporting it to Microsoft. Seems pretty in line with principles of openness. It is not like anybody is holding information hostage for money, nor would I support that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39888, "question": "&gt;Anytime an unpatched vulnerability is discussed, blackhats everywhere start trying to figure out how to exploit it, adding even more stress to customers and companies. This is why it's so important to be judicious in your reveals.\n\nWhat if I discovered a security bug in a MS product and MS was my (or my employers) competitor? What if I believe that proprietary software is immoral?\n\nShould I then go out of my way to work for free against my own interests for a company with shady business practices?", "aSentId": 39893, "answer": "&gt; competitor?\n\nYou still report it because if they are a competitor, then their users are your (future) users and you will be able to publicise the bug (at some near future date) while allowing MS to make a fix and protect users. This is better than essentially turning MS customers into potential targets for a small (probably backfiring) commercial gain.\n\n&gt; proprietary software is immoral\n\nAgain, you can publish the bug soon, while sitting on your high horse. However, by grandstanding, you don't really harm Microsoft much except by exposing the users to a greater risk of harm.\n\n&gt; Should I then go out of my way to work for free against my own interests for a company with shady business practices?\n\nNo-one is forcing anything to do anything. In this case the work was done. The issue is the widely accepted (and not Microsoft specific)method of announcing security bugs of all sorts (not just MS ones).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39894, "question": "&gt; competitor?\n\nYou still report it because if they are a competitor, then their users are your (future) users and you will be able to publicise the bug (at some near future date) while allowing MS to make a fix and protect users. This is better than essentially turning MS customers into potential targets for a small (probably backfiring) commercial gain.\n\n&gt; proprietary software is immoral\n\nAgain, you can publish the bug soon, while sitting on your high horse. However, by grandstanding, you don't really harm Microsoft much except by exposing the users to a greater risk of harm.\n\n&gt; Should I then go out of my way to work for free against my own interests for a company with shady business practices?\n\nNo-one is forcing anything to do anything. In this case the work was done. The issue is the widely accepted (and not Microsoft specific)method of announcing security bugs of all sorts (not just MS ones).", "aSentId": 39895, "answer": "&gt;In this case the work was done.\n\nWhat is the problem then? From some of the comments here it seems that people want the author to do more(or do things differently). It might not be that much work, but it is still work. I imagine that if you were e.g. Richard Stallman you would not want to do work for Microsoft. Not even symbollically.\n\n&gt;while sitting on your *high horse*. However, by *grandstanding*,\n\nGotcha, you don't hold those views about propeirtary software. Would you report or security bug to an ISIS web site dedeciated to radicalizing young muslims? Or do the widely accepted standard protocol trumpf everything because it is standard and widely accepted?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39896, "question": "&gt;In this case the work was done.\n\nWhat is the problem then? From some of the comments here it seems that people want the author to do more(or do things differently). It might not be that much work, but it is still work. I imagine that if you were e.g. Richard Stallman you would not want to do work for Microsoft. Not even symbollically.\n\n&gt;while sitting on your *high horse*. However, by *grandstanding*,\n\nGotcha, you don't hold those views about propeirtary software. Would you report or security bug to an ISIS web site dedeciated to radicalizing young muslims? Or do the widely accepted standard protocol trumpf everything because it is standard and widely accepted?", "aSentId": 39897, "answer": "You're being weird, is it on purpose? RMS would not have occasion to report a bug to Microsoft because he doesn't use their products and so has no way of finding them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39898, "question": "You're being weird, is it on purpose? RMS would not have occasion to report a bug to Microsoft because he doesn't use their products and so has no way of finding them.", "aSentId": 39899, "answer": "It was just an example. Are you saying that there are no security interested people who might examine Microsoft windows, who also have strong views about free software out there?\n\nFor example, if I personally was good at and interested in security, I don't think I would feel any obligation to report any bugs I found in Windows to MS(hence my original comment). But maybe your views on this matter comes automatically with expertise in security, and as such holding my views and being good at these things are mutually exclusive?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39884, "question": "If we haven't gotten around to reporting the bug to Microsoft yet, I know it's on our task board.  :)", "aSentId": 39901, "answer": "Wait, what? You \"have gotten around\" to a 3,000-word blog post, and to reposting that on reddit, but \"maybe\" not to actually reporting the bug?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39884, "question": "If we haven't gotten around to reporting the bug to Microsoft yet, I know it's on our task board.  :)", "aSentId": 39903, "answer": "Yeah, no time to report a bug to the people that can actually fix it.\n\nGreat that you did manage to find the time to brag about it on reddit.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39904, "question": "Yeah, no time to report a bug to the people that can actually fix it.\n\nGreat that you did manage to find the time to brag about it on reddit.", "aSentId": 39905, "answer": "Why don't you reproduce his results and send the bug to Microsoft?\n\nI suspect time is a big factor in lack of following the protocol. Ffs, they use php. This is not their core business.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39904, "question": "Yeah, no time to report a bug to the people that can actually fix it.\n\nGreat that you did manage to find the time to brag about it on reddit.", "aSentId": 39907, "answer": "That's what happens when you're a repressed, overqualified engineer working on a garbage product.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39908, "question": "That's what happens when you're a repressed, overqualified engineer working on a garbage product.", "aSentId": 39909, "answer": "No, it's what happens when you have no integrity. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39880, "question": "IMVU's automated tests uncover a bug in the Windows SSL layer", "aSentId": 39912, "answer": "I suspect microsoft is aware of this problem because ms14-066 added DHE GCM suits (9e/9f) rather than the ecdhe gcm suites Firefox and Chrome prefer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39880, "question": "IMVU's automated tests uncover a bug in the Windows SSL layer", "aSentId": 39914, "answer": "&gt;SSL layer", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39915, "question": "&gt;SSL layer", "aSentId": 39916, "answer": "Hope they're not using that in any ATM machines.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39917, "question": "Hope they're not using that in any ATM machines.", "aSentId": 39918, "answer": "If the machine is infected, you don't want to enter your PIN number", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39919, "question": "If the machine is infected, you don't want to enter your PIN number", "aSentId": 39920, "answer": "Yay, I'm relevant!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39921, "question": "Yay, I'm relevant!", "aSentId": 39922, "answer": "*pinumber*number\n\nYes, we know Pi is a number, Mr. Mister Redundance.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39921, "question": "Yay, I'm relevant!", "aSentId": 39924, "answer": "So how am I supposed to say to people to enter in their PIN while also implying that it's in numerical form? Personal Identification Number is too long and PIN has been in use for so long that many people aren't going to register the fact that they're the same noun. PI Number has never been used in either context and will just confuse people.\n\nThe correct solution to this perceived \"redundancy\" is to replace this level of linguistic pedantry and just arbitrarily declare \"PIN\" to have no acronym. I mean, what part of a PIN is personal anyway, when it's also used to secure business accounts too? Do we need to ask consumers to enter their PIN and businesses to enter their BIN? Let's just forget that PIN ever stood for anything and stop joking when people make perfectly natural linguistic constructions.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39925, "question": "So how am I supposed to say to people to enter in their PIN while also implying that it's in numerical form? Personal Identification Number is too long and PIN has been in use for so long that many people aren't going to register the fact that they're the same noun. PI Number has never been used in either context and will just confuse people.\n\nThe correct solution to this perceived \"redundancy\" is to replace this level of linguistic pedantry and just arbitrarily declare \"PIN\" to have no acronym. I mean, what part of a PIN is personal anyway, when it's also used to secure business accounts too? Do we need to ask consumers to enter their PIN and businesses to enter their BIN? Let's just forget that PIN ever stood for anything and stop joking when people make perfectly natural linguistic constructions.", "aSentId": 39926, "answer": "What's wrong with \"please enter your PIN\"?\n\n&gt;while also implying that it's in numerical form\n\nThere's no need, everyone knows what a PIN is.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39925, "question": "So how am I supposed to say to people to enter in their PIN while also implying that it's in numerical form? Personal Identification Number is too long and PIN has been in use for so long that many people aren't going to register the fact that they're the same noun. PI Number has never been used in either context and will just confuse people.\n\nThe correct solution to this perceived \"redundancy\" is to replace this level of linguistic pedantry and just arbitrarily declare \"PIN\" to have no acronym. I mean, what part of a PIN is personal anyway, when it's also used to secure business accounts too? Do we need to ask consumers to enter their PIN and businesses to enter their BIN? Let's just forget that PIN ever stood for anything and stop joking when people make perfectly natural linguistic constructions.", "aSentId": 39928, "answer": "/r/iamverysmart", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39925, "question": "So how am I supposed to say to people to enter in their PIN while also implying that it's in numerical form? Personal Identification Number is too long and PIN has been in use for so long that many people aren't going to register the fact that they're the same noun. PI Number has never been used in either context and will just confuse people.\n\nThe correct solution to this perceived \"redundancy\" is to replace this level of linguistic pedantry and just arbitrarily declare \"PIN\" to have no acronym. I mean, what part of a PIN is personal anyway, when it's also used to secure business accounts too? Do we need to ask consumers to enter their PIN and businesses to enter their BIN? Let's just forget that PIN ever stood for anything and stop joking when people make perfectly natural linguistic constructions.", "aSentId": 39930, "answer": "A product that i work on does indeed have a BIN for businesses.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39932, "question": "Fucking software, man.\n\nStill, great detective work.  \nWould have loved to see the reaction of management as well - \"what did your research show after $30k of man hours?\" \"oh, we just have to untick this one checkbox here\".", "aSentId": 39933, "answer": "How about:\n\nOur automated testing infrastructure was occasionally giving incorrect results. Dealing with these issues was costing the development team significant time and energy. Additionally the failures might indicate a configuration problem that could also be present on our production servers, potentially costing us revenue. \n\nAfter investigation we identified an alternative configuration that did not exhibit the problem. Unfortunately this configuration could not be applied to production because it had significant downsides. Applying the configuration change only on the testing system would lead to a not well-understood discrepancy between production and testing. This can lead to problems only being caught in production instead of during testing. \n\nWe investigated the problem further so the differences between our testing and production configurations would at least be well-understood, even if the additional investigation failed to solve the problem. After eliminating all components of our own software and infrastructure as possible causes the problem was tracked down to a component of Internet Explorer. This problem is worked around with a change to our testing servers. While this means there is a discrepancy between production and testing, we are confident that at least the problem is solved and the implications of the workaround are well-understood. \n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39934, "question": "How about:\n\nOur automated testing infrastructure was occasionally giving incorrect results. Dealing with these issues was costing the development team significant time and energy. Additionally the failures might indicate a configuration problem that could also be present on our production servers, potentially costing us revenue. \n\nAfter investigation we identified an alternative configuration that did not exhibit the problem. Unfortunately this configuration could not be applied to production because it had significant downsides. Applying the configuration change only on the testing system would lead to a not well-understood discrepancy between production and testing. This can lead to problems only being caught in production instead of during testing. \n\nWe investigated the problem further so the differences between our testing and production configurations would at least be well-understood, even if the additional investigation failed to solve the problem. After eliminating all components of our own software and infrastructure as possible causes the problem was tracked down to a component of Internet Explorer. This problem is worked around with a change to our testing servers. While this means there is a discrepancy between production and testing, we are confident that at least the problem is solved and the implications of the workaround are well-understood. \n", "aSentId": 39935, "answer": "Can I pay you to write to my clients?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39932, "question": "Fucking software, man.\n\nStill, great detective work.  \nWould have loved to see the reaction of management as well - \"what did your research show after $30k of man hours?\" \"oh, we just have to untick this one checkbox here\".", "aSentId": 39937, "answer": "Chad pointed me at this question. I am the executive sponsor of this work (VP Technology,) and I think it was worth it!\n\nIMVU is a significantly more complex technology with significantly more feature points than most other web stacks, because we are a large-scale, anonymous, social network AND a large-scale, user-generated, 3D game.\n\nWe don't have time to have people hand-hold all kinds of flaky processes and manual work-arounds. We need to have our engineers work on putting exciting features that people like, where they want to see those features, and to adapt to the changing world (anything from security advisories to payment gateway changes.)\n\nThe fact that the fix was so simple, and can be merged into any and all of our Windows-based images, is a bonus, not a negative!\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39938, "question": "Chad pointed me at this question. I am the executive sponsor of this work (VP Technology,) and I think it was worth it!\n\nIMVU is a significantly more complex technology with significantly more feature points than most other web stacks, because we are a large-scale, anonymous, social network AND a large-scale, user-generated, 3D game.\n\nWe don't have time to have people hand-hold all kinds of flaky processes and manual work-arounds. We need to have our engineers work on putting exciting features that people like, where they want to see those features, and to adapt to the changing world (anything from security advisories to payment gateway changes.)\n\nThe fact that the fix was so simple, and can be merged into any and all of our Windows-based images, is a bonus, not a negative!\n", "aSentId": 39939, "answer": "Thanks for the answer, that is so refreshing to hear.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39932, "question": "Fucking software, man.\n\nStill, great detective work.  \nWould have loved to see the reaction of management as well - \"what did your research show after $30k of man hours?\" \"oh, we just have to untick this one checkbox here\".", "aSentId": 39941, "answer": "&gt;what did your research show after $30k of man hours.\n\n**[Citation Needed]**\n\n*^I ^am ^a ^bot. ^For ^questions ^or ^comments, ^please ^contact ^/u/slickytail*", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39942, "question": "&gt;what did your research show after $30k of man hours.\n\n**[Citation Needed]**\n\n*^I ^am ^a ^bot. ^For ^questions ^or ^comments, ^please ^contact ^/u/slickytail*", "aSentId": 39943, "answer": "You're a stupid and pointless bot", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39944, "question": "You're a stupid and pointless bot", "aSentId": 39945, "answer": "Most of them are ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39942, "question": "&gt;what did your research show after $30k of man hours.\n\n**[Citation Needed]**\n\n*^I ^am ^a ^bot. ^For ^questions ^or ^comments, ^please ^contact ^/u/slickytail*", "aSentId": 39947, "answer": "Reassurance that skynet is not quite ready for primetime", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39949, "question": "Why didn't you just calculate the MAC yourself to verify whether windows calculates the correct MAC or not?\n\nIt seems to me that you both have the expertise and willingness to go so far given that you even modified the gnutls-serv source.", "aSentId": 39950, "answer": "That would have been extremely difficult or impossible to do. How would you even do that? For the IE + Apache/openssl combination, they wouldn't be able to get enough information to calculate the MAC. That was the whole point about perfect forward secrecy: Wireshark wasn't able to tell them anything about the handshake.\n\nI think adding more logging to the gnutls-serv source was the right way to figure this out.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39951, "question": "That would have been extremely difficult or impossible to do. How would you even do that? For the IE + Apache/openssl combination, they wouldn't be able to get enough information to calculate the MAC. That was the whole point about perfect forward secrecy: Wireshark wasn't able to tell them anything about the handshake.\n\nI think adding more logging to the gnutls-serv source was the right way to figure this out.", "aSentId": 39952, "answer": "You need to determine the private keys for one of the sides, either through logging or memory tricks in order to calculate the MAC. It doesn't seem incredibly difficult given that one of the codebases is open source.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39959, "question": "TL;DR would be great.", "aSentId": 39960, "answer": "The TL;DR is that they suspect Windows has a bug where it incorrectly calculates a MAC during a TLS 1.2 initialization.  Turning off TLS 1.2 support in IE works around the problem in their testing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39959, "question": "TL;DR would be great.", "aSentId": 39962, "answer": "&gt; The bottom line is that the implementation of Diffie-Hellman key exchange used by Internet Explorer 11 on Windows 7 is broken. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39966, "question": "Yeah, security and closed source software .... ROFL.", "aSentId": 39967, "answer": "Sorry being pedantic, but the article does not imply that this bug can be abused as a security breach. For the while, it is only an annoying bug.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39969, "question": "Lenovo's SuperFish Removal Tool on GitHub", "aSentId": 39970, "answer": "&amp;gt; System.Threading.Thread.Sleep(500); // Let the user see the final 100% before hiding progress bar\n\n  \n  \nInteresting use of sleep. They seem to purposely slow down the removal in order to make the user think it's doing heavy work. I wonder if that's why Windows Update takes about 3 hours after a fresh install...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39971, "question": "&amp;gt; System.Threading.Thread.Sleep(500); // Let the user see the final 100% before hiding progress bar\n\n  \n  \nInteresting use of sleep. They seem to purposely slow down the removal in order to make the user think it's doing heavy work. I wonder if that's why Windows Update takes about 3 hours after a fresh install...", "aSentId": 39972, "answer": "It's actually fairly common and quite important. It's absolutely awful for the user to not see 100%. These 500ms won't slow anything down but with them, the user sees it has completed and not aborted. An alternative is to show a message box or another screen but that actually slows you down more.\n\nNB: I haven't checked the program doesn't do a combination of these", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39971, "question": "&amp;gt; System.Threading.Thread.Sleep(500); // Let the user see the final 100% before hiding progress bar\n\n  \n  \nInteresting use of sleep. They seem to purposely slow down the removal in order to make the user think it's doing heavy work. I wonder if that's why Windows Update takes about 3 hours after a fresh install...", "aSentId": 39974, "answer": "Imagine a user sees the progress at 50% then it suddenly closes. Did it complete successfully or not?\n\nA lot of people will assume it crashed if they don't see it complete.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39969, "question": "Lenovo's SuperFish Removal Tool on GitHub", "aSentId": 39976, "answer": "So Lenovo's only Github project is a tool to remove its \"oops, we got caught\" malware.  I wonder what other yet-to-be-discovered malware comes with these computers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39969, "question": "Lenovo's SuperFish Removal Tool on GitHub", "aSentId": 39978, "answer": "I sincerely despise that they won't own up to it verbally. Lets just publish a patch silently and we're done here, right?\n\nLenovo was a brand I actually trusted and all they care to do is nod that they did this, no apology, not even a dialog about how this could have occurred. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39979, "question": "I sincerely despise that they won't own up to it verbally. Lets just publish a patch silently and we're done here, right?\n\nLenovo was a brand I actually trusted and all they care to do is nod that they did this, no apology, not even a dialog about how this could have occurred. ", "aSentId": 39980, "answer": "Does it even matter? They *installed malware* on the computers they made. No amount of talk can undo that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39979, "question": "I sincerely despise that they won't own up to it verbally. Lets just publish a patch silently and we're done here, right?\n\nLenovo was a brand I actually trusted and all they care to do is nod that they did this, no apology, not even a dialog about how this could have occurred. ", "aSentId": 39982, "answer": "Not sure what you're talking about. Their CTO said \"we messed up\" in some interview and on Twitter. Also, a bunch of tech-sites reported their press-release on how to remove it and they worked with MS and anti-vir companies to get it removed as fast as possible.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39983, "question": "Not sure what you're talking about. Their CTO said \"we messed up\" in some interview and on Twitter. Also, a bunch of tech-sites reported their press-release on how to remove it and they worked with MS and anti-vir companies to get it removed as fast as possible.", "aSentId": 39984, "answer": "Where is their official statement? Because they did *officially* defend the thing and that's what multiple outlets published. I don't read their Twitter and have not seen this interview you mentioned.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39985, "question": "Where is their official statement? Because they did *officially* defend the thing and that's what multiple outlets published. I don't read their Twitter and have not seen this interview you mentioned.", "aSentId": 39986, "answer": "Like I said, it was in an interview (can't find the original transcript, both re/code and pcworld claim the interview was with them but I remember seeing more of the interview on another site). If you google \"lenovo messed up\" you'll find hundreds of publications printing the story.\n\nLet me among the first to say that none of what they do now excuses them willfully exposing their users to this security threat. But I don't think it's honest to say that they're not apologetic and pro-active in remedying the situation.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39989, "question": "Linux kernel booting process. Part 5.", "aSentId": 39990, "answer": "Added to my watchlist. This is so awesome.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39992, "question": "Interviewing for a JavaScript Job", "aSentId": 39993, "answer": "TL;DR: Fictional strawman about how a genius savant solves a problem that I would need a thesaurus to comprehend.  Said genius fails the interview because he writes unreadable code.  The moral of this story is, of course, shower before you go to interviews because poor personal hygiene will make people tune you out.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39994, "question": "TL;DR: Fictional strawman about how a genius savant solves a problem that I would need a thesaurus to comprehend.  Said genius fails the interview because he writes unreadable code.  The moral of this story is, of course, shower before you go to interviews because poor personal hygiene will make people tune you out.", "aSentId": 39995, "answer": "Code is always unreadable if you don't understand the programming technique being used. \n\nSo is the problem that the author writes incomprehensible code, or that the reader has not educated themselves enough in the available development techniques?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39996, "question": "Code is always unreadable if you don't understand the programming technique being used. \n\nSo is the problem that the author writes incomprehensible code, or that the reader has not educated themselves enough in the available development techniques?", "aSentId": 39997, "answer": "\"Unreadable\" always reminds of the Pascal forums.\n\n(In Pascal all variables must be declared directly after the function signature, before any code.      \nSo you declare variable `i`, then write `for i := 1 to 10 do`. Like if you would always write `int i; for (i = 1; i &lt;= 10; i++) ` instead `for (int i = 1; i &lt;= 10; i++) `.)\n\nAnd the most focal users always say that is a good thing. \"Imagine you could declare variables anywhere. That would be completely *unreadable*\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39998, "question": "\"Unreadable\" always reminds of the Pascal forums.\n\n(In Pascal all variables must be declared directly after the function signature, before any code.      \nSo you declare variable `i`, then write `for i := 1 to 10 do`. Like if you would always write `int i; for (i = 1; i &lt;= 10; i++) ` instead `for (int i = 1; i &lt;= 10; i++) `.)\n\nAnd the most focal users always say that is a good thing. \"Imagine you could declare variables anywhere. That would be completely *unreadable*\"", "aSentId": 39999, "answer": "That's also how C worked until C99. Variables had to be declared prior to any other code in a block. I actually like this style when writing C, because it separates data from operations.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39994, "question": "TL;DR: Fictional strawman about how a genius savant solves a problem that I would need a thesaurus to comprehend.  Said genius fails the interview because he writes unreadable code.  The moral of this story is, of course, shower before you go to interviews because poor personal hygiene will make people tune you out.", "aSentId": 40001, "answer": "I thought until the middle that the essence would be: cheating pays off...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39994, "question": "TL;DR: Fictional strawman about how a genius savant solves a problem that I would need a thesaurus to comprehend.  Said genius fails the interview because he writes unreadable code.  The moral of this story is, of course, shower before you go to interviews because poor personal hygiene will make people tune you out.", "aSentId": 40003, "answer": "If you need a thesaurus to understand any of the words in this problem:\n\n&gt; Consider a finite checkerboard of unknown size. On each square, we randomly place an arrow pointing to one of its four sides. A chequer is placed randomly on the checkerboard. Each move consists of moving the chequer one square in the direction of the arrow in the square it occupies. If the arrow should cause the chequer to move off the edge of the board, the game halts.\n\n&gt; The problem is this: The game board is hidden from us. A player moves the chequer, following the rules. As the player moves the chequer, they calls out the direction of movement, e.g. \u201c\u2191, \u2192, \u2191, \u2193, \u2191, \u2192\u2026\u201d Write an algorithm that will determine whether the game halts, strictly from the called out directions, in finite time and space.\n\n...then your education has failed you, badly.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40004, "question": "If you need a thesaurus to understand any of the words in this problem:\n\n&gt; Consider a finite checkerboard of unknown size. On each square, we randomly place an arrow pointing to one of its four sides. A chequer is placed randomly on the checkerboard. Each move consists of moving the chequer one square in the direction of the arrow in the square it occupies. If the arrow should cause the chequer to move off the edge of the board, the game halts.\n\n&gt; The problem is this: The game board is hidden from us. A player moves the chequer, following the rules. As the player moves the chequer, they calls out the direction of movement, e.g. \u201c\u2191, \u2192, \u2191, \u2193, \u2191, \u2192\u2026\u201d Write an algorithm that will determine whether the game halts, strictly from the called out directions, in finite time and space.\n\n...then your education has failed you, badly.", "aSentId": 40005, "answer": "Never heard the word \"chequer\"\n\nBut I guess it does not matter what it is as long as it is moving", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40006, "question": "Never heard the word \"chequer\"\n\nBut I guess it does not matter what it is as long as it is moving", "aSentId": 40007, "answer": "It's a \"checker\", for the US-Americans out there. And you really couldn't figure that out from the context? Or are you just being disingenuous?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40004, "question": "If you need a thesaurus to understand any of the words in this problem:\n\n&gt; Consider a finite checkerboard of unknown size. On each square, we randomly place an arrow pointing to one of its four sides. A chequer is placed randomly on the checkerboard. Each move consists of moving the chequer one square in the direction of the arrow in the square it occupies. If the arrow should cause the chequer to move off the edge of the board, the game halts.\n\n&gt; The problem is this: The game board is hidden from us. A player moves the chequer, following the rules. As the player moves the chequer, they calls out the direction of movement, e.g. \u201c\u2191, \u2192, \u2191, \u2193, \u2191, \u2192\u2026\u201d Write an algorithm that will determine whether the game halts, strictly from the called out directions, in finite time and space.\n\n...then your education has failed you, badly.", "aSentId": 40009, "answer": "I misread \"whether the game halts\" as \"when the game halts\". I think it would be clearer to ask when the game falls into an endless loop.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39992, "question": "Interviewing for a JavaScript Job", "aSentId": 40011, "answer": "This gets to the heart of a couple of big issues in software development.\n\nFirst, should a programmer use the advanced development techniques that they know?  Often results in the simplest solutions that are incomprehensible to the less knowledgeable developer, so other members of the same team may be stumped when they see the code.  Made worse when the original developer has left the team \"man that guy wrote incomprehensible code, we need to rewrite it all to be simpler!\".\n\nSecondly, technical job interviewers can only assess developers/job candidates up to their own level of (in)competence and when they see code beyond their understanding label it as being incomprehensible.  That's the measure of the maximum level of technical development competence of any organisation. Only a few months ago I saw precisely this happen - one of the most productive and effective developers I have ever known was rejected from a job interview because they didn't understand his code - their loss.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40012, "question": "This gets to the heart of a couple of big issues in software development.\n\nFirst, should a programmer use the advanced development techniques that they know?  Often results in the simplest solutions that are incomprehensible to the less knowledgeable developer, so other members of the same team may be stumped when they see the code.  Made worse when the original developer has left the team \"man that guy wrote incomprehensible code, we need to rewrite it all to be simpler!\".\n\nSecondly, technical job interviewers can only assess developers/job candidates up to their own level of (in)competence and when they see code beyond their understanding label it as being incomprehensible.  That's the measure of the maximum level of technical development competence of any organisation. Only a few months ago I saw precisely this happen - one of the most productive and effective developers I have ever known was rejected from a job interview because they didn't understand his code - their loss.", "aSentId": 40013, "answer": "If nobody else than the productive genius in the company would understand the code he wrote, it may be right to reject him and take someone who can write code they understand, read and modify and reuse - his loss.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40014, "question": "If nobody else than the productive genius in the company would understand the code he wrote, it may be right to reject him and take someone who can write code they understand, read and modify and reuse - his loss.", "aSentId": 40015, "answer": "The tone of this comment has a slight derogatory note to imply that developers with knowledge of advanced techniques are ivory tower \"geniuses\" who write code that is not real-world, and that it is up to the less knowledgable to write the \"real code\".\n\nWhy not get your fresh graduate developers to do the interviewing, impose a rule that all code must use fresh graduate level development techniques, and impose a rule that unless the fresh graduate developers doing the interviewing understand a job-seekers code, then that job seeker does not fit the team?\n\nWhat level of programming technique is acceptable to your team? \n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 39992, "question": "Interviewing for a JavaScript Job", "aSentId": 40017, "answer": "If the interviewer didn't express his inability to understand, remarking, for example, \"I can't follow that,\" or \"I haven't heard of that concept, could you explain it?\" then the dev doesn't want to be working there anyway. One of my main frustrations on the job as a programmer has been that a lot of other devs (especially your seniors) tend not to admit when they don't understand or aren't familiar with a concept.   ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40022, "question": "I don't see how JavaScript is relevant to the parable of the programmer Jesus. It could have been about any programming language. ", "aSentId": 40023, "answer": "I don't think anybody made that claim. The author made that choice, probably because he knows a lot about JS.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40024, "question": "I don't think anybody made that claim. The author made that choice, probably because he knows a lot about JS.", "aSentId": 40025, "answer": "Is \u201cThe Carpenter\u201d a programming Jesus?\n\n- His given name is \u201cJohn.\u201d\n- He does business with a reptilian recruiter named Bob Plissken.\n- He interviewed with the Thing Software\n- His interviewer was Christine\n- He asked if They Live\n- He got a different job with FOG\n- And something to do with the conference room and Precinct 13.\n\nThese are all John Carpenter movie references. For no good reason.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40026, "question": "Is \u201cThe Carpenter\u201d a programming Jesus?\n\n- His given name is \u201cJohn.\u201d\n- He does business with a reptilian recruiter named Bob Plissken.\n- He interviewed with the Thing Software\n- His interviewer was Christine\n- He asked if They Live\n- He got a different job with FOG\n- And something to do with the conference room and Precinct 13.\n\nThese are all John Carpenter movie references. For no good reason.", "aSentId": 40027, "answer": "Perhaps the reason might have been to have light-hearted fun. The Thing is a great movie.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40030, "question": "Downvoted because...Javascript.", "aSentId": 40031, "answer": "Downvoted because stupid... comments ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40032, "question": "Downvoted because stupid... comments ", "aSentId": 40033, "answer": "Upvoted because good comment ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40030, "question": "Downvoted because...Javascript.", "aSentId": 40035, "answer": "And what's wrong with that?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40038, "question": "Moving Groovy to a Foundation", "aSentId": 40039, "answer": "This is a little strange: didn't Google just make Gradle the \"official\" Android build tool? I assume Google researched Gradle and Groovy first; why would they choose a tool that was on this sort of shaky ground?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40040, "question": "This is a little strange: didn't Google just make Gradle the \"official\" Android build tool? I assume Google researched Gradle and Groovy first; why would they choose a tool that was on this sort of shaky ground?", "aSentId": 40041, "answer": "I'm guessing no one saw it coming when Pivotal pulled support.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40042, "question": "I'm guessing no one saw it coming when Pivotal pulled support.", "aSentId": 40043, "answer": "Not even pivotals own product spring.  I saw a recent tutorial from spring which used gradle", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40038, "question": "Moving Groovy to a Foundation", "aSentId": 40045, "answer": "I'm personally very curious why the discussion around which foundation to choose is more highly prioritised than the discussion around how to guarantee financing the project.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40046, "question": "I'm personally very curious why the discussion around which foundation to choose is more highly prioritised than the discussion around how to guarantee financing the project.", "aSentId": 40047, "answer": "You cannot solve financing via a discussion in the forum. Negotiations happen outside the forum, probably.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40046, "question": "I'm personally very curious why the discussion around which foundation to choose is more highly prioritised than the discussion around how to guarantee financing the project.", "aSentId": 40049, "answer": "The first step to acquiring funding is providing a somewhat unified front so that funders don't feel like their money is at risk of being wasted?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40046, "question": "I'm personally very curious why the discussion around which foundation to choose is more highly prioritised than the discussion around how to guarantee financing the project.", "aSentId": 40051, "answer": "I'm personally very curious why everyone these days needs 'funding' and a 'foundation'. What happened to open source for the sake of it?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40052, "question": "I'm personally very curious why everyone these days needs 'funding' and a 'foundation'. What happened to open source for the sake of it?", "aSentId": 40053, "answer": "Are you volunteering to step up and devote hours every week for nothing but good feels?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40054, "question": "Are you volunteering to step up and devote hours every week for nothing but good feels?", "aSentId": 40055, "answer": "It has nothing to do with 'good feels', but I do contribute to some open source projects.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40057, "question": "9 Ways to Lose Your Data", "aSentId": 40058, "answer": "I need to revisit my database backups....", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40057, "question": "9 Ways to Lose Your Data", "aSentId": 40060, "answer": "I was making full HD backups with dd to another disk.\n\nNoticed earlier this month, that the target partition was around 1 GB too small, so if the original disk had failed, there would have been some lost files.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40063, "question": "A Tiny Real-Time Software Rasterizer in C++11", "aSentId": 40064, "answer": "why use `std::bind` when you have lambdas? :(", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40065, "question": "why use `std::bind` when you have lambdas? :(", "aSentId": 40066, "answer": "In C++11 there are some _useful_ things that you can do with `bind`, that you cannot do with lambdas. In C++14, this is no longer the case. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40065, "question": "why use `std::bind` when you have lambdas? :(", "aSentId": 40068, "answer": "The main reasons are that \n\n1) I thought the code looked cleaner than the lambda syntax.  \n\n2), which is most important, I wanted to *intentionally* draw a parallel to the semantics of OpenGL 2, where one \"binds\" constant \"uniform\" parameters to the shader before invoking it, which is what I was doing here.   Lambda is faster and clearer but I liked the parallel between \"binding\" a uniform to shaders in GLSL and \"binding\" parameters to shaders using std::bind in C++", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40069, "question": "The main reasons are that \n\n1) I thought the code looked cleaner than the lambda syntax.  \n\n2), which is most important, I wanted to *intentionally* draw a parallel to the semantics of OpenGL 2, where one \"binds\" constant \"uniform\" parameters to the shader before invoking it, which is what I was doing here.   Lambda is faster and clearer but I liked the parallel between \"binding\" a uniform to shaders in GLSL and \"binding\" parameters to shaders using std::bind in C++", "aSentId": 40070, "answer": "I do like the comparison between `std::bind` and binding shader inputs. It actually makes sense, and it's also close to how DirectX 12 models it. However, I have to disagree with your point (1): IMO, I doubt the average C++ programmer understands how `std::bind` works, so it probably looks like black magic to most of your audience (and really, it is.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40065, "question": "why use `std::bind` when you have lambdas? :(", "aSentId": 40072, "answer": "Bind and placeholders are an abomination.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40063, "question": "A Tiny Real-Time Software Rasterizer in C++11", "aSentId": 40074, "answer": "Good stuff, brings back memories! A fun and simple optimization: run the rasterizer loop for blocks of e.g. 8x8 px and you'll be able to discard all-out and simplify all-in cases nicely (check whether all 4 corners of the block are in/out). Also, the all-in case of 8x8 interpolation is still doable in affine space without image quality suffering too much...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40075, "question": "Good stuff, brings back memories! A fun and simple optimization: run the rasterizer loop for blocks of e.g. 8x8 px and you'll be able to discard all-out and simplify all-in cases nicely (check whether all 4 corners of the block are in/out). Also, the all-in case of 8x8 interpolation is still doable in affine space without image quality suffering too much...", "aSentId": 40076, "answer": "I guess it depends at which precision/depth you want to rasterize: if you have a model sufficiently far from the camera, couldn't it be contained in a small screen block? ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40075, "question": "Good stuff, brings back memories! A fun and simple optimization: run the rasterizer loop for blocks of e.g. 8x8 px and you'll be able to discard all-out and simplify all-in cases nicely (check whether all 4 corners of the block are in/out). Also, the all-in case of 8x8 interpolation is still doable in affine space without image quality suffering too much...", "aSentId": 40078, "answer": "4 corners alone won't work for rejection -- a triangle can intersect a tile without containing any of its corners.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40063, "question": "A Tiny Real-Time Software Rasterizer in C++11", "aSentId": 40080, "answer": "OP delivered!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40083, "question": "How are fill conventions being handled? It looks like the in-triangle check always rejects the edges of the triangle, which could lead to dropouts when an edge within a mesh overlaps pixel centers.\n", "aSentId": 40084, "answer": "This could be fixed by changing the barycentric check to &lt;= instead of &lt;, but honestly I haven't been able to see any artifacts in the tests I've run.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40087, "question": "Specific Vs Generic - A Meditation on Scala and Python", "aSentId": 40088, "answer": " Refactoring recommended:\n\n    abstract class SuperState\n    case class EndState() extends SuperState\n\n    case class State[T]() extends SuperState {\n      def apply(inputs: T*)(closure: T =&gt; SuperState)\n      def unknown(closure: T =&gt; SuperState)\n      def end(closure: () =&gt; Unit)\n      def run(input: Option[T]): SuperState\n    }\n\nto:\n\n    trait SuperState\n    case object EndState extends SuperState\n\n    case class State[T](val inputs: T*, closure: T =&gt; SuperState) extends SuperState {\n         def unknown(closure: T =&gt; SuperState)\n         def end(closure: =&gt; Unit)\n         def run(input: Option[T]): SuperState\n    }\n\n...and\n\n     abstract class DispenserOutput\n         case class Change() extends DispenserOutput\n         case class Drink() extends DispenserOutput\n         case class ErrorMessage() extends DispenserOutput\n         case class ReadyMessage() extends DispenserOutput\n    }\n\nto\n\n    object DispenserOutput extends Enumeration {\n        val Change, Drink, ErrorMessage, ReadyMessage = Value\n    }\n    import DispenserOutput._\n\n...and why flatMap for this?\n\n    elems.flatMap { (elem: Int) =&gt; if (elem % 2 == 0) None() else Some(elem * 2) }\n\nit can be: elems.filter(_ % 2 == 0)\n\n \"ready_to_dispense\" - this is NOT the way you declare variables and using \"return\" is something close to be deprecated.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40091, "question": "Mac Apps That Use Garbage Collection Must Move to ARC", "aSentId": 40092, "answer": "\nOne day a student came to Moon and said: \"I understand how to make a better garbage collector. We must keep a reference count of the pointers to each cons.\"\nMoon patiently told the student the following story:\n\n     \"One day a student came to Moon and said: `I understand\n     how to make a better garbage collector...\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40093, "question": "\nOne day a student came to Moon and said: \"I understand how to make a better garbage collector. We must keep a reference count of the pointers to each cons.\"\nMoon patiently told the student the following story:\n\n     \"One day a student came to Moon and said: `I understand\n     how to make a better garbage collector...\n", "aSentId": 40094, "answer": "Best laugh of the day, thank you. :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40093, "question": "\nOne day a student came to Moon and said: \"I understand how to make a better garbage collector. We must keep a reference count of the pointers to each cons.\"\nMoon patiently told the student the following story:\n\n     \"One day a student came to Moon and said: `I understand\n     how to make a better garbage collector...\n", "aSentId": 40096, "answer": "Well, it's replacing one stupid idea with a slightly less stupid idea. Maybe one day they'll finally discover the closing curly brace. It's a step. Let's be positive.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40091, "question": "Mac Apps That Use Garbage Collection Must Move to ARC", "aSentId": 40098, "answer": "Interesting approach, I wonder what prompted them to want to remove gc and instead go back to ref counting (even if it is auto generated)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40099, "question": "Interesting approach, I wonder what prompted them to want to remove gc and instead go back to ref counting (even if it is auto generated)", "aSentId": 40100, "answer": "GC didn't work that well, it's hard to add to a mature language after the fact, it had a performance hit and decreases battery life, and ARC turned out to be just as good.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40101, "question": "GC didn't work that well, it's hard to add to a mature language after the fact, it had a performance hit and decreases battery life, and ARC turned out to be just as good.", "aSentId": 40102, "answer": "I do not agree that ARC is just as good as garbage collection.  They are totally different beasts and it depends on your needs.  The major benefit of garbage collection, at least for my uses, is that ARC does not clean up reference cycles whereas a decent garbage collector would.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40103, "question": "I do not agree that ARC is just as good as garbage collection.  They are totally different beasts and it depends on your needs.  The major benefit of garbage collection, at least for my uses, is that ARC does not clean up reference cycles whereas a decent garbage collector would.", "aSentId": 40104, "answer": "While GC is much easier for a beginner programmer to deal with, to a seasoned programmer I would think that it's quite easy to deal with cycles when they occur, and to debug memory leaks using Apple's tools was quite easy last time I did it.\n\nIn other words, GC vs ARC is just a trade-off. But it's hard to have a language that supports both, because the style of memory handling affects how libraries are designed and used. And given Apples circumstances it's understandable why they landed on ARC.\n\nIt's a bit like having fixed-width integers (C) vs. \"infinite\" integers (Python/Ruby). The second is certainly preferable to a beginner who might be confused that numbers can overflow, but to an experienced programmed the ideal is to have both and use the best one for the circumstances. But again the language has to decide on one or the other as standard.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40105, "question": "While GC is much easier for a beginner programmer to deal with, to a seasoned programmer I would think that it's quite easy to deal with cycles when they occur, and to debug memory leaks using Apple's tools was quite easy last time I did it.\n\nIn other words, GC vs ARC is just a trade-off. But it's hard to have a language that supports both, because the style of memory handling affects how libraries are designed and used. And given Apples circumstances it's understandable why they landed on ARC.\n\nIt's a bit like having fixed-width integers (C) vs. \"infinite\" integers (Python/Ruby). The second is certainly preferable to a beginner who might be confused that numbers can overflow, but to an experienced programmed the ideal is to have both and use the best one for the circumstances. But again the language has to decide on one or the other as standard.", "aSentId": 40106, "answer": "I've only been in Objective C (and now Swift) land for 2 years, so it's possible I am still not seasoned enough.  But I still find leaks being created in code due to nonintuitive reference cycles and/or unclear strong/weak semantics (e.g. I should have checked if that delegate property was weak or strong so I could have remembered to clear it).\n\nThe tools aren't that bad, but they certainly aren't great.  The Leaks profiling tool will show you where the references were created/released which is great except for the fact that for many objects there are 1000's of references and only half of those got automatically grouped into retain/release pairs.  Also reference cycles aren't considered leaks to that tool so you have to have an idea what to look for in the first place.\n\nI am not arguing GC is better.  ARC just doesn't completely free the programmer from thinking about memory management the way GC does.  And all of the automatic memory management schemes share that as a common goal:  reduce the burden on the programmer around managing memory and reduce the possibility of making mistakes.  GC gets you very far along towards that goal but at the cost of performance and runtime complexity.  Those costs make it unacceptable in many cases.  ARC gets you most of the way towards that goal, with no runtime cost, making it a much better general solution.  Both are good.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40103, "question": "I do not agree that ARC is just as good as garbage collection.  They are totally different beasts and it depends on your needs.  The major benefit of garbage collection, at least for my uses, is that ARC does not clean up reference cycles whereas a decent garbage collector would.", "aSentId": 40108, "answer": "Having reference cycles in the first place is a logic bug.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40109, "question": "Having reference cycles in the first place is a logic bug.", "aSentId": 40110, "answer": "Not every data structure is reducible to a DAG.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40111, "question": "Not every data structure is reducible to a DAG.", "aSentId": 40112, "answer": "I dare you to name one that isn't reducible.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40113, "question": "I dare you to name one that isn't reducible.\n", "aSentId": 40114, "answer": "Circularly linked list. That a program using such lists can be rewritten without them is irrelevant. The original program does not contain a \"bug\" simply because it uses such lists.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40115, "question": "Circularly linked list. That a program using such lists can be rewritten without them is irrelevant. The original program does not contain a \"bug\" simply because it uses such lists.", "aSentId": 40116, "answer": "Oh, you're talking about bug-for-bug backward compatibility.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40113, "question": "I dare you to name one that isn't reducible.\n", "aSentId": 40118, "answer": "A directed cyclic graph?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40101, "question": "GC didn't work that well, it's hard to add to a mature language after the fact, it had a performance hit and decreases battery life, and ARC turned out to be just as good.", "aSentId": 40120, "answer": "Also was completely not an option on iOS.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40121, "question": "Also was completely not an option on iOS.", "aSentId": 40122, "answer": "Why?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40123, "question": "Why?", "aSentId": 40124, "answer": "They never supported it on iOS to begin with. I'm guessing this was initially due to performance concerns and then the GC fell out of favour completely.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40123, "question": "Why?", "aSentId": 40126, "answer": "I always heard it was because of the hits on battery life it would have.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40127, "question": "I always heard it was because of the hits on battery life it would have.", "aSentId": 40128, "answer": "I haven't really done much mobile dev, so I'm speaking from a position of ignorance here, but the native language for Android development is Java, with GC, isn't it?  I mean, that may very well be the reason, but it seems like it wasn't an insurmountable problem.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40129, "question": "I haven't really done much mobile dev, so I'm speaking from a position of ignorance here, but the native language for Android development is Java, with GC, isn't it?  I mean, that may very well be the reason, but it seems like it wasn't an insurmountable problem.", "aSentId": 40130, "answer": "And if you remember, back in the old days performance and battery life was a tremendous problem on android.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40131, "question": "And if you remember, back in the old days performance and battery life was a tremendous problem on android.", "aSentId": 40132, "answer": "I actually didn't remember that, but I guess that explains it.  Thank you.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40129, "question": "I haven't really done much mobile dev, so I'm speaking from a position of ignorance here, but the native language for Android development is Java, with GC, isn't it?  I mean, that may very well be the reason, but it seems like it wasn't an insurmountable problem.", "aSentId": 40134, "answer": "Or Android just doesn't work as well. Which seems quite likely from experience,", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40135, "question": "Or Android just doesn't work as well. Which seems quite likely from experience,", "aSentId": 40136, "answer": "Well I only jumped into the fold recently but it works great for me now.  I guess it might have been rougher in the early days.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40101, "question": "GC didn't work that well, it's hard to add to a mature language after the fact, it had a performance hit and decreases battery life, and ARC turned out to be just as good.", "aSentId": 40138, "answer": "Also GC made it harder to integrate with C/C++ libraries and so on. :-)\n\nPlus, Apple own the compiler they use so they can add all kinds of smarts to the compilation step. And soon they will be launching the Apple Watches which will come with downsized hardware. :-)\n\nApple liking miniature hardware is like a Japanese company with an American culture. Not something we see every day.\n\nThere may be a clash of cultures between the \"cloud\" and the \"consumer electronics\" going on.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40099, "question": "Interesting approach, I wonder what prompted them to want to remove gc and instead go back to ref counting (even if it is auto generated)", "aSentId": 40140, "answer": "More efficient, they make the compiler now and know where it needs to insert all the frees and releases into the code for optimized performance. Why have a GC run all the time?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40141, "question": "More efficient, they make the compiler now and know where it needs to insert all the frees and releases into the code for optimized performance. Why have a GC run all the time?", "aSentId": 40142, "answer": "&gt; Why have a GC run all the time?\n\nBecause reference counting alone doesn't collect cycles and the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads. It doesn't seem likely that they were really situated to take advantage of a modern tracing gc, though.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40143, "question": "&gt; Why have a GC run all the time?\n\nBecause reference counting alone doesn't collect cycles and the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads. It doesn't seem likely that they were really situated to take advantage of a modern tracing gc, though.", "aSentId": 40144, "answer": "ObjC never had a compacting GC", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40145, "question": "ObjC never had a compacting GC", "aSentId": 40146, "answer": "God, I can't imagine compacting in a C-derivative language. It's common practice to hold base pointers, compute addresses on the fly, alias addresses multiple ways, etc. You can rewrite basic \"object reference\" style pointers easily enough on compaction, but you'll never catch all of those indirect pointers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40145, "question": "ObjC never had a compacting GC", "aSentId": 40148, "answer": "Indeed! And the benefits of precise GC mean they can have dependable latency, it's a little easier to reason about. I definitely support their decision to switch over.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40143, "question": "&gt; Why have a GC run all the time?\n\nBecause reference counting alone doesn't collect cycles and the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads. It doesn't seem likely that they were really situated to take advantage of a modern tracing gc, though.", "aSentId": 40150, "answer": "&gt; the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads\n\nThey're probably not the workloads Apple cares about though.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40151, "question": "&gt; the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads\n\nThey're probably not the workloads Apple cares about though.", "aSentId": 40152, "answer": "Agree. Apple is solely focused on consumer-grade products.\n\nNo sane person would want to run critical/high-availability/high-performance application on OSX.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40153, "question": "Agree. Apple is solely focused on consumer-grade products.\n\nNo sane person would want to run critical/high-availability/high-performance application on OSX.", "aSentId": 40154, "answer": "Even Apple runs all their critical stuff on enterprise account Linux like everyone else. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40153, "question": "Agree. Apple is solely focused on consumer-grade products.\n\nNo sane person would want to run critical/high-availability/high-performance application on OSX.", "aSentId": 40156, "answer": "&gt; No sane person would want to run critical/high-availability/high-performance application on OSX.\n\nWhile that's mostly true (OSX really isn't targeted for that), that's also really irrelevant: ARC is for obj-c objects, there is no reason whatsoever to use these in high-performance applications. For mixed systems (e.g. 3D software), only the interface would be in objective-c and the actual work would be done in a high-performance (and hopefully portable) language. A feature of obj-c is actually that dropping to C or C++ (with obj-c++) is just not using the \"objective\" features.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40157, "question": "&gt; No sane person would want to run critical/high-availability/high-performance application on OSX.\n\nWhile that's mostly true (OSX really isn't targeted for that), that's also really irrelevant: ARC is for obj-c objects, there is no reason whatsoever to use these in high-performance applications. For mixed systems (e.g. 3D software), only the interface would be in objective-c and the actual work would be done in a high-performance (and hopefully portable) language. A feature of obj-c is actually that dropping to C or C++ (with obj-c++) is just not using the \"objective\" features.", "aSentId": 40158, "answer": "It's not only ObjectiveC, it's the whole stack which is just not competitve anymore.\n\nHFS+ is trying to be the MongoDB of filesystems, GPGPU performance is completely unpredictable, random breakages in minor versions all across the stack, networking is too slow ... it's kind of surprising that despite being able to pick their own hardware parts they are losing across the board against Linux (and Windows).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40159, "question": "It's not only ObjectiveC, it's the whole stack which is just not competitve anymore.\n\nHFS+ is trying to be the MongoDB of filesystems, GPGPU performance is completely unpredictable, random breakages in minor versions all across the stack, networking is too slow ... it's kind of surprising that despite being able to pick their own hardware parts they are losing across the board against Linux (and Windows).", "aSentId": 40160, "answer": "I've been reading through the 10.6 XNU kernel source when it was released, and recently I tried to diagnose a kernel panic by looking into the 10.9 kernel. The amount of hacks they added since 10.6... I don't know how it even boots without exploding immediately. It's magical.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40161, "question": "I've been reading through the 10.6 XNU kernel source when it was released, and recently I tried to diagnose a kernel panic by looking into the 10.9 kernel. The amount of hacks they added since 10.6... I don't know how it even boots without exploding immediately. It's magical.", "aSentId": 40162, "answer": "some example?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40163, "question": "some example?", "aSentId": 40164, "answer": "For example, I've noticed some new page queues were implemented (throttled, zf and speculative, in addition to active and inactive). The VM code is already complicated because of all the multi-core page juggling with spinlocks, and these new queues caused lots of small changes here and there. I wonder how they test it. Also, they casuse the VM system to free pages prior to hibernation by bashing it with huge allocations/deallocations. I'm not a kernel developer, don't know if it's a standard trick, but I found it amusing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40153, "question": "Agree. Apple is solely focused on consumer-grade products.\n\nNo sane person would want to run critical/high-availability/high-performance application on OSX.", "aSentId": 40166, "answer": "Why not? The fact that their products have some of the best battery life in their class kinda shows that their software is efficient if nothing else. (Windows for example isn't nearly as graphically intensive as the Aqua GUI yet it will lose at least an hour of battery when running on the same hardware.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40167, "question": "Why not? The fact that their products have some of the best battery life in their class kinda shows that their software is efficient if nothing else. (Windows for example isn't nearly as graphically intensive as the Aqua GUI yet it will lose at least an hour of battery when running on the same hardware.)", "aSentId": 40168, "answer": "Fair point but efficiency on a desktop/office workload is different to efficiency in something like data processing.\n\nIt matters less for your power consumption if your CPU is occasionally sleeping waiting for RAM than if you draw all your windows 20 times or use inefficient algorithms to solve problems.\n\nA Mac can afford a cache miss that causes something to take a little longer (AFAIK not burning as much power as an active CPU), but can't afford to unnecessarily invoke the GPU or something. A server or high-performance game or simulation must try to minimise cache misses or any form of I/O blocking as much as possible to minimise latency and maximise throughput.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40167, "question": "Why not? The fact that their products have some of the best battery life in their class kinda shows that their software is efficient if nothing else. (Windows for example isn't nearly as graphically intensive as the Aqua GUI yet it will lose at least an hour of battery when running on the same hardware.)", "aSentId": 40170, "answer": "Yes, we're all running our mission critical services and hardware from a Surface....that's why it makes sense to be talking battery life right now........", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40171, "question": "Yes, we're all running our mission critical services and hardware from a Surface....that's why it makes sense to be talking battery life right now........", "aSentId": 40172, "answer": "I meant that if there were any bottlenecks in the OS core they would show up in either UI performance or battery life, but it remains undeniably more responsive than Windows without compromising energy efficiency.\n\nI haven't seen how Windows 10 fares on comparable hardware.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40167, "question": "Why not? The fact that their products have some of the best battery life in their class kinda shows that their software is efficient if nothing else. (Windows for example isn't nearly as graphically intensive as the Aqua GUI yet it will lose at least an hour of battery when running on the same hardware.)", "aSentId": 40174, "answer": "We had a mail server running on Mac OS X Server. Worst. Idea. Ever.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40177, "question": "Stability is pretty poor on them, they have excellent battery life, but they tend to suffer in stability.  Windows may be inefficient and bloated but modern windows/linux based platforms are both stable as hell.  It is the trade off, by having all that support for all the different options you end up with very bloated systems that use more resources but they tend to be a lot better at stability from the design.   The other problem with it is that upgrade cycle on OSX is much to fast for businesses to considered it and they tend to be really poor on backwards compatibility which is crucial for most businesses. ", "aSentId": 40178, "answer": "This is the first time I've heard anyone calling Windows more stable than OS X :P\n\nThey've had some problems here and there since Mavericks but I'd chalk that down to the yearly upgrade cycle being unprecedented for a major desktop OS (not to mention the practice of introducing new features in minor releases, like the upcoming Photos app in 10.10.3). Personally, this fast pace is one of the things I love most about OS X.\n\nI guess you have to wait for the n.n.2 releases to make sure everything has been ironed out. In any case upgrading is optional. It's largely up to third-party developers to maintain compatibility and there's nothing stopping them from targeting older OS versions (even rulings like this one, about the ARC, only affect App Store submissions.)\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40179, "question": "This is the first time I've heard anyone calling Windows more stable than OS X :P\n\nThey've had some problems here and there since Mavericks but I'd chalk that down to the yearly upgrade cycle being unprecedented for a major desktop OS (not to mention the practice of introducing new features in minor releases, like the upcoming Photos app in 10.10.3). Personally, this fast pace is one of the things I love most about OS X.\n\nI guess you have to wait for the n.n.2 releases to make sure everything has been ironed out. In any case upgrading is optional. It's largely up to third-party developers to maintain compatibility and there's nothing stopping them from targeting older OS versions (even rulings like this one, about the ARC, only affect App Store submissions.)\n", "aSentId": 40180, "answer": "Windows is definitely more stable. My latest gen mac book pro can't keep a wireless connection for its life. And the latest update to Yosemite still hasn't fixed the problem. It can't be a network problem, since it happens both at home and at work.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40181, "question": "Windows is definitely more stable. My latest gen mac book pro can't keep a wireless connection for its life. And the latest update to Yosemite still hasn't fixed the problem. It can't be a network problem, since it happens both at home and at work.", "aSentId": 40182, "answer": "I get that problem when docked at an external display with the lid down. It started happening after 10.10.1 and strangely only if I run a Wine/Cider app like Steam..\n\nYou can try Alt+Clicking the wifi menu icon and it'll show you the RSSI and everything you're getting, so you can move to a better spot in the meantime. I also saw some suggestions for changing the MTU in System Preferences &gt; Network &gt; Advanced &gt; Hardware.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40184, "question": "Windows mobile devices all have had better battery life than comparable Apple products in recent history. Windows Phone 8 and Windows RT for sure given comparable platforms. Obliterates Android as seen on the HTC One M8. ", "aSentId": 40185, "answer": "The Surface Pro has barely around 4 hours, while the iPad and MacBook Air have in excess of 10 hours. /r/surface pretty much confirmed this back when I was trying to decide whether to go for the SP3 or wait for the rumored Retina MBAs this year.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40186, "question": "The Surface Pro has barely around 4 hours, while the iPad and MacBook Air have in excess of 10 hours. /r/surface pretty much confirmed this back when I was trying to decide whether to go for the SP3 or wait for the rumored Retina MBAs this year.", "aSentId": 40187, "answer": "The surface pro is an actual full computer with no where to stash more battery like the MBA. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40190, "question": "OS X is not intended to be a server OS, so that line of reasoning is pointless.", "aSentId": 40191, "answer": "Well there used to be an OSX Server.\n\nIt's been folded in a server add-in to the regular OSX a few versions back and is really about administration, and maybe some light-ish servicing for full-apple SMEs.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40193, "question": "Why not? It's not like you can't run Java or any other language on it. ", "aSentId": 40194, "answer": "The priorities of the implementation is not setup for high availability/reliability, it's setup for consumer-grade responsiveness.\n\nThe architecture is not the most efficient from a computational standpoint (so you're getting less throughput/raw power than on other OS), the system does not like being highly stressed (OSX will lockup/die when hammered) and its filesystem is widely seen as the worst one in widespread use (with good reason, HFS+ is really, really shit).\n\nPlus /u/whatawasteoftime_'s criteria are actually separate and not necessarily fulfilled by the same OS (or may require widely different OS configuration to get the good stuff) e.g. OpenBSD aims at being a secure system, but it's not very fast so you probably don't want to use it for high-performance computing applications. It's great for network-facing stuff though.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40151, "question": "&gt; the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads\n\nThey're probably not the workloads Apple cares about though.", "aSentId": 40196, "answer": "Lo", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40143, "question": "&gt; Why have a GC run all the time?\n\nBecause reference counting alone doesn't collect cycles and the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads. It doesn't seem likely that they were really situated to take advantage of a modern tracing gc, though.", "aSentId": 40198, "answer": "&gt; Because reference counting alone doesn't collect cycles\n\nIt does break cycles if one of the referents is a weak pointer.\n\nFor example, if you have a tree structure (such as a DOM) then the parents will hold strong referents to their children and the children will hold weak referents to the parents.\n\nWhen you want to do an operation on a weak pointer, it's converted first into a strong pointer, and then the operations can be done on that pointer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40199, "question": "&gt; Because reference counting alone doesn't collect cycles\n\nIt does break cycles if one of the referents is a weak pointer.\n\nFor example, if you have a tree structure (such as a DOM) then the parents will hold strong referents to their children and the children will hold weak referents to the parents.\n\nWhen you want to do an operation on a weak pointer, it's converted first into a strong pointer, and then the operations can be done on that pointer.", "aSentId": 40200, "answer": "If one of the references is a weak pointer, then it's not a cycle. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40201, "question": "If one of the references is a weak pointer, then it's not a cycle. ", "aSentId": 40202, "answer": "&gt; Because reference counting alone doesn't collect cycles and the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads. It doesn't see\n\nIt's still a referent cycle, just one of the edges is weak instead of strong.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40203, "question": "&gt; Because reference counting alone doesn't collect cycles and the benefits of compaction from a tracing garbage collector can be extremely worthwhile for certain workloads. It doesn't see\n\nIt's still a referent cycle, just one of the edges is weak instead of strong.", "aSentId": 40204, "answer": "The only reason a reference cycle is worthy of talking about is if each referent prevents the other from being released. Once you \"break it,\" it's not worth mentioning because it's not a problem. I understand the literal interpretation you're asserting, but my point is that it's an observation that doesn't really add any value in the context of this discussion. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40199, "question": "&gt; Because reference counting alone doesn't collect cycles\n\nIt does break cycles if one of the referents is a weak pointer.\n\nFor example, if you have a tree structure (such as a DOM) then the parents will hold strong referents to their children and the children will hold weak referents to the parents.\n\nWhen you want to do an operation on a weak pointer, it's converted first into a strong pointer, and then the operations can be done on that pointer.", "aSentId": 40206, "answer": "We're really talking about cycles from the garbage collector's perspective. Yes there are ways to make logical cycles that a reference counted GC is still able to collect, and weak references are one of those ways.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40141, "question": "More efficient, they make the compiler now and know where it needs to insert all the frees and releases into the code for optimized performance. Why have a GC run all the time?", "aSentId": 40208, "answer": "&gt;  Why have a GC run all the time?\n\nIt doesn't seem like you have a realistic perspective on what a GC does. It doesn't have to \"run all the time\", like on a separate thread. In fact, just like RC acquire/release points, GC's simply require \"safe points\" where the GC can run on the same thread. There are in fact reference counting GCs that properly collect cycles. This requires no conceptual change to the RC semantics, it's just that each object that is decremented goes through a local trace to see if there are any cycles.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40141, "question": "More efficient, they make the compiler now and know where it needs to insert all the frees and releases into the code for optimized performance. Why have a GC run all the time?", "aSentId": 40210, "answer": "&gt; they make the compiler now and know where it needs to insert all the frees and releases into the code for optimized performance\n\nThe first does _not_ imply the second.  Deducing when and where to free memory is Turing-complete - in other words, for some programs at least, the only way to figure it out is by actually running the program in question (and that's for programs without user input).\n\nFor example, you might go through a block 99 times in a row, and each time you are able to delete a block of memory at the end.  Can you do it every time?  No!  Perhaps the 100th time someone else is keeping a reference to the block - perhaps there's something sampling it and storing it in a table - perhaps it got taken into a response from a user input and made permanent.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40212, "question": "I guess if they never had a good compacting gc then this is a decent middle ground of providing some sort of automatic handling. Doesn't seem super clean to me that the user has to now be cognizant of their gc but not actively manage it. I'd almost rather have all or none, but maybe it works well in practice?", "aSentId": 40213, "answer": "ARC is brilliant. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40091, "question": "Mac Apps That Use Garbage Collection Must Move to ARC", "aSentId": 40215, "answer": "This applies only to applications that are submitted to and delivered to customers via the Mac App Store.\n\nThis is not a wide-reaching OS X requirement.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40217, "question": "I would assume ARC would be slower, since each retain/release would require synchronization. Or is there a way to express unique ownership?\n\nAlso, I am not as familiar with ARC. Is there a way to break or detect cycles?", "aSentId": 40218, "answer": "ARC is a compile-time system. It doesn't actually function as a garbage collector, it just inserts the proper memory management methods into the code. So technically I'm pretty sure it's no less performant than manually managing your retain/release of objects.  \n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40219, "question": "ARC is a compile-time system. It doesn't actually function as a garbage collector, it just inserts the proper memory management methods into the code. So technically I'm pretty sure it's no less performant than manually managing your retain/release of objects.  \n\n", "aSentId": 40220, "answer": "&gt; So technically I'm pretty sure it's no less performant than manually managing your retain/release of objects.\n\nYes of course, but I wasn't talking about the performance difference between ARC and manual retain/release.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40221, "question": "&gt; So technically I'm pretty sure it's no less performant than manually managing your retain/release of objects.\n\nYes of course, but I wasn't talking about the performance difference between ARC and manual retain/release.", "aSentId": 40222, "answer": "Manual memory management offers better performance than GC, so is ARC offers the same performance as manual memory management (and it probably does), then ARC has better performance than GC.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40223, "question": "Manual memory management offers better performance than GC, so is ARC offers the same performance as manual memory management (and it probably does), then ARC has better performance than GC.", "aSentId": 40224, "answer": "&gt; Manual memory management offers better performance than GC\n\nWrong. Manual memory management *could* offer better performance than GC, but it is in no way automatically better. Naiive manual memory management (using `malloc` and `free` or similar) suffers from fragmentation and cache performance. Manually managing memory is also eager, meaning you free it once you no longer use it, rather than free it when you need it. GC usually has the freedom to do what it chooses, including lazily freeing memory. What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). Even if it does need to free it can do so in bulk, and depending on the algorithm and the program it can be quite a bit faster to free the memory en masse.\n\n&gt; ARC offers the same performance as manual memory management (and it probably does)\n\nNope not even close. Reference counting requires doing a locked/syncronized increment or decrement each time a reference is assigned to, or goes out of scope. This means poor multi-threading scalability, as well as a substantial amount of work done for each object.\n\n&gt; ARC has better performance than GC\n\nFor one, ARC is GC. Garbage Collection refers to a process that automatically takes care of freeing memory, how it does so is an implementation detail. \n\nARC is the kind of garbage collection that super fast languages such as PHP use. &lt;/sarcasm&gt;\n\nIt is a very common misconception that tracing collectors (the kind of thing in most JavaScript implementations, Java and C#) are slower than reference counters. They are in fact faster, but suffer from pauses. The main benefits of reference counters is in preventing any pauses, not in increasing overall performance. Notably reference counting wouldn't be good for a game, because despite the fact that it'd reduce pauses and give a more consistent framerate, it'd drop the framerate overall. The best approach for games is to use object pools (which is true of manual memory management too).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40225, "question": "&gt; Manual memory management offers better performance than GC\n\nWrong. Manual memory management *could* offer better performance than GC, but it is in no way automatically better. Naiive manual memory management (using `malloc` and `free` or similar) suffers from fragmentation and cache performance. Manually managing memory is also eager, meaning you free it once you no longer use it, rather than free it when you need it. GC usually has the freedom to do what it chooses, including lazily freeing memory. What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). Even if it does need to free it can do so in bulk, and depending on the algorithm and the program it can be quite a bit faster to free the memory en masse.\n\n&gt; ARC offers the same performance as manual memory management (and it probably does)\n\nNope not even close. Reference counting requires doing a locked/syncronized increment or decrement each time a reference is assigned to, or goes out of scope. This means poor multi-threading scalability, as well as a substantial amount of work done for each object.\n\n&gt; ARC has better performance than GC\n\nFor one, ARC is GC. Garbage Collection refers to a process that automatically takes care of freeing memory, how it does so is an implementation detail. \n\nARC is the kind of garbage collection that super fast languages such as PHP use. &lt;/sarcasm&gt;\n\nIt is a very common misconception that tracing collectors (the kind of thing in most JavaScript implementations, Java and C#) are slower than reference counters. They are in fact faster, but suffer from pauses. The main benefits of reference counters is in preventing any pauses, not in increasing overall performance. Notably reference counting wouldn't be good for a game, because despite the fact that it'd reduce pauses and give a more consistent framerate, it'd drop the framerate overall. The best approach for games is to use object pools (which is true of manual memory management too).", "aSentId": 40226, "answer": "Note that for a game, a high but inconsistent framerate is a disaster compared to medium but consistent framerate. Inconsistent framerate due to gc pauses causes stutter, which makes the game a terrible experience. I agree with you that object pools are the way to go for games, I just wanted to clarify the reasoning.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40225, "question": "&gt; Manual memory management offers better performance than GC\n\nWrong. Manual memory management *could* offer better performance than GC, but it is in no way automatically better. Naiive manual memory management (using `malloc` and `free` or similar) suffers from fragmentation and cache performance. Manually managing memory is also eager, meaning you free it once you no longer use it, rather than free it when you need it. GC usually has the freedom to do what it chooses, including lazily freeing memory. What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). Even if it does need to free it can do so in bulk, and depending on the algorithm and the program it can be quite a bit faster to free the memory en masse.\n\n&gt; ARC offers the same performance as manual memory management (and it probably does)\n\nNope not even close. Reference counting requires doing a locked/syncronized increment or decrement each time a reference is assigned to, or goes out of scope. This means poor multi-threading scalability, as well as a substantial amount of work done for each object.\n\n&gt; ARC has better performance than GC\n\nFor one, ARC is GC. Garbage Collection refers to a process that automatically takes care of freeing memory, how it does so is an implementation detail. \n\nARC is the kind of garbage collection that super fast languages such as PHP use. &lt;/sarcasm&gt;\n\nIt is a very common misconception that tracing collectors (the kind of thing in most JavaScript implementations, Java and C#) are slower than reference counters. They are in fact faster, but suffer from pauses. The main benefits of reference counters is in preventing any pauses, not in increasing overall performance. Notably reference counting wouldn't be good for a game, because despite the fact that it'd reduce pauses and give a more consistent framerate, it'd drop the framerate overall. The best approach for games is to use object pools (which is true of manual memory management too).", "aSentId": 40228, "answer": "&gt; Naiive manual memory management (using malloc and free or similar) suffers from fragmentation and cache performance. Manually managing memory is also eager, meaning you free it once you no longer use it, rather than free it when you need it. GC usually has the freedom to do what it chooses, including lazily freeing memory. What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). Even if it does need to free it can do so in bulk, and depending on the algorithm and the program it can be quite a bit faster to free the memory en masse.\n\nMemory allocation in Cocoa and Cocoa Touch (really, in anything that inherits from `NSObject`) is highly optimized. Allocations are drawn from zones which groups similarly-sized objects together (reducing a lot of memory fragmentation) and also allows a number of optimizations when creating an object and when freeing one.\n\n&gt; Nope not even close. Reference counting requires doing a locked/syncronized increment or decrement each time a reference is assigned to, or goes out of scope. This means poor multi-threading scalability, as well as a substantial amount of work done for each object.\n\nTrue\u2014there is some work that has to be done to deal with reference incrementing/decrementing, although this, too, is highly optimized in Cocoa/Cocoa Touch (atomic increment/decrement operations, which don't completely remove the performance penalty but reduce it somewhat, as well as optimizations for dispatching `retain`/`release` calls).\n\n&gt; ARC is the kind of garbage collection that super fast languages such as PHP use. \n\nThe performance of PHP is not solely due to its memory management architecture, nor is the performance of Objective-C (or Swift) solely due to its memory management architecture.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40229, "question": "&gt; Naiive manual memory management (using malloc and free or similar) suffers from fragmentation and cache performance. Manually managing memory is also eager, meaning you free it once you no longer use it, rather than free it when you need it. GC usually has the freedom to do what it chooses, including lazily freeing memory. What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). Even if it does need to free it can do so in bulk, and depending on the algorithm and the program it can be quite a bit faster to free the memory en masse.\n\nMemory allocation in Cocoa and Cocoa Touch (really, in anything that inherits from `NSObject`) is highly optimized. Allocations are drawn from zones which groups similarly-sized objects together (reducing a lot of memory fragmentation) and also allows a number of optimizations when creating an object and when freeing one.\n\n&gt; Nope not even close. Reference counting requires doing a locked/syncronized increment or decrement each time a reference is assigned to, or goes out of scope. This means poor multi-threading scalability, as well as a substantial amount of work done for each object.\n\nTrue\u2014there is some work that has to be done to deal with reference incrementing/decrementing, although this, too, is highly optimized in Cocoa/Cocoa Touch (atomic increment/decrement operations, which don't completely remove the performance penalty but reduce it somewhat, as well as optimizations for dispatching `retain`/`release` calls).\n\n&gt; ARC is the kind of garbage collection that super fast languages such as PHP use. \n\nThe performance of PHP is not solely due to its memory management architecture, nor is the performance of Objective-C (or Swift) solely due to its memory management architecture.", "aSentId": 40230, "answer": "&gt; The performance of PHP is not solely due to its memory management architecture, nor is the performance of Objective-C (or Swift) solely due to its memory management architecture.\n\nYeah I mostly pointing it out as ARC not being a feature. ARC is a lazy mans GC, and it requires quite a lot of improvements before it can get to the same level of performance. \n\nLast I did a bit of research Immix was the fastest tracing collector, and RC Immix, which is a paper trying to close the performance gap of reference counting and tracing collectors, basically implements the immix GC, and not just as cycle detection. It also does a bunch of stuff with buffering retain/release, to the point where I wonder how they can even call it reference counting anymore.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40225, "question": "&gt; Manual memory management offers better performance than GC\n\nWrong. Manual memory management *could* offer better performance than GC, but it is in no way automatically better. Naiive manual memory management (using `malloc` and `free` or similar) suffers from fragmentation and cache performance. Manually managing memory is also eager, meaning you free it once you no longer use it, rather than free it when you need it. GC usually has the freedom to do what it chooses, including lazily freeing memory. What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). Even if it does need to free it can do so in bulk, and depending on the algorithm and the program it can be quite a bit faster to free the memory en masse.\n\n&gt; ARC offers the same performance as manual memory management (and it probably does)\n\nNope not even close. Reference counting requires doing a locked/syncronized increment or decrement each time a reference is assigned to, or goes out of scope. This means poor multi-threading scalability, as well as a substantial amount of work done for each object.\n\n&gt; ARC has better performance than GC\n\nFor one, ARC is GC. Garbage Collection refers to a process that automatically takes care of freeing memory, how it does so is an implementation detail. \n\nARC is the kind of garbage collection that super fast languages such as PHP use. &lt;/sarcasm&gt;\n\nIt is a very common misconception that tracing collectors (the kind of thing in most JavaScript implementations, Java and C#) are slower than reference counters. They are in fact faster, but suffer from pauses. The main benefits of reference counters is in preventing any pauses, not in increasing overall performance. Notably reference counting wouldn't be good for a game, because despite the fact that it'd reduce pauses and give a more consistent framerate, it'd drop the framerate overall. The best approach for games is to use object pools (which is true of manual memory management too).", "aSentId": 40232, "answer": "&gt; What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). \n\nThis gives less memory to the OS to cache stuff (like disk data) and room memory defragmentation. People should stop assuming that the memory that is not used by running programs is wasted.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40233, "question": "&gt; What this means is that if you have more memory than your program needs your program may never need to free memory (except when it ends). \n\nThis gives less memory to the OS to cache stuff (like disk data) and room memory defragmentation. People should stop assuming that the memory that is not used by running programs is wasted.", "aSentId": 40234, "answer": "&gt; This gives less memory to the OS to cache stuff\n\nYes but what I'm talking about is single run programs, or programs that really don't accumulate a ton of garbage. Compilers as an example greatly benefit from not freeing memory. Other quickly executed tools can get the same boost. Servers can simply dump all the memory used in a request en masse, and likewise get a boost from lazily freeing.\n\n&gt; People should stop assuming that the memory that is not used by running programs is wasted.\n\nOh definitely, but I have a 16 GB computer, and a large SSD. The OS has tons of free memory to play with, and not as much need to cache disk access. If Chrome decides to hold off on GC'ing this current tab until I close it, it'd be a performance win.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40235, "question": "&gt; This gives less memory to the OS to cache stuff\n\nYes but what I'm talking about is single run programs, or programs that really don't accumulate a ton of garbage. Compilers as an example greatly benefit from not freeing memory. Other quickly executed tools can get the same boost. Servers can simply dump all the memory used in a request en masse, and likewise get a boost from lazily freeing.\n\n&gt; People should stop assuming that the memory that is not used by running programs is wasted.\n\nOh definitely, but I have a 16 GB computer, and a large SSD. The OS has tons of free memory to play with, and not as much need to cache disk access. If Chrome decides to hold off on GC'ing this current tab until I close it, it'd be a performance win.\n", "aSentId": 40236, "answer": "&gt; Oh definitely, but I have a 16 GB computer, and a large SSD. The OS has tons of free memory to play with, and not as much need to cache disk access.\n\neven if your app takes up &lt;100mb of ram, keep in mind that Apple still sells Macbooks with 4GB of ram. also plenty of users are still using their 2GB macbook airs.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40237, "question": "&gt; Oh definitely, but I have a 16 GB computer, and a large SSD. The OS has tons of free memory to play with, and not as much need to cache disk access.\n\neven if your app takes up &lt;100mb of ram, keep in mind that Apple still sells Macbooks with 4GB of ram. also plenty of users are still using their 2GB macbook airs.\n", "aSentId": 40238, "answer": "Yes of course, but 100MB of RAM is still very high (considering the only application I currently have running taking up more than 100MB is chrome. And that's with quite a few programs running). ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40235, "question": "&gt; This gives less memory to the OS to cache stuff\n\nYes but what I'm talking about is single run programs, or programs that really don't accumulate a ton of garbage. Compilers as an example greatly benefit from not freeing memory. Other quickly executed tools can get the same boost. Servers can simply dump all the memory used in a request en masse, and likewise get a boost from lazily freeing.\n\n&gt; People should stop assuming that the memory that is not used by running programs is wasted.\n\nOh definitely, but I have a 16 GB computer, and a large SSD. The OS has tons of free memory to play with, and not as much need to cache disk access. If Chrome decides to hold off on GC'ing this current tab until I close it, it'd be a performance win.\n", "aSentId": 40240, "answer": "Indeed, in those cases i think it is ok (i don't really like compilers not freeing memory since this makes their code bad for reuse as a library, but this is another point), i was more thinking of the kinds of programs you'd see on the Mac App Store - that is desktop apps which run for some decent time and affect the experience of the whole computer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40241, "question": "Indeed, in those cases i think it is ok (i don't really like compilers not freeing memory since this makes their code bad for reuse as a library, but this is another point), i was more thinking of the kinds of programs you'd see on the Mac App Store - that is desktop apps which run for some decent time and affect the experience of the whole computer.", "aSentId": 40242, "answer": "Even in those cases I can see processes or threads launched by the app that can be reclaimed en mass. Like if you have a text editor with tabs, each tab could be it's own thread, and closing a tab releasing all the memory at once would be faster than releasing it individually.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40244, "question": "Your comment on poor scalability with locked reference counting is not entirely accurate. In practice 99% of objects have their reference modified without contention. Compilers &amp; CPUs are incredibly optimized for the case of no contention but take large penalties when there is.", "aSentId": 40245, "answer": "Not really. 40+ cycles on ARM, 20+ cycles on i5 x86. Versus 1 cycle unsynced, and 0 cycles garbage-collected. \n\n(this is for the uncontended case)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40246, "question": "Not really. 40+ cycles on ARM, 20+ cycles on i5 x86. Versus 1 cycle unsynced, and 0 cycles garbage-collected. \n\n(this is for the uncontended case)", "aSentId": 40247, "answer": "Dude, 25-40 cycles for a reference counted operation is not that much. Also, is that the access time for a mutex lock acquisition or an atomic integer increment? The latter is what you should be timing for a Reference counted object.\n\nI've worked on the Google Earth project for 5 years where everything was referenced counted. In our profiler we saw maybe 2-3% of the CPU time being spent in atomic reference counting when lots of ref-counted objects were being manipulated. Otherwise it was less than 1%.\n\nI'm sure that refcounting could be an actual bottleneck in a contrived example - but I've never seen it in production in the decade that I've been a software engineer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40246, "question": "Not really. 40+ cycles on ARM, 20+ cycles on i5 x86. Versus 1 cycle unsynced, and 0 cycles garbage-collected. \n\n(this is for the uncontended case)", "aSentId": 40249, "answer": "Most of the actual reference counting in Objective-C is elided by the compiler. The clang compiler performs compile-time data flow analysis and knows when there's no possible shared references within a given scope.\n\nGenerally, the ARC overhead is zero unless your object is actually shared.\n\nEven when there is shared memory, Objective-C's reference counting uses atomic spin locks, not mutexes. The overhead is about 6 cycles on Intel.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40251, "question": "Thank you so much for this. The thread you were replying to is infuriating if you know a bit about memory management.", "aSentId": 40252, "answer": "Unfortunately, many of the problems mentioned with reference counting in that comment have at least some partial solutions in Objective-C. Sync only needs to happen on free and because it uses autorelease pools, freeing doesn't happen immediately only.\n\nThe issues mentioned are in a na\u00efve reference counting implementation, but Objective-C is far from a na\u00efve implementation.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40254, "question": "&gt; It is a very common misconception that tracing collectors (the kind of thing in most JavaScript implementations, Java and C#) are slower than reference counters. They are in fact faster, but suffer from pauses. The main benefits of reference counters is in preventing any pauses, not in increasing overall performance.\n\nThat's an OK first approximation, but it's not quite right.\n\nIt makes the most sense to think of GC design as having a bunch of tradeoffs, with simple ref counting and simple mark-and-sweep being different ends of the (multi-dimensional) solution space.\n\nDepending on how you make those tradeoffs, you can have pause-free mark and sweep. And depending on what data you reference count, you can have huge pauses as you free a bunch of data at once.", "aSentId": 40255, "answer": "Yes that is true. Linked lists and trees cause reference counters to pause.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40257, "question": "&gt;Nope not even close. Reference counting requires doing a locked/syncronized increment or decrement each time a reference is assigned to, or goes out of scope. This means poor multi-threading scalability, as well as a substantial amount of work done for each object.\n\nAren't those operations atomic?", "aSentId": 40258, "answer": "An atomic operation still needs to be syncronized. If thread A has object `i` in it's cache, and thread B needs to update it, thread A must purge it from it's cache, which is expensive (re-fetching from main memory is very costly).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40223, "question": "Manual memory management offers better performance than GC, so is ARC offers the same performance as manual memory management (and it probably does), then ARC has better performance than GC.", "aSentId": 40262, "answer": "I can't speak to ARC in particular, but it's really no different than plain-old reference counting.  And not only does reference counting not offer performance on par with manual memory management, it offers performance that is markedly worse than basically all other forms of garbage collection.\n\nThe only reason that ARC could possibly be as performant as manual memory management is if Apple is doing some crazy optimizations behind the scenes, but I would remain skeptical.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40263, "question": "I can't speak to ARC in particular, but it's really no different than plain-old reference counting.  And not only does reference counting not offer performance on par with manual memory management, it offers performance that is markedly worse than basically all other forms of garbage collection.\n\nThe only reason that ARC could possibly be as performant as manual memory management is if Apple is doing some crazy optimizations behind the scenes, but I would remain skeptical.", "aSentId": 40264, "answer": "Cocoa's retain/release mechanism does, in fact, offer a number of \"crazy optimizations\". Many of the most-commonly used objects, for example, have their own way of managing references using atomic increments/decrements instead of locking. Calls to `retain` and `release` are also highly optimized by bypassing the usual method-dispatching system in Objective-C.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40263, "question": "I can't speak to ARC in particular, but it's really no different than plain-old reference counting.  And not only does reference counting not offer performance on par with manual memory management, it offers performance that is markedly worse than basically all other forms of garbage collection.\n\nThe only reason that ARC could possibly be as performant as manual memory management is if Apple is doing some crazy optimizations behind the scenes, but I would remain skeptical.", "aSentId": 40266, "answer": "&gt; but I would remain skeptical.\n\nAs would I since they don't even offer a way to detect or free cycles. ARC totally allows memory leaks.\n\nThe literature for RC vs Tracing Collectors shows that referencing counting actually can be as just fast as tracing collectors (See RCImmix) but it comes at the cost of quite a lot of complexity along with lesser guarantees of no pausing (something which RC doesn't normally guarantee anyway, thanks to linked lists or trees) and lesser guarantees of eager freeing (again, thanks to cycles, reference counters usually don't guarantee this either).\n\n&gt; Apple is doing some crazy optimizations behind the scenes\n\nI'm assuming they are at least doing local cancelling of `retain/release` otherwise the performance would be disastrous, and the rest of the optimizations would be applicable to manual memory management as well (cancelling out `free` and `malloc`, re-ordering for increased cache performance etc).\n\nThe frustrating part is that garbage collectors in most mainstream languages is so far behind the theory and experimental or smaller language garbage collectors. There are quite a lot of static optimizations garbage collection could do, but it doesn't since most mainstream garbage collected languages are simply interpreted (or JIT compiled, which means static optimizations must be quick). I suspect that the native C# compiler could make leaps and bounds with performance due to static garbage collection.\n\nHaskell is an interesting case, because despite the fact that performance isn't one of the language goals, and it has GC and immutability (both known as big no-nos for performance), it still gets faster than C performance if done right.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40267, "question": "&gt; but I would remain skeptical.\n\nAs would I since they don't even offer a way to detect or free cycles. ARC totally allows memory leaks.\n\nThe literature for RC vs Tracing Collectors shows that referencing counting actually can be as just fast as tracing collectors (See RCImmix) but it comes at the cost of quite a lot of complexity along with lesser guarantees of no pausing (something which RC doesn't normally guarantee anyway, thanks to linked lists or trees) and lesser guarantees of eager freeing (again, thanks to cycles, reference counters usually don't guarantee this either).\n\n&gt; Apple is doing some crazy optimizations behind the scenes\n\nI'm assuming they are at least doing local cancelling of `retain/release` otherwise the performance would be disastrous, and the rest of the optimizations would be applicable to manual memory management as well (cancelling out `free` and `malloc`, re-ordering for increased cache performance etc).\n\nThe frustrating part is that garbage collectors in most mainstream languages is so far behind the theory and experimental or smaller language garbage collectors. There are quite a lot of static optimizations garbage collection could do, but it doesn't since most mainstream garbage collected languages are simply interpreted (or JIT compiled, which means static optimizations must be quick). I suspect that the native C# compiler could make leaps and bounds with performance due to static garbage collection.\n\nHaskell is an interesting case, because despite the fact that performance isn't one of the language goals, and it has GC and immutability (both known as big no-nos for performance), it still gets faster than C performance if done right.", "aSentId": 40268, "answer": "&gt; Haskell is an interesting case, because despite the fact that performance isn't one of the language goals, and it has GC and immutability (both known as big no-nos for performance), it still gets faster than C performance if done right.\n\nI keep hearing about how Haskell can do this - do you have any non-trivial non-contrived performance metrics that show this?\n\nIt keeps cropping up but somehow we get various incarnations of prime number sieves or other lazy evaluated structures where the compiler basically eliminates lots of the program but something like C or C++ have to do the computation at runtime.\n\nI find it interesting that John Carmack played around with it for a bit and the result seems to have been \"some principles interesting will use them, rest not practical\". I could be remembering wrong there though .-)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40269, "question": "&gt; Haskell is an interesting case, because despite the fact that performance isn't one of the language goals, and it has GC and immutability (both known as big no-nos for performance), it still gets faster than C performance if done right.\n\nI keep hearing about how Haskell can do this - do you have any non-trivial non-contrived performance metrics that show this?\n\nIt keeps cropping up but somehow we get various incarnations of prime number sieves or other lazy evaluated structures where the compiler basically eliminates lots of the program but something like C or C++ have to do the computation at runtime.\n\nI find it interesting that John Carmack played around with it for a bit and the result seems to have been \"some principles interesting will use them, rest not practical\". I could be remembering wrong there though .-)", "aSentId": 40270, "answer": "Generally you can get within a factor of 2 to 3 of C pretty reliably.  That's what the benchmark shootout shows and I also get the same results in my own hands.\n\nThere are two ways you can do this:\n\nApproach #1: Avoid recursion.  You can transform any recursive algorithm into a non-recursive equivalent and the compiler excels at optimizing non-recursive code.\n\nApproach #2: Use recursion, but write \"C in Haskell\" (i.e. translate your C code almost literally to Haskell code, using the operations in Haskell's `Foreign` module hierarchy).\n\nAn example of Approach #1 is the `attoparsec` library, which produces incredibly fast parsers competitive with hand-rolled C code.\n\nAn example of Approach #2 is most of the Haskell code in the benchmark shootout.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40271, "question": "Generally you can get within a factor of 2 to 3 of C pretty reliably.  That's what the benchmark shootout shows and I also get the same results in my own hands.\n\nThere are two ways you can do this:\n\nApproach #1: Avoid recursion.  You can transform any recursive algorithm into a non-recursive equivalent and the compiler excels at optimizing non-recursive code.\n\nApproach #2: Use recursion, but write \"C in Haskell\" (i.e. translate your C code almost literally to Haskell code, using the operations in Haskell's `Foreign` module hierarchy).\n\nAn example of Approach #1 is the `attoparsec` library, which produces incredibly fast parsers competitive with hand-rolled C code.\n\nAn example of Approach #2 is most of the Haskell code in the benchmark shootout.", "aSentId": 40272, "answer": "&gt; Generally you can get within a factor of 2 to 3 of C pretty reliably. That's what the benchmark shootout shows and I also get the same results in my own hands.\n\nThis seems more along the lines of what I'd imagine practical experience to show (given runtime overhead, relative difficultly in expressing things like cache usage and packing/alignment) - it's within a plausable order of magnitude - and you have data that backs up the assertion (shootout).\n\nThe thing I took umbrage with was the parent assertion of \"faster than C when done right\".\n\n&gt; .. Avoiding recursion, writing C in language X\n\nGenerally a good idea when looking for performance wins. I guess it is the \"portable assembly\" part of C that we're really benefiting from rather than C's expressions holding much in the way of algorithmic or optimisation magic.\n\nNow as someone that has some experience getting decent performance from Haskell - how deep would you say you need to know the runtime to get this kind of performance out of it?\n\nI've done some trivial bits of haskell but avoided going any deeper with it once I saw how far away I was from what was being executed on the back end.\n\nPresumably the way that language constructs are consumed by the optimiser/runtime has a larger influence on performance than something like C - would you say it's along the order of C++ templates/constexpr, less, greater? (Sorry, I'm assuming you know C++). I'm curious what the investment of time in learning the runtime/compiler is compared to more traditional imperative languages.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40273, "question": "&gt; Generally you can get within a factor of 2 to 3 of C pretty reliably. That's what the benchmark shootout shows and I also get the same results in my own hands.\n\nThis seems more along the lines of what I'd imagine practical experience to show (given runtime overhead, relative difficultly in expressing things like cache usage and packing/alignment) - it's within a plausable order of magnitude - and you have data that backs up the assertion (shootout).\n\nThe thing I took umbrage with was the parent assertion of \"faster than C when done right\".\n\n&gt; .. Avoiding recursion, writing C in language X\n\nGenerally a good idea when looking for performance wins. I guess it is the \"portable assembly\" part of C that we're really benefiting from rather than C's expressions holding much in the way of algorithmic or optimisation magic.\n\nNow as someone that has some experience getting decent performance from Haskell - how deep would you say you need to know the runtime to get this kind of performance out of it?\n\nI've done some trivial bits of haskell but avoided going any deeper with it once I saw how far away I was from what was being executed on the back end.\n\nPresumably the way that language constructs are consumed by the optimiser/runtime has a larger influence on performance than something like C - would you say it's along the order of C++ templates/constexpr, less, greater? (Sorry, I'm assuming you know C++). I'm curious what the investment of time in learning the runtime/compiler is compared to more traditional imperative languages.\n", "aSentId": 40274, "answer": "The main things that you need to know about the run time when tuning Haskell code are:\n\n* For non-recursive code, data structures are essentially free\n* For recursive streaming code that creates a lot of highly transient data structures, creating and then immediately consuming a data structure costs on the order of 10-20 ns (including the cost of GCing the constructor)\n* For code that creates some sort of large permanent index, bump up the initial heap size to the size of your index, because you pay a full GC penalty every time the compiler bumps up the heap size\n* The `ghc` compiler will not do loop unrolling itself, but the LLVM backend will if you enable it\n* Haskell's threading runtime blows away every other language's threading runtime\n* Most things in the `Foreign.*` hierarchy are analogous to C code, except not quite optimized as well as `gcc` would\n* `INLINE`/`INLINABLE` pragmas are like `gcc` inline annotations ... kind of\n* Rewrite rules essentially do compile-time evaluation to improve performance (kind of like how C++ templates are sometimes used)\n\nA lot of this you can learn by studying Haskell's generated \"core\" which is essentially System Fw plus some Haskell extensions and primitive operations.  You don't really gain much from studying the layers below core.\n\nWhen people talk about Haskell being faster than C they are sometimes right, but it's not that common and the examples are non-trivial.  The reason this sometimes can happen is:\n\n* The Haskell compiler exports source code alongside each module to allow additional optimization opportunities across module or library boundaries, whereas C doesn't\n* The purely functional nature of the language permits some optimizations that imperative languages don't.  For small examples this usually doesn't make that much of a difference.  However, one area it does make a big difference is the threading runtime, which has a lot more freedom to optimize things than other threading runtimes\n* Haskell libraries can always \"cheat\" and invoke a C FFI for an additional speed boost.  However, a large number of high-performance Haskell libraries (like `vector`, `containers` and `text`) are actually pure Haskell implementations (except for some features of `text` like UTF8 encoding/decoding and other unicode support).  Of course \"pure Haskell\" is a little misnomer in the sense that they use a lot of GHC-specific built-ins and primitives for really high-performance\n\nI estimate it takes several dedicated weeks of playing with the CPU and heap profiler, studying generated core, using `criterion` and playing around with compiler pragmas to learn all of this.  It's worth knowing if you want to write high-performance libraries for others.  However, if you just stick to existing high-performance libraries they do most of the work for you.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40275, "question": "The main things that you need to know about the run time when tuning Haskell code are:\n\n* For non-recursive code, data structures are essentially free\n* For recursive streaming code that creates a lot of highly transient data structures, creating and then immediately consuming a data structure costs on the order of 10-20 ns (including the cost of GCing the constructor)\n* For code that creates some sort of large permanent index, bump up the initial heap size to the size of your index, because you pay a full GC penalty every time the compiler bumps up the heap size\n* The `ghc` compiler will not do loop unrolling itself, but the LLVM backend will if you enable it\n* Haskell's threading runtime blows away every other language's threading runtime\n* Most things in the `Foreign.*` hierarchy are analogous to C code, except not quite optimized as well as `gcc` would\n* `INLINE`/`INLINABLE` pragmas are like `gcc` inline annotations ... kind of\n* Rewrite rules essentially do compile-time evaluation to improve performance (kind of like how C++ templates are sometimes used)\n\nA lot of this you can learn by studying Haskell's generated \"core\" which is essentially System Fw plus some Haskell extensions and primitive operations.  You don't really gain much from studying the layers below core.\n\nWhen people talk about Haskell being faster than C they are sometimes right, but it's not that common and the examples are non-trivial.  The reason this sometimes can happen is:\n\n* The Haskell compiler exports source code alongside each module to allow additional optimization opportunities across module or library boundaries, whereas C doesn't\n* The purely functional nature of the language permits some optimizations that imperative languages don't.  For small examples this usually doesn't make that much of a difference.  However, one area it does make a big difference is the threading runtime, which has a lot more freedom to optimize things than other threading runtimes\n* Haskell libraries can always \"cheat\" and invoke a C FFI for an additional speed boost.  However, a large number of high-performance Haskell libraries (like `vector`, `containers` and `text`) are actually pure Haskell implementations (except for some features of `text` like UTF8 encoding/decoding and other unicode support).  Of course \"pure Haskell\" is a little misnomer in the sense that they use a lot of GHC-specific built-ins and primitives for really high-performance\n\nI estimate it takes several dedicated weeks of playing with the CPU and heap profiler, studying generated core, using `criterion` and playing around with compiler pragmas to learn all of this.  It's worth knowing if you want to write high-performance libraries for others.  However, if you just stick to existing high-performance libraries they do most of the work for you.", "aSentId": 40276, "answer": "Great info - thank you for this. It's gone into my \"stuff to note\" index for when I get round to pounding on Haskell properly.\n\nSome comments about the \"faster than C\" bits:\n\n&gt; exports source code ... across module or library boundaries, whereas C doesn't\n\nFair point. I can see there are opportunities for optimisation here but doesn't PGO (profile guided optimisation) go some way to negating these benefits? For extreme cases there is nothing stopping a C programmer implementing that particularly hot cross compilation unit loop as a special case. You could argue that Haskell removes the need for writing that code, which I'll accept - but better than C performance - seems a little out of the park, tbh.\n\n&gt; one area it does make a big difference is the threading runtime\n\nThreads/cores are one of the worst and best artefacts of modern computing performance we have (after caching issues). It's the one area I would agree that the C use of threads (which is more or less posix style threads in C99 I believe) is naively abused at worst (mutable state everywhere) through to routinely used badly at best (mutexes to lock silly things). I would point to the parent assumption of \"better than C when done properly\" where I would hope that the C would be written properly too. If Haskell can run things in a \"correct\" isolated way on top of threads, there isn't anything stopping a C program doing that.\n\nI guess what this comes down to is the trade off between how the \"commonly used language idioms\" work out in performance.\n\nI was going to ramble a bit about how you can write C to do work algorithmically like Haskell, but I get the impression you're pragmatic about language limitations so it doesn't feel necessary.\n\nEnjoyed your post :-)\n\nDan\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40277, "question": "Great info - thank you for this. It's gone into my \"stuff to note\" index for when I get round to pounding on Haskell properly.\n\nSome comments about the \"faster than C\" bits:\n\n&gt; exports source code ... across module or library boundaries, whereas C doesn't\n\nFair point. I can see there are opportunities for optimisation here but doesn't PGO (profile guided optimisation) go some way to negating these benefits? For extreme cases there is nothing stopping a C programmer implementing that particularly hot cross compilation unit loop as a special case. You could argue that Haskell removes the need for writing that code, which I'll accept - but better than C performance - seems a little out of the park, tbh.\n\n&gt; one area it does make a big difference is the threading runtime\n\nThreads/cores are one of the worst and best artefacts of modern computing performance we have (after caching issues). It's the one area I would agree that the C use of threads (which is more or less posix style threads in C99 I believe) is naively abused at worst (mutable state everywhere) through to routinely used badly at best (mutexes to lock silly things). I would point to the parent assumption of \"better than C when done properly\" where I would hope that the C would be written properly too. If Haskell can run things in a \"correct\" isolated way on top of threads, there isn't anything stopping a C program doing that.\n\nI guess what this comes down to is the trade off between how the \"commonly used language idioms\" work out in performance.\n\nI was going to ramble a bit about how you can write C to do work algorithmically like Haskell, but I get the impression you're pragmatic about language limitations so it doesn't feel necessary.\n\nEnjoyed your post :-)\n\nDan\n", "aSentId": 40278, "answer": "Yeah, thanks for the discussion :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40267, "question": "&gt; but I would remain skeptical.\n\nAs would I since they don't even offer a way to detect or free cycles. ARC totally allows memory leaks.\n\nThe literature for RC vs Tracing Collectors shows that referencing counting actually can be as just fast as tracing collectors (See RCImmix) but it comes at the cost of quite a lot of complexity along with lesser guarantees of no pausing (something which RC doesn't normally guarantee anyway, thanks to linked lists or trees) and lesser guarantees of eager freeing (again, thanks to cycles, reference counters usually don't guarantee this either).\n\n&gt; Apple is doing some crazy optimizations behind the scenes\n\nI'm assuming they are at least doing local cancelling of `retain/release` otherwise the performance would be disastrous, and the rest of the optimizations would be applicable to manual memory management as well (cancelling out `free` and `malloc`, re-ordering for increased cache performance etc).\n\nThe frustrating part is that garbage collectors in most mainstream languages is so far behind the theory and experimental or smaller language garbage collectors. There are quite a lot of static optimizations garbage collection could do, but it doesn't since most mainstream garbage collected languages are simply interpreted (or JIT compiled, which means static optimizations must be quick). I suspect that the native C# compiler could make leaps and bounds with performance due to static garbage collection.\n\nHaskell is an interesting case, because despite the fact that performance isn't one of the language goals, and it has GC and immutability (both known as big no-nos for performance), it still gets faster than C performance if done right.", "aSentId": 40280, "answer": "Actually, the Haskell implementers are surprisingly anal about performance.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40281, "question": "Actually, the Haskell implementers are surprisingly anal about performance.", "aSentId": 40282, "answer": "Compiler implementors everywhere are surprisingly meticulous about performance.  The same for base libraries, in practically all languages.  The reasons are pretty simple: at some point, when some code has enough users with enough of a range of requirements, it's worth gaining almost any amount of performance, no matter how small, for almost any amount of effort, no matter how large.  The same is almost never true of application code.\n\nCombine that with the fact that Haskell makes performance optimization a much more interesting problem (e.g., there are a whole lot more things you can try and at least not actually break the code), and you've got a winning combination for attracting superhuman effort around optimization.  SO GHC these days is a phenomenal achievement; probably the most advanced optimizing compiler in the world.\n\nThat said, I still wouldn't characterize Haskell as having better performance comparable to C.  I'd characterize it as having reasonable performance, and some rare corner cases where it might generate faster code than C.  It still suffers from a fragility problem, though, where minor differences in the way code is written can lead to massive ballooning of memory requirements or running time, because you missed a picky form of a rewrite rule or something like that.  Most of the examples of how fast Haskell can be, sadly, are either written by the person that implemented the optimization, or are about code that bears little resemblance to Haskell in practice.  It's great that the language lets you work at that level when you want to, but it's disingenuous to cite that as evidence that Haskell is an unusually fast programming language.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40281, "question": "Actually, the Haskell implementers are surprisingly anal about performance.", "aSentId": 40284, "answer": "Really? I guess it doesn't surprise me that much, but it's definitely not the priority for the language. The priority is things like type safety and correct programs.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40285, "question": "Really? I guess it doesn't surprise me that much, but it's definitely not the priority for the language. The priority is things like type safety and correct programs.", "aSentId": 40286, "answer": "They have type safety since the beginning, and you can get pretty near correctness with various extensions to Haskell 2010's type system (e.g GADTs).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40219, "question": "ARC is a compile-time system. It doesn't actually function as a garbage collector, it just inserts the proper memory management methods into the code. So technically I'm pretty sure it's no less performant than manually managing your retain/release of objects.  \n\n", "aSentId": 40288, "answer": "This is incorrect.  ARC automatically manages the *reference count* of objects.  When the reference count reaches zero, it performs the freeing of the memory. \n\nThis means that the reference counting functionality needs to be thread-safe.  In highly multi-threaded applications, where objects are shared heavily between threads (always a recipe for disaster, no matter what platform you're using), this can produce a serious bottleneck.\n\nA sufficiently intelligent garbage collector *could* outperform ARC for heavily multi-threaded applications.  The problem is, of course, that garbage collectors are a very difficult nut to crack, and making one that works well for all workloads is *very* difficult.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40219, "question": "ARC is a compile-time system. It doesn't actually function as a garbage collector, it just inserts the proper memory management methods into the code. So technically I'm pretty sure it's no less performant than manually managing your retain/release of objects.  \n\n", "aSentId": 40290, "answer": "It's not compile time only, as reference counting inherently requires incrementing and decrementing a counter at runtime for all but trivial functions where the lifetime of an object can already be predicted at compile time. Every decrement also means a possible branch to the destruction of the object, including decrementing more counters and destruction for whole object graphs. In this aspect, pauses can be as severe as with a GC cycle and even worse, although the required level of synchronization is much lower. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40292, "question": "I don't use Objective-C but I assume ARC's counter updates are thread-safe (otherwise you could not safely pass such a reference between threads.) This means they must be guarded by memory barriers which incur at least a pipeline stall and a lock on the cache line, which might cause inter-core (and potentially inter-socket) coherency traffic.\n\nStop-the-world GC does not need these CPU barriers because the mutator (your program) is stopped from running while the GC runs so there can be no data races.", "aSentId": 40293, "answer": "When I stepped through the iOS retain/release code a few years ago, it was actually strangely complicated. I was expecting a simple inc/dec (or its ARM equivalent), but looked like it was using some kind of hash table! So my guess was that it has a thread-local object refcount table, and then only needs to do some kind of sync when an object's per-thread refcount goes to zero.\n\nThe whole thing struck me as nuts at the time, and in fact still does, since back then all iOS devices were single-core! - so perhaps I was misunderstanding what was going on? (I do find following assembly language in gdb quite difficult.) But if things ended up that way because that's how Mac OS X did it, that would make sense. Having multiple cores writing to the same region is very expensive. (And of course now iOS devices are all multi core, it will make a lot more sense.)\n\nI've since sworn off iOS development, and my Mac is dead, so this is all solely as I remember it :(", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40294, "question": "When I stepped through the iOS retain/release code a few years ago, it was actually strangely complicated. I was expecting a simple inc/dec (or its ARM equivalent), but looked like it was using some kind of hash table! So my guess was that it has a thread-local object refcount table, and then only needs to do some kind of sync when an object's per-thread refcount goes to zero.\n\nThe whole thing struck me as nuts at the time, and in fact still does, since back then all iOS devices were single-core! - so perhaps I was misunderstanding what was going on? (I do find following assembly language in gdb quite difficult.) But if things ended up that way because that's how Mac OS X did it, that would make sense. Having multiple cores writing to the same region is very expensive. (And of course now iOS devices are all multi core, it will make a lot more sense.)\n\nI've since sworn off iOS development, and my Mac is dead, so this is all solely as I remember it :(", "aSentId": 40295, "answer": "If you're stepping through a hash table, you're probably looking at an object with more than 4 references to it. The Objective-C retain/release code uses atomic spin locks and is stored in-pointer for the first 4 references. After that point, the reference count must be stored externally.\n\nEven so, most Objective-C retain/releases are elided (they never happen) because the compiler knows that the object isn't shared within a given scope. And exceeding 4 references is pretty rare (typical is 1).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40294, "question": "When I stepped through the iOS retain/release code a few years ago, it was actually strangely complicated. I was expecting a simple inc/dec (or its ARM equivalent), but looked like it was using some kind of hash table! So my guess was that it has a thread-local object refcount table, and then only needs to do some kind of sync when an object's per-thread refcount goes to zero.\n\nThe whole thing struck me as nuts at the time, and in fact still does, since back then all iOS devices were single-core! - so perhaps I was misunderstanding what was going on? (I do find following assembly language in gdb quite difficult.) But if things ended up that way because that's how Mac OS X did it, that would make sense. Having multiple cores writing to the same region is very expensive. (And of course now iOS devices are all multi core, it will make a lot more sense.)\n\nI've since sworn off iOS development, and my Mac is dead, so this is all solely as I remember it :(", "aSentId": 40297, "answer": "Easy to explain actually, even at the time you could run multiple threads on the single CPU... so it doesn't happen as often, but the OS might still preempt thread A at any point, resume B and corrupt A's state if you don't make stuff shared by A and B thread-safe.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40298, "question": "Easy to explain actually, even at the time you could run multiple threads on the single CPU... so it doesn't happen as often, but the OS might still preempt thread A at any point, resume B and corrupt A's state if you don't make stuff shared by A and B thread-safe.", "aSentId": 40299, "answer": "Yes, good point, and you're probably right. I suppose I was thinking of various other CPUs I've used, where you can do a single DEC directly on the object's refcount, and you're golden (at least in the single-CPU scenario). But on ARM there are no operations that work directly on memory, so I think you have to do a load-dec-store sequence. Which is pretty much the classic textbook example potential multithreading problem!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40300, "question": "Yes, good point, and you're probably right. I suppose I was thinking of various other CPUs I've used, where you can do a single DEC directly on the object's refcount, and you're golden (at least in the single-CPU scenario). But on ARM there are no operations that work directly on memory, so I think you have to do a load-dec-store sequence. Which is pretty much the classic textbook example potential multithreading problem!", "aSentId": 40301, "answer": "Well, it actually doesn't depend on the CPU... the basic shared pointer release requires atomic compare and swap to be thread safe. Eg. this code will cause double frees on all platforms:  \n\n    void release() {\n         if(--count &lt;= 0) {\n             delete ptr;\n         }\n    }\nbut then I wouldn't know why they do hashmaps anyway, if they do.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40217, "question": "I would assume ARC would be slower, since each retain/release would require synchronization. Or is there a way to express unique ownership?\n\nAlso, I am not as familiar with ARC. Is there a way to break or detect cycles?", "aSentId": 40304, "answer": "&gt; I would assume ARC would be slower, since each retain/release would require synchronization.\n\nSlower than what? Objective-C was built on (explicit) refcounting, so that already existed (the inc/dec calls would just get ignored under GC IIRC), and on 64b platforms the refcount is embedded in the isa pointer so it's just an atomic inc/dec away.\n\n&gt; Or is there a way to express unique ownership?\n\nNo.\n\n&gt; Also, I am not as familiar with ARC. Is there a way to break or detect cycles?\n\nNope. ARC is just the compiler manually adding inc/dec calls, then the optimiser eliding the redundant one.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40305, "question": "&gt; I would assume ARC would be slower, since each retain/release would require synchronization.\n\nSlower than what? Objective-C was built on (explicit) refcounting, so that already existed (the inc/dec calls would just get ignored under GC IIRC), and on 64b platforms the refcount is embedded in the isa pointer so it's just an atomic inc/dec away.\n\n&gt; Or is there a way to express unique ownership?\n\nNo.\n\n&gt; Also, I am not as familiar with ARC. Is there a way to break or detect cycles?\n\nNope. ARC is just the compiler manually adding inc/dec calls, then the optimiser eliding the redundant one.", "aSentId": 40306, "answer": "&gt; Slower than what?\n\nSlower than a tracing GC. \n\n&gt; so it's just an atomic inc/dec away.\n\nThe keyword being atomic. Synchronization on the open and closing of a function destroys cpu utilization.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40307, "question": "&gt; Slower than what?\n\nSlower than a tracing GC. \n\n&gt; so it's just an atomic inc/dec away.\n\nThe keyword being atomic. Synchronization on the open and closing of a function destroys cpu utilization.", "aSentId": 40308, "answer": "&gt; Slower than a tracing GC.\n\nThat response is deeply insufficient. There are many dimensions to an allocator, and allocation throughput speed is but one of these, and may or may not be the most important.\n\nSkip a frame because the GC has decided to run right there, or lock up the device because it had to perform a full collection because the GC needs twice the memory of an equivalent manually managed or RC'd workload and you'll see whether your GC is considered faster than RC.\n\n&gt; The keyword being atomic.\n\nYes, it's a keyword.\n\n&gt; Synchronization on the open and closing of a function destroys cpu utilization.\n\nThe compiler is smart enough to elide a number of refcount operations, and an *uncontested* atomic increment or decrement on a modern processor doesn't have that much overhead (especially given obj-c messages are dynamically dispatched, even with a global refcount hashtable \u2014 which is what is used on 32bit platforms \u2014 was not enough of an issue to generate much outcry that I know of, I guess developers would just drop to raw C or C++ and bypass all of the obj-c runtime when it was).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40309, "question": "&gt; Slower than a tracing GC.\n\nThat response is deeply insufficient. There are many dimensions to an allocator, and allocation throughput speed is but one of these, and may or may not be the most important.\n\nSkip a frame because the GC has decided to run right there, or lock up the device because it had to perform a full collection because the GC needs twice the memory of an equivalent manually managed or RC'd workload and you'll see whether your GC is considered faster than RC.\n\n&gt; The keyword being atomic.\n\nYes, it's a keyword.\n\n&gt; Synchronization on the open and closing of a function destroys cpu utilization.\n\nThe compiler is smart enough to elide a number of refcount operations, and an *uncontested* atomic increment or decrement on a modern processor doesn't have that much overhead (especially given obj-c messages are dynamically dispatched, even with a global refcount hashtable \u2014 which is what is used on 32bit platforms \u2014 was not enough of an issue to generate much outcry that I know of, I guess developers would just drop to raw C or C++ and bypass all of the obj-c runtime when it was).", "aSentId": 40310, "answer": "Yes, \"just\" 20+ cycles on i5 x86, and 40+ cycles on ARM. Per increment and per decrement. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40311, "question": "Yes, \"just\" 20+ cycles on i5 x86, and 40+ cycles on ARM. Per increment and per decrement. ", "aSentId": 40312, "answer": "Now look up the objc message dispatch cost.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40313, "question": "Now look up the objc message dispatch cost.", "aSentId": 40314, "answer": "&gt;  objc message dispatch cost.\n\n120+ cycles. Kewl... Versus 3 and 24 cycles. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40217, "question": "I would assume ARC would be slower, since each retain/release would require synchronization. Or is there a way to express unique ownership?\n\nAlso, I am not as familiar with ARC. Is there a way to break or detect cycles?", "aSentId": 40316, "answer": "ARC does this with weak and strong references.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40318, "question": "I assume the motivation is to avoid GC pauses, which makes sense for any app with a GUI. Does anyone know of any platform that supports reference counting and tracing GC in one platform? It seems a referencing-counting (or manually memory managed) thin front end with a tracing GC back end (and an efficient communications channel between them) could be the best of both worlds.", "aSentId": 40319, "answer": "&gt; I assume the motivation is to avoid GC pauses\n\nNo, the motivation is terminating their experiment in ObjC GC and re-unifying their development worlds: they introduced a GC in ObjC/OSX, never introduced it in iOS and actually deprecated it back in 2012 (in favor of ARC).\n\nHere they simply completely disallow the already-deprecated GC.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40320, "question": "&gt; I assume the motivation is to avoid GC pauses\n\nNo, the motivation is terminating their experiment in ObjC GC and re-unifying their development worlds: they introduced a GC in ObjC/OSX, never introduced it in iOS and actually deprecated it back in 2012 (in favor of ARC).\n\nHere they simply completely disallow the already-deprecated GC.", "aSentId": 40321, "answer": "GC support was also dropped entirely in Xcode 5.1 (released roughly a year ago), so it's been obvious for a while that it's deprecated-for-real and not just one of those deprecated things that still sticks around for the next decade or two.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40318, "question": "I assume the motivation is to avoid GC pauses, which makes sense for any app with a GUI. Does anyone know of any platform that supports reference counting and tracing GC in one platform? It seems a referencing-counting (or manually memory managed) thin front end with a tracing GC back end (and an efficient communications channel between them) could be the best of both worlds.", "aSentId": 40323, "answer": "WinRT is a reference counted API/app model which can then be driven by mixture of regular recounted C++ as well as managed C# and JS", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40324, "question": "WinRT is a reference counted API/app model which can then be driven by mixture of regular recounted C++ as well as managed C# and JS", "aSentId": 40325, "answer": "It's actually a really impressive system, I've always thought of microsoft as a company with the brightest engineers and the worst product managers \n\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40324, "question": "WinRT is a reference counted API/app model which can then be driven by mixture of regular recounted C++ as well as managed C# and JS", "aSentId": 40327, "answer": "That's very interesting. I'll have to look into that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40318, "question": "I assume the motivation is to avoid GC pauses, which makes sense for any app with a GUI. Does anyone know of any platform that supports reference counting and tracing GC in one platform? It seems a referencing-counting (or manually memory managed) thin front end with a tracing GC back end (and an efficient communications channel between them) could be the best of both worlds.", "aSentId": 40329, "answer": "Isn't that how Python does it? GC pauses haven't been a problem using Python even with GUI apps (other types of blocking like file I/O can be, but that's why I wrote quamash)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40330, "question": "Isn't that how Python does it? GC pauses haven't been a problem using Python even with GUI apps (other types of blocking like file I/O can be, but that's why I wrote quamash)", "aSentId": 40331, "answer": "I haven't spent too much time with Python, but I do believe \nPython uses ref counting all the way through. And I think that means cycles (A --&gt; B --&gt; C --&gt; A) can't get garbage collected.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40332, "question": "I haven't spent too much time with Python, but I do believe \nPython uses ref counting all the way through. And I think that means cycles (A --&gt; B --&gt; C --&gt; A) can't get garbage collected.", "aSentId": 40333, "answer": "There is another pass which can deal with cycles.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40335, "question": "C++/CLI allows for that if you use both `shared_ptr`/`weak_ptr` and `gcnew`. I wouldn't consider this a good solution by any stretch though.", "aSentId": 40336, "answer": "Yeah, mixing the two is a fairly awful idea. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40338, "question": "I don't know of one that does, but I agree that this would be the best solution.\n\nAlthough with generational GC the pauses can be so small that they shouldn't be visible to regular UI (only visible in things like games, where skipping a frame makes a difference).", "aSentId": 40339, "answer": "You still get occasional full-heap collections with a generational GC, and the relatively large pauses that entails.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40340, "question": "You still get occasional full-heap collections with a generational GC, and the relatively large pauses that entails.", "aSentId": 40341, "answer": "GCs these days can work in the background with very minimal pauses. Of course I do not expect Apple's deprecated GC to get these features so...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40340, "question": "You still get occasional full-heap collections with a generational GC, and the relatively large pauses that entails.", "aSentId": 40343, "answer": "I don't notice any GC pauses in NetBeans, which is a very (very) large GUI app. The rule of thumb for HotSpot is that you might get up to one second of pause for every GB of old-gen heap used, but for a well behaved app that shouldn't happen more than once a day or so (and no more than once every few hours).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40346, "question": "And this is why the iPhone runs so well with half (or less) the memory of Android. It's also why you don't have OS-wide stutters.\n\nI know this is less of a thing with newer hardware, but... android would be much better for everyone but bad programmers if they followed Apple's lead on this.", "aSentId": 40347, "answer": "And also don't forget the fantastic battery life!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40348, "question": "And also don't forget the fantastic battery life!", "aSentId": 40349, "answer": "And my axe!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40346, "question": "And this is why the iPhone runs so well with half (or less) the memory of Android. It's also why you don't have OS-wide stutters.\n\nI know this is less of a thing with newer hardware, but... android would be much better for everyone but bad programmers if they followed Apple's lead on this.", "aSentId": 40351, "answer": "Then why does Windows phone do as well or better running on a .net subset?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40346, "question": "And this is why the iPhone runs so well with half (or less) the memory of Android. It's also why you don't have OS-wide stutters.\n\nI know this is less of a thing with newer hardware, but... android would be much better for everyone but bad programmers if they followed Apple's lead on this.", "aSentId": 40353, "answer": "&gt; And this is why the iPhone runs so well with half (or less) the memory of Android\n\nARC is slower than a good tracing GC. iPhones performance is more to do with less background tasks and less power to developers than anything else.\n\n&gt; android would be much better for everyone but bad programmers if they followed Apple's lead on this.\n\nNo, Apple would be better if they allowed developers more freedom on their devices. If they allowed chrome to actually have their own javascript engine, rather than relying on iPhones (and until recently, it was iPhone's very old pre-JIT engine).\n\nPhones in general need more mature tools and developers, and they should definitely not restrict what languages or tools can be used, as some language constructs would allow for amazing benefits on phones.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40354, "question": "&gt; And this is why the iPhone runs so well with half (or less) the memory of Android\n\nARC is slower than a good tracing GC. iPhones performance is more to do with less background tasks and less power to developers than anything else.\n\n&gt; android would be much better for everyone but bad programmers if they followed Apple's lead on this.\n\nNo, Apple would be better if they allowed developers more freedom on their devices. If they allowed chrome to actually have their own javascript engine, rather than relying on iPhones (and until recently, it was iPhone's very old pre-JIT engine).\n\nPhones in general need more mature tools and developers, and they should definitely not restrict what languages or tools can be used, as some language constructs would allow for amazing benefits on phones.", "aSentId": 40355, "answer": "&gt; ARC is slower than a good tracing GC.\n\nIt has lower theoretical throughput than a very advanced GC. It also doesn't require more than doubling the machine's RAM for the same logical load, and provides more time-sensitiveness guarantees (in terms both of code running and object deallocation) than the vast majority of GCs, without the complexity of advanced generational GCs.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40356, "question": "&gt; ARC is slower than a good tracing GC.\n\nIt has lower theoretical throughput than a very advanced GC. It also doesn't require more than doubling the machine's RAM for the same logical load, and provides more time-sensitiveness guarantees (in terms both of code running and object deallocation) than the vast majority of GCs, without the complexity of advanced generational GCs.", "aSentId": 40357, "answer": "&gt; provides more time-sensitiveness guarantees\n\nIt's unlikely to provide better guarantees. It may provide better expected behavior on many workloads, but ref counting can give you huge pauses when you deallocate, e.g., the root of a big tree.\n\nYou can trade this off by delaying deallocation - but then you run into the same deallocation delays that you'd have with a mark and sweep collector.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40358, "question": "&gt; provides more time-sensitiveness guarantees\n\nIt's unlikely to provide better guarantees. It may provide better expected behavior on many workloads, but ref counting can give you huge pauses when you deallocate, e.g., the root of a big tree.\n\nYou can trade this off by delaying deallocation - but then you run into the same deallocation delays that you'd have with a mark and sweep collector.", "aSentId": 40359, "answer": "&gt; It may provide better expected behavior on many workloads, but ref counting can give you huge pauses when you deallocate, e.g., the root of a big tree.\n\nEven manual allocation will do that. The difference is most GCs will also give huge pauses when not deallocating a significant amount of resources, because it's reached a collection threshold.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40360, "question": "&gt; It may provide better expected behavior on many workloads, but ref counting can give you huge pauses when you deallocate, e.g., the root of a big tree.\n\nEven manual allocation will do that. The difference is most GCs will also give huge pauses when not deallocating a significant amount of resources, because it's reached a collection threshold.", "aSentId": 40361, "answer": "On the other hand, a tracing GC an be designed to *never* have huge pauses by using an incremental strategy.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40362, "question": "On the other hand, a tracing GC an be designed to *never* have huge pauses by using an incremental strategy.", "aSentId": 40363, "answer": "That's a pretty completely feature for a very theoretical issue, I'm not sure even C4 bothers with that, they've already got their hands full designing a GC which never has huge pauses on actually reasonable allocation patterns.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40356, "question": "&gt; ARC is slower than a good tracing GC.\n\nIt has lower theoretical throughput than a very advanced GC. It also doesn't require more than doubling the machine's RAM for the same logical load, and provides more time-sensitiveness guarantees (in terms both of code running and object deallocation) than the vast majority of GCs, without the complexity of advanced generational GCs.", "aSentId": 40365, "answer": "The complexity of the GC is irrelevant unless you are the one programming the GC. Typically the more complex it is the less you have to worry about it, making it smarter is the whole reason for the complexity. \n\nThe time-sensitive guarantees are also irrelevant. Unless you are using a real-time operating system you can't make those guarantees anyway. And users won't notice GC pauses unless your GC is crap or you are doing something horribly wrong.\n\nBad programmers give GCs a bad reputation because you can still cause a program to bloat and become slow if you do a poor job managing references. It is actually doing a great job dealing with your mess. GC is just a scapegoat to bad programmers because it is where the problems with their design become most evident.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40366, "question": "The complexity of the GC is irrelevant unless you are the one programming the GC. Typically the more complex it is the less you have to worry about it, making it smarter is the whole reason for the complexity. \n\nThe time-sensitive guarantees are also irrelevant. Unless you are using a real-time operating system you can't make those guarantees anyway. And users won't notice GC pauses unless your GC is crap or you are doing something horribly wrong.\n\nBad programmers give GCs a bad reputation because you can still cause a program to bloat and become slow if you do a poor job managing references. It is actually doing a great job dealing with your mess. GC is just a scapegoat to bad programmers because it is where the problems with their design become most evident.", "aSentId": 40367, "answer": "&gt; The complexity of the GC is irrelevant unless you are the one programming the GC.\n\nThe complexity of the GC is very relevant to how advanced it will be, sucks up engineering resources and is a source of bugs.\n\n&gt; The time-sensitive guarantees are also irrelevant.\n\nTell that to game developers who have to work around garbage collectors, I'm sure they'll be glad to learn about GC pauses blowing their frames being irrelevant.\n\n&gt; And users won't notice GC pauses unless your GC is crap or you are doing something horribly wrong.\n\nGCs aren't magically \"not-crap\" just because you wish it. Google is only just getting their Android GC issues under control. Low-latency GCs (let alone pauseless) are much rarer and more difficult than high-throughput GCs, and lose much of a GC's throughput advantage, leaving pretty much only the convenience part.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40368, "question": "&gt; The complexity of the GC is irrelevant unless you are the one programming the GC.\n\nThe complexity of the GC is very relevant to how advanced it will be, sucks up engineering resources and is a source of bugs.\n\n&gt; The time-sensitive guarantees are also irrelevant.\n\nTell that to game developers who have to work around garbage collectors, I'm sure they'll be glad to learn about GC pauses blowing their frames being irrelevant.\n\n&gt; And users won't notice GC pauses unless your GC is crap or you are doing something horribly wrong.\n\nGCs aren't magically \"not-crap\" just because you wish it. Google is only just getting their Android GC issues under control. Low-latency GCs (let alone pauseless) are much rarer and more difficult than high-throughput GCs, and lose much of a GC's throughput advantage, leaving pretty much only the convenience part.", "aSentId": 40369, "answer": "&gt; Google is only just getting their Android GC issues under control.\n\nWhich were caused by political issues, not technical.\n\nIf they had just used/licensed a working GC instead of doing their usual NIH-at-Google dance, Android would wouldn't stand for \"slow, freezing, laggy UI\".", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40368, "question": "&gt; The complexity of the GC is irrelevant unless you are the one programming the GC.\n\nThe complexity of the GC is very relevant to how advanced it will be, sucks up engineering resources and is a source of bugs.\n\n&gt; The time-sensitive guarantees are also irrelevant.\n\nTell that to game developers who have to work around garbage collectors, I'm sure they'll be glad to learn about GC pauses blowing their frames being irrelevant.\n\n&gt; And users won't notice GC pauses unless your GC is crap or you are doing something horribly wrong.\n\nGCs aren't magically \"not-crap\" just because you wish it. Google is only just getting their Android GC issues under control. Low-latency GCs (let alone pauseless) are much rarer and more difficult than high-throughput GCs, and lose much of a GC's throughput advantage, leaving pretty much only the convenience part.", "aSentId": 40371, "answer": "It's funny that you should bring up gamedev; The recommendation from the bitsquid team was to have your game engine use manual allocation/deallocation, and to have scripting implemented in a garbage collected scripting language with spare milliseconds each frame allocated to incremental garbage collection. Of course, they didn't recommend garbage collection for the meat-and-bones of the engine, but they didn't recommend atomic reference counting, either, and I don't think I can come up with anyone who has. But if you can, that would be good support for your position.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40368, "question": "&gt; The complexity of the GC is irrelevant unless you are the one programming the GC.\n\nThe complexity of the GC is very relevant to how advanced it will be, sucks up engineering resources and is a source of bugs.\n\n&gt; The time-sensitive guarantees are also irrelevant.\n\nTell that to game developers who have to work around garbage collectors, I'm sure they'll be glad to learn about GC pauses blowing their frames being irrelevant.\n\n&gt; And users won't notice GC pauses unless your GC is crap or you are doing something horribly wrong.\n\nGCs aren't magically \"not-crap\" just because you wish it. Google is only just getting their Android GC issues under control. Low-latency GCs (let alone pauseless) are much rarer and more difficult than high-throughput GCs, and lose much of a GC's throughput advantage, leaving pretty much only the convenience part.", "aSentId": 40373, "answer": "&gt; Tell that to game developers who have to work around garbage collectors, I'm sure they'll be glad to learn about GC pauses blowing their frames being irrelevant.\n\nI'm not sure the entire toolkit should be designed around a specialist workflow with unusual demands.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40376, "question": "So you have experienced a GC bug? I somehow doubt it. Its equivalent to arguing that compilers should be simplistic because complicated compilers introduce bugs. They don't \"suck up engineering resources\". Experts designs the GC so most people don't have to spend resources on their own memory management scheme. It is a strictly more efficient use of engineering resources.\n\nAllocating and freeing memory causing pauses is a problem in games regardless of whether you use a GC. I have seen plenty of C++ games with WORSE pauses that last over a second because they were doing memory management operations. And almost all of them hang completely while they are loading levels. The only way to completely avoid pauses is to pre-allocate the memory you need which is what most games do. There is nothing stopping you from avoiding heap allocations while the game is running with a GC other than programmer laziness. Don't blame the GC because the programmers didn't put any thought into their design. Frankly, you have to do something brain-dead to have this problem like allocating objects in your render loop. And even then, unless you are keeping references to them around a good generational GC will have no problem collecting hundreds of megabytes of objects per second, without introducing pauses.\n\nIt doesn't matter how difficult the GC is to implement Google, Microsoft or whoever implements your language can throw resources at it so you don't have to.", "aSentId": 40377, "answer": "&gt; There is nothing stopping you from avoiding heap allocations while the game is running with a GC other than programmer laziness.\n\nThis is true. But in a GC collected language you are still getting all your threads halted for a non trivial period during a phase of the GC. There will be another thread running along with the context switches associated (and potentially priority inversions as a result).\n\nThere are no-pause GC's I'll admit, but all the free open run times suffer from this problem which is unacceptable in real time programs (games, audio, basically anything with user interaction shouldn't be GC'd).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40378, "question": "&gt; There is nothing stopping you from avoiding heap allocations while the game is running with a GC other than programmer laziness.\n\nThis is true. But in a GC collected language you are still getting all your threads halted for a non trivial period during a phase of the GC. There will be another thread running along with the context switches associated (and potentially priority inversions as a result).\n\nThere are no-pause GC's I'll admit, but all the free open run times suffer from this problem which is unacceptable in real time programs (games, audio, basically anything with user interaction shouldn't be GC'd).", "aSentId": 40379, "answer": "I just said non-GCed games suffer from the same problems and you bring up games again? If you don't allocate memory on the heap the garbage collector does absolutely nothing. There are no pauses whatsoever.\n\nOne extra thread that isn't doing any work isn't going to do anything to meaningfully hurt your performance. But you *can* substantially speed up loading times since allocating memory is cheaper with a GC.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40376, "question": "So you have experienced a GC bug? I somehow doubt it. Its equivalent to arguing that compilers should be simplistic because complicated compilers introduce bugs. They don't \"suck up engineering resources\". Experts designs the GC so most people don't have to spend resources on their own memory management scheme. It is a strictly more efficient use of engineering resources.\n\nAllocating and freeing memory causing pauses is a problem in games regardless of whether you use a GC. I have seen plenty of C++ games with WORSE pauses that last over a second because they were doing memory management operations. And almost all of them hang completely while they are loading levels. The only way to completely avoid pauses is to pre-allocate the memory you need which is what most games do. There is nothing stopping you from avoiding heap allocations while the game is running with a GC other than programmer laziness. Don't blame the GC because the programmers didn't put any thought into their design. Frankly, you have to do something brain-dead to have this problem like allocating objects in your render loop. And even then, unless you are keeping references to them around a good generational GC will have no problem collecting hundreds of megabytes of objects per second, without introducing pauses.\n\nIt doesn't matter how difficult the GC is to implement Google, Microsoft or whoever implements your language can throw resources at it so you don't have to.", "aSentId": 40381, "answer": "&gt; So you have experienced a GC bug? I somehow doubt it.\n\nI have. Several times, in two major browser engines, one of which is closed source. It's a god damn nightmare, especially in an embedded system.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40366, "question": "The complexity of the GC is irrelevant unless you are the one programming the GC. Typically the more complex it is the less you have to worry about it, making it smarter is the whole reason for the complexity. \n\nThe time-sensitive guarantees are also irrelevant. Unless you are using a real-time operating system you can't make those guarantees anyway. And users won't notice GC pauses unless your GC is crap or you are doing something horribly wrong.\n\nBad programmers give GCs a bad reputation because you can still cause a program to bloat and become slow if you do a poor job managing references. It is actually doing a great job dealing with your mess. GC is just a scapegoat to bad programmers because it is where the problems with their design become most evident.", "aSentId": 40383, "answer": "There is a very large market for time-sensitive guarantees, namely video games. If you can't deliver on 60fps or 30fps, the user will notice, without a doubt.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40384, "question": "There is a very large market for time-sensitive guarantees, namely video games. If you can't deliver on 60fps or 30fps, the user will notice, without a doubt.", "aSentId": 40385, "answer": "You cannot make time sensitive guarantees without a real-time operating system. Since games run on general purpose operating systems this isn't relevant.\n\nYou could claim that it is harder to make a mistake with your code that causes you to drop a frame without a GC. There are no guarantees though.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40384, "question": "There is a very large market for time-sensitive guarantees, namely video games. If you can't deliver on 60fps or 30fps, the user will notice, without a doubt.", "aSentId": 40387, "answer": "An occasional GC pause is not going to halve your frame rate. Incremental GC might, if it's happening on every frame, but a full GC pass won't, precisely because it *doesn't* happen on every frame.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40356, "question": "&gt; ARC is slower than a good tracing GC.\n\nIt has lower theoretical throughput than a very advanced GC. It also doesn't require more than doubling the machine's RAM for the same logical load, and provides more time-sensitiveness guarantees (in terms both of code running and object deallocation) than the vast majority of GCs, without the complexity of advanced generational GCs.", "aSentId": 40389, "answer": "ARC is a GC, I wanna be clear on that first. In fact it's the GC that powers default PHP.\n\nThe ability of reference counting to more likely reclaim something immediately after being used is one of the strong points true. It's why languages have started looking at things like unique pointers (it's currently on the table for C# 7). ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40390, "question": "ARC is a GC, I wanna be clear on that first. In fact it's the GC that powers default PHP.\n\nThe ability of reference counting to more likely reclaim something immediately after being used is one of the strong points true. It's why languages have started looking at things like unique pointers (it's currently on the table for C# 7). ", "aSentId": 40391, "answer": "&gt; ARC is a GC, I wanna be clear on that first. In fact it's the GC that powers default PHP.\n\nNo. In PHP, the refcounting is performed by the language runtime with no awareness (or care for) user code. ARC is the compiler statically injecting explicit refcount operations in the userland code (before the optimisation passes). Just because they both count references does not mean they're the same. Neither is `shared_ptr`, even though it also is a refcounting scheme.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40392, "question": "&gt; ARC is a GC, I wanna be clear on that first. In fact it's the GC that powers default PHP.\n\nNo. In PHP, the refcounting is performed by the language runtime with no awareness (or care for) user code. ARC is the compiler statically injecting explicit refcount operations in the userland code (before the optimisation passes). Just because they both count references does not mean they're the same. Neither is `shared_ptr`, even though it also is a refcounting scheme.", "aSentId": 40393, "answer": "So if someone made a PHP compiler that inserted `retain/relase` calls rather than requring a different runtime, that'd no longer be GC somehow?\n\nGarbage collection is simply a system that attempts to reclaim garbage generated by a program. Whether the GC is part of a special runtime, or inserted by the compiler doesn't changge that.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40354, "question": "&gt; And this is why the iPhone runs so well with half (or less) the memory of Android\n\nARC is slower than a good tracing GC. iPhones performance is more to do with less background tasks and less power to developers than anything else.\n\n&gt; android would be much better for everyone but bad programmers if they followed Apple's lead on this.\n\nNo, Apple would be better if they allowed developers more freedom on their devices. If they allowed chrome to actually have their own javascript engine, rather than relying on iPhones (and until recently, it was iPhone's very old pre-JIT engine).\n\nPhones in general need more mature tools and developers, and they should definitely not restrict what languages or tools can be used, as some language constructs would allow for amazing benefits on phones.", "aSentId": 40395, "answer": "[GC is very memory intensive](http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-10.15.29-PM.png). The chart is showing memory footpring relative to performance. The huge downward slope is the speedup you get with more memory. Basically a GCed program require 6X the minimum amount of memory to get fast performance. Here's an [excellent writeup](http://sealedabstract.com/rants/why-mobile-web-apps-are-slow/) on language performance on mobile devices with a keen eye to garbage collection vs ARC.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40396, "question": "[GC is very memory intensive](http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-10.15.29-PM.png). The chart is showing memory footpring relative to performance. The huge downward slope is the speedup you get with more memory. Basically a GCed program require 6X the minimum amount of memory to get fast performance. Here's an [excellent writeup](http://sealedabstract.com/rants/why-mobile-web-apps-are-slow/) on language performance on mobile devices with a keen eye to garbage collection vs ARC.", "aSentId": 40397, "answer": "GC seems like one of those computer science ideas that in theory could be great. In practice .Net and Java applications which use it are notorious for having honking great pauses. \n\nNow I don't see 'em with Lollipop but that's probably because Android apps tend to have a small memory footprint, Google employ some very smart people and you can buy very fast phones with lots of SDRAM.\n\nEdit: \n\n&gt; Here's an excellent writeup on language performance on mobile devices with a keen eye to garbage collection vs ARC.\n\nThat is indeed an excellent article.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40398, "question": "GC seems like one of those computer science ideas that in theory could be great. In practice .Net and Java applications which use it are notorious for having honking great pauses. \n\nNow I don't see 'em with Lollipop but that's probably because Android apps tend to have a small memory footprint, Google employ some very smart people and you can buy very fast phones with lots of SDRAM.\n\nEdit: \n\n&gt; Here's an excellent writeup on language performance on mobile devices with a keen eye to garbage collection vs ARC.\n\nThat is indeed an excellent article.", "aSentId": 40399, "answer": "I do pretty performance intensive .NET code and the only real GC issues we usually encounter are memory leaks and its because we usually did something stupid somewhere. Bad code creating objects that either don't get fully dereferenced, are not really needed, or end up spitting out large collections that end up on the large object heap. The GC really isn't the problem...its us coding stupidly. \n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40400, "question": "I do pretty performance intensive .NET code and the only real GC issues we usually encounter are memory leaks and its because we usually did something stupid somewhere. Bad code creating objects that either don't get fully dereferenced, are not really needed, or end up spitting out large collections that end up on the large object heap. The GC really isn't the problem...its us coding stupidly. \n\n", "aSentId": 40401, "answer": "Wait, isn't the reason people want to use garbage collectors over manual memory management to avoid memory leaks? There are no issues with manual memory management either if you don't code stupidly.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40402, "question": "Wait, isn't the reason people want to use garbage collectors over manual memory management to avoid memory leaks? There are no issues with manual memory management either if you don't code stupidly.", "aSentId": 40403, "answer": "Its a lot easier to create a memory leak in an unmanaged language than a managed one. My environment is pretty extreme where I currently work. We run into problems (like this) that I'm sure the majority of developers would never encounter. People that write the same scale Java stuff encounter the same stuff we encounter I'm sure. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40398, "question": "GC seems like one of those computer science ideas that in theory could be great. In practice .Net and Java applications which use it are notorious for having honking great pauses. \n\nNow I don't see 'em with Lollipop but that's probably because Android apps tend to have a small memory footprint, Google employ some very smart people and you can buy very fast phones with lots of SDRAM.\n\nEdit: \n\n&gt; Here's an excellent writeup on language performance on mobile devices with a keen eye to garbage collection vs ARC.\n\nThat is indeed an excellent article.", "aSentId": 40405, "answer": "Lollipop made a significant overhaul of the Java runtime and in particular the GC. The Dalvik (JIT compiled) engine was completely replaced with ART (AOT compiled).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40398, "question": "GC seems like one of those computer science ideas that in theory could be great. In practice .Net and Java applications which use it are notorious for having honking great pauses. \n\nNow I don't see 'em with Lollipop but that's probably because Android apps tend to have a small memory footprint, Google employ some very smart people and you can buy very fast phones with lots of SDRAM.\n\nEdit: \n\n&gt; Here's an excellent writeup on language performance on mobile devices with a keen eye to garbage collection vs ARC.\n\nThat is indeed an excellent article.", "aSentId": 40407, "answer": "&gt;In practice .Net and Java applications which use it are notorious for having honking great pauses.\n\n\u2026among people who think it's still 1997.\n\nI use Java development tools every day, including two big, heavy IDEs. They do *not* have \u201chonking great pauses\u201d. That is *bullshit.* Stop repeating it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40408, "question": "&gt;In practice .Net and Java applications which use it are notorious for having honking great pauses.\n\n\u2026among people who think it's still 1997.\n\nI use Java development tools every day, including two big, heavy IDEs. They do *not* have \u201chonking great pauses\u201d. That is *bullshit.* Stop repeating it.", "aSentId": 40409, "answer": "I notice pauses in Android Studio all the time. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40354, "question": "&gt; And this is why the iPhone runs so well with half (or less) the memory of Android\n\nARC is slower than a good tracing GC. iPhones performance is more to do with less background tasks and less power to developers than anything else.\n\n&gt; android would be much better for everyone but bad programmers if they followed Apple's lead on this.\n\nNo, Apple would be better if they allowed developers more freedom on their devices. If they allowed chrome to actually have their own javascript engine, rather than relying on iPhones (and until recently, it was iPhone's very old pre-JIT engine).\n\nPhones in general need more mature tools and developers, and they should definitely not restrict what languages or tools can be used, as some language constructs would allow for amazing benefits on phones.", "aSentId": 40412, "answer": "While I agree with you about Chrome, it is completely irrelevant to the topic at hand.  I also suspect the parent was talking about Android hypothetically attempting to move to ARC in general, rather than about this particular strict prohibition.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40413, "question": "While I agree with you about Chrome, it is completely irrelevant to the topic at hand.  I also suspect the parent was talking about Android hypothetically attempting to move to ARC in general, rather than about this particular strict prohibition.", "aSentId": 40414, "answer": "GP was talking about Android's GC and its historical issues with stuttering and GC pauses (colloquially called \"jank\" in the android community), as well as the increased memory requirements inherent to using a GC wrt more deterministic schemes.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40415, "question": "GP was talking about Android's GC and its historical issues with stuttering and GC pauses (colloquially called \"jank\" in the android community), as well as the increased memory requirements inherent to using a GC wrt more deterministic schemes.\n", "aSentId": 40416, "answer": "Right, which is why I was saying that the particular issue of the platform vendor forcing apps to migrate to the new thing is fairly irrelevant.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40413, "question": "While I agree with you about Chrome, it is completely irrelevant to the topic at hand.  I also suspect the parent was talking about Android hypothetically attempting to move to ARC in general, rather than about this particular strict prohibition.", "aSentId": 40418, "answer": "&gt;  Android hypothetically attempting to move to ARC in general\n\nARC done correctly should be transparent to the programmer. Most PHP programmers are unaware of the fact that it uses reference counting. So it could easily be made at a VM level without the programmer having to even do anything to their code.\n\nThe problem would be it'd slow down performance. reference counting is slower than a good garbage collector, the benefit being immediate destruction and no pausing. But the pausing should only be noticed in games, and the immediate destruction is only useful if the programmer knows and is guaranteed that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40419, "question": "&gt;  Android hypothetically attempting to move to ARC in general\n\nARC done correctly should be transparent to the programmer. Most PHP programmers are unaware of the fact that it uses reference counting. So it could easily be made at a VM level without the programmer having to even do anything to their code.\n\nThe problem would be it'd slow down performance. reference counting is slower than a good garbage collector, the benefit being immediate destruction and no pausing. But the pausing should only be noticed in games, and the immediate destruction is only useful if the programmer knows and is guaranteed that.", "aSentId": 40420, "answer": "Not quite.  Like many interpreters, PHP uses a mix of reference counting and a cycle collector; the cycle collector will cause pauses like any GC, although since most PHP scripts only run for a short time (something inapplicable to smartphone apps), it will usually never get run.  ARC is pure reference counting, so cycles will not be collected unless you mark one of the references weak.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40421, "question": "Not quite.  Like many interpreters, PHP uses a mix of reference counting and a cycle collector; the cycle collector will cause pauses like any GC, although since most PHP scripts only run for a short time (something inapplicable to smartphone apps), it will usually never get run.  ARC is pure reference counting, so cycles will not be collected unless you mark one of the references weak.\n", "aSentId": 40422, "answer": "PHP pre 5.3 did not collect cycles, it's only recently they added that (rather than just leaking memory).\n\nThe pausing that the cycle collector has could easily exist in reference counting as well. Linked lists and trees cause reference counters to pause to collect them. If you were to write a compiler, ARC would get you awful performance as well as pauses (especially if you used immutable trees, which allow things like the compiler existing as an API and incremental parsing). Tracing garbage collection on the other hand would simply get you the pausing, and perhaps not that much (for tracers you pay for live memory, for reference counting you pay for all memory used).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40424, "question": "&gt;Phones in general need more mature tools and developers, and they should definitely not restrict what languages or tools can be used, as some language constructs would allow for amazing benefits on phones.\n\nGood thing iOS doesn't restrict the languages you can use. ", "aSentId": 40425, "answer": "It'd be impossible for them to do so anyway, due to the large number of LLVM front-ends. I think people just got confused by Apple's hatred of Adobe Flash and AIR.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40424, "question": "&gt;Phones in general need more mature tools and developers, and they should definitely not restrict what languages or tools can be used, as some language constructs would allow for amazing benefits on phones.\n\nGood thing iOS doesn't restrict the languages you can use. ", "aSentId": 40427, "answer": "&gt; Good thing iOS doesn't restrict the languages you can use.\n\nThey used to restrict you from running non-compiled languages (which was why xamarin had to pre-compile the code). I hear they've changed this recently to only running code that was all packaged in the app, which is less restricting, but still fairly restricting.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40428, "question": "&gt; Good thing iOS doesn't restrict the languages you can use.\n\nThey used to restrict you from running non-compiled languages (which was why xamarin had to pre-compile the code). I hear they've changed this recently to only running code that was all packaged in the app, which is less restricting, but still fairly restricting.", "aSentId": 40429, "answer": "That's not very restricting. Desktop and phone apps usually have to be self-contained anyway, since there usually isn't any package manager to fetch dependencies with. (Linux desktops are the obvious exception.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40430, "question": "That's not very restricting. Desktop and phone apps usually have to be self-contained anyway, since there usually isn't any package manager to fetch dependencies with. (Linux desktops are the obvious exception.)", "aSentId": 40431, "answer": "Browsers are completely restricted by it (you can't write your own, you can only put UI on the default), games can't have any sort of modding system, or even an in-game way to download DLC (if the DLC would contain new code, it must be pre-packaged with the app, and then enabled, meaning every single user pays for the space requirements of all the code for all DLC).\n\nMaybe it's not the case in the land of objective-c, but in C#/.NET there are programs that rely on code generation for performance. Serialization being a big one (it uses reflection to look at the object and build a function that serializes it, the cost of reflection is used only once per object). Templates are another huge area. Templates are usually compiled to a function that is passed the relevant object or parameters, and generates the result. You can of course pre-compile them, but that means the app would need to be updated every single time a template changes, even for very minor changes.\n\nEven having a in-program database requires interpreting a query language. These queries can often times be built up from user driven actions, but you can't do it with this restriction. (e.g. user could choose to view only pg13 content, you might conditionally add a where clause to your database query). With this restriction all such queries must either be pre-compiled (giving you quite a lot of queries) or run outside of the query language (giving you worse performance).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40436, "question": "Galaxy Note 2 here. What OS-wide stutters? My phone works quite well, thank you *very* much.", "aSentId": 40437, "answer": "Please. I'm surrounded by people with upper-end Androids, and whenever we put our phones next to each other the difference vs. the buttery smoothness of an iPhone is undeniable.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40438, "question": "Please. I'm surrounded by people with upper-end Androids, and whenever we put our phones next to each other the difference vs. the buttery smoothness of an iPhone is undeniable.", "aSentId": 40439, "answer": "Good for you. I prefer to *use* my phone, not stare at its animations. At no point has GC (or any other performance issue) impaired the usability of my phone.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40440, "question": "Good for you. I prefer to *use* my phone, not stare at its animations. At no point has GC (or any other performance issue) impaired the usability of my phone.", "aSentId": 40441, "answer": "&gt; I prefer to use my phone, not stare at its animations.\n\nI prefer my ~~phone~~ software to use its hardware as efficiently as possible :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40442, "question": "&gt; I prefer to use my phone, not stare at its animations.\n\nI prefer my ~~phone~~ software to use its hardware as efficiently as possible :)", "aSentId": 40443, "answer": "Well, you won't find that on any Apple device. \u201cAs efficiently as possible\u201d means everything is written in hand-optimized assembly by humanity's best programmers. It definitely doesn't mean Objective-C and ARC, which has overhead of its own.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40444, "question": "Well, you won't find that on any Apple device. \u201cAs efficiently as possible\u201d means everything is written in hand-optimized assembly by humanity's best programmers. It definitely doesn't mean Objective-C and ARC, which has overhead of its own.", "aSentId": 40445, "answer": "Are we really comparing a C-based ObjC with ARC to Java and GC? Really?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40446, "question": "Are we really comparing a C-based ObjC with ARC to Java and GC? Really?", "aSentId": 40447, "answer": "They are the standard application programming languages for iOS and Android, respectively. iOS and Android are directly-competing smartphone and tablet operating systems. The relative performance of these operating systems (and the devices that run them) is the subject of the discussion at hand.\n\nSo, yes, of course we are. Why wouldn't we?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40436, "question": "Galaxy Note 2 here. What OS-wide stutters? My phone works quite well, thank you *very* much.", "aSentId": 40449, "answer": "I don't know why you're being downvoted for speaking the truth. Lots of apple fanboys in here I guess. \n\nAnyone that's used an Android released in the last three or so years would roll there eyes to the assertion that there are os-wide stutters. I haven't noticed any on my old note 2 or my current note 3.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40451, "question": "Yes, it's *that one thing* and not the fact that Android is running a server OS in your pocket... :P\n\n(Full disclosure: you can have my Nexus 6 when you pry it from my cold dead hands.)", "aSentId": 40452, "answer": "I have no idea what you're getting at. \n\nIf you're saying because it has a Unix underpinning that's bad because it wasn't designed for mobile, something else would be better? A Windows kernel? Some custom fuck-it-we-have-to-reinvent-the-wheel-again kernel?\n\nUnix subsystems are very lightweight. Their architectures are simplistic. I can't see how using this as the basis of your os would be terrible. \n\nAt least it isn't running Xorg. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40453, "question": "I have no idea what you're getting at. \n\nIf you're saying because it has a Unix underpinning that's bad because it wasn't designed for mobile, something else would be better? A Windows kernel? Some custom fuck-it-we-have-to-reinvent-the-wheel-again kernel?\n\nUnix subsystems are very lightweight. Their architectures are simplistic. I can't see how using this as the basis of your os would be terrible. \n\nAt least it isn't running Xorg. ", "aSentId": 40454, "answer": "&gt; I have no idea what you're getting at.\n\nEspecially since iOS is Darwin-based and thus at least as unixy as Android.\n\nIt's amazing, really. You would have had a hard time convincing me that Unix and workalikes would be the dominant operating system across almost every class of device in 2015 back in 2000-2005, when a big part of my work was the (to me) sad task of migrating shops from fancy, interesting and expensive Unix hardware to commodity Windows boxes.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40455, "question": "&gt; I have no idea what you're getting at.\n\nEspecially since iOS is Darwin-based and thus at least as unixy as Android.\n\nIt's amazing, really. You would have had a hard time convincing me that Unix and workalikes would be the dominant operating system across almost every class of device in 2015 back in 2000-2005, when a big part of my work was the (to me) sad task of migrating shops from fancy, interesting and expensive Unix hardware to commodity Windows boxes.", "aSentId": 40456, "answer": "Did not know that! That is interesting.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40459, "question": "I hope that this notice is only in reference to their own crappy implementation of GC, and not GC in general (especially with other languages. Apple seems to forget that languages besides objective-C exist). Otherwise performance is going to suffer since ARC isn't even a very good implementation of GC (yes automatic reference counting is garbage collection, it's just not a *tracing* garbage collector, apple is confused about the terms). It's been shown time and time again that reference counters are usually outperformed by tracing collectors, with the downside of having pauses.", "aSentId": 40460, "answer": "The notice is (quite obviously) specifically for Objective-C's garbage-collected mode.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40463, "question": "This seems pretty bizzare to me. That makes this Apple's decision to make?", "aSentId": 40464, "answer": "On the surface the answer is an obvious yes: if you want to sell apps through Apple store then you need to follow the rules.\n\nFor Mac developers that don't sell through the App Store this is a pretty clear sign that support for GC, which was deprecated in OS X Mountain Lion in 2012, is likely to be removed entirely in the next version of OS X, and if they don't get off that horse now they're going to have trouble compiling their apps next year.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40465, "question": "On the surface the answer is an obvious yes: if you want to sell apps through Apple store then you need to follow the rules.\n\nFor Mac developers that don't sell through the App Store this is a pretty clear sign that support for GC, which was deprecated in OS X Mountain Lion in 2012, is likely to be removed entirely in the next version of OS X, and if they don't get off that horse now they're going to have trouble compiling their apps next year.", "aSentId": 40466, "answer": "You already can't compile apps with GC enabled without using a significantly out of date version of Xcode. The thing that will probably change soon is that the apps won't even run on newer versions of OS X.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40463, "question": "This seems pretty bizzare to me. That makes this Apple's decision to make?", "aSentId": 40468, "answer": "&gt; Apps submitted to the Mac app store", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40463, "question": "This seems pretty bizzare to me. That makes this Apple's decision to make?", "aSentId": 40470, "answer": "It's \"their\" compiler and their App Store. Which part isn't their decision? You're of course welcome to use some other language or distribute your app online.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40472, "question": "now if apple made a libc that didn't have functions which shell out to perl .. :D", "aSentId": 40473, "answer": "They already did. The libc in Yosemite doesn't shell out to perl :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40474, "question": "They already did. The libc in Yosemite doesn't shell out to perl :)", "aSentId": 40475, "answer": "LOL baby steps are good :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40478, "question": "Rethinking API Design with Traits", "aSentId": 40479, "answer": "Sanity Warning: Veeeeery thick french accent.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40480, "question": "Sanity Warning: Veeeeery thick french accent.", "aSentId": 40481, "answer": "I can get past an accent pretty easily, but the flow of his presentation is super off. I found myself just clicking through and reading the bullet points rather than hear him ramble.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40485, "question": "Java Makes Programmers Want To Do Absolutely Anything Else With Their Time", "aSentId": 40486, "answer": "What's the deal with these linkbait articles that just lift a question/answer from somewhere else?  I've seen them in Ars Technica, now it's in Forbes...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40487, "question": "What's the deal with these linkbait articles that just lift a question/answer from somewhere else?  I've seen them in Ars Technica, now it's in Forbes...", "aSentId": 40488, "answer": "I think someone figured out a % of their viewer base are programmers,  probably a tactic to drive traffic to the site.  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40489, "question": "I think someone figured out a % of their viewer base are programmers,  probably a tactic to drive traffic to the site.  ", "aSentId": 40490, "answer": "Or the intersection of \"occupations most likely browsing the internet\" and \"occupations with middle to upper class socioeconomic status\" is a viable demographic to target.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40487, "question": "What's the deal with these linkbait articles that just lift a question/answer from somewhere else?  I've seen them in Ars Technica, now it's in Forbes...", "aSentId": 40492, "answer": "Same reason journalists lift wholesale from press releases. They've got a quota to fill and it gets an article out the door in the least amount of time.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40487, "question": "What's the deal with these linkbait articles that just lift a question/answer from somewhere else?  I've seen them in Ars Technica, now it's in Forbes...", "aSentId": 40494, "answer": "Ars Technica ones are definitely not clickbait. I mean they don't have the absurd title this one has.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40485, "question": "Java Makes Programmers Want To Do Absolutely Anything Else With Their Time", "aSentId": 40496, "answer": "I feel that the learning curve for making a solid real-world Java application or library is quite steep.\n\nImagine a newbie learning Java for the first time: Within minutes he has created his \"Hello World\" command-line program. But in the real world, everything has to be a dynamic web application so he dives into Java EE. Hmm, I need to host my app in a container, huh? Okay, I'll install Glassfish/Wildfly. Hmm, I need to output some JSON, but the default javax-libraries suck at this, let's see what's out there, GSON that looks okay, let's download it and put it in my lib folder....\n\nThe next day, a new version of GSON is released, so our newbie thinks \"hmm, this is not a very effective way to manage my dependencies, there must be something to make this easier... oh, Maven, let's check it out!\"\n\nAbout a month later our newbie finally understands that group is mostly just a fancy name for project name and artifact is a fancy name for a library or application created within the project.\n\nNow that his application is evolving he starts to think about testing, hmm, JUnit, let's add that and do some unit testing. Oh, but how do I unit test my spaghetti? Every object I create, creates many other objects. Can I just pretend that I have an object without triggering my entire application code? Enter Mockito. Oh and add Arquillian to make it more complex.\n\nFinally, he has a Java EE app with dependency management, unit testing and mocking and btw he added it to source control. He chose Git because it seemed cooler than SVN.\n\nBut he's tired of doing everything manually and googles for \"automatic building\" and stumbles upon tools like Jenkins.\n\nAbout half a year later, he feels he's finally comfortable of being in the real-world Java environment where there is a lot of stuff that isn't actually Java.\n\nI don't know whether C# has the same problems or whether it provides a more complete ecosystem out of the box, but the hard part about Java is not the code itself, it's learning the ecosystem.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40497, "question": "I feel that the learning curve for making a solid real-world Java application or library is quite steep.\n\nImagine a newbie learning Java for the first time: Within minutes he has created his \"Hello World\" command-line program. But in the real world, everything has to be a dynamic web application so he dives into Java EE. Hmm, I need to host my app in a container, huh? Okay, I'll install Glassfish/Wildfly. Hmm, I need to output some JSON, but the default javax-libraries suck at this, let's see what's out there, GSON that looks okay, let's download it and put it in my lib folder....\n\nThe next day, a new version of GSON is released, so our newbie thinks \"hmm, this is not a very effective way to manage my dependencies, there must be something to make this easier... oh, Maven, let's check it out!\"\n\nAbout a month later our newbie finally understands that group is mostly just a fancy name for project name and artifact is a fancy name for a library or application created within the project.\n\nNow that his application is evolving he starts to think about testing, hmm, JUnit, let's add that and do some unit testing. Oh, but how do I unit test my spaghetti? Every object I create, creates many other objects. Can I just pretend that I have an object without triggering my entire application code? Enter Mockito. Oh and add Arquillian to make it more complex.\n\nFinally, he has a Java EE app with dependency management, unit testing and mocking and btw he added it to source control. He chose Git because it seemed cooler than SVN.\n\nBut he's tired of doing everything manually and googles for \"automatic building\" and stumbles upon tools like Jenkins.\n\nAbout half a year later, he feels he's finally comfortable of being in the real-world Java environment where there is a lot of stuff that isn't actually Java.\n\nI don't know whether C# has the same problems or whether it provides a more complete ecosystem out of the box, but the hard part about Java is not the code itself, it's learning the ecosystem.", "aSentId": 40498, "answer": "What do blondes and spaghetti have in common? They both wiggle when you eat them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40499, "question": "What do blondes and spaghetti have in common? They both wiggle when you eat them.", "aSentId": 40500, "answer": "How would Hannibal Lecter interpret this joke?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40501, "question": "How would Hannibal Lecter interpret this joke?", "aSentId": 40502, "answer": "Chatting with a robot that eats people... I think it replies to all comments with spaghetti in them. Maybe once per thread, so it doesn't over saturate and get banned.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40501, "question": "How would Hannibal Lecter interpret this joke?", "aSentId": 40504, "answer": "&gt; How would Hannibal Lecter interpret this joke?\n\nLiterally.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40497, "question": "I feel that the learning curve for making a solid real-world Java application or library is quite steep.\n\nImagine a newbie learning Java for the first time: Within minutes he has created his \"Hello World\" command-line program. But in the real world, everything has to be a dynamic web application so he dives into Java EE. Hmm, I need to host my app in a container, huh? Okay, I'll install Glassfish/Wildfly. Hmm, I need to output some JSON, but the default javax-libraries suck at this, let's see what's out there, GSON that looks okay, let's download it and put it in my lib folder....\n\nThe next day, a new version of GSON is released, so our newbie thinks \"hmm, this is not a very effective way to manage my dependencies, there must be something to make this easier... oh, Maven, let's check it out!\"\n\nAbout a month later our newbie finally understands that group is mostly just a fancy name for project name and artifact is a fancy name for a library or application created within the project.\n\nNow that his application is evolving he starts to think about testing, hmm, JUnit, let's add that and do some unit testing. Oh, but how do I unit test my spaghetti? Every object I create, creates many other objects. Can I just pretend that I have an object without triggering my entire application code? Enter Mockito. Oh and add Arquillian to make it more complex.\n\nFinally, he has a Java EE app with dependency management, unit testing and mocking and btw he added it to source control. He chose Git because it seemed cooler than SVN.\n\nBut he's tired of doing everything manually and googles for \"automatic building\" and stumbles upon tools like Jenkins.\n\nAbout half a year later, he feels he's finally comfortable of being in the real-world Java environment where there is a lot of stuff that isn't actually Java.\n\nI don't know whether C# has the same problems or whether it provides a more complete ecosystem out of the box, but the hard part about Java is not the code itself, it's learning the ecosystem.", "aSentId": 40506, "answer": "Part of the what makes C#/.NET an easier platform to get up and running with is that a lot of what you need is provided right out of the box.  And for what's not, there's *one* accepted solution.\n\nYou don't have the situation like you do with Java where there are ten different application servers that all ostensibly implement the standard servlet API (yet all do it in subtly incompatible ways so that effectively you end up with an application that's tied to one server in particular).  With .NET, for better or for worse, you have *one* application server: IIS/ASP.NET.\n\nYou have *one* ORM: the Entity Framework.\n\nYou have *one* project build script format: MSBuild.\n\nYou have *one* unit testing framework: MSUnit.\n\nYou have *one* application architecture: ASP.NET MVC.  And maybe some legacy Web Forms / ASMX / WCF.\n\nThough there are still holdouts for some of the older frameworks, they're becoming a dying breed because Microsoft has done such a good job of making the out-of-the-box solutions really good and well-supported.  (Entity Framework in particular used to *suck*.)\n\nProbably the biggest challenge .NET is going to face as it expands to new platforms with .NET Core is preventing the ecosystem from exploding into the giant incompatible mess Java has.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40507, "question": "Part of the what makes C#/.NET an easier platform to get up and running with is that a lot of what you need is provided right out of the box.  And for what's not, there's *one* accepted solution.\n\nYou don't have the situation like you do with Java where there are ten different application servers that all ostensibly implement the standard servlet API (yet all do it in subtly incompatible ways so that effectively you end up with an application that's tied to one server in particular).  With .NET, for better or for worse, you have *one* application server: IIS/ASP.NET.\n\nYou have *one* ORM: the Entity Framework.\n\nYou have *one* project build script format: MSBuild.\n\nYou have *one* unit testing framework: MSUnit.\n\nYou have *one* application architecture: ASP.NET MVC.  And maybe some legacy Web Forms / ASMX / WCF.\n\nThough there are still holdouts for some of the older frameworks, they're becoming a dying breed because Microsoft has done such a good job of making the out-of-the-box solutions really good and well-supported.  (Entity Framework in particular used to *suck*.)\n\nProbably the biggest challenge .NET is going to face as it expands to new platforms with .NET Core is preventing the ecosystem from exploding into the giant incompatible mess Java has.", "aSentId": 40508, "answer": "Those examples are all things that are largely created by, or endorsed by Microsoft. What's the situation for things that Microsoft hasn't weighed in on?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40497, "question": "I feel that the learning curve for making a solid real-world Java application or library is quite steep.\n\nImagine a newbie learning Java for the first time: Within minutes he has created his \"Hello World\" command-line program. But in the real world, everything has to be a dynamic web application so he dives into Java EE. Hmm, I need to host my app in a container, huh? Okay, I'll install Glassfish/Wildfly. Hmm, I need to output some JSON, but the default javax-libraries suck at this, let's see what's out there, GSON that looks okay, let's download it and put it in my lib folder....\n\nThe next day, a new version of GSON is released, so our newbie thinks \"hmm, this is not a very effective way to manage my dependencies, there must be something to make this easier... oh, Maven, let's check it out!\"\n\nAbout a month later our newbie finally understands that group is mostly just a fancy name for project name and artifact is a fancy name for a library or application created within the project.\n\nNow that his application is evolving he starts to think about testing, hmm, JUnit, let's add that and do some unit testing. Oh, but how do I unit test my spaghetti? Every object I create, creates many other objects. Can I just pretend that I have an object without triggering my entire application code? Enter Mockito. Oh and add Arquillian to make it more complex.\n\nFinally, he has a Java EE app with dependency management, unit testing and mocking and btw he added it to source control. He chose Git because it seemed cooler than SVN.\n\nBut he's tired of doing everything manually and googles for \"automatic building\" and stumbles upon tools like Jenkins.\n\nAbout half a year later, he feels he's finally comfortable of being in the real-world Java environment where there is a lot of stuff that isn't actually Java.\n\nI don't know whether C# has the same problems or whether it provides a more complete ecosystem out of the box, but the hard part about Java is not the code itself, it's learning the ecosystem.", "aSentId": 40510, "answer": "I fully agree with this. The thing that makes Java bad is that it's old, and just keeps accumulating \"things\" that you need to know to be good at it. The amount of mental baggage that a developer needs to juggle distracts them from their focus on writing concise programs.\n\nI remember working with some developers a while back that were relatively new to Java, and being frustrated because they weren't using some widely adopted packages and practices that make Java friendlier. Then I thought to myself, \"Why isn't this built into the language?\". The problem isn't Java itself; its that Java + \"everything else\" is too much to expect from an average developer.\n\nThat's what I like about Go. Sure, I can accomplish the same exact things in Java, but I have to add dependency x, process y, etc to get the same thing as the builtin features of Go. There's less to juggle in my brain. Will Go become bloated? Probably. Old languages always find a way. But I'm enjoying it in the meantime.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40511, "question": "I fully agree with this. The thing that makes Java bad is that it's old, and just keeps accumulating \"things\" that you need to know to be good at it. The amount of mental baggage that a developer needs to juggle distracts them from their focus on writing concise programs.\n\nI remember working with some developers a while back that were relatively new to Java, and being frustrated because they weren't using some widely adopted packages and practices that make Java friendlier. Then I thought to myself, \"Why isn't this built into the language?\". The problem isn't Java itself; its that Java + \"everything else\" is too much to expect from an average developer.\n\nThat's what I like about Go. Sure, I can accomplish the same exact things in Java, but I have to add dependency x, process y, etc to get the same thing as the builtin features of Go. There's less to juggle in my brain. Will Go become bloated? Probably. Old languages always find a way. But I'm enjoying it in the meantime.", "aSentId": 40512, "answer": "Even if there's a \"default single-provider implementation\" for each thing (continuous integration, dependencies, cross-platform serialization, unit-test harnesses) you still have to learn to use it, and that's still a distraction from \"writing concise programs\".", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40513, "question": "Even if there's a \"default single-provider implementation\" for each thing (continuous integration, dependencies, cross-platform serialization, unit-test harnesses) you still have to learn to use it, and that's still a distraction from \"writing concise programs\".", "aSentId": 40514, "answer": "It's not a provider - it's in the language runtime. Yes, of course you have to learn it, but the amount of mental overhead involved is far lower.\n\n* http://attilaolah.eu/2013/11/29/json-decoding-in-go/\n* http://golang.org/pkg/testing/\n\nI remember when Java first hit the scene - it was popular because the java.sql package was in the JDK itself and not some bolted-on thing. Same with collections. People loved that. Maybe you were around to remember this? It's a similar thing with Go.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40485, "question": "Java Makes Programmers Want To Do Absolutely Anything Else With Their Time", "aSentId": 40518, "answer": "I have no love for java.\n\n&gt;While it performs pretty well nowadays, it still isn\u2019t competitive with C or C++ and, with a little love, Haskell and OCaml can or will eclipse it in that domain.\n\nI didn't think this was true, i thought it was somewhat close to C (excluding startup). \n\n&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nThis is really seems like reaching for something to be a problem that isn't.\n\n&gt;because it objectively sucks.\n\nIf people can't even define OO, it can't objectively suck. If you were making a pun i forgive you.\n\n&gt;culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory\n\nThese kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40519, "question": "I have no love for java.\n\n&gt;While it performs pretty well nowadays, it still isn\u2019t competitive with C or C++ and, with a little love, Haskell and OCaml can or will eclipse it in that domain.\n\nI didn't think this was true, i thought it was somewhat close to C (excluding startup). \n\n&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nThis is really seems like reaching for something to be a problem that isn't.\n\n&gt;because it objectively sucks.\n\nIf people can't even define OO, it can't objectively suck. If you were making a pun i forgive you.\n\n&gt;culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory\n\nThese kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"", "aSentId": 40520, "answer": "&gt; These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nI agree to an extent - but I do think the Java community overembraces creation of single-purpose objects over just calling functions.\n\nSee this example from the Apache HTTP client docs:\n\n    HttpPost httpPost = new HttpPost(\"http://targethost/login\");\n    List &lt;NameValuePair&gt; nvps = new ArrayList &lt;NameValuePair&gt;();\n    nvps.add(new BasicNameValuePair(\"username\", \"vip\"));\n    nvps.add(new BasicNameValuePair(\"password\", \"secret\"));\n    httpPost.setEntity(new UrlEncodedFormEntity(nvps));\n    CloseableHttpResponse response2 = httpclient.execute(httpPost);\n\nFirst off, it's great that they used an ArrayList&lt;&gt; instead of a NameValueCollection() or something, but wouldn't the code be better like:\n\n    HttpPost httpPost = httpclient.post(\"http://targethost/login\");\n    httpPost.addParam(\"username\", \"vip\");\n    httpPost.addParam(\"password\", \"secret\");\n    HttpResponse response = httpPost.execute();\n\nThat's 33% less written code, with no real minuses other than implementation details are hidden.\n\nIt seems very endemic to Java libraries that the API is written to require the full power of the library, rather than being written to be simple to use.\nIn this case, it's written to allow a lot of flexibility in how forms are encoded, in how name-value pairs are constructed, etc., at the cost of needing to build (unnecessary) HttpPost, NameValuePair and UrlEncodedFormEntity objects.\n\nSee also: Swing, Apache Lucene, Struts, many other popular frameworks.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40521, "question": "&gt; These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nI agree to an extent - but I do think the Java community overembraces creation of single-purpose objects over just calling functions.\n\nSee this example from the Apache HTTP client docs:\n\n    HttpPost httpPost = new HttpPost(\"http://targethost/login\");\n    List &lt;NameValuePair&gt; nvps = new ArrayList &lt;NameValuePair&gt;();\n    nvps.add(new BasicNameValuePair(\"username\", \"vip\"));\n    nvps.add(new BasicNameValuePair(\"password\", \"secret\"));\n    httpPost.setEntity(new UrlEncodedFormEntity(nvps));\n    CloseableHttpResponse response2 = httpclient.execute(httpPost);\n\nFirst off, it's great that they used an ArrayList&lt;&gt; instead of a NameValueCollection() or something, but wouldn't the code be better like:\n\n    HttpPost httpPost = httpclient.post(\"http://targethost/login\");\n    httpPost.addParam(\"username\", \"vip\");\n    httpPost.addParam(\"password\", \"secret\");\n    HttpResponse response = httpPost.execute();\n\nThat's 33% less written code, with no real minuses other than implementation details are hidden.\n\nIt seems very endemic to Java libraries that the API is written to require the full power of the library, rather than being written to be simple to use.\nIn this case, it's written to allow a lot of flexibility in how forms are encoded, in how name-value pairs are constructed, etc., at the cost of needing to build (unnecessary) HttpPost, NameValuePair and UrlEncodedFormEntity objects.\n\nSee also: Swing, Apache Lucene, Struts, many other popular frameworks.\n", "aSentId": 40522, "answer": "Some newer libraries are getting better at this. For example, now you can use Unirest for http in java, which is even simpler than your example:\n\n```\nUnirest.post(\"http://httpbin.org/post\")\n  .queryString(\"name\", \"Mark\")\n  .field(\"last\", \"Polo\")\n  .asJson()\n```\n\nAlso, the new Java RESTful web services API is actually pretty good. I actually like its way of defining endpoints better than how python frameworks like django and flask do it.\n\nBut yeah, it really does baffle me how so many java libraries seem to go out of their way to make you use five lines instead of one. Why not add a bunch of helper methods for the most common use-cases? Time adds up when everything you do is twice as verbose as it needs to be.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40521, "question": "&gt; These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nI agree to an extent - but I do think the Java community overembraces creation of single-purpose objects over just calling functions.\n\nSee this example from the Apache HTTP client docs:\n\n    HttpPost httpPost = new HttpPost(\"http://targethost/login\");\n    List &lt;NameValuePair&gt; nvps = new ArrayList &lt;NameValuePair&gt;();\n    nvps.add(new BasicNameValuePair(\"username\", \"vip\"));\n    nvps.add(new BasicNameValuePair(\"password\", \"secret\"));\n    httpPost.setEntity(new UrlEncodedFormEntity(nvps));\n    CloseableHttpResponse response2 = httpclient.execute(httpPost);\n\nFirst off, it's great that they used an ArrayList&lt;&gt; instead of a NameValueCollection() or something, but wouldn't the code be better like:\n\n    HttpPost httpPost = httpclient.post(\"http://targethost/login\");\n    httpPost.addParam(\"username\", \"vip\");\n    httpPost.addParam(\"password\", \"secret\");\n    HttpResponse response = httpPost.execute();\n\nThat's 33% less written code, with no real minuses other than implementation details are hidden.\n\nIt seems very endemic to Java libraries that the API is written to require the full power of the library, rather than being written to be simple to use.\nIn this case, it's written to allow a lot of flexibility in how forms are encoded, in how name-value pairs are constructed, etc., at the cost of needing to build (unnecessary) HttpPost, NameValuePair and UrlEncodedFormEntity objects.\n\nSee also: Swing, Apache Lucene, Struts, many other popular frameworks.\n", "aSentId": 40524, "answer": "There are, as other comments have mentioned \"better\" HTTP libraries that present a much higher-level API.  But Apache's HTTP Client has the specific aim of implementing HTTP as it's defined, and designed it's class-structure with that as a goal, allowing the various options to be substituted.\n\nSo, of course, form submission will be the most verbose example, as URL-encoding pairs of values is a convention, the mechanics of POST go far beyond that one case (yes, that one case is the most common).\n\nThere's nothing wrong with this approach.  Indeed it's very valuable for non-trivial circumstances.  But if you don't need it, there are other libraries available.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40525, "question": "There are, as other comments have mentioned \"better\" HTTP libraries that present a much higher-level API.  But Apache's HTTP Client has the specific aim of implementing HTTP as it's defined, and designed it's class-structure with that as a goal, allowing the various options to be substituted.\n\nSo, of course, form submission will be the most verbose example, as URL-encoding pairs of values is a convention, the mechanics of POST go far beyond that one case (yes, that one case is the most common).\n\nThere's nothing wrong with this approach.  Indeed it's very valuable for non-trivial circumstances.  But if you don't need it, there are other libraries available.", "aSentId": 40526, "answer": "&gt; There's nothing wrong with this approach.\n\nIsn't there? Why?\n\nWhat value does this structuring of the library actually add, other than scratching some obsessive itch of the developers?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40527, "question": "&gt; There's nothing wrong with this approach.\n\nIsn't there? Why?\n\nWhat value does this structuring of the library actually add, other than scratching some obsessive itch of the developers?", "aSentId": 40528, "answer": "&gt; Isn't there? Why?\n\nIs there?  Why?\n\n&gt; What value does this structuring of the library actually add, other than scratching some obsessive itch of the developers?\n\nRight, because it's an all-too-typical standard Java ego-driven bigger-the-better library?  Am I right?  What would you cite as a good HTTP library in that case?\n\nMeanwhile, back in reality.  The httpcomponents project, of which the Apache HTTP Client is a component, is a tried and tested multi-decade project that's more than proven itself.  Indeed it's widely used as the basis for these higher-level libraries - the maven central repository finds hundreds of artifacts that cite httpcomponents as a dependency.\n\nAnd it doesn't just end there, it's used as the basis for HTTP libraries in other JVM languages too.  People may think they're escaping Java verbosity writing in Clojure, but if you've made an HTTP request directory or indirectly, in Clojure/Scala/Groovy/etc. you have almost certainly used this library.\n\nAnd why is it so popular?  Because it does *everything*.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40521, "question": "&gt; These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nI agree to an extent - but I do think the Java community overembraces creation of single-purpose objects over just calling functions.\n\nSee this example from the Apache HTTP client docs:\n\n    HttpPost httpPost = new HttpPost(\"http://targethost/login\");\n    List &lt;NameValuePair&gt; nvps = new ArrayList &lt;NameValuePair&gt;();\n    nvps.add(new BasicNameValuePair(\"username\", \"vip\"));\n    nvps.add(new BasicNameValuePair(\"password\", \"secret\"));\n    httpPost.setEntity(new UrlEncodedFormEntity(nvps));\n    CloseableHttpResponse response2 = httpclient.execute(httpPost);\n\nFirst off, it's great that they used an ArrayList&lt;&gt; instead of a NameValueCollection() or something, but wouldn't the code be better like:\n\n    HttpPost httpPost = httpclient.post(\"http://targethost/login\");\n    httpPost.addParam(\"username\", \"vip\");\n    httpPost.addParam(\"password\", \"secret\");\n    HttpResponse response = httpPost.execute();\n\nThat's 33% less written code, with no real minuses other than implementation details are hidden.\n\nIt seems very endemic to Java libraries that the API is written to require the full power of the library, rather than being written to be simple to use.\nIn this case, it's written to allow a lot of flexibility in how forms are encoded, in how name-value pairs are constructed, etc., at the cost of needing to build (unnecessary) HttpPost, NameValuePair and UrlEncodedFormEntity objects.\n\nSee also: Swing, Apache Lucene, Struts, many other popular frameworks.\n", "aSentId": 40530, "answer": "&gt; It seems very endemic to Java libraries that the API is written to require the full power of the library, rather than being written to be simple to use.\n\nI seem to be in the minority, but I absolutely love this aspect of big java libraries. There's always *something* to be done about just about everything. If I want to change how expressions are parsed in a .jsp document, I can.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40531, "question": "&gt; It seems very endemic to Java libraries that the API is written to require the full power of the library, rather than being written to be simple to use.\n\nI seem to be in the minority, but I absolutely love this aspect of big java libraries. There's always *something* to be done about just about everything. If I want to change how expressions are parsed in a .jsp document, I can.", "aSentId": 40532, "answer": "Exactly.  Most language comparisons around here come down to \"here's an example I don't like, therefore it's wrong\" often accompanied by a citation to some completely different tool.\n\nThere are trade-offs.  If you need to control the corner cases of HTTP than Apache's HTTP client is a good choice; if you're building a REST API client there are REST clients which do a much better job.  One is not right and one is not wrong, they're just serving different purposes.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40537, "question": "Apache libs tend to get stuck in the past.", "aSentId": 40538, "answer": "I'd say they aim at being very general in their domain, so they tend to display both a high level of abstraction and a low-level API. They can be used anywhere but you have to pay a high upfront cost for that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40542, "question": "Obviously you are not an IDE user.", "aSentId": 40543, "answer": "I am if I use Java, due to the being not much alternative if you want to maintain sanity.\n\nI don't really use an IDE for any other language.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40519, "question": "I have no love for java.\n\n&gt;While it performs pretty well nowadays, it still isn\u2019t competitive with C or C++ and, with a little love, Haskell and OCaml can or will eclipse it in that domain.\n\nI didn't think this was true, i thought it was somewhat close to C (excluding startup). \n\n&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nThis is really seems like reaching for something to be a problem that isn't.\n\n&gt;because it objectively sucks.\n\nIf people can't even define OO, it can't objectively suck. If you were making a pun i forgive you.\n\n&gt;culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory\n\nThese kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"", "aSentId": 40545, "answer": "&gt;&gt; MetaModelVibratorVisitorFactory\n\n&gt;These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nHow is that a strawman? My current project has a class EntityManagerProvider that creates an EntityManager through an EntityManagerFactory, and another one named EntityManagerProviderProvider that provides the previous. This is not even a joke. EntityManagerFactory is standard Java, around 10% of the Java classes I know are named Handler and it's never not been like it whenever I was reading Java code. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40546, "question": "&gt;&gt; MetaModelVibratorVisitorFactory\n\n&gt;These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nHow is that a strawman? My current project has a class EntityManagerProvider that creates an EntityManager through an EntityManagerFactory, and another one named EntityManagerProviderProvider that provides the previous. This is not even a joke. EntityManagerFactory is standard Java, around 10% of the Java classes I know are named Handler and it's never not been like it whenever I was reading Java code. ", "aSentId": 40547, "answer": "I must be on the other side of the Java planet", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40546, "question": "&gt;&gt; MetaModelVibratorVisitorFactory\n\n&gt;These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nHow is that a strawman? My current project has a class EntityManagerProvider that creates an EntityManager through an EntityManagerFactory, and another one named EntityManagerProviderProvider that provides the previous. This is not even a joke. EntityManagerFactory is standard Java, around 10% of the Java classes I know are named Handler and it's never not been like it whenever I was reading Java code. ", "aSentId": 40549, "answer": "Classes ending in 'er' are code smell IMHO. 'Beer' being a notable exception.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40550, "question": "Classes ending in 'er' are code smell IMHO. 'Beer' being a notable exception.", "aSentId": 40551, "answer": "and *Controller", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40552, "question": "and *Controller", "aSentId": 40553, "answer": "Good point, let's call it LocusOfControl ;)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40519, "question": "I have no love for java.\n\n&gt;While it performs pretty well nowadays, it still isn\u2019t competitive with C or C++ and, with a little love, Haskell and OCaml can or will eclipse it in that domain.\n\nI didn't think this was true, i thought it was somewhat close to C (excluding startup). \n\n&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nThis is really seems like reaching for something to be a problem that isn't.\n\n&gt;because it objectively sucks.\n\nIf people can't even define OO, it can't objectively suck. If you were making a pun i forgive you.\n\n&gt;culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory\n\nThese kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"", "aSentId": 40555, "answer": "These kinds of classnames make me feel like \"I don't have to read another line of code this person writes.\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40556, "question": "These kinds of classnames make me feel like \"I don't have to read another line of code this person writes.\"", "aSentId": 40557, "answer": "You'll love [this](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40559, "question": "&gt;i thought it was somewhat close to C (excluding startup).\n\nIt is not, except for a few unlikely scenarios where the JIT works perfectly. You can't assume this is going to happen in general.\n\nEven if Java is \"as fast as\" C, Java is still a heavily heap-oriented language, which means just about anything except primitive integer arithmetic is going to have substantial overhead compared to the idiomatic way of doing something in C or C++.", "aSentId": 40560, "answer": "It's definitely no C, but it's a hell of a lot closer than most of the languages that go into prod these days (excluding the MLs, which despite reddit's hope, get very little industry love).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40559, "question": "&gt;i thought it was somewhat close to C (excluding startup).\n\nIt is not, except for a few unlikely scenarios where the JIT works perfectly. You can't assume this is going to happen in general.\n\nEven if Java is \"as fast as\" C, Java is still a heavily heap-oriented language, which means just about anything except primitive integer arithmetic is going to have substantial overhead compared to the idiomatic way of doing something in C or C++.", "aSentId": 40562, "answer": "Yep. Cache misses are a _huge_ and \"hidden\" cost on modern CPU architectures. Everything being a heap-allocated object in Java means that unless you're iterating over an array of primitives, you're going to be doing a lot of bouncing around in memory. See: http://gameprogrammingpatterns.com/data-locality.html", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40563, "question": "Yep. Cache misses are a _huge_ and \"hidden\" cost on modern CPU architectures. Everything being a heap-allocated object in Java means that unless you're iterating over an array of primitives, you're going to be doing a lot of bouncing around in memory. See: http://gameprogrammingpatterns.com/data-locality.html", "aSentId": 40564, "answer": "&gt; Everything being a heap-allocated object in Java\n\nBut this is not really true anymore. Java does escape analysis (IIRC from Java 6 with some option, from Java 7 by default) and puts short-lived (i.e. those which don't escape method scope) objects on stack.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40565, "question": "&gt; Everything being a heap-allocated object in Java\n\nBut this is not really true anymore. Java does escape analysis (IIRC from Java 6 with some option, from Java 7 by default) and puts short-lived (i.e. those which don't escape method scope) objects on stack.", "aSentId": 40566, "answer": "Escape analysis is great for strings, but I don't see how it could help with lists.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40567, "question": "Escape analysis is great for strings, but I don't see how it could help with lists.", "aSentId": 40568, "answer": "Are you talking about \"growability\" of collections? If so, it can be solved by preallocating the necessary number of elements (if known), e.g. new ArrayList(1000) or even new ArrayList(otherColl.size())", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40569, "question": "Are you talking about \"growability\" of collections? If so, it can be solved by preallocating the necessary number of elements (if known), e.g. new ArrayList(1000) or even new ArrayList(otherColl.size())", "aSentId": 40570, "answer": "Escape analysis just moves objects from the heap to the stack. It can't restructure an array so that it can hold the elements directly instead of just pointers to the objects. \n\nInheritance is the problem here, as you don't know ahead of time how large each object is going to be.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40571, "question": "Escape analysis just moves objects from the heap to the stack. It can't restructure an array so that it can hold the elements directly instead of just pointers to the objects. \n\nInheritance is the problem here, as you don't know ahead of time how large each object is going to be.", "aSentId": 40572, "answer": "&gt; It can't restructure an array so that it can hold the elements directly instead of just pointers to the objects.\n\nI'm not sure why you'd want it to.\n\n    public void something() {\n    \tList list = new ArrayList();\n    \tlist.add(new Member());\n    \t\n    \t// do something with the objects\n    }\n\nIn this example both collection and member can be put on the stack.\n\n    public Member something() {\n    \tMember member = new Member();\n    \t\n    \tList list = new ArrayList();\n    \tlist.add(member);\n    \t\n    \t// do something with the objects\n    \t\n    \treturn member;\n    }\n\nIn this example member obviously escapes so needs to be on the heap. But list can be on the stack. Everything seems to be fine.\n\n&gt; Inheritance is the problem here, as you don't know ahead of time how large each object is going to be.\n\nCan you elaborate on this? When JVM start creating an object it already has all the classes from which the instantiated class is inheriting, so JVM also knows the size of the object (it must know so that it can allocate proper amount of memory).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40573, "question": "&gt; It can't restructure an array so that it can hold the elements directly instead of just pointers to the objects.\n\nI'm not sure why you'd want it to.\n\n    public void something() {\n    \tList list = new ArrayList();\n    \tlist.add(new Member());\n    \t\n    \t// do something with the objects\n    }\n\nIn this example both collection and member can be put on the stack.\n\n    public Member something() {\n    \tMember member = new Member();\n    \t\n    \tList list = new ArrayList();\n    \tlist.add(member);\n    \t\n    \t// do something with the objects\n    \t\n    \treturn member;\n    }\n\nIn this example member obviously escapes so needs to be on the heap. But list can be on the stack. Everything seems to be fine.\n\n&gt; Inheritance is the problem here, as you don't know ahead of time how large each object is going to be.\n\nCan you elaborate on this? When JVM start creating an object it already has all the classes from which the instantiated class is inheriting, so JVM also knows the size of the object (it must know so that it can allocate proper amount of memory).", "aSentId": 40574, "answer": "The CPU cache isn't exactly large. So if you array is non-trivial in length then you have to burn at least two cache lines, one for the array itself and one for the data. And you have to pay the cost for chasing the pointer from the array to the data.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40575, "question": "The CPU cache isn't exactly large. So if you array is non-trivial in length then you have to burn at least two cache lines, one for the array itself and one for the data. And you have to pay the cost for chasing the pointer from the array to the data.\n", "aSentId": 40576, "answer": "That's a separate problem though. EA and stack vs. heap is about cost of allocation and deallocation (GC) of memory, not about extra cost of chasing pointers and CPU cache ...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40577, "question": "That's a separate problem though. EA and stack vs. heap is about cost of allocation and deallocation (GC) of memory, not about extra cost of chasing pointers and CPU cache ...", "aSentId": 40578, "answer": "They're both reasons for using structs to improve performance.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40559, "question": "&gt;i thought it was somewhat close to C (excluding startup).\n\nIt is not, except for a few unlikely scenarios where the JIT works perfectly. You can't assume this is going to happen in general.\n\nEven if Java is \"as fast as\" C, Java is still a heavily heap-oriented language, which means just about anything except primitive integer arithmetic is going to have substantial overhead compared to the idiomatic way of doing something in C or C++.", "aSentId": 40580, "answer": "&gt; except for a few unlikely scenarios where the JIT works perfectly\n\nThis isn't even a strawman.  JIT will never \"work perfectly\", and it doesn't have to.  This is very much a case of 50% of the effort delivering 90% of the benefit; most cases are \"good enough\" rather than all-but one being bad.\n\nIt's also wrong to call what Java does JIT.  Compilation occurs during run-time, the same piece of code can and will be recompiled multiple times as it's running.\n\nAll this means that Java's performance is non-deterministic, which is a showstopper for a lot of applications, but not all.  Being non-deterministic doesn't mean \"bad\", the average, and even 90th percentile I'd say, case is still very good.\n\nGood enough that the difference between C and Java is within an order of magnitude in \"real-world\" cases.\n\nJava's memory usage, however, will be much higher.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40581, "question": "&gt; except for a few unlikely scenarios where the JIT works perfectly\n\nThis isn't even a strawman.  JIT will never \"work perfectly\", and it doesn't have to.  This is very much a case of 50% of the effort delivering 90% of the benefit; most cases are \"good enough\" rather than all-but one being bad.\n\nIt's also wrong to call what Java does JIT.  Compilation occurs during run-time, the same piece of code can and will be recompiled multiple times as it's running.\n\nAll this means that Java's performance is non-deterministic, which is a showstopper for a lot of applications, but not all.  Being non-deterministic doesn't mean \"bad\", the average, and even 90th percentile I'd say, case is still very good.\n\nGood enough that the difference between C and Java is within an order of magnitude in \"real-world\" cases.\n\nJava's memory usage, however, will be much higher.", "aSentId": 40582, "answer": "&gt; All this means that Java's performance is non-deterministic, which is a showstopper for a lot of applications, but not all. Being non-deterministic doesn't mean \"bad\", the average, and even 90th percentile I'd say, case is still very good.\n\nWell, you can always *-XComp*, but that curiously enough tends to *degrade* performance.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40581, "question": "&gt; except for a few unlikely scenarios where the JIT works perfectly\n\nThis isn't even a strawman.  JIT will never \"work perfectly\", and it doesn't have to.  This is very much a case of 50% of the effort delivering 90% of the benefit; most cases are \"good enough\" rather than all-but one being bad.\n\nIt's also wrong to call what Java does JIT.  Compilation occurs during run-time, the same piece of code can and will be recompiled multiple times as it's running.\n\nAll this means that Java's performance is non-deterministic, which is a showstopper for a lot of applications, but not all.  Being non-deterministic doesn't mean \"bad\", the average, and even 90th percentile I'd say, case is still very good.\n\nGood enough that the difference between C and Java is within an order of magnitude in \"real-world\" cases.\n\nJava's memory usage, however, will be much higher.", "aSentId": 40584, "answer": "But JIT can't fix your data structures (at least Java's can't), and heap fragmentation does terrible things to performance on modern CPUs.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40585, "question": "But JIT can't fix your data structures (at least Java's can't), and heap fragmentation does terrible things to performance on modern CPUs.", "aSentId": 40586, "answer": "No, but it's a similar principal.  You can't force data structures to have a specific layout in a memory in Java in much the same way you can't force it to have deterministic performance.\n\nBut at the same time the work the JVM does do makes it less-bad than if you naively heap-allocating everything in C++ or other such languages.  One of the tiers of compilation the JVM does, once the code has been run a few times, is inlining function calls followed by escape analysis; this means that most short-lived objects will be stack-allocated anyway.  Also, by virtue of the garbage collector, there's little fragmentation in the heap; things allocated at the same time will almost certainly be near each other, the heap is compacted (although how, when, etc. depends on which version of Java and which GC; they can take significantly different approaches).\n\nOf course, as an application developer, you cannot control any of these things; and as it runs on the bytecode after-inlining it can be surprising when it does (e.g. just because an object is returned from a method to a method in a different class, it doesn't have to be heap-allocated).  But it does mean the average performance is no-where near as bad as the worst-case described whenever this issue comes up.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40587, "question": "No, but it's a similar principal.  You can't force data structures to have a specific layout in a memory in Java in much the same way you can't force it to have deterministic performance.\n\nBut at the same time the work the JVM does do makes it less-bad than if you naively heap-allocating everything in C++ or other such languages.  One of the tiers of compilation the JVM does, once the code has been run a few times, is inlining function calls followed by escape analysis; this means that most short-lived objects will be stack-allocated anyway.  Also, by virtue of the garbage collector, there's little fragmentation in the heap; things allocated at the same time will almost certainly be near each other, the heap is compacted (although how, when, etc. depends on which version of Java and which GC; they can take significantly different approaches).\n\nOf course, as an application developer, you cannot control any of these things; and as it runs on the bytecode after-inlining it can be surprising when it does (e.g. just because an object is returned from a method to a method in a different class, it doesn't have to be heap-allocated).  But it does mean the average performance is no-where near as bad as the worst-case described whenever this issue comes up.", "aSentId": 40588, "answer": "Yeah, stack allocation can make a difference. I was thinking of the very specific case where you have arrays that are iterated over in order. At least in practice you can usually just use an array of some primitive type.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40581, "question": "&gt; except for a few unlikely scenarios where the JIT works perfectly\n\nThis isn't even a strawman.  JIT will never \"work perfectly\", and it doesn't have to.  This is very much a case of 50% of the effort delivering 90% of the benefit; most cases are \"good enough\" rather than all-but one being bad.\n\nIt's also wrong to call what Java does JIT.  Compilation occurs during run-time, the same piece of code can and will be recompiled multiple times as it's running.\n\nAll this means that Java's performance is non-deterministic, which is a showstopper for a lot of applications, but not all.  Being non-deterministic doesn't mean \"bad\", the average, and even 90th percentile I'd say, case is still very good.\n\nGood enough that the difference between C and Java is within an order of magnitude in \"real-world\" cases.\n\nJava's memory usage, however, will be much higher.", "aSentId": 40590, "answer": "&gt; Good enough that the difference between C and Java is within an order of magnitude in \"real-world\" cases.\n\nWe can be within an order of magnitude and I'm paying $110k for my server infrastructure while you're paying $1M. That's 6 or 7 devs yearly salary difference there.\n\nJava is probably a lot better than 9x slower than C most of the time, but the point still stands. Of course, if your devs are a lot more productive in Java and the difference is only 3x, maybe Java's the right choice.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40593, "question": "We just have to wait another 6 years for Java to have user-defined value types that can be used as generic parameters, a feature C# had for many years.", "aSentId": 40594, "answer": "Yet c# is still slower in practice. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40598, "question": " What about Scala?", "aSentId": 40599, "answer": "I like Scala. It does away with a lot of the boiler plate code from Java. Although it does have a steep learning curve, the functional side of it teaches Java devs to be better programmers, it has for me anyway. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40598, "question": " What about Scala?", "aSentId": 40601, "answer": " I'm glad you mentioned! It is a really powerful language! I think everybody should try Scala and its community to feel the higher-level easy development and break the slave chains of big companies.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40602, "question": " I'm glad you mentioned! It is a really powerful language! I think everybody should try Scala and its community to feel the higher-level easy development and break the slave chains of big companies.", "aSentId": 40603, "answer": "It has quite the learning curve though. I thought I'd just start with it and see where it takes me  similar to my groovy experience, but it took me quite a whilst longer to create functionality.\n\nI really like the type inference and the immutability, so I'll stick with it for bigger projects in favor of java.\n\nWhat I did not like is that scala is currently impossible to mix with groovy, it can be mixed with java, but not groovy (at least not in the IDE). You can however let your scala classes handle interpreted groovy scripts, which is pretty cool. So I don't think it should be that hard to fix this problem, I might take a look at it when I have time.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40602, "question": " I'm glad you mentioned! It is a really powerful language! I think everybody should try Scala and its community to feel the higher-level easy development and break the slave chains of big companies.", "aSentId": 40605, "answer": "I like a lot of things about Scala, especially the imperative-functional balance that it has, but some things are just idiotic in my mind. Variable name, Colon, Variable Type is stupid and forces me to type an extra colon all over the place, which is contrary to their usual design pattern of \"remove unnecessary bloat\" like semi-colons. Also, casting from one type to another is painful using the .AsInstanceOf[Type] method, as this also breaks the \"lets not be verbose!\" mantra. Also, refusing to have operator overloading is another pain in the ass. Also, compiler errors are completely cryptic and not very descriptive at times. Once I switched to IntelliJ I realized that a large portion of my frustration with the language was due to Eclipse, but I feel like a few simple changes would make the language 100x better. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40606, "question": "I like a lot of things about Scala, especially the imperative-functional balance that it has, but some things are just idiotic in my mind. Variable name, Colon, Variable Type is stupid and forces me to type an extra colon all over the place, which is contrary to their usual design pattern of \"remove unnecessary bloat\" like semi-colons. Also, casting from one type to another is painful using the .AsInstanceOf[Type] method, as this also breaks the \"lets not be verbose!\" mantra. Also, refusing to have operator overloading is another pain in the ass. Also, compiler errors are completely cryptic and not very descriptive at times. Once I switched to IntelliJ I realized that a large portion of my frustration with the language was due to Eclipse, but I feel like a few simple changes would make the language 100x better. ", "aSentId": 40607, "answer": "`.asInstanceOf[Foo]` is *intentionally* verbose. Why? Because it's a code smell, you're throwing type safety out the window. Pattern match instead.\n\n&gt; refusing to have operator overloading is another pain in the ass\n\nwhat on earth are you talking about? In Scala you can operator overload as you please: `def &gt;&gt;(q: Query) = ...`, `def &lt;*&gt;[T](l: List[T]) = ...`, etc.\n\nSpend some time with the language, your complaints will turn to, \"oh, now I see\" instead of, \"arggghhh, why isn't it like Java?\"\n\np.s. Scala tooling and compile times suck compared to Java, no shortage of frustration there when starting out.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40608, "question": "`.asInstanceOf[Foo]` is *intentionally* verbose. Why? Because it's a code smell, you're throwing type safety out the window. Pattern match instead.\n\n&gt; refusing to have operator overloading is another pain in the ass\n\nwhat on earth are you talking about? In Scala you can operator overload as you please: `def &gt;&gt;(q: Query) = ...`, `def &lt;*&gt;[T](l: List[T]) = ...`, etc.\n\nSpend some time with the language, your complaints will turn to, \"oh, now I see\" instead of, \"arggghhh, why isn't it like Java?\"\n\np.s. Scala tooling and compile times suck compared to Java, no shortage of frustration there when starting out.", "aSentId": 40609, "answer": "Pattern matching just to cast an object that I know is a float to a float? That's ridiculous. Furthermore, making a cast more verbose doesn't change anything, and doesn't remove the \"code smell\".  Pattern matching just makes the problem worse in this case as I have to write significantly more code.\r\rLet me give you an example of the problem I had. I was using spark to read a row of data from a database. It returns an area of objects as the row, and I have to cast each column into its appropriate data type. Doing this in C# or Java or C++ is straightforward and simple, but using pattern matching for this is laughable, and using .AsInstanceOf[Type] is more verbose than bloody Java.\r\rAs far as operator overloading goes, that's great that I can do it, but its not very helpful when the standard library never uses the feature. I Should be able to compare Timestamps and Date objects without calling methods and without creating my own operators.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40606, "question": "I like a lot of things about Scala, especially the imperative-functional balance that it has, but some things are just idiotic in my mind. Variable name, Colon, Variable Type is stupid and forces me to type an extra colon all over the place, which is contrary to their usual design pattern of \"remove unnecessary bloat\" like semi-colons. Also, casting from one type to another is painful using the .AsInstanceOf[Type] method, as this also breaks the \"lets not be verbose!\" mantra. Also, refusing to have operator overloading is another pain in the ass. Also, compiler errors are completely cryptic and not very descriptive at times. Once I switched to IntelliJ I realized that a large portion of my frustration with the language was due to Eclipse, but I feel like a few simple changes would make the language 100x better. ", "aSentId": 40611, "answer": "&gt; Variable name, Colon, Variable Type is stupid and forces me to type an extra colon all over the place, which is contrary to their usual design pattern of \"remove unnecessary bloat\" like semi-colons\n\nLike \"val x = List(1, 2)\"?\nOr \"val rand = new Random()\"\nWhat semicolons? :D\n\n&gt; ...using the .AsInstanceOf[Type] method...\n\nimplicit class As(a: Any) { def as[T] = a.asInstanceOf[T] } // Problem solved", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40612, "question": "&gt; Variable name, Colon, Variable Type is stupid and forces me to type an extra colon all over the place, which is contrary to their usual design pattern of \"remove unnecessary bloat\" like semi-colons\n\nLike \"val x = List(1, 2)\"?\nOr \"val rand = new Random()\"\nWhat semicolons? :D\n\n&gt; ...using the .AsInstanceOf[Type] method...\n\nimplicit class As(a: Any) { def as[T] = a.asInstanceOf[T] } // Problem solved", "aSentId": 40613, "answer": "&gt; Like \"val x = List(1, 2)\"? Or \"val rand = new Random()\" What semicolons? :D\n\nI presume he's referring to\n\n    def foo(x: Int, y: String): Bar\n\nthough I personally prefer having the colon there as it is a visually distinctive marker.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40614, "question": "&gt; Like \"val x = List(1, 2)\"? Or \"val rand = new Random()\" What semicolons? :D\n\nI presume he's referring to\n\n    def foo(x: Int, y: String): Bar\n\nthough I personally prefer having the colon there as it is a visually distinctive marker.", "aSentId": 40615, "answer": "I find the colon does nothing for me. You could use the same logic to say that Scala should mandate semi-colons at the end of statements as a \"visual marker\". I love that they made the semicolon optional, but then they just replace it with an equally redundant colon. It's not needed at all and makes the code visually more complex than it could to be.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40598, "question": " What about Scala?", "aSentId": 40617, "answer": "Scala is a horrible language. It's far too flexible. The creators see c++ and thought it didn't give you enough ways to write confusing code so they added even more options. Everything in scala has like 5 ways you can call it and everyone does it a different way making using third party libraries a pain if you ever have to debug.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40618, "question": "Scala is a horrible language. It's far too flexible. The creators see c++ and thought it didn't give you enough ways to write confusing code so they added even more options. Everything in scala has like 5 ways you can call it and everyone does it a different way making using third party libraries a pain if you ever have to debug.", "aSentId": 40619, "answer": "&gt; Scala is a horrible language. It's far too flexible.\n\n Then what we should use? A language with zero-flexibility, like Go? Flexibility is very-very important to write verbose dsls for frameworks. It prevents to make disastrously ugly &amp; non-verbose fws like spring and hibernate.\n \n&gt;  Everything in scala has like 5 ways you can call it and everyone does it a different way making using third party libraries a pain if you ever have to debug.\n\nI don't know what kind of experience you have with Scala but debugging Scala is easy beacuse of typesafety.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40620, "question": "&gt; Scala is a horrible language. It's far too flexible.\n\n Then what we should use? A language with zero-flexibility, like Go? Flexibility is very-very important to write verbose dsls for frameworks. It prevents to make disastrously ugly &amp; non-verbose fws like spring and hibernate.\n \n&gt;  Everything in scala has like 5 ways you can call it and everyone does it a different way making using third party libraries a pain if you ever have to debug.\n\nI don't know what kind of experience you have with Scala but debugging Scala is easy beacuse of typesafety.", "aSentId": 40621, "answer": "&gt; Then what we should use?\n\nKotlin and Ceylon are two interesting languages showing what a post-Scala language can look like. They take some of the good parts of Scala but they both have a very narrow focus on their scope and feature set.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40622, "question": "&gt; Then what we should use?\n\nKotlin and Ceylon are two interesting languages showing what a post-Scala language can look like. They take some of the good parts of Scala but they both have a very narrow focus on their scope and feature set.\n", "aSentId": 40623, "answer": "&gt; They take some of the good parts of Scala...\n\nThey take no part of Scala. Actually, ceylon doesn't bring too much to the jvm just some cheap things. And kotlin just feels limited compared to Scala. You have to explore Scala's implicit-system with typeclasses and consider the benefits of it.\n\nEdit:\n The main problem of Kotlin is that they don't want to make another Scala which is ok but they doesn't implement the best features of it. This choice make it a poor language compared to FP langs.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40624, "question": "&gt; They take some of the good parts of Scala...\n\nThey take no part of Scala. Actually, ceylon doesn't bring too much to the jvm just some cheap things. And kotlin just feels limited compared to Scala. You have to explore Scala's implicit-system with typeclasses and consider the benefits of it.\n\nEdit:\n The main problem of Kotlin is that they don't want to make another Scala which is ok but they doesn't implement the best features of it. This choice make it a poor language compared to FP langs.", "aSentId": 40625, "answer": "The Scala baggage to implement type classes is plain crazy, I'll stick to Haskell if I need to implement something that will benefit from type classes.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40626, "question": "The Scala baggage to implement type classes is plain crazy, I'll stick to Haskell if I need to implement something that will benefit from type classes.\n", "aSentId": 40627, "answer": " Why? Scala's typeclasses knows more than Haskell's. There are problems that those solves easier. But isn't it tricky to program in Kotlin, Ceylon and Haskell at the same time? :D", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40628, "question": " Why? Scala's typeclasses knows more than Haskell's. There are problems that those solves easier. But isn't it tricky to program in Kotlin, Ceylon and Haskell at the same time? :D", "aSentId": 40629, "answer": "Not really. I actually find it healthy to juggle languages, I fear the day where I'll only be comfortable with one language and any other language feels too different to me.\n\nAt work, I do Java on Android and back end. At home, I have a Kotlin android app I'm working on (Kotlin really shines for Android) and I switch between Ceylon and Haskell for the rest. The simple thought of using Scala feels pretty ridiculous to me now, especially after spending a few days in a row writing Haskell (I used to love Scala, though).\n\nInterestingly, I've found Kotlin easier to use to translate type class based code because of extension methods, which Ceylon doesn't have. Overall, I find Ceylon's type system more interesting and more powerful (especially with the awesome native support for product and sum types) but encoding type classes with it is more painful.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40630, "question": "Not really. I actually find it healthy to juggle languages, I fear the day where I'll only be comfortable with one language and any other language feels too different to me.\n\nAt work, I do Java on Android and back end. At home, I have a Kotlin android app I'm working on (Kotlin really shines for Android) and I switch between Ceylon and Haskell for the rest. The simple thought of using Scala feels pretty ridiculous to me now, especially after spending a few days in a row writing Haskell (I used to love Scala, though).\n\nInterestingly, I've found Kotlin easier to use to translate type class based code because of extension methods, which Ceylon doesn't have. Overall, I find Ceylon's type system more interesting and more powerful (especially with the awesome native support for product and sum types) but encoding type classes with it is more painful.\n", "aSentId": 40631, "answer": "&gt; Not really. I actually find it healthy to juggle languages, I fear the day where I'll only be comfortable with one language and any other language feels too different to me.\n\n I program in Scala, Nim, C, Shell very often and what? Scala is just a good way to do enterprisy and webdev things easily.\n\n&gt; Interestingly, I've found Kotlin easier to use to translate type class based code because of extension methods...\n\n What does it have to do with typeclasses? If that is what you call a type class what Kotlin does then you have to try Rust or Nim. They don't use real typeclasses but easy to use languages(except Rust).\n\n&gt; especially with the awesome native support for product and sum types\n\n Those things are the lasts what i want to see in a project! Signs of a poor typesystem. Code-smells.\n\n I think you didn't used Scala enough to recognize its benefits and get rid of stone tools... ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40630, "question": "Not really. I actually find it healthy to juggle languages, I fear the day where I'll only be comfortable with one language and any other language feels too different to me.\n\nAt work, I do Java on Android and back end. At home, I have a Kotlin android app I'm working on (Kotlin really shines for Android) and I switch between Ceylon and Haskell for the rest. The simple thought of using Scala feels pretty ridiculous to me now, especially after spending a few days in a row writing Haskell (I used to love Scala, though).\n\nInterestingly, I've found Kotlin easier to use to translate type class based code because of extension methods, which Ceylon doesn't have. Overall, I find Ceylon's type system more interesting and more powerful (especially with the awesome native support for product and sum types) but encoding type classes with it is more painful.\n", "aSentId": 40633, "answer": " Just why are you using languages with the same DSL?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40622, "question": "&gt; Then what we should use?\n\nKotlin and Ceylon are two interesting languages showing what a post-Scala language can look like. They take some of the good parts of Scala but they both have a very narrow focus on their scope and feature set.\n", "aSentId": 40635, "answer": "Ceylon is a joke, and neither come close to what Scala does.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40636, "question": "Ceylon is a joke, and neither come close to what Scala does.", "aSentId": 40637, "answer": "That's their stength: they offer a lot of what Scala does without all the crazy syntactic and semantic baggage.\n\nSometimes, less is more.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40638, "question": "That's their stength: they offer a lot of what Scala does without all the crazy syntactic and semantic baggage.\n\nSometimes, less is more.\n", "aSentId": 40639, "answer": "No, they offer some syntactical sugar.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40618, "question": "Scala is a horrible language. It's far too flexible. The creators see c++ and thought it didn't give you enough ways to write confusing code so they added even more options. Everything in scala has like 5 ways you can call it and everyone does it a different way making using third party libraries a pain if you ever have to debug.", "aSentId": 40641, "answer": "I agree. It doesn't seem to be a language with a plan, just a \"whatever the hell we feel like adding at the moment\" kind of thing. Scala actually drove me to Clojure...and I didn't know a Lisp so that's pretty bad. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40642, "question": "I agree. It doesn't seem to be a language with a plan, just a \"whatever the hell we feel like adding at the moment\" kind of thing. Scala actually drove me to Clojure...and I didn't know a Lisp so that's pretty bad. ", "aSentId": 40643, "answer": "&gt; It doesn't seem to be a language with a plan, just a \"whatever the hell we feel like adding at the moment\" kind of thing. \n\n That is called evolution and it is unstoppable. Java and c# already introducing some of the features of Scala.\n\n&gt; Scala actually drove me to Clojure...and I didn't know a Lisp so that's pretty bad. \n\n[Is](https://github.com/LightTable/Clojure/blob/master/runner/src/leiningen/light_nrepl.clj) it better?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40618, "question": "Scala is a horrible language. It's far too flexible. The creators see c++ and thought it didn't give you enough ways to write confusing code so they added even more options. Everything in scala has like 5 ways you can call it and everyone does it a different way making using third party libraries a pain if you ever have to debug.", "aSentId": 40645, "answer": "Odersky and others at Typesafe are aware of this, hopefully we'll see improvements soon.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40647, "question": "What about c#?", "aSentId": 40648, "answer": "I feel like C# kind of inverts the problems of java. On the one hand it's got a way more usable standard library, on the other hand it's VM has until recently paled in comparison to the JVM, and still has compatability/portability issues.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40649, "question": "I feel like C# kind of inverts the problems of java. On the one hand it's got a way more usable standard library, on the other hand it's VM has until recently paled in comparison to the JVM, and still has compatability/portability issues.", "aSentId": 40650, "answer": "Compatibility issues?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40651, "question": "Compatibility issues?", "aSentId": 40652, "answer": "I assume he means the official VM is windows only", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40653, "question": "I assume he means the official VM is windows only", "aSentId": 40654, "answer": "[.NET CLR](https://github.com/dotnet/coreclr) is open source and apparently passing build on linux. How well it works, I have no idea.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40655, "question": "[.NET CLR](https://github.com/dotnet/coreclr) is open source and apparently passing build on linux. How well it works, I have no idea.", "aSentId": 40656, "answer": "Very true, I forgot about that. That's only a new development though", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40657, "question": "Very true, I forgot about that. That's only a new development though", "aSentId": 40658, "answer": "Mono's been around for years; and it's a perfectly serviceable runtime.  The problem has always been library support.  Most .NET applications were written using libraries that were *very* Windows-specific, like Windows Forms which exposed a lot of the raw Win32 underneath, making it hard to come up with a good cross-platform alternative because it expanded the problem scope from just having a 100% compatible .NET runtime to also having a 100% compatible Win32 layer underneath.\n\nThat's been changing as .NET's become more of a platform to power web server applications -- the libraries used in that arena have never had the same Windows API reliance as the client GUI stuff has had.\n\nAnd of course, Mono's always lagged behind more mature VMs in performance.  That's to be expected, considering how much more manpower they've had invested in them.  That's probably the biggest area where .NET Core is going to have an impact.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40659, "question": "Mono's been around for years; and it's a perfectly serviceable runtime.  The problem has always been library support.  Most .NET applications were written using libraries that were *very* Windows-specific, like Windows Forms which exposed a lot of the raw Win32 underneath, making it hard to come up with a good cross-platform alternative because it expanded the problem scope from just having a 100% compatible .NET runtime to also having a 100% compatible Win32 layer underneath.\n\nThat's been changing as .NET's become more of a platform to power web server applications -- the libraries used in that arena have never had the same Windows API reliance as the client GUI stuff has had.\n\nAnd of course, Mono's always lagged behind more mature VMs in performance.  That's to be expected, considering how much more manpower they've had invested in them.  That's probably the biggest area where .NET Core is going to have an impact.", "aSentId": 40660, "answer": "I wasn't saying OP was right, I was just trying to guess what they meant", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40647, "question": "What about c#?", "aSentId": 40662, "answer": "C# is awesome.. So long as you are only dealing with windows machines. Hopefully open sourcing the .NET core will make that better in the future", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40663, "question": "C# is awesome.. So long as you are only dealing with windows machines. Hopefully open sourcing the .NET core will make that better in the future", "aSentId": 40664, "answer": "&gt; So long as you are only dealing with windows machines.\n\nYou mean unless you are dealing with Windows, Linux (Mono), mobile devices (xamarin) or wish to script a video game (Unity, XNA)?\n\nI mean, those different contexts might not get you the **full** .net framework, but you can still code in C# using them and most of them come close.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40665, "question": "&gt; So long as you are only dealing with windows machines.\n\nYou mean unless you are dealing with Windows, Linux (Mono), mobile devices (xamarin) or wish to script a video game (Unity, XNA)?\n\nI mean, those different contexts might not get you the **full** .net framework, but you can still code in C# using them and most of them come close.", "aSentId": 40666, "answer": "Yes, there are a bajillion stipulations with using C# on anything but windows, which makes it not awesome for non-windows devices. Fact is, that .NET is not a good option if you want cross platform compatibility at the moment, but I'm really hoping that will change because C# is by far favorite language. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40665, "question": "&gt; So long as you are only dealing with windows machines.\n\nYou mean unless you are dealing with Windows, Linux (Mono), mobile devices (xamarin) or wish to script a video game (Unity, XNA)?\n\nI mean, those different contexts might not get you the **full** .net framework, but you can still code in C# using them and most of them come close.", "aSentId": 40668, "answer": "I use various Linux distros as my main OS on all of my computers. Have for years. If I want to install a program, and I notice it's written using mono/CS, I'll throw it out the window immediately. Why? Because mono is several hundred megabytes. All the libraries for all the other languages (C, C++, Java, Python, Perl) combined are roughly this size. Fuck that microsoft style bloat. No wonder Windows is ~60GB installed.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40669, "question": "I use various Linux distros as my main OS on all of my computers. Have for years. If I want to install a program, and I notice it's written using mono/CS, I'll throw it out the window immediately. Why? Because mono is several hundred megabytes. All the libraries for all the other languages (C, C++, Java, Python, Perl) combined are roughly this size. Fuck that microsoft style bloat. No wonder Windows is ~60GB installed.", "aSentId": 40670, "answer": "&gt; No wonder Windows is ~60GB installed.\n\nWindows 8.1 minimum hardware requirements are 16 GB. Windows itself is less than 10 GB installed. Sometimes additional third party drivers are installed for convenience which take up a lot of additional space, but this is not required.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40671, "question": "&gt; No wonder Windows is ~60GB installed.\n\nWindows 8.1 minimum hardware requirements are 16 GB. Windows itself is less than 10 GB installed. Sometimes additional third party drivers are installed for convenience which take up a lot of additional space, but this is not required.", "aSentId": 40672, "answer": "20GB for 64bit. No sane person would use a 32bit OS in 2015. And those 20GB will be almost full, making Windows complain about low disk space, and making it behave weirdly. There won't be enough space for system restore points for updates, breaking them. And so on and so forth. Most Linux distros are a few gigabytes installed, including applications that Windows lacks in the default install.\n\nI'm not some idiot Linux diehard fan trying to bash Windows. From a technical perspective, this is simply ridiculous. Even if Microsoft included compatibility libraries for 32bit (as does my 64bit Debian installation by the way), and then several versions of each of those on top of all that, it shouldn't get bigger than 10GB. I just don't get it. Microsoft has some of the very best engineers and architects in the world, and they mostly write good code, as we have seen from the leaks of NT and of the open sourcing of .NET.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40673, "question": "20GB for 64bit. No sane person would use a 32bit OS in 2015. And those 20GB will be almost full, making Windows complain about low disk space, and making it behave weirdly. There won't be enough space for system restore points for updates, breaking them. And so on and so forth. Most Linux distros are a few gigabytes installed, including applications that Windows lacks in the default install.\n\nI'm not some idiot Linux diehard fan trying to bash Windows. From a technical perspective, this is simply ridiculous. Even if Microsoft included compatibility libraries for 32bit (as does my 64bit Debian installation by the way), and then several versions of each of those on top of all that, it shouldn't get bigger than 10GB. I just don't get it. Microsoft has some of the very best engineers and architects in the world, and they mostly write good code, as we have seen from the leaks of NT and of the open sourcing of .NET.", "aSentId": 40674, "answer": "The answer is simple:\n\n1. What you see is NOT what you get (a whole folder in Windows, WinSxS is mostly made out of smoke and mirrors).\n2. Consider having to include *ALL* versions of each library in Linux. That's effectively what Windows does. The reason: Backward compatibility. Yes, it sucks, but not being able to run that *one* program that an external consultant built for your company and no-one dares touch it code, this sucks way more than 20 GB of disk (which cost like 1$ or 10$ for SSD)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40675, "question": "The answer is simple:\n\n1. What you see is NOT what you get (a whole folder in Windows, WinSxS is mostly made out of smoke and mirrors).\n2. Consider having to include *ALL* versions of each library in Linux. That's effectively what Windows does. The reason: Backward compatibility. Yes, it sucks, but not being able to run that *one* program that an external consultant built for your company and no-one dares touch it code, this sucks way more than 20 GB of disk (which cost like 1$ or 10$ for SSD)", "aSentId": 40676, "answer": "1. I know what hardlinks are. I don't measure the size of a Windows installation by what explorer.exe tells me, but by the size of a VM. A RHEL 7 VM template is a few gigabytes in size, a Windows 2012 VM template is a few dozen gigabytes in size. Creating a new RHEL VM is done in seconds, and Puppet has installed, configured, integrated and started its services by the time the windows VM has finished cloning and is starting to boot.\n\n2. Windows is missing package management. These applications that depend on specific versions of specific libraries should inform Windows about them. Windows would then be able to build a tree of needed libraries and install those.\n\nActually, I think the one feature that Windows is missing is package management. Imagine a repository server (like WSUS, but for software and libraries) that the windows instances could pull their components from as needed.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40671, "question": "&gt; No wonder Windows is ~60GB installed.\n\nWindows 8.1 minimum hardware requirements are 16 GB. Windows itself is less than 10 GB installed. Sometimes additional third party drivers are installed for convenience which take up a lot of additional space, but this is not required.", "aSentId": 40678, "answer": "In my experience, useful windows systems occupy twice the disk space of useful Linux or OS X systems.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40669, "question": "I use various Linux distros as my main OS on all of my computers. Have for years. If I want to install a program, and I notice it's written using mono/CS, I'll throw it out the window immediately. Why? Because mono is several hundred megabytes. All the libraries for all the other languages (C, C++, Java, Python, Perl) combined are roughly this size. Fuck that microsoft style bloat. No wonder Windows is ~60GB installed.", "aSentId": 40680, "answer": "&gt;  Why? Because mono is several hundred megabytes. \n\nYea, so? Are you still using a hard drive from the late 90's?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40681, "question": "&gt;  Why? Because mono is several hundred megabytes. \n\nYea, so? Are you still using a hard drive from the late 90's?", "aSentId": 40682, "answer": "Why do all other languages mentioned work without taking up such a huge amount of disk space, while offering similar functionality, if it is not for bad design and/or implementation? Just because we have more powerful machines now, does that mean that we can throw good engineering and efficiency out the window?\n\nIt doesn't matter too much if my SSD occupies a bit more space, but when you're running thousands of machines on shared storage it starts to matter quite a bit. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40683, "question": "Why do all other languages mentioned work without taking up such a huge amount of disk space, while offering similar functionality, if it is not for bad design and/or implementation? Just because we have more powerful machines now, does that mean that we can throw good engineering and efficiency out the window?\n\nIt doesn't matter too much if my SSD occupies a bit more space, but when you're running thousands of machines on shared storage it starts to matter quite a bit. ", "aSentId": 40684, "answer": "In 2010 we were looking at a price of roughly 10 cents per gigabyte.\n\nhttp://notebooks.com/2011/03/09/hard-drive-prices-over-time-price-per-gb-from-1981-to-2010/\n\nLets say Mono takes 1 GB even and you get paid, with benefits and other overhead, $50/hour.\n\nIf it takes you more than two hours ($100) to find an alternative to the Mono-based application you were looking at (0.10 * 1000 machines = $100) then you've cost your company money.\n\nI'm all for reducing bloat, but let's not exaggerate its costs.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40685, "question": "In 2010 we were looking at a price of roughly 10 cents per gigabyte.\n\nhttp://notebooks.com/2011/03/09/hard-drive-prices-over-time-price-per-gb-from-1981-to-2010/\n\nLets say Mono takes 1 GB even and you get paid, with benefits and other overhead, $50/hour.\n\nIf it takes you more than two hours ($100) to find an alternative to the Mono-based application you were looking at (0.10 * 1000 machines = $100) then you've cost your company money.\n\nI'm all for reducing bloat, but let's not exaggerate its costs.", "aSentId": 40686, "answer": "I care about technology, good design, and good engineering. This is what guides my decisions, not mere money.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40687, "question": "I care about technology, good design, and good engineering. This is what guides my decisions, not mere money.", "aSentId": 40688, "answer": "The first two are legit, but good engineering includes  cost analysis.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40689, "question": "The first two are legit, but good engineering includes  cost analysis.", "aSentId": 40690, "answer": "And externalising the cost of implementing a space-efficient framework to the customer in the form of bloat is a good engineering decision by the developers of mono?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40647, "question": "What about c#?", "aSentId": 40692, "answer": "What about it? Seems like a nice language. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40693, "question": "What about it? Seems like a nice language. ", "aSentId": 40694, "answer": "I've heard that it's a much better \"version\" of java.  I was wondering if /u/karlhungus has experience with c#.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40695, "question": "I've heard that it's a much better \"version\" of java.  I was wondering if /u/karlhungus has experience with c#.", "aSentId": 40696, "answer": "Ah it wasn't clear from your comment.\n\nTo me, C# seems like a nice and simple language. Like Java, its optimal use story involves the use of an IDE. I would really like to try it out but unfortunately, the best C# IDE (Visual Studio) is Windows-only, while the best Java IDE (IntelliJ IDEA) is available on all major platforms.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40697, "question": "Ah it wasn't clear from your comment.\n\nTo me, C# seems like a nice and simple language. Like Java, its optimal use story involves the use of an IDE. I would really like to try it out but unfortunately, the best C# IDE (Visual Studio) is Windows-only, while the best Java IDE (IntelliJ IDEA) is available on all major platforms.", "aSentId": 40698, "answer": "Xamarin studio works fairly well in Linux and Mac.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40699, "question": "Xamarin studio works fairly well in Linux and Mac.", "aSentId": 40700, "answer": "But still sucks compared to Visual Studio.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40697, "question": "Ah it wasn't clear from your comment.\n\nTo me, C# seems like a nice and simple language. Like Java, its optimal use story involves the use of an IDE. I would really like to try it out but unfortunately, the best C# IDE (Visual Studio) is Windows-only, while the best Java IDE (IntelliJ IDEA) is available on all major platforms.", "aSentId": 40702, "answer": "Mono develop is ok.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40703, "question": "Mono develop is ok.", "aSentId": 40704, "answer": "As someone working on a cross-platform C# project, it very, very isn't.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40705, "question": "As someone working on a cross-platform C# project, it very, very isn't.", "aSentId": 40706, "answer": "I never had any serious problems using it. I'd argue that it's leaps and bounds more usable than Eclipse is for Java.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40707, "question": "I never had any serious problems using it. I'd argue that it's leaps and bounds more usable than Eclipse is for Java.", "aSentId": 40708, "answer": "The gulf to VS + Resharper is massive.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40709, "question": "The gulf to VS + Resharper is massive.", "aSentId": 40710, "answer": "Resharper has some wicked features but there's actually quite a bit of overlap with what can already be done in VS.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40705, "question": "As someone working on a cross-platform C# project, it very, very isn't.", "aSentId": 40712, "answer": "I said it was OK, not that it was a good VS replacement. I, too, love VS + resharper.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40695, "question": "I've heard that it's a much better \"version\" of java.  I was wondering if /u/karlhungus has experience with c#.", "aSentId": 40714, "answer": "C# is a fantastic language. It's significantly less verbose than Java and has had years of development and features added to it while Java has been stagnant over the years. Scala is a pretty good Java replacement language, apart from the idiotic variable name, colon, variable type syntax. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40716, "question": "C# and Java are like siblings that grew up together and at some point one of them made the right life decision and the other one made the opposite, wrong choice. \n\nThen you look at them years later and you see how they sort of have a lot of similarities, but one of them just ended up much better than the other.", "aSentId": 40717, "answer": "Java has way better standard library support for concurrency though. From what I can tell, C# lacks an equivalent for ConcurrentLinkedQueue and ConcurrentSkipListMap. Also no ForkJoinPool or Phaser.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40718, "question": "Java has way better standard library support for concurrency though. From what I can tell, C# lacks an equivalent for ConcurrentLinkedQueue and ConcurrentSkipListMap. Also no ForkJoinPool or Phaser.", "aSentId": 40719, "answer": "Those 2 data structures don't exist in the .Net framework, indeed.\n\nRegarding parallelism in general, the TPL (and async/await from C# 5) address all parallel/asynchronous needs.\n\nAnd with support for delegates as first-class values you write much less code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40716, "question": "C# and Java are like siblings that grew up together and at some point one of them made the right life decision and the other one made the opposite, wrong choice. \n\nThen you look at them years later and you see how they sort of have a lot of similarities, but one of them just ended up much better than the other.", "aSentId": 40721, "answer": "Yet the inferior language (Java) has far more market share than the better language, sort of like how PHP still has more market share than saner technologies.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40722, "question": "Yet the inferior language (Java) has far more market share than the better language, sort of like how PHP still has more market share than saner technologies.", "aSentId": 40723, "answer": "The power of free.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40725, "question": "&gt; This is really seems like reaching for something to be a problem that isn't.\n\nIt's only not a problem if you can successfully tune it. Given the memory (ab)usage of the JVM, and then the necessary tuning of the heap parameters, I can imagine many people throwing in the towel for better things. \n\n\n\n&gt; &gt; culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory\n\n&gt; These kinds of strawmen make me feel like \"I don't have to read another word this person writes.\"\n\nExcept this bullshit is rife in J2EE, and isn't a strawman in the least. This modular bullshit makes you understand an order of magnitude more objects to figure out what is going on. And you can't have it all on one screen like you could in a sane language, you've got to trace down through many wrapper classes, and god help you if they're working through an interface, then you've got to figure out what type is actually being called.", "aSentId": 40726, "answer": "J2EE is the biggest and most widely used software abomination in history. I don't really understand why people would use its features since it obfuscates everything, runs slow and is hell to debug.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40727, "question": "J2EE is the biggest and most widely used software abomination in history. I don't really understand why people would use its features since it obfuscates everything, runs slow and is hell to debug.", "aSentId": 40728, "answer": "At the time, it was J2EE, CORBA, or COM+. I knew which one to go with.\n\nNowadays, Java EE is a completely different thing. Much easier to use. But, then we have so many more choices for distributed computing today.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40730, "question": "I'm not sure why people see C and C++ as different languages in terms of performance. C++ code can be made as fast as C with 2 exceptions: no VLA's, no restrict keyword. I don't see VLA's used much in C, and most C++ compilers provide their own non-standard version of restrict.\n\nIf you want java to be as fast as the C family, give me true value-type classes and arrays, explicit simd instructions and relaxed atomics.\n\nWithout these features java will never be as fast as the C family for highly optimized programs.", "aSentId": 40731, "answer": "&gt;  relaxed atomics.\n\naka the nuclear landmines that won't help much most of the time. They have been called the single most experts-only feature in all of C++!\n\nWorld-class experts like Stephan Lavavej fucked those up. And there are basically just two architectures on which you will gain anything from them (IIRC old ARM-versions and power-pc).\n\nOh, and their necessary price is completely undefined behavior.\n\nSo: No, you don't want them in Java. (And probably you don't want to use them in C++ either.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40732, "question": "&gt;  relaxed atomics.\n\naka the nuclear landmines that won't help much most of the time. They have been called the single most experts-only feature in all of C++!\n\nWorld-class experts like Stephan Lavavej fucked those up. And there are basically just two architectures on which you will gain anything from them (IIRC old ARM-versions and power-pc).\n\nOh, and their necessary price is completely undefined behavior.\n\nSo: No, you don't want them in Java. (And probably you don't want to use them in C++ either.)", "aSentId": 40733, "answer": "I don't agree. It's true that at the hardware level the improvement over plain atomic is limited to a few architectures (ARMv7, consoles, itanium). Using relaxed atomics also allows the compiler to optimize a bit more in some situations, even on hardware with a strong memory model.\n\nI wouldn't advice anyone to actually use them, because often it isn't important. But it is these things that give C/C++ an edge over other programming languages when it actually matters.\n\nSaying that there's undefined behavior is kind of a bad argument. The entire C++ standard is littered with undefined behavior. Even multiplying 2 uint32_t can result in undefined behavior, but that doesn't mean we should avoid them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40734, "question": "I don't agree. It's true that at the hardware level the improvement over plain atomic is limited to a few architectures (ARMv7, consoles, itanium). Using relaxed atomics also allows the compiler to optimize a bit more in some situations, even on hardware with a strong memory model.\n\nI wouldn't advice anyone to actually use them, because often it isn't important. But it is these things that give C/C++ an edge over other programming languages when it actually matters.\n\nSaying that there's undefined behavior is kind of a bad argument. The entire C++ standard is littered with undefined behavior. Even multiplying 2 uint32_t can result in undefined behavior, but that doesn't mean we should avoid them.", "aSentId": 40735, "answer": "&gt; Saying that there's undefined behavior is kind of a bad argument. The entire C++ standard is littered with undefined behavior.\n\nYes and that is great for C++, but it would be weird in a language that doesn't contain it by explicit design.\n\n&gt; Even multiplying 2 uint32_t can result in undefined behavior\n\nOnly if `int` would be at least 64 bit wide, otherwise you will get mod 2^32 arithmetics.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40737, "question": "Haskell is slooow https://github.com/logicchains/LPATHBench/blob/master/writeup.md", "aSentId": 40738, "answer": "That's a highly questionable benchmark to generalize from. It looks like a highly imperative/stateful/impure pathfinding algorithm, which will obviously suffer an impedance mismatch when written in a declarative/stateless/pure language. Without going through the author's code carefully, I would also avoid assuming he correctly leveraged strictness annotation and Haskell's various mutable programming features (like ST).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40739, "question": "That's a highly questionable benchmark to generalize from. It looks like a highly imperative/stateful/impure pathfinding algorithm, which will obviously suffer an impedance mismatch when written in a declarative/stateless/pure language. Without going through the author's code carefully, I would also avoid assuming he correctly leveraged strictness annotation and Haskell's various mutable programming features (like ST).", "aSentId": 40740, "answer": "For what it's worth, the Haskell implementation was originally faster than the Java implementation (which used classes). But then someone came along and converted the Java implementation to use primitive arrays instead of classes (simulating value types), while no-one stepped in to similarly optimise the Haskell. \n\nPersonally I think the Haskell implementation was slowed down by the use of an IORef, which was unavoidable in the algorithm.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40741, "question": "For what it's worth, the Haskell implementation was originally faster than the Java implementation (which used classes). But then someone came along and converted the Java implementation to use primitive arrays instead of classes (simulating value types), while no-one stepped in to similarly optimise the Haskell. \n\nPersonally I think the Haskell implementation was slowed down by the use of an IORef, which was unavoidable in the algorithm.\n", "aSentId": 40742, "answer": "&gt;Personally I think the Haskell implementation was slowed down by the use of an IORef, which was unavoidable in the algorithm.\n\nI suspect performance may improve using ST instead of IO, but I'm not certain. At the very least, it would avoid extraneous use of the IO type.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40744, "question": "It's about even with c++, not c. With enough memory, and GC costs, and startup time.\n\nOcaml can compile natively. It's fast. And not really a fair fight. Ocaml is real good and competitive with c in some arenas. But tough to deal with initially. I'm a big ocaml fan but can't use it in production.", "aSentId": 40745, "answer": "F# has ocaml roots, so that may be of interest.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40747, "question": "&gt; Why do many software engineers not like Java?\n\nThey don't.\n\nSeriously, I know it might be hard to believe, especially if you spend time reading reddit, HN or if you are subscribed to a few mailing-lists on the subject (which means you are part of a very tiny minority), but the bottom line is that the majority of Java developers is quite happy with Java.\n\nIf you are one of these bleeding edge developers who keep their knowledge current, are aware of Scala, Kotlin, Ceylon, Clojure or maybe even ML or Haskell, you are convinced that Java is an abomination and that certainly, all its users must absolutely hate it. And you are dead, dead wrong about that.\n\nBefore Java, we had C++, and if in the 1990-1995 period, you had interviewed C++ developers, you would probably have found out that a huge proportion of C++ developers absolutely hated programming in this language. Which set the stage for Java to take over in 1995.\n\nI'm not seeing this today. There are no rabid mobs of developers with pitchforks massing at the gates and asking for a revolution. Java is respected for its productivity, its readability and its unbeatable fast path to getting things done in a way that's scalable and maintainable.\n\nWhich is why that it's not going to be replaced any time soon. Not by Scala, not by Kotlin, not by Ceylon. In a lustrum, maybe. But not in the near future.\n\nJava is fine, it's liked, it's respected (for good and bad reasons) and it's going to be around for a very, very long time.\n", "aSentId": 40748, "answer": "I am one of those bleeding edge developers you mention, I know Lisp, ML, Haskell and am currently looking into Rust. And I'm also a Java developer, and quite happy with Java.\n\nJava sucks at some points, yes, but not as hard as many think. For a lot of problems, it's actually quite capable, and the specific pain points some folks never tire to mention either can be worked around with little effort or don't impair productivity as much as they think anyway. Also, frankly, the tooling just rocks.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40749, "question": "I am one of those bleeding edge developers you mention, I know Lisp, ML, Haskell and am currently looking into Rust. And I'm also a Java developer, and quite happy with Java.\n\nJava sucks at some points, yes, but not as hard as many think. For a lot of problems, it's actually quite capable, and the specific pain points some folks never tire to mention either can be worked around with little effort or don't impair productivity as much as they think anyway. Also, frankly, the tooling just rocks.", "aSentId": 40750, "answer": "&gt; I am one of those bleeding edge developers you mention, I know Lisp, ML, Haskell\n\n* Lisp: 1960\n* ML: 1979\n* Caml: 1987\n* Haskell: 1990\n\nIt's funny that those are considered bleeding edge. And I picked the year of the first formal publication. In reality, even Haskell is several years older than the mature (read: old-fashioned) Java.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40751, "question": "&gt; I am one of those bleeding edge developers you mention, I know Lisp, ML, Haskell\n\n* Lisp: 1960\n* ML: 1979\n* Caml: 1987\n* Haskell: 1990\n\nIt's funny that those are considered bleeding edge. And I picked the year of the first formal publication. In reality, even Haskell is several years older than the mature (read: old-fashioned) Java.", "aSentId": 40752, "answer": "I guess it's more that those languages have seen increased popularity (and changes, probably) recently.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40751, "question": "&gt; I am one of those bleeding edge developers you mention, I know Lisp, ML, Haskell\n\n* Lisp: 1960\n* ML: 1979\n* Caml: 1987\n* Haskell: 1990\n\nIt's funny that those are considered bleeding edge. And I picked the year of the first formal publication. In reality, even Haskell is several years older than the mature (read: old-fashioned) Java.", "aSentId": 40754, "answer": "Well, at least Haskell has changed quite a bit since the first release. Even Rust, which is pre-1.0 has been there for some years.\n\nSorry, but Clojure, Ceylon and Kotlin, while being nice, bring no dramatically new ideas to the table.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40749, "question": "I am one of those bleeding edge developers you mention, I know Lisp, ML, Haskell and am currently looking into Rust. And I'm also a Java developer, and quite happy with Java.\n\nJava sucks at some points, yes, but not as hard as many think. For a lot of problems, it's actually quite capable, and the specific pain points some folks never tire to mention either can be worked around with little effort or don't impair productivity as much as they think anyway. Also, frankly, the tooling just rocks.", "aSentId": 40756, "answer": "As one of those bleeding edge developers who developed Java professionally for a decade before moving to Clojure, I would not go back to working with Java.\n\nMy team saw a huge leap in productivity compared to the similar scope projects we've done in Java. The language does play a big role in this. Being able to write code close to the problem domain makes the code base much smaller and easier to maintain.\n\nHaving drastically less code has impact on things like refactoring. When it takes you a 100 lines to solve a problem you're not all that attached to the code. When it takes you a 1000 then you're much less likely to want to revisit it.\n\nBeing able to safely reason about parts of application in is a huge benefit when you're working on a large project with a team. I know that I can work on my piece and I'm guaranteed that it doesn't have any shared state with another piece somebody else is working on.\n\nWhen I come back to some code 6 months down the road I know that the changes I make are guaranteed to be local. I don't have to remember how it interacts with the rest of the application, where the data is coming from and where it's going.\n\nI also agree that tooling is important. I find REPL to be an indispensable tool. With it I can solve problems interactively and see exactly what the code is doing. Having it integrated into the workflow makes development a far more pleasant experience.\n\nAside from that, I find you have pretty much the same tooling you have for Java. You've got Leiningen or Maven for doing builds, you can use the same profilers, build servers, and deployment targets.\n\nYou can also use the same IDEs such as Eclipse or IntelliJ. The refactoring support might not be as powerful, but you also tend to have orders of magnitude less code. I'd much rather have less code to work with than fancy tools to help me manage giant heaps of it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40757, "question": "As one of those bleeding edge developers who developed Java professionally for a decade before moving to Clojure, I would not go back to working with Java.\n\nMy team saw a huge leap in productivity compared to the similar scope projects we've done in Java. The language does play a big role in this. Being able to write code close to the problem domain makes the code base much smaller and easier to maintain.\n\nHaving drastically less code has impact on things like refactoring. When it takes you a 100 lines to solve a problem you're not all that attached to the code. When it takes you a 1000 then you're much less likely to want to revisit it.\n\nBeing able to safely reason about parts of application in is a huge benefit when you're working on a large project with a team. I know that I can work on my piece and I'm guaranteed that it doesn't have any shared state with another piece somebody else is working on.\n\nWhen I come back to some code 6 months down the road I know that the changes I make are guaranteed to be local. I don't have to remember how it interacts with the rest of the application, where the data is coming from and where it's going.\n\nI also agree that tooling is important. I find REPL to be an indispensable tool. With it I can solve problems interactively and see exactly what the code is doing. Having it integrated into the workflow makes development a far more pleasant experience.\n\nAside from that, I find you have pretty much the same tooling you have for Java. You've got Leiningen or Maven for doing builds, you can use the same profilers, build servers, and deployment targets.\n\nYou can also use the same IDEs such as Eclipse or IntelliJ. The refactoring support might not be as powerful, but you also tend to have orders of magnitude less code. I'd much rather have less code to work with than fancy tools to help me manage giant heaps of it.", "aSentId": 40758, "answer": "&gt; When I come back to some code 6 months down the road I know that the changes I make are guaranteed to be local. I don't have to remember how it interacts with the rest of the application, where the data is coming from and where it's going.\n\nWhy do you get this with clojure and not java, isn't it just the way you structure your code?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40759, "question": "&gt; When I come back to some code 6 months down the road I know that the changes I make are guaranteed to be local. I don't have to remember how it interacts with the rest of the application, where the data is coming from and where it's going.\n\nWhy do you get this with clojure and not java, isn't it just the way you structure your code?", "aSentId": 40760, "answer": "With Clojure everything is immutable by default and functions are pure. I only need to understand the specific of the code I wish to change in order to know that the change works.\n\nIn Java pretty much everything is mutable and you're dealing with references. It's much harder to tell what the scope of a particular change is without knowing every other place in the application that might reference the same data. Any time you call a function with side effects it might be changing something in an unexpected way.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40761, "question": "With Clojure everything is immutable by default and functions are pure. I only need to understand the specific of the code I wish to change in order to know that the change works.\n\nIn Java pretty much everything is mutable and you're dealing with references. It's much harder to tell what the scope of a particular change is without knowing every other place in the application that might reference the same data. Any time you call a function with side effects it might be changing something in an unexpected way.\n", "aSentId": 40762, "answer": "\n&gt; Any time you call a function with side effects it might be changing something in an unexpected way.\n\nAlleging thing without giving a concrete context of your claims, \n\nAnd what is this something that your are talking about, how this something is gonna affect the rest of the program running if it state is changed?\n\nIs this \"something\", immutable?\n\nHow big is the program?\n\nWhat are the side effects?\n\nAre best practice applied on the overall architecture to avoid or predict the effects that cause this type of change?\n\nAre we talking about global variable?\n\nHow the data represented?\n\nHow much is the complexity of data?\n\nThe cost of copying data vs mutate it is viable for this program?\n\nI could go on. But I think that you are sensationalizing your claims a little bit too much and baking them up with the most convenient scenarios for their sake.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40757, "question": "As one of those bleeding edge developers who developed Java professionally for a decade before moving to Clojure, I would not go back to working with Java.\n\nMy team saw a huge leap in productivity compared to the similar scope projects we've done in Java. The language does play a big role in this. Being able to write code close to the problem domain makes the code base much smaller and easier to maintain.\n\nHaving drastically less code has impact on things like refactoring. When it takes you a 100 lines to solve a problem you're not all that attached to the code. When it takes you a 1000 then you're much less likely to want to revisit it.\n\nBeing able to safely reason about parts of application in is a huge benefit when you're working on a large project with a team. I know that I can work on my piece and I'm guaranteed that it doesn't have any shared state with another piece somebody else is working on.\n\nWhen I come back to some code 6 months down the road I know that the changes I make are guaranteed to be local. I don't have to remember how it interacts with the rest of the application, where the data is coming from and where it's going.\n\nI also agree that tooling is important. I find REPL to be an indispensable tool. With it I can solve problems interactively and see exactly what the code is doing. Having it integrated into the workflow makes development a far more pleasant experience.\n\nAside from that, I find you have pretty much the same tooling you have for Java. You've got Leiningen or Maven for doing builds, you can use the same profilers, build servers, and deployment targets.\n\nYou can also use the same IDEs such as Eclipse or IntelliJ. The refactoring support might not be as powerful, but you also tend to have orders of magnitude less code. I'd much rather have less code to work with than fancy tools to help me manage giant heaps of it.", "aSentId": 40764, "answer": "I usually whip up a quick unit test + debugger if I need to test something, but I also sometimes just start a beanshell.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40765, "question": "I usually whip up a quick unit test + debugger if I need to test something, but I also sometimes just start a beanshell.", "aSentId": 40766, "answer": "Sure, but that's still more work than simply being able to look at a function and know what it's doing definitely. The other big aspect of it is the REPL, which provides far more fluid integration than the debugger or the beanshell. As you can see [here](https://cursiveclojure.com/userguide/repl.html) the editor is linked up with the running image of the app and you can evaluate any function you write directly in the context of the application.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40749, "question": "I am one of those bleeding edge developers you mention, I know Lisp, ML, Haskell and am currently looking into Rust. And I'm also a Java developer, and quite happy with Java.\n\nJava sucks at some points, yes, but not as hard as many think. For a lot of problems, it's actually quite capable, and the specific pain points some folks never tire to mention either can be worked around with little effort or don't impair productivity as much as they think anyway. Also, frankly, the tooling just rocks.", "aSentId": 40768, "answer": "How much shorter do you think your programs would be if you were allowed to write them in either Lisp, ML, or Haskell?\n\nMy personal wild guess is somewhere between 3 and a full order of magnitude. Java may be fine, but whenever I see a lost opportunity for brevity and simplicity, the gap between what I have and what I know kills me. The only way I'm still happy at my current, C++/Qt day job, is because I'm currently learning OOP based GUI programming, and don't know any other way yet. I kinda fear the day when I will.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40769, "question": "How much shorter do you think your programs would be if you were allowed to write them in either Lisp, ML, or Haskell?\n\nMy personal wild guess is somewhere between 3 and a full order of magnitude. Java may be fine, but whenever I see a lost opportunity for brevity and simplicity, the gap between what I have and what I know kills me. The only way I'm still happy at my current, C++/Qt day job, is because I'm currently learning OOP based GUI programming, and don't know any other way yet. I kinda fear the day when I will.\n\n", "aSentId": 40770, "answer": "Well, part of my programs could be considerably shorter. Of those, I generate a good percentage (e.g. Lombok). But I do a lot of number crunching, and the arithmetic looks the same whether I write it in Java or Haskell.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40772, "question": "Java has classes and objects. You'd be looking long for a more powerful abstraction mechanism than that. Other languages might have more abstraction tools that are more suited to some situations, but objects can almost always get the job done. Other mechanisms are just more terse, which can be valuable, but they are not strictly speaking more powerful.\n\nWhat Java lacks is some sort of syntactic abstraction such as e.g. macros or haskells handling of two argument functions. ", "aSentId": 40773, "answer": "I'd say that the two things that Java is really hurting for are first-class functions and closures.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40774, "question": "I'd say that the two things that Java is really hurting for are first-class functions and closures.", "aSentId": 40775, "answer": "And the lack of a not brain-dead datetime/calendar library.\n\nWooo Java 8. I'll probably never be able to upgrade to Java 8. Also, I'm pretty sure it's anonymous functions are internally just converted to classes anyway, and are really just sugar. But I like sugar.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40776, "question": "And the lack of a not brain-dead datetime/calendar library.\n\nWooo Java 8. I'll probably never be able to upgrade to Java 8. Also, I'm pretty sure it's anonymous functions are internally just converted to classes anyway, and are really just sugar. But I like sugar.", "aSentId": 40777, "answer": "You don't like joda?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40778, "question": "You don't like joda?", "aSentId": 40779, "answer": "We don't use joda. And the builtins are infuriating.\n\nI think I'm going to jam it in on Monday and see if anyone notices. We have a ton of garbage date and time code that should have been using joda forever ago, but we haven't had time to rewrite it all. So for some reason that meant we just never started using it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40772, "question": "Java has classes and objects. You'd be looking long for a more powerful abstraction mechanism than that. Other languages might have more abstraction tools that are more suited to some situations, but objects can almost always get the job done. Other mechanisms are just more terse, which can be valuable, but they are not strictly speaking more powerful.\n\nWhat Java lacks is some sort of syntactic abstraction such as e.g. macros or haskells handling of two argument functions. ", "aSentId": 40781, "answer": "&gt; Java has classes and objects\n\nIn Java context those two are more of less same thing. I think you mean interfaces and objects and it is an okayish abstraction mechanism, but not exactly powerful.\n\nAm I wrong to assume you don't really understand other abstractions other those found in OOP nowadays? Because terseness in the non-oop abstractions you refer to are not the strengths of these abstractions.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40782, "question": "&gt; Java has classes and objects\n\nIn Java context those two are more of less same thing. I think you mean interfaces and objects and it is an okayish abstraction mechanism, but not exactly powerful.\n\nAm I wrong to assume you don't really understand other abstractions other those found in OOP nowadays? Because terseness in the non-oop abstractions you refer to are not the strengths of these abstractions.", "aSentId": 40783, "answer": "&gt; Because terseness in the non-oop abstractions you refer to are not the strengths of these abstractions.\n\nIf you're saying what I think you're saying, I agree with you.\n\nJava is predominant in the enterprise, and OOP abstractions are more communicable for the concepts an people in that environment than non-OOP abstractions. For example, it is easier to explain the concept of an Account.withdraw() operation to an entire team than explaining a monad.\n\nOn the other hand, if you were to write software in a team where mathematics is predominant, functional abstractions would be better suited.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40782, "question": "&gt; Java has classes and objects\n\nIn Java context those two are more of less same thing. I think you mean interfaces and objects and it is an okayish abstraction mechanism, but not exactly powerful.\n\nAm I wrong to assume you don't really understand other abstractions other those found in OOP nowadays? Because terseness in the non-oop abstractions you refer to are not the strengths of these abstractions.", "aSentId": 40785, "answer": "I think you are wrong to assume that. Objects (and by the same token, closures) are the most general purpose abstraction mechanisms there are, even the things done with call/cc and friends can be done using objects, just in different ways. \n\nThis is not to say that objects are the most optimal way to do things, it is just to say that Java has a very powerful abstraction mechanism at its disposal which means it very rarely leaves you hanging even if it might be a bit (quite even) verbose.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40747, "question": "&gt; Why do many software engineers not like Java?\n\nThey don't.\n\nSeriously, I know it might be hard to believe, especially if you spend time reading reddit, HN or if you are subscribed to a few mailing-lists on the subject (which means you are part of a very tiny minority), but the bottom line is that the majority of Java developers is quite happy with Java.\n\nIf you are one of these bleeding edge developers who keep their knowledge current, are aware of Scala, Kotlin, Ceylon, Clojure or maybe even ML or Haskell, you are convinced that Java is an abomination and that certainly, all its users must absolutely hate it. And you are dead, dead wrong about that.\n\nBefore Java, we had C++, and if in the 1990-1995 period, you had interviewed C++ developers, you would probably have found out that a huge proportion of C++ developers absolutely hated programming in this language. Which set the stage for Java to take over in 1995.\n\nI'm not seeing this today. There are no rabid mobs of developers with pitchforks massing at the gates and asking for a revolution. Java is respected for its productivity, its readability and its unbeatable fast path to getting things done in a way that's scalable and maintainable.\n\nWhich is why that it's not going to be replaced any time soon. Not by Scala, not by Kotlin, not by Ceylon. In a lustrum, maybe. But not in the near future.\n\nJava is fine, it's liked, it's respected (for good and bad reasons) and it's going to be around for a very, very long time.\n", "aSentId": 40787, "answer": "I've always maintained that HN and Reddit over represents the startup mentality in almost everything. In reality a ton of Java is written (if you asked around here everyone would think that Java is legacy only), and it seems to be working just fine.\n\nEventually it'll go, of course. It'd be foolisg to say that Java is it, but there's not a ton of evidence that the time is now.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40788, "question": "I've always maintained that HN and Reddit over represents the startup mentality in almost everything. In reality a ton of Java is written (if you asked around here everyone would think that Java is legacy only), and it seems to be working just fine.\n\nEventually it'll go, of course. It'd be foolisg to say that Java is it, but there's not a ton of evidence that the time is now.", "aSentId": 40789, "answer": "It over represents opinions from people who care enough about their profession to browse /r/programming. These are the same people who are dissatisfied with working in poor languages. People who don't care would rather stay with whatever they already know. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40790, "question": "It over represents opinions from people who care enough about their profession to browse /r/programming. These are the same people who are dissatisfied with working in poor languages. People who don't care would rather stay with whatever they already know. ", "aSentId": 40791, "answer": "&gt; People who don't care would rather stay with whatever they already know.\n\nOr stay with what you're being paid to use. Because I like other languages too, but I only get paid to use Java.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40792, "question": "&gt; People who don't care would rather stay with whatever they already know.\n\nOr stay with what you're being paid to use. Because I like other languages too, but I only get paid to use Java.", "aSentId": 40793, "answer": "If you know what you're doing you can work in any language you like. There are plenty of jobs for niche languages and there's often less competition because less people know them.\n\nWhen you're applying for Java jobs you're competing with a huge pool of people. It makes it much harder to differentiate yourself from the rest of the crowd.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40794, "question": "If you know what you're doing you can work in any language you like. There are plenty of jobs for niche languages and there's often less competition because less people know them.\n\nWhen you're applying for Java jobs you're competing with a huge pool of people. It makes it much harder to differentiate yourself from the rest of the crowd.", "aSentId": 40795, "answer": "Perhaps, but I haven't found many jobs for niche languages in my country, and as a junior developer you're always competing with a lot of people.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40794, "question": "If you know what you're doing you can work in any language you like. There are plenty of jobs for niche languages and there's often less competition because less people know them.\n\nWhen you're applying for Java jobs you're competing with a huge pool of people. It makes it much harder to differentiate yourself from the rest of the crowd.", "aSentId": 40797, "answer": "Bollocks. The first part. The second is irrelevant for the topic.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40790, "question": "It over represents opinions from people who care enough about their profession to browse /r/programming. These are the same people who are dissatisfied with working in poor languages. People who don't care would rather stay with whatever they already know. ", "aSentId": 40799, "answer": "I can name some poor damn languages, but Java isn't on the list.\n\nWhat is? PHP, Python, JavaScript, and Ruby. Ugh. Do not fucking want. Dynamic typing is a terrible idea.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40800, "question": "I can name some poor damn languages, but Java isn't on the list.\n\nWhat is? PHP, Python, JavaScript, and Ruby. Ugh. Do not fucking want. Dynamic typing is a terrible idea.", "aSentId": 40801, "answer": "At least those languages tell you up front that they're dynamic. Java's type system isn't much better, and there's a lot of casting to and from Object that happens behind the scenes. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40802, "question": "At least those languages tell you up front that they're dynamic. Java's type system isn't much better, and there's a lot of casting to and from Object that happens behind the scenes. ", "aSentId": 40803, "answer": "Yeah, but it's behind the scenes. The compiler is still doing the type checks.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40788, "question": "I've always maintained that HN and Reddit over represents the startup mentality in almost everything. In reality a ton of Java is written (if you asked around here everyone would think that Java is legacy only), and it seems to be working just fine.\n\nEventually it'll go, of course. It'd be foolisg to say that Java is it, but there's not a ton of evidence that the time is now.", "aSentId": 40805, "answer": "There is no such thing as \"it\". As long as computer science exists, new languages will keep getting invented.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40788, "question": "I've always maintained that HN and Reddit over represents the startup mentality in almost everything. In reality a ton of Java is written (if you asked around here everyone would think that Java is legacy only), and it seems to be working just fine.\n\nEventually it'll go, of course. It'd be foolisg to say that Java is it, but there's not a ton of evidence that the time is now.", "aSentId": 40807, "answer": "&gt; In reality a ton of Java is written (if you asked around here everyone would think that Java is legacy only), and it seems to be working just fine.\n\nA lot of things *seems* to be working just fine. Until they don't.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40747, "question": "&gt; Why do many software engineers not like Java?\n\nThey don't.\n\nSeriously, I know it might be hard to believe, especially if you spend time reading reddit, HN or if you are subscribed to a few mailing-lists on the subject (which means you are part of a very tiny minority), but the bottom line is that the majority of Java developers is quite happy with Java.\n\nIf you are one of these bleeding edge developers who keep their knowledge current, are aware of Scala, Kotlin, Ceylon, Clojure or maybe even ML or Haskell, you are convinced that Java is an abomination and that certainly, all its users must absolutely hate it. And you are dead, dead wrong about that.\n\nBefore Java, we had C++, and if in the 1990-1995 period, you had interviewed C++ developers, you would probably have found out that a huge proportion of C++ developers absolutely hated programming in this language. Which set the stage for Java to take over in 1995.\n\nI'm not seeing this today. There are no rabid mobs of developers with pitchforks massing at the gates and asking for a revolution. Java is respected for its productivity, its readability and its unbeatable fast path to getting things done in a way that's scalable and maintainable.\n\nWhich is why that it's not going to be replaced any time soon. Not by Scala, not by Kotlin, not by Ceylon. In a lustrum, maybe. But not in the near future.\n\nJava is fine, it's liked, it's respected (for good and bad reasons) and it's going to be around for a very, very long time.\n", "aSentId": 40809, "answer": "I'm one of those bleeding edge developers, and believe it or not, I'm _still quite happy with java_.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40810, "question": "I'm one of those bleeding edge developers, and believe it or not, I'm _still quite happy with java_.", "aSentId": 40811, "answer": "Same here, latest fun language has been purescript.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40813, "question": "I hoped to see a large-scale interview when I saw the title. Without that you can't really say whether java developers are happy with their language or not.\n\nLooking on Reddit I see people advocating about all kinds of languages. You'll find APL, C, C++, PHP, Fortran lovers. Wouldn't be surprised if somebody says he loves cobol or basic.\n\nYou probably can't know if people hated C++ in the 1990-1995 period, similar to how you can't know if people hate java now. We don't have the data to drive those conclusion. Besides you've pretty much proved this far that such study couldn't lead us to other conclusions. Popularity of a programming language isn't rooted into it's quality.\n\nI'm surprised to hear that you respect java for it's productivity and readability, though. But maybe you're doing so simple things that it works out.", "aSentId": 40814, "answer": "I think it's extremely readable, because unlike functional languages and newer languages it doesn't encourage the cleverness that often impedes code readability. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40815, "question": "I think it's extremely readable, because unlike functional languages and newer languages it doesn't encourage the cleverness that often impedes code readability. ", "aSentId": 40816, "answer": "I remember having heard that kind of argument. Somebody said it about Visual Basic or QBasic. Again, given certain constraints, it's true.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40815, "question": "I think it's extremely readable, because unlike functional languages and newer languages it doesn't encourage the cleverness that often impedes code readability. ", "aSentId": 40818, "answer": "Layering several abstractions, spread across various files/packages, just to achieve future maintainability impairs readability. Shared mutable state impairs understanding, and thus readability.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40819, "question": "Layering several abstractions, spread across various files/packages, just to achieve future maintainability impairs readability. Shared mutable state impairs understanding, and thus readability.", "aSentId": 40820, "answer": "Layering several layers of abstraction and composing several functions both impair readability in the same way (not that much). ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40821, "question": "Layering several layers of abstraction and composing several functions both impair readability in the same way (not that much). ", "aSentId": 40822, "answer": "Ya, I wasn't clear. The issue I was trying to get across is the lack of locality with regards to the control flow that is forced upon the developer because the tools in the language are verbose and spread across several files/packages. Add to that the lack of expressiveness has encouraged the use of heavier frameworks/libraries to lower the boilerplate, but often with the cost of obscuring the flow even more. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40823, "question": "Ya, I wasn't clear. The issue I was trying to get across is the lack of locality with regards to the control flow that is forced upon the developer because the tools in the language are verbose and spread across several files/packages. Add to that the lack of expressiveness has encouraged the use of heavier frameworks/libraries to lower the boilerplate, but often with the cost of obscuring the flow even more. ", "aSentId": 40824, "answer": "You just have to use the right tool with it. That means a text editor that can jump to definitions. There are a lot of them for free and paid. Then locality doesn't matter a bit.\n\nAnd really, it doesn't' matter if you know how the called methods work anyway. The whole point of functions and objects is that you trust that they do what they say they do. When they don't and you have to debug, it's not hard to see which methods or functions aren't abiding by their stated functionality, as long as you have a good debugger. Java has good debuggers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40827, "question": "I love java.  I use it for fun even on my personal projects.\n", "aSentId": 40828, "answer": "Which other languages do you know?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40829, "question": "Which other languages do you know?", "aSentId": 40830, "answer": "I like Java, but I never use it on my personal projects. I like C# but I'd I'd never pay for the licenses needed to run it for personal projects and Mono isn't quite there yet.\n\nI dislike PHP but it's up and running in seconds, so it gets the call up often. I've dabbled with python but the latest major release fucked everything and now it's like there are two languages and the documentation and libraries are only sort of correct now.\n\nI think for my next big non-scripted project I'm going to try out Scala.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40831, "question": "I like Java, but I never use it on my personal projects. I like C# but I'd I'd never pay for the licenses needed to run it for personal projects and Mono isn't quite there yet.\n\nI dislike PHP but it's up and running in seconds, so it gets the call up often. I've dabbled with python but the latest major release fucked everything and now it's like there are two languages and the documentation and libraries are only sort of correct now.\n\nI think for my next big non-scripted project I'm going to try out Scala.", "aSentId": 40832, "answer": "&gt; I like C# but I'd I'd never pay for the licenses needed to run it for personal projects and Mono isn't quite there yet.\n\nJust curious but since you don't mean Mono here(or xamarin thats based on it) what do you mean by needing to pay for licenses to run C#? ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40833, "question": "&gt; I like C# but I'd I'd never pay for the licenses needed to run it for personal projects and Mono isn't quite there yet.\n\nJust curious but since you don't mean Mono here(or xamarin thats based on it) what do you mean by needing to pay for licenses to run C#? ", "aSentId": 40834, "answer": "OS licenses. Visual studio licenses.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40835, "question": "OS licenses. Visual studio licenses.", "aSentId": 40836, "answer": "You should check out the community edition of VS.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40837, "question": "You should check out the community edition of VS.", "aSentId": 40838, "answer": "Good if I'm working by myself, not so good if I want to start up a business with a team... gotta pay then.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40839, "question": "Good if I'm working by myself, not so good if I want to start up a business with a team... gotta pay then.", "aSentId": 40840, "answer": "If you have a team of +5 people working for you, then I seriously doubt that putting out some cash for a VS license is going to hurt you at all. \n\nYou're just bitching and expecting a top quality IDE to be given away for free just like your inferior java stuff.\n\nThat's right, keep using your retarded free \"eclipse\" crap, and make sure you gather some savings for the medical treatment of the java-induced cancer in the balls.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40841, "question": "If you have a team of +5 people working for you, then I seriously doubt that putting out some cash for a VS license is going to hurt you at all. \n\nYou're just bitching and expecting a top quality IDE to be given away for free just like your inferior java stuff.\n\nThat's right, keep using your retarded free \"eclipse\" crap, and make sure you gather some savings for the medical treatment of the java-induced cancer in the balls.", "aSentId": 40842, "answer": "I use about 4 languages on a day-day basis at work, including both Java and C# in VS and Eclipse.\n\nI also know that we forked out a ton of cash for the licensing to Microsoft, money that could have instead been my bonus.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40841, "question": "If you have a team of +5 people working for you, then I seriously doubt that putting out some cash for a VS license is going to hurt you at all. \n\nYou're just bitching and expecting a top quality IDE to be given away for free just like your inferior java stuff.\n\nThat's right, keep using your retarded free \"eclipse\" crap, and make sure you gather some savings for the medical treatment of the java-induced cancer in the balls.", "aSentId": 40844, "answer": "IntelliJ is also free.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40835, "question": "OS licenses. Visual studio licenses.", "aSentId": 40846, "answer": "Visual Studio Community Edition is free. This isn't the limited express version. I paid more for my apple mouse pad than I did my Windows 8 license but I really can't fault you if you are that poor.   ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40847, "question": "Visual Studio Community Edition is free. This isn't the limited express version. I paid more for my apple mouse pad than I did my Windows 8 license but I really can't fault you if you are that poor.   ", "aSentId": 40848, "answer": "Can you sell software written with the community version?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40849, "question": "Can you sell software written with the community version?", "aSentId": 40850, "answer": "Of course you can. LOL what a stupidity. Why is java people so very much convinced that the entire universe is somehow frozen in 1990???", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40851, "question": "Of course you can. LOL what a stupidity. Why is java people so very much convinced that the entire universe is somehow frozen in 1990???", "aSentId": 40852, "answer": "Maybe because Microsoft audited our office and made us pay over 6 figures in license fees for VS and Windows server?\n\nYou can't sell software that isn't open source made with VS Community edition if you work for an \"organization\". It's right in their ToS.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40853, "question": "Maybe because Microsoft audited our office and made us pay over 6 figures in license fees for VS and Windows server?\n\nYou can't sell software that isn't open source made with VS Community edition if you work for an \"organization\". It's right in their ToS.", "aSentId": 40854, "answer": "&gt; You can't sell software that isn't open source made with VS Community edition if you work for an \"organization\". It's right in their ToS\n\nWe were specifically talking about \"for personal projects\" as thats where my question originated. The license allows you to sell software in that regard. The license makes it clear even a personal project of up to five people working on it does not constitute an \"organization\".  \n\n&gt; Maybe because Microsoft audited our office and made us pay over 6 figures in license fees for VS and Windows server?\n\nWere they making your office pay for unlicensed copies of the software that your office was running?  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40855, "question": "&gt; You can't sell software that isn't open source made with VS Community edition if you work for an \"organization\". It's right in their ToS\n\nWe were specifically talking about \"for personal projects\" as thats where my question originated. The license allows you to sell software in that regard. The license makes it clear even a personal project of up to five people working on it does not constitute an \"organization\".  \n\n&gt; Maybe because Microsoft audited our office and made us pay over 6 figures in license fees for VS and Windows server?\n\nWere they making your office pay for unlicensed copies of the software that your office was running?  ", "aSentId": 40856, "answer": "Well, they did an audit, I'm not certain why. The result of which was that we had to pay for a number of licenses we weren't paying for previously. I can only speculate.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40857, "question": "Well, they did an audit, I'm not certain why. The result of which was that we had to pay for a number of licenses we weren't paying for previously. I can only speculate.", "aSentId": 40858, "answer": "&gt;Well, they did an audit, I'm not certain why. The result of which was that we had to pay for a number of licenses we weren't paying for previously. I can only speculate.\n\nCome on.  I just spoke with our software attorney and if it was provable all that all the licenses you were using were legit Microsoft can't have found you responsible for paying anything. It doesn't require speculation. Whether your company has licenses or not is not a subjective piece of information. There is either a record of your license or there is not.  If your org ponied up that much rather than fight something they could easily win tells me exactly what I need to know. Either your organization is made up epic imbeciles for not fighting with their evidence of licenses or they know they were caught red handed.  I would side with the latter.  \n\n&gt; The result of which was that we had to pay for a number of licenses **we weren't paying for previously**.\n\nSee. No need to speculate. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40859, "question": "&gt;Well, they did an audit, I'm not certain why. The result of which was that we had to pay for a number of licenses we weren't paying for previously. I can only speculate.\n\nCome on.  I just spoke with our software attorney and if it was provable all that all the licenses you were using were legit Microsoft can't have found you responsible for paying anything. It doesn't require speculation. Whether your company has licenses or not is not a subjective piece of information. There is either a record of your license or there is not.  If your org ponied up that much rather than fight something they could easily win tells me exactly what I need to know. Either your organization is made up epic imbeciles for not fighting with their evidence of licenses or they know they were caught red handed.  I would side with the latter.  \n\n&gt; The result of which was that we had to pay for a number of licenses **we weren't paying for previously**.\n\nSee. No need to speculate. ", "aSentId": 40860, "answer": "I don't have hard evidence. In fact, the only evidence I have that there *was* an audit is hearsay. But feel free to keep drawing conclusions on third hand information which isn't relevant to the conversation - that unless you are ripping someone off, running Microsoft stuff at a small company is more expensive than Linux. I don't need to fight with you over the semantic definition of the word speculate.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40861, "question": "I don't have hard evidence. In fact, the only evidence I have that there *was* an audit is hearsay. But feel free to keep drawing conclusions on third hand information which isn't relevant to the conversation - that unless you are ripping someone off, running Microsoft stuff at a small company is more expensive than Linux. I don't need to fight with you over the semantic definition of the word speculate.", "aSentId": 40862, "answer": "&gt; In fact, the only evidence I have that there was an audit is hearsay. But feel free to keep drawing conclusions\n\nYou seem to be the one that is drawing conclusion from admitted hearsay about an audit. You first claimed that Microsoft \"made us pay over 6 figures in license fees for VS and Windows server\".  Now the audit itself is hearsay. \n\n&gt; on third hand information which isn't relevant to the conversation\n\nYou bought up the audit and what your company had to pay. If you don't like to be called on something your bring into the conversation to answer the question the other guy asked of you then don't bring it in as your primary reason. \n\n&gt;  that unless you are ripping someone off, running Microsoft stuff at a small company is more expensive than Linux.\n\n&gt;  I don't need to fight with you \n\nThis isn't a fight. I've kept my comments tame without calling you any names. If you think it is you need to step back from the internet for a while and stop taking it so seriously.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40853, "question": "Maybe because Microsoft audited our office and made us pay over 6 figures in license fees for VS and Windows server?\n\nYou can't sell software that isn't open source made with VS Community edition if you work for an \"organization\". It's right in their ToS.", "aSentId": 40864, "answer": "LOL...\n\nMaybe because you had a lot of pirated software and you were using it commercially in a for profit organization?\n\nWho's to blame? MS or yourselves?\n\nWhat would you do if a client of yours suddenly has $100,000 worth of your own products and they didn't pay for that?\n\nAnd why the hell you're bitching from paying VS licenses if you're making money from it?, I already told you, go keep using your retarded \"eclipse\" crap and make sure you protect your balls from java-induced cancer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40865, "question": "LOL...\n\nMaybe because you had a lot of pirated software and you were using it commercially in a for profit organization?\n\nWho's to blame? MS or yourselves?\n\nWhat would you do if a client of yours suddenly has $100,000 worth of your own products and they didn't pay for that?\n\nAnd why the hell you're bitching from paying VS licenses if you're making money from it?, I already told you, go keep using your retarded \"eclipse\" crap and make sure you protect your balls from java-induced cancer.", "aSentId": 40866, "answer": "I already told you I'm paying for and using Visual Studio, troll. And that the cost of it comes directly out of money I could be getting paid.\n\nBut keep praying to your omnipotent diety Microsoft, for it shall save your soul and bring you to the promised land.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40867, "question": "I already told you I'm paying for and using Visual Studio, troll. And that the cost of it comes directly out of money I could be getting paid.\n\nBut keep praying to your omnipotent diety Microsoft, for it shall save your soul and bring you to the promised land.", "aSentId": 40868, "answer": "You and I both know that companies wouldn't increase pay to employees if they didn't have to pay for VS. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40869, "question": "You and I both know that companies wouldn't increase pay to employees if they didn't have to pay for VS. ", "aSentId": 40870, "answer": "Every performance review I have I like to highlight the things that I did that made or saved the company money, in addition to fulfilling my normal duties.\n\nIf that isn't what managers want to see, I don't know what is. The bottom line is always money.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40867, "question": "I already told you I'm paying for and using Visual Studio, troll. And that the cost of it comes directly out of money I could be getting paid.\n\nBut keep praying to your omnipotent diety Microsoft, for it shall save your soul and bring you to the promised land.", "aSentId": 40872, "answer": "I don't give a fuck about microsoft, but none of that makes java less retarded and useless.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40873, "question": "I don't give a fuck about microsoft, but none of that makes java less retarded and useless.", "aSentId": 40874, "answer": "If you want to be a fanboy, learn LISP or Haskell. We don't need your kind.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40875, "question": "If you want to be a fanboy, learn LISP or Haskell. We don't need your kind.", "aSentId": 40876, "answer": "He is pretty much learning f#, he can get enough of the Microsoft's milk, but at least he is on the right path.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40873, "question": "I don't give a fuck about microsoft, but none of that makes java less retarded and useless.", "aSentId": 40878, "answer": "Is sad that the most of the important programs that we use to day are writing on Java and not .Net. I mean, you should thanks Java for giving you delicious toasts every morning :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40879, "question": "Is sad that the most of the important programs that we use to day are writing on Java and not .Net. I mean, you should thanks Java for giving you delicious toasts every morning :)", "aSentId": 40880, "answer": "... And the majority of web sites out there are written in PHP.\n\nThat doesn't make it less retarded and useless either.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40881, "question": "... And the majority of web sites out there are written in PHP.\n\nThat doesn't make it less retarded and useless either.", "aSentId": 40882, "answer": "Websites are websites and toast are toast, apples and oranges here!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40883, "question": "Websites are websites and toast are toast, apples and oranges here!", "aSentId": 40884, "answer": "&gt; apples and oranges here\n\nbut PHP and java are equally retarded and put forward by people who don't know shit.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40885, "question": "&gt; apples and oranges here\n\nbut PHP and java are equally retarded and put forward by people who don't know shit.", "aSentId": 40886, "answer": "At least they know how to put forward something, can you put forward your hate for things that you supposedly don't care nor plan to use on the foreseeing future?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40887, "question": "At least they know how to put forward something, can you put forward your hate for things that you supposedly don't care nor plan to use on the foreseeing future?", "aSentId": 40888, "answer": "I don't \"hate\" anything. everyone knows java sucks balls, even forbes that is totally not related to programming... \n\nLOL you should feel bad for using it, people think (know) it's pure crap.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40889, "question": "I don't \"hate\" anything. everyone knows java sucks balls, even forbes that is totally not related to programming... \n\nLOL you should feel bad for using it, people think (know) it's pure crap.", "aSentId": 40890, "answer": "I not using Java nor PHP for any of my projects, and even .Net is out of question for my purposes. But I feel that Java for taking one, it doesn't need to prove it's worth, believe or not there are people that still use and like to use regardless of the assumption that they know about meadows with greener grass. You should give some respect for those people given that you really can not imagine the context which make then choice that language for their work. Could be the platform, libraries, the cross-platform support, Android (Xamarin is buggy, so I heard multiple times ;)), or making delicious toast, it does not matter. What matter is the thing that people are making with it, not the tools which they are made.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40891, "question": "I not using Java nor PHP for any of my projects, and even .Net is out of question for my purposes. But I feel that Java for taking one, it doesn't need to prove it's worth, believe or not there are people that still use and like to use regardless of the assumption that they know about meadows with greener grass. You should give some respect for those people given that you really can not imagine the context which make then choice that language for their work. Could be the platform, libraries, the cross-platform support, Android (Xamarin is buggy, so I heard multiple times ;)), or making delicious toast, it does not matter. What matter is the thing that people are making with it, not the tools which they are made.", "aSentId": 40892, "answer": "&gt; Xamarin is buggy\n\nThe IDE is buggy, not the framework / platform.\n\nNo one gives a fuck about the IDE because people use Visual Studio.\n\nand yeah, I'd rather deal with cross platform Xamarin (even if it was buggy, which it isn't) code than retarded worthless android only platform lock in of java, with inferior tooling and inferior language.\n\nAnd I also don't give a fuck whether the entire world uses java (or PHP), it still sucks a fuck ton of horse balls (both of them)\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40867, "question": "I already told you I'm paying for and using Visual Studio, troll. And that the cost of it comes directly out of money I could be getting paid.\n\nBut keep praying to your omnipotent diety Microsoft, for it shall save your soul and bring you to the promised land.", "aSentId": 40894, "answer": "&gt; I already told you I'm paying for and using Visual Studio\n\nYour organization or company is paying for Visual Studio right?  Because above you tell us that  \"I'd never pay for the licenses needed to run it for personal projects\".   \n\nI've worked in many different corporate environments using C++, Java, and C#. Not since I graduated college 20 years ago have I thought the price we pay for alls the tools and hardware we use had to do with us not getting a bonus or a raise.  Many of the companies seemed to spend 10x as much a stupid things in other departments that are outside of the tools we needed to have  to complete our projects. I'm willing to bet if your organization is big it  spends more elsewhere and gets a ROI on you that far outweighs any tools they bought for you.  If not, your organization is burning money like a new lotto winner that can't invest and won't be around for long. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40895, "question": "&gt; I already told you I'm paying for and using Visual Studio\n\nYour organization or company is paying for Visual Studio right?  Because above you tell us that  \"I'd never pay for the licenses needed to run it for personal projects\".   \n\nI've worked in many different corporate environments using C++, Java, and C#. Not since I graduated college 20 years ago have I thought the price we pay for alls the tools and hardware we use had to do with us not getting a bonus or a raise.  Many of the companies seemed to spend 10x as much a stupid things in other departments that are outside of the tools we needed to have  to complete our projects. I'm willing to bet if your organization is big it  spends more elsewhere and gets a ROI on you that far outweighs any tools they bought for you.  If not, your organization is burning money like a new lotto winner that can't invest and won't be around for long. ", "aSentId": 40896, "answer": "I wrote a proof of concept for a piece of software that we would have spent well over 100k buying in two days. They gave me 2 weeks to implement it, and it's now in production. Of course, it didn't have the full toolset of the 100k software, but it did what we needed.\n\nMy bonus that was was pretty healthy. Maybe it would have been the same, but I see a pretty clear correlation where I work and making or saving the company money and compensation. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40897, "question": "I wrote a proof of concept for a piece of software that we would have spent well over 100k buying in two days. They gave me 2 weeks to implement it, and it's now in production. Of course, it didn't have the full toolset of the 100k software, but it did what we needed.\n\nMy bonus that was was pretty healthy. Maybe it would have been the same, but I see a pretty clear correlation where I work and making or saving the company money and compensation. ", "aSentId": 40898, "answer": "&gt; I wrote a proof of concept for a piece of software that we would have spent well over 100k buying in two days. They gave me 2 weeks to implement it, and it's now in production. Of course, it didn't have the full toolset of the 100k software, but it did what we needed.\n\nThats the point.  The amount they spent to license your pc and your visual studio is chump change in comparison to what they make off of you. You made the claim elsewhere that the licensing fees were possibly taking away from the your bonus by saying it was \"money that could have instead been my bonus.\"  Its unlikely they realized you saved them 100k but then lowered the bonus you would have gotten for it a certain amount because they had to deduct the comparatively piddly license fees for software on your machine.  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40851, "question": "Of course you can. LOL what a stupidity. Why is java people so very much convinced that the entire universe is somehow frozen in 1990???", "aSentId": 40900, "answer": "Uh, wait a second. I still remember when there wasn't any free version of Visual Studio.NET and the cheapest edition explicitly prohibited selling applications written with it. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40831, "question": "I like Java, but I never use it on my personal projects. I like C# but I'd I'd never pay for the licenses needed to run it for personal projects and Mono isn't quite there yet.\n\nI dislike PHP but it's up and running in seconds, so it gets the call up often. I've dabbled with python but the latest major release fucked everything and now it's like there are two languages and the documentation and libraries are only sort of correct now.\n\nI think for my next big non-scripted project I'm going to try out Scala.", "aSentId": 40902, "answer": "There's no license see associated with \"running C#\".\n\nThe .Net framework is free of charge, and there're 2 free versions of Visual Studio (Express &amp; Community).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40903, "question": "There's no license see associated with \"running C#\".\n\nThe .Net framework is free of charge, and there're 2 free versions of Visual Studio (Express &amp; Community).", "aSentId": 40904, "answer": "Windows, one copy for each server and developer box.\n\nVisual Studio Express and Community can only be used for personal development and selling, not organizational unless it's open source development.\n\nThe point is that it's free to stand up a linux box and run Java, PHP, nodejs, python, Scala, etc, even for a massive company. Unless you want something like RedHat Enterprise edition with support or something.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40905, "question": "Windows, one copy for each server and developer box.\n\nVisual Studio Express and Community can only be used for personal development and selling, not organizational unless it's open source development.\n\nThe point is that it's free to stand up a linux box and run Java, PHP, nodejs, python, Scala, etc, even for a massive company. Unless you want something like RedHat Enterprise edition with support or something.", "aSentId": 40906, "answer": "VS Express can be used for commercial purposes; it doesn't support plugins however.\n\nVS Community can be used for commercial purposes as well, though only by small organizations (up to 250 PCs or $1M revenue), and by 5 users only.\n\nIn any case, beyond a certain company size, developing in C# does cost money indeed, but the overall development, deployment &amp; maintenance costs aren't necessarily higher than \"free\" alternatives.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40905, "question": "Windows, one copy for each server and developer box.\n\nVisual Studio Express and Community can only be used for personal development and selling, not organizational unless it's open source development.\n\nThe point is that it's free to stand up a linux box and run Java, PHP, nodejs, python, Scala, etc, even for a massive company. Unless you want something like RedHat Enterprise edition with support or something.", "aSentId": 40908, "answer": "I think you are right on everything except Community edition only being for personal or OS dev. You can use it to build paid apps.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40909, "question": "I think you are right on everything except Community edition only being for personal or OS dev. You can use it to build paid apps.", "aSentId": 40910, "answer": "I literally just read the licensing info. You can write and sell apps as an individual, but not in an org. I guess I worded that wrong in my other comment.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40911, "question": "I literally just read the licensing info. You can write and sell apps as an individual, but not in an org. I guess I worded that wrong in my other comment.", "aSentId": 40912, "answer": "Right, anything &gt; 5 devs needs an actual license. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40829, "question": "Which other languages do you know?", "aSentId": 40914, "answer": "python, R, groovy, pl-sql, tsql, some experience with html, css, c#, c++, MATLAB, VBA\n\nany suggestions for what I should pick up?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40915, "question": "python, R, groovy, pl-sql, tsql, some experience with html, css, c#, c++, MATLAB, VBA\n\nany suggestions for what I should pick up?", "aSentId": 40916, "answer": "Not necessarily for productive use, but you could take a look at Haskell or ML. I found it quite interesting to get into this totally different way of thinking when programming, although I never used it in RL (yet).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40918, "question": "True, majority of developers see absolutely nothing wrong with Java. It's probably the only language they've used professionally since they got churned out of school and never had a reason to learn anything else during their careers.\n\nMajority of people don't even care about programming all that much in the first place. It's a job and it pays their bills. They punch in, write whatever it is they're told to write and go home to do whatever it is they're actually interested in.\n\nMost of the people who have actual interest in programming learn things on their own time. They're the minority and they're the ones who end up getting jobs in startups and forward thinking companies.\n\nPeople seem to have a lot of hate for anybody who works with a niche language. You hear terms like \"hipsters\", or \"rock stars\". Seems to me a lot of the derision and the hate comes from knowing that these people actually enjoy doing their jobs.", "aSentId": 40919, "answer": "&gt; People seem to have a lot of hate for anybody who works with a niche language. You hear terms like \"hipsters\", or \"rock stars\". Seems to me a lot of the derision and the hate comes from knowing that these people actually enjoy doing their jobs.\n\nSome people fear what they don't understand or see as competition.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40918, "question": "True, majority of developers see absolutely nothing wrong with Java. It's probably the only language they've used professionally since they got churned out of school and never had a reason to learn anything else during their careers.\n\nMajority of people don't even care about programming all that much in the first place. It's a job and it pays their bills. They punch in, write whatever it is they're told to write and go home to do whatever it is they're actually interested in.\n\nMost of the people who have actual interest in programming learn things on their own time. They're the minority and they're the ones who end up getting jobs in startups and forward thinking companies.\n\nPeople seem to have a lot of hate for anybody who works with a niche language. You hear terms like \"hipsters\", or \"rock stars\". Seems to me a lot of the derision and the hate comes from knowing that these people actually enjoy doing their jobs.", "aSentId": 40921, "answer": "Or maybe people like the sector where they are workiing, or maybe they like the company or maybe they like the things they are building. Or they don't like the start up culture where companies have short live span. Or they have some other unkown reason why they punch in Java Your implying that the majority of Java programmers don't care about programming all that much in the first place. This is such generalizing, ignorant and arrogant post, it's fine to be proud of your own work but don't shit on others and say they don't enjoy their work, because they programm in Java.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40923, "question": "I work at a Java-heavy company employing about 70 devs, 60+ of which despise Java. There's only a handful of them that are actually willing to even touch the Java bits.\n\nThere definitely is *a lot* of people that hate Java. At this point, there are some much nicer alternatives (Rust, Go, D, etc.). None have existed long enough to reach the maturity required to supplant Java yet, but I definitely think it will happen within the next 5-10 years.", "aSentId": 40924, "answer": "&gt; There definitely is a lot of people that hate Java. At this point, there are some much nicer alternatives (Rust, Go, D, etc.). None have existed long enough to reach the maturity required to supplant Java yet, but I definitely think it will happen within the next 5-10 years.\n\nNot a chance.\n\nThe space that Java occupies is, if anything, thinning out rather than gaining competitors.  Ten years ago it was the arrival of higher-level scripting languages, more recently there's been the flood of C++-replacements (of which Rust, Go, and D are all members).\n\nThe middle-ground, the managed runtime level, is lacking in competition.  Or rather the competition that exists is complementary (e.g. other JVM languages).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40925, "question": "&gt; There definitely is a lot of people that hate Java. At this point, there are some much nicer alternatives (Rust, Go, D, etc.). None have existed long enough to reach the maturity required to supplant Java yet, but I definitely think it will happen within the next 5-10 years.\n\nNot a chance.\n\nThe space that Java occupies is, if anything, thinning out rather than gaining competitors.  Ten years ago it was the arrival of higher-level scripting languages, more recently there's been the flood of C++-replacements (of which Rust, Go, and D are all members).\n\nThe middle-ground, the managed runtime level, is lacking in competition.  Or rather the competition that exists is complementary (e.g. other JVM languages).", "aSentId": 40926, "answer": "C# says hi. \n\nAnd considering it's gone open source, that's a pretty big competitor. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40927, "question": "C# says hi. \n\nAnd considering it's gone open source, that's a pretty big competitor. ", "aSentId": 40928, "answer": "My BluRay player, set-top box, smart cards, Android tablet, bank, etc. tell me Java is here to stay.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40929, "question": "My BluRay player, set-top box, smart cards, Android tablet, bank, etc. tell me Java is here to stay.\n", "aSentId": 40930, "answer": "But a dude on the internet says it's not, so I just have to go with that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40927, "question": "C# says hi. \n\nAnd considering it's gone open source, that's a pretty big competitor. ", "aSentId": 40932, "answer": "&gt; And considering it's gone open source, that's a pretty big competitor.\n\nUnless Linux becomes a first class citizen there is no real competition.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40933, "question": "&gt; And considering it's gone open source, that's a pretty big competitor.\n\nUnless Linux becomes a first class citizen there is no real competition.", "aSentId": 40934, "answer": "Servers. Never forget about servers. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40933, "question": "&gt; And considering it's gone open source, that's a pretty big competitor.\n\nUnless Linux becomes a first class citizen there is no real competition.", "aSentId": 40936, "answer": "That is Microsofts's stated intent.  Their builds pass on Linux now, there's a ways to go, but I'd say that \nCLR and LLVM languages are significant threats to Java in the server space.  If Microsoft or Apple start running Clojure and/or \nScala as first class languages then Java could be in real trouble.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40937, "question": "That is Microsofts's stated intent.  Their builds pass on Linux now, there's a ways to go, but I'd say that \nCLR and LLVM languages are significant threats to Java in the server space.  If Microsoft or Apple start running Clojure and/or \nScala as first class languages then Java could be in real trouble.", "aSentId": 40938, "answer": "&gt; If Microsoft or Apple start running Clojure and/or Scala as first class languages then Java could be in real trouble.\n\nThat's really not likely to happen.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40937, "question": "That is Microsofts's stated intent.  Their builds pass on Linux now, there's a ways to go, but I'd say that \nCLR and LLVM languages are significant threats to Java in the server space.  If Microsoft or Apple start running Clojure and/or \nScala as first class languages then Java could be in real trouble.", "aSentId": 40940, "answer": "&gt;but I'd say that CLR and LLVM languages are significant threats to Java in the server space.\n\nIt's a ways off, the tooling around running CLR on a linux box is literally decades behind the JVM tooling.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40927, "question": "C# says hi. \n\nAnd considering it's gone open source, that's a pretty big competitor. ", "aSentId": 40942, "answer": "C# is what Java could have been if it wasn't shackled by backwards compatibility requirements.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40943, "question": "C# is what Java could have been if it wasn't shackled by backwards compatibility requirements.", "aSentId": 40944, "answer": "Reasons lie elsewhere. You could port good portion of C# to JVM if you wanted to, structs and C pointers in unsafe blocks are probably the only exceptions. I think they wanted to keep Java simple on purpose. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40945, "question": "Reasons lie elsewhere. You could port good portion of C# to JVM if you wanted to, structs and C pointers in unsafe blocks are probably the only exceptions. I think they wanted to keep Java simple on purpose. ", "aSentId": 40946, "answer": "That and the JVM type system, which has been a pain in the ass for Scala.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40947, "question": "That and the JVM type system, which has been a pain in the ass for Scala.", "aSentId": 40948, "answer": "The other way around: the reason why Scala.net ended up being abandoned is because .net's reification of generics makes it impossible to port Scala's type system on it.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40949, "question": "The other way around: the reason why Scala.net ended up being abandoned is because .net's reification of generics makes it impossible to port Scala's type system on it.\n\n", "aSentId": 40950, "answer": "Interesting. Do you have a source/link for more information?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40949, "question": "The other way around: the reason why Scala.net ended up being abandoned is because .net's reification of generics makes it impossible to port Scala's type system on it.\n\n", "aSentId": 40952, "answer": "~~Are you talking about Structural Types?  Because last I looked that was the feature that was hard to implement on the CLR.~~  After more reading I stand corrected, thanks!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40947, "question": "That and the JVM type system, which has been a pain in the ass for Scala.", "aSentId": 40954, "answer": "What do you mean? ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40955, "question": "What do you mean? ", "aSentId": 40956, "answer": "The current JVM has type erasure baked in, the CLR does not.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40925, "question": "&gt; There definitely is a lot of people that hate Java. At this point, there are some much nicer alternatives (Rust, Go, D, etc.). None have existed long enough to reach the maturity required to supplant Java yet, but I definitely think it will happen within the next 5-10 years.\n\nNot a chance.\n\nThe space that Java occupies is, if anything, thinning out rather than gaining competitors.  Ten years ago it was the arrival of higher-level scripting languages, more recently there's been the flood of C++-replacements (of which Rust, Go, and D are all members).\n\nThe middle-ground, the managed runtime level, is lacking in competition.  Or rather the competition that exists is complementary (e.g. other JVM languages).", "aSentId": 40958, "answer": "&gt; C++-replacements (of which Rust, Go, and D are all members).\n\nExcept that Go isn't (and never was) a C++ replacement. Even the Go authors decided it was a mistake to have called it a \"systems language\" when it came out.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40925, "question": "&gt; There definitely is a lot of people that hate Java. At this point, there are some much nicer alternatives (Rust, Go, D, etc.). None have existed long enough to reach the maturity required to supplant Java yet, but I definitely think it will happen within the next 5-10 years.\n\nNot a chance.\n\nThe space that Java occupies is, if anything, thinning out rather than gaining competitors.  Ten years ago it was the arrival of higher-level scripting languages, more recently there's been the flood of C++-replacements (of which Rust, Go, and D are all members).\n\nThe middle-ground, the managed runtime level, is lacking in competition.  Or rather the competition that exists is complementary (e.g. other JVM languages).", "aSentId": 40960, "answer": "&gt;  more recently there's been the flood of C++-replacements (of which Rust, Go, and D are all members).\n\nI wouldn't consider Go to be in the same class as C++, Rust, and D. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40962, "question": "I don't see any reason why \"C++-replacements\" couldn't compete with Java. Why would I care if they are managed or not?", "aSentId": 40963, "answer": "If you're writing the world's millionth accounting app or whatever you probably want managed code because the performance implications are just irrelevant.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40923, "question": "I work at a Java-heavy company employing about 70 devs, 60+ of which despise Java. There's only a handful of them that are actually willing to even touch the Java bits.\n\nThere definitely is *a lot* of people that hate Java. At this point, there are some much nicer alternatives (Rust, Go, D, etc.). None have existed long enough to reach the maturity required to supplant Java yet, but I definitely think it will happen within the next 5-10 years.", "aSentId": 40965, "answer": "I think most of the hate related to Java comes from bad frameworks and tools and not from the JVM or the language itself. Most companies hate rewrites or changing tools so they continue using the same bad frameworks for years and years even though they become less and less productive compared to the competition.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40966, "question": "I think most of the hate related to Java comes from bad frameworks and tools and not from the JVM or the language itself. Most companies hate rewrites or changing tools so they continue using the same bad frameworks for years and years even though they become less and less productive compared to the competition.", "aSentId": 40967, "answer": "Java backward compatibility may have ended up to be more of a curse than an asset.  The number of companies running Spring 2 is amazing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40923, "question": "I work at a Java-heavy company employing about 70 devs, 60+ of which despise Java. There's only a handful of them that are actually willing to even touch the Java bits.\n\nThere definitely is *a lot* of people that hate Java. At this point, there are some much nicer alternatives (Rust, Go, D, etc.). None have existed long enough to reach the maturity required to supplant Java yet, but I definitely think it will happen within the next 5-10 years.", "aSentId": 40969, "answer": "Stupid question, but if they hate Java, why are they working at a Java heavy company?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40972, "question": "&gt;but the bottom line is that the majority of Java developers is quite happy with Java.\n\nhttp://c2.com/cgi/wiki?BlubParadox", "aSentId": 40973, "answer": "The Blub Paradox is unhelpful as an argument.  Unless you're a Common Lisp programmer, everything is Blub by that reckoning.  Yet it's mostly used by Blub + 1 programmers to shame people one-level down the pecking order.\n\nIt's also, almost completely, bollocks.  There have been studies comparing programming languages and their effect on productivity and defect-rates, and while correlations have been found, the difference hasn't been as much as the likes of Paul Graham would have you believe.  Indeed, for some higher-Blub languages (Ruby and Python spring to mind), the defect rate climbs significantly higher than Java.\n\nAs a group, we occasionally hint at, but never really embrace the real reason for so many different languages and language flame-wars.  That it's just a matter of preference, some people like one, some like another. It's just like buying a van for a small business, so many brands to choose from, different capacities and fuel-efficiencies; many comparisons made, people swearing by one brand and hating others.  What's the real difference?  Almost impossible to quantify.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40974, "question": "The Blub Paradox is unhelpful as an argument.  Unless you're a Common Lisp programmer, everything is Blub by that reckoning.  Yet it's mostly used by Blub + 1 programmers to shame people one-level down the pecking order.\n\nIt's also, almost completely, bollocks.  There have been studies comparing programming languages and their effect on productivity and defect-rates, and while correlations have been found, the difference hasn't been as much as the likes of Paul Graham would have you believe.  Indeed, for some higher-Blub languages (Ruby and Python spring to mind), the defect rate climbs significantly higher than Java.\n\nAs a group, we occasionally hint at, but never really embrace the real reason for so many different languages and language flame-wars.  That it's just a matter of preference, some people like one, some like another. It's just like buying a van for a small business, so many brands to choose from, different capacities and fuel-efficiencies; many comparisons made, people swearing by one brand and hating others.  What's the real difference?  Almost impossible to quantify.\n", "aSentId": 40975, "answer": "I think Paul Graham has a minor error in \"The Blub Paradox\". Programming languages aren't just about expressive \"power\". There are various other useful traits you want in a PL other than expressive power. For example, restrictive power (e.g: a strong type system restricting various invalid programs from being written).\n\nIf you include this, CL is no longer at the \"top\", but there are still \"blub\" languages, and people using them looking at languages with more expressive/restrictive power or other good traits will often shake their heads and not understand.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40976, "question": "I think Paul Graham has a minor error in \"The Blub Paradox\". Programming languages aren't just about expressive \"power\". There are various other useful traits you want in a PL other than expressive power. For example, restrictive power (e.g: a strong type system restricting various invalid programs from being written).\n\nIf you include this, CL is no longer at the \"top\", but there are still \"blub\" languages, and people using them looking at languages with more expressive/restrictive power or other good traits will often shake their heads and not understand.\n", "aSentId": 40977, "answer": "I always considered CL to be a \"blub\" language. When I used it back in college I kept thinking that my assignments would be so much easier if I could use a more expressive language like Visual Basic 6. \n\nThe problem with the word \"expressive\" as a metric is that you have to first define what it is that you want to express.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40978, "question": "I always considered CL to be a \"blub\" language. When I used it back in college I kept thinking that my assignments would be so much easier if I could use a more expressive language like Visual Basic 6. \n\nThe problem with the word \"expressive\" as a metric is that you have to first define what it is that you want to express.", "aSentId": 40979, "answer": "You could define it as being the maximum conciseness of programs that at least some humans can read in reasonable time or with reasonable ease.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40978, "question": "I always considered CL to be a \"blub\" language. When I used it back in college I kept thinking that my assignments would be so much easier if I could use a more expressive language like Visual Basic 6. \n\nThe problem with the word \"expressive\" as a metric is that you have to first define what it is that you want to express.", "aSentId": 40981, "answer": "\"Our new bioarchitecture is totally expressive! Just ignore those tumors popping up everywhere.\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40974, "question": "The Blub Paradox is unhelpful as an argument.  Unless you're a Common Lisp programmer, everything is Blub by that reckoning.  Yet it's mostly used by Blub + 1 programmers to shame people one-level down the pecking order.\n\nIt's also, almost completely, bollocks.  There have been studies comparing programming languages and their effect on productivity and defect-rates, and while correlations have been found, the difference hasn't been as much as the likes of Paul Graham would have you believe.  Indeed, for some higher-Blub languages (Ruby and Python spring to mind), the defect rate climbs significantly higher than Java.\n\nAs a group, we occasionally hint at, but never really embrace the real reason for so many different languages and language flame-wars.  That it's just a matter of preference, some people like one, some like another. It's just like buying a van for a small business, so many brands to choose from, different capacities and fuel-efficiencies; many comparisons made, people swearing by one brand and hating others.  What's the real difference?  Almost impossible to quantify.\n", "aSentId": 40983, "answer": "Except your pool of potential employees is totally determined by what kind of van you use, and if you switch brands of van you either have to deal with having a mixed-van shop (requiring those rare employees that can handle both kinds of van, or splitting your talent pool between the van types) or convert all your previous work to be compatible with the new van.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40984, "question": "Except your pool of potential employees is totally determined by what kind of van you use, and if you switch brands of van you either have to deal with having a mixed-van shop (requiring those rare employees that can handle both kinds of van, or splitting your talent pool between the van types) or convert all your previous work to be compatible with the new van.", "aSentId": 40985, "answer": "That assumption is completely false in practice. Hiring was one of the primary concerns for my team switching from Java to Clojure. Our reasoning was that since we were able to learn Clojure with relative ease we would expect new hires to do the same.\n\nWe've been using it for 4 years now and all our co-op students use Clojure just fine. Our contractors learned and liked using Clojure. Our last hire had no FP experience whatsoever, he worked with C# and PHP previously, but was interested in trying something new. He had no problems learning Clojure either.\n\nWe now see it as a filter, if a person would not be comfortable with Clojure we probably don't want to hire them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40988, "question": "Out of curiosity, what caused all the C++ hate?", "aSentId": 40989, "answer": "Oooh, many things caused the hate. \n\n-The tendency of some programmers to conflate high-level and low-level features. So you need to have a bunch of concepts in your head at the same. \n\n- A large set of features in the languages that interact in strange ways. \n\n- A bunch of inexperienced programmers using the language and unwillingness to absorb C++ minutia to use it effectively. \n\n- A bunch of inexperienced programmers finding \"pet features\" and overusing it. \n\n- Legacy code that is bad hard to work with workarounds that are unnecessary on more modern compilers/libraries/standards. And nobody bothered to fix them during upgrades of the code base. \n\n- Header/implementation instead of a good module system. \n\n- ...\n\nI could keep on going with the list of problems. The hate is understandable. But studying up on the hairy stuff can make it workable and nice language to work with. The problem is usually other programmers that just sits and complains. \n ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40995, "question": "&gt;the majority of Java developers is quite happy with Java.\n\nThe majority of developers are idiots.  There are brilliant developers, and there are boneheads.  This is my experience of 30+ years writing software for money.  Given a million dollar budget I would much prefer 4 elite developers at $250k each to 20 shitty J-heads at $50k each.  The 4 elite ones will wipe the floor with the 20 \"average\" developers.\n\nAs a hiring manager, a sure clue that someone was an idiot was if they represented themselves as a \"java [architect|developer|engineer]\" rather than a software person with multiple languages under their belt.", "aSentId": 40996, "answer": "&gt; The 4 elite ones will wipe the floor with the 20 \"average\" developers.\n\nThat's always true, notwithstanding the standard disclaimers on the difficulties of identifying the elite, regardless of technologies.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40997, "question": "&gt; The 4 elite ones will wipe the floor with the 20 \"average\" developers.\n\nThat's always true, notwithstanding the standard disclaimers on the difficulties of identifying the elite, regardless of technologies.", "aSentId": 40998, "answer": "And yet, most companies would prefer the 20. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 40995, "question": "&gt;the majority of Java developers is quite happy with Java.\n\nThe majority of developers are idiots.  There are brilliant developers, and there are boneheads.  This is my experience of 30+ years writing software for money.  Given a million dollar budget I would much prefer 4 elite developers at $250k each to 20 shitty J-heads at $50k each.  The 4 elite ones will wipe the floor with the 20 \"average\" developers.\n\nAs a hiring manager, a sure clue that someone was an idiot was if they represented themselves as a \"java [architect|developer|engineer]\" rather than a software person with multiple languages under their belt.", "aSentId": 41000, "answer": "I think it is easy to misconstrue your statement to conclude that only idiots are happy with java but you didn't say that.  Right tool for the job still applies and I agree with you that most developers I have worked with are mediocre at best, they actually will hate any majority language because they are lazy as well frequently.  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41004, "question": "But how much of that lack of hate stems from just not being aware of other languages?\n\n1990-95 is a bit before my time, but I imagine most people working with C++ at the time had more exposure to other languages than some modern Java devs might.\n\nI was lucky enough to avoid working with Java until quite recently. I won't claim to really know the language, but I find myself hating it more than I thought possible. For a good portion of the simple stuff I'm doing, I think Brainfuck might actually be nicer.", "aSentId": 41005, "answer": "I've written CUDA applications, a javascript interpreter in ML, I've been following the development of Rust on the edge of my seat. I wrote a graphics display engine for a one-off toy game in C++ and openGL. I've given most languages I've heard of in any serious context a shot.\n\nBut when it comes to my work, I like java. It's capable and fast, relatively safe, and it's used **everywhere**. I simply don't have to worry about if there won't be a supporting library, chances are there is.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41006, "question": "I've written CUDA applications, a javascript interpreter in ML, I've been following the development of Rust on the edge of my seat. I wrote a graphics display engine for a one-off toy game in C++ and openGL. I've given most languages I've heard of in any serious context a shot.\n\nBut when it comes to my work, I like java. It's capable and fast, relatively safe, and it's used **everywhere**. I simply don't have to worry about if there won't be a supporting library, chances are there is.", "aSentId": 41007, "answer": "Yeah, libraries and tooling are reasons I understand for using it. It's a sensible enough language to use just because it's just so prevalent. All the same, just looking at the language, I absolutely despise it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41008, "question": "Yeah, libraries and tooling are reasons I understand for using it. It's a sensible enough language to use just because it's just so prevalent. All the same, just looking at the language, I absolutely despise it.", "aSentId": 41009, "answer": "I was kind of 'meh' on it until the most recent version. It's made many things, most notably async operations and collection manipulation, much more concise.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41010, "question": "I was kind of 'meh' on it until the most recent version. It's made many things, most notably async operations and collection manipulation, much more concise.", "aSentId": 41011, "answer": "Unfortunately it seems like a lot of shops are not willing or able to update. The most egregious example being Android. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41012, "question": "Unfortunately it seems like a lot of shops are not willing or able to update. The most egregious example being Android. ", "aSentId": 41013, "answer": "Yeah, that's by far the biggest problem. Fortunately for me, my company's relatively new to the java environment, so we don't have a ton of legacy stuff to hold us back.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41008, "question": "Yeah, libraries and tooling are reasons I understand for using it. It's a sensible enough language to use just because it's just so prevalent. All the same, just looking at the language, I absolutely despise it.", "aSentId": 41015, "answer": "&gt; I absolutely despise it.\n\ni'm curious.  how do you feel about, i dunno, isis burning people allve, or rape, or torture?\n\nbecause i suspect whan you say \"i absolutely despise it\" you mean something more like \"i mildly don't like it\".\n\nand i don't get why you need to talk that way.  do you think it makes you sound smarter?  more experienced?  more emotional?  mentally unstable?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41016, "question": "&gt; I absolutely despise it.\n\ni'm curious.  how do you feel about, i dunno, isis burning people allve, or rape, or torture?\n\nbecause i suspect whan you say \"i absolutely despise it\" you mean something more like \"i mildly don't like it\".\n\nand i don't get why you need to talk that way.  do you think it makes you sound smarter?  more experienced?  more emotional?  mentally unstable?", "aSentId": 41017, "answer": "I say it because it most accurately reflects my feelings on the matter within the given context. Yes, I'd probably prefer programming in Java to ISIS burning people alive. That's sort of a given, you know?\n\nIf you restrict everything to a limited, absolute scale it becomes very difficult to distinguish between smaller, more local effects. On the scale of all things, I don't have enough words in the English language to really say anything about one programming language over another.\n\nSo you use context to allow you to talk about this sort of thing. We're just talking about programming languages, so that's the context. Within that realm, I feel strongly enough about Java to say I despise it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41016, "question": "&gt; I absolutely despise it.\n\ni'm curious.  how do you feel about, i dunno, isis burning people allve, or rape, or torture?\n\nbecause i suspect whan you say \"i absolutely despise it\" you mean something more like \"i mildly don't like it\".\n\nand i don't get why you need to talk that way.  do you think it makes you sound smarter?  more experienced?  more emotional?  mentally unstable?", "aSentId": 41019, "answer": "I know that my current job is working with Java, and that the environment I find myself working in makes me completely miserable. I hate getting up and going to work every day. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41020, "question": "I know that my current job is working with Java, and that the environment I find myself working in makes me completely miserable. I hate getting up and going to work every day. ", "aSentId": 41021, "answer": "look for a new job.  in my (over 20 years) experience, the conditions you work in and the people you work with matter much more than the language.  find a new job, even if it is in java.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41006, "question": "I've written CUDA applications, a javascript interpreter in ML, I've been following the development of Rust on the edge of my seat. I wrote a graphics display engine for a one-off toy game in C++ and openGL. I've given most languages I've heard of in any serious context a shot.\n\nBut when it comes to my work, I like java. It's capable and fast, relatively safe, and it's used **everywhere**. I simply don't have to worry about if there won't be a supporting library, chances are there is.", "aSentId": 41023, "answer": "Years of working with C++ and not using Java taught me that Java does solve most pain points of C++, like advertised.\nWhen I watch how Java developers can work with their tools I have a strange \"this is high-tech\" feeling.\nBut I don't really know Java so my post can be discarded.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41004, "question": "But how much of that lack of hate stems from just not being aware of other languages?\n\n1990-95 is a bit before my time, but I imagine most people working with C++ at the time had more exposure to other languages than some modern Java devs might.\n\nI was lucky enough to avoid working with Java until quite recently. I won't claim to really know the language, but I find myself hating it more than I thought possible. For a good portion of the simple stuff I'm doing, I think Brainfuck might actually be nicer.", "aSentId": 41025, "answer": "I'm pretty familiar with a bunch of languages, and java is fine. Not great, but a tool that mostly gets out of your way.\n\nYes it's wordy. Because you lazy fucks won't comment your code. Fine. Now everything is wordy. Auto complete is a critical part of any ide worth naming. So that's what we'll do.\n\nThe JVM, on the other hand is a shining gem that is going to lead us monkeys into the promised land by giving us a platform to write good languages that don't have to boot their ecosystem from scratch.\n\nLed by Scala (for the conservative) and clojure (for the early adopters who just want to cut to the chase).\n\nAnd backed by a bunch of java legacy junk. Which works, and that's mostly the point.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41026, "question": "I'm pretty familiar with a bunch of languages, and java is fine. Not great, but a tool that mostly gets out of your way.\n\nYes it's wordy. Because you lazy fucks won't comment your code. Fine. Now everything is wordy. Auto complete is a critical part of any ide worth naming. So that's what we'll do.\n\nThe JVM, on the other hand is a shining gem that is going to lead us monkeys into the promised land by giving us a platform to write good languages that don't have to boot their ecosystem from scratch.\n\nLed by Scala (for the conservative) and clojure (for the early adopters who just want to cut to the chase).\n\nAnd backed by a bunch of java legacy junk. Which works, and that's mostly the point.", "aSentId": 41027, "answer": "I've been finding nothing but it getting my way.\n\nCan't have unsigned types. Can't put enumerations in inner classes. Everything constantly tries to promote types to ints. Can't find the method I need because it's hidden several base classes up (IntelliJ helps here, docs sure don't). Can't rely on exceptions being thrown, because occasionally error codes are used instead. Can't even trust a clearly boolean return value is actually a bool, because Java decides it needs to use -1 as an error code, so it's actually an int.\n\nBut yes. The JVM has actually done some cool things.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41028, "question": "I've been finding nothing but it getting my way.\n\nCan't have unsigned types. Can't put enumerations in inner classes. Everything constantly tries to promote types to ints. Can't find the method I need because it's hidden several base classes up (IntelliJ helps here, docs sure don't). Can't rely on exceptions being thrown, because occasionally error codes are used instead. Can't even trust a clearly boolean return value is actually a bool, because Java decides it needs to use -1 as an error code, so it's actually an int.\n\nBut yes. The JVM has actually done some cool things.", "aSentId": 41029, "answer": "Well, OK, but where did you come from? You sound like a c/c++ kid to me, because that's the kind of beef I might have, haha.\n\nI mean, java has its stink, we can all own it, but is my house totally clean, or did I just get used to the smell?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41030, "question": "Well, OK, but where did you come from? You sound like a c/c++ kid to me, because that's the kind of beef I might have, haha.\n\nI mean, java has its stink, we can all own it, but is my house totally clean, or did I just get used to the smell?", "aSentId": 41031, "answer": "C/C++ is what I cut my teeth on, although recently I've become quite enamored (some of my friends might say obsessed) with Ada.\n\nI'm certainly not arguing other languages don't have their issues. They do - no doubt about it. Java just seems... so much worse. At least with them, on day one I'm not running into these sorts of issues. Normally that takes a least a week or two when I'm trying to make the language do something it really doesn't want to do.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41032, "question": "C/C++ is what I cut my teeth on, although recently I've become quite enamored (some of my friends might say obsessed) with Ada.\n\nI'm certainly not arguing other languages don't have their issues. They do - no doubt about it. Java just seems... so much worse. At least with them, on day one I'm not running into these sorts of issues. Normally that takes a least a week or two when I'm trying to make the language do something it really doesn't want to do.", "aSentId": 41033, "answer": "I tell you the thing that drives me apeshit-- compiler warnings on template classes.  Because the compiler wants to statically type the template class constructors return value, but the constructor requires me to use an unsafe cast for the generic factory method.\n\nWELL JUST GIVE ME A STRONGLY TYPED TEMPLATE CLASS CONSTRUCTOR THEN.\n\nBut this is sadly out of scope for the language. THAT is a language fuck up. Which will never get fixed. I annotate them but I never really feel good about it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41004, "question": "But how much of that lack of hate stems from just not being aware of other languages?\n\n1990-95 is a bit before my time, but I imagine most people working with C++ at the time had more exposure to other languages than some modern Java devs might.\n\nI was lucky enough to avoid working with Java until quite recently. I won't claim to really know the language, but I find myself hating it more than I thought possible. For a good portion of the simple stuff I'm doing, I think Brainfuck might actually be nicer.", "aSentId": 41035, "answer": "How do you even have this opinion. Java is very similar to many other languages, like C#, and I cannot possibly see how it would be worse than Brainfuck, of all things...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41036, "question": "How do you even have this opinion. Java is very similar to many other languages, like C#, and I cannot possibly see how it would be worse than Brainfuck, of all things...", "aSentId": 41037, "answer": "Java is similar but... not in a good way. I haven't used C#, so I can't really compare it there myself.\n\nAs I just put in another response, as far as I can tell Java basically takes the worst of C++ and Python and marries it all into one ugly bundle. You still have to do everything very explicitly, as in C++. At the same time, everything is buried in layer after layer of abstraction so you never really know what you're working with. At least in Python all that deep magic buys me nice, easy ways of getting things done.\n\nThe Brainfuck reference was mostly to some low level bit twiddling stuff I've been doing. Java makes that an absolute pain with a lack of unsigned types, and for some unfathomable reason bitwise operators on chars return integers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41038, "question": "Java is similar but... not in a good way. I haven't used C#, so I can't really compare it there myself.\n\nAs I just put in another response, as far as I can tell Java basically takes the worst of C++ and Python and marries it all into one ugly bundle. You still have to do everything very explicitly, as in C++. At the same time, everything is buried in layer after layer of abstraction so you never really know what you're working with. At least in Python all that deep magic buys me nice, easy ways of getting things done.\n\nThe Brainfuck reference was mostly to some low level bit twiddling stuff I've been doing. Java makes that an absolute pain with a lack of unsigned types, and for some unfathomable reason bitwise operators on chars return integers.", "aSentId": 41039, "answer": "The fact that those things are the \"worst\" of the two languages is an opinion. I find the explicit type declaration in languages like C++ to be good and did not like the way variables and types were handled in Python, when I found myself having to explicitly cast things in odd places.\n\nAnd in Java, what exactly is buried under any abstraction? You can easily read the source for the classes Oracle provides, or, just simply not use them... C++ has similar libraries for Strings, etc.\n\nAnd every tool has a different job. If you are trying to do fairly low level stuff in Java, you are going to have a bad time. Similar to if you attempted to pave a road with a hammer...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41040, "question": "The fact that those things are the \"worst\" of the two languages is an opinion. I find the explicit type declaration in languages like C++ to be good and did not like the way variables and types were handled in Python, when I found myself having to explicitly cast things in odd places.\n\nAnd in Java, what exactly is buried under any abstraction? You can easily read the source for the classes Oracle provides, or, just simply not use them... C++ has similar libraries for Strings, etc.\n\nAnd every tool has a different job. If you are trying to do fairly low level stuff in Java, you are going to have a bad time. Similar to if you attempted to pave a road with a hammer...", "aSentId": 41041, "answer": "Oh absolutely - those are my opinions. These are all really my opinions. In some cases I'll be happy to argue my opinion is correct (like bitwise operators on chars returning ints - if you want to talk about explicitly casting things in odd places), but generally this sort of stuff is hard to argue about in a strictly objective manner.\n\nI also really enjoy explicit type declarations. Recently I've been somewhat obsessed with Ada, so yes, I too like explicit, static typing.\n\nAbstraction is really unavoidable in Java. Just look at system.out. The starting place for \"Hello World.\" It's a PrintStream, which is a FilterOutputStream, which is an OutputStream.\n\nIn my very simple programs I end up with strings of anonymous objects that are merely there to be passed to other objects. In order to really understand this relatively simple code, I need to go through each of those intermediate objects. IntelliJ has proved more useful than the docs here, simply because IntelliJ will tell me every applicable method rather than forcing me to climb through all the relevant class hierarchy docs just to see what my options are.\n\nAnd Java is being thrown onto embedded devices these days. The way you do things in Java isn't really any higher level than C (some newer features excepted). But it isn't as understandable what you are really doing because of all the abstraction. So you're doing things the old way, but you don't really get to understand how it's all working. It's certainly not an ideal language for low level stuff, but it's being used that way and had some amount of consideration for such uses built-in to it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41042, "question": "Oh absolutely - those are my opinions. These are all really my opinions. In some cases I'll be happy to argue my opinion is correct (like bitwise operators on chars returning ints - if you want to talk about explicitly casting things in odd places), but generally this sort of stuff is hard to argue about in a strictly objective manner.\n\nI also really enjoy explicit type declarations. Recently I've been somewhat obsessed with Ada, so yes, I too like explicit, static typing.\n\nAbstraction is really unavoidable in Java. Just look at system.out. The starting place for \"Hello World.\" It's a PrintStream, which is a FilterOutputStream, which is an OutputStream.\n\nIn my very simple programs I end up with strings of anonymous objects that are merely there to be passed to other objects. In order to really understand this relatively simple code, I need to go through each of those intermediate objects. IntelliJ has proved more useful than the docs here, simply because IntelliJ will tell me every applicable method rather than forcing me to climb through all the relevant class hierarchy docs just to see what my options are.\n\nAnd Java is being thrown onto embedded devices these days. The way you do things in Java isn't really any higher level than C (some newer features excepted). But it isn't as understandable what you are really doing because of all the abstraction. So you're doing things the old way, but you don't really get to understand how it's all working. It's certainly not an ideal language for low level stuff, but it's being used that way and had some amount of consideration for such uses built-in to it.", "aSentId": 41043, "answer": "I do not know much about C++, but I am pretty sure cout and cin are objects of ostream and istream, and that is a very similar level of abstraction in my mind.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41044, "question": "I do not know much about C++, but I am pretty sure cout and cin are objects of ostream and istream, and that is a very similar level of abstraction in my mind.", "aSentId": 41045, "answer": "You're right. C++ does have that kind of abstraction too. I've just never been inconvenienced by it. I'm really not sure exactly where the difference is, to be honest. I was picking up C++ as practically a first language (minus a week or two of Python some years earlier), which you'd think would make it worse.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41042, "question": "Oh absolutely - those are my opinions. These are all really my opinions. In some cases I'll be happy to argue my opinion is correct (like bitwise operators on chars returning ints - if you want to talk about explicitly casting things in odd places), but generally this sort of stuff is hard to argue about in a strictly objective manner.\n\nI also really enjoy explicit type declarations. Recently I've been somewhat obsessed with Ada, so yes, I too like explicit, static typing.\n\nAbstraction is really unavoidable in Java. Just look at system.out. The starting place for \"Hello World.\" It's a PrintStream, which is a FilterOutputStream, which is an OutputStream.\n\nIn my very simple programs I end up with strings of anonymous objects that are merely there to be passed to other objects. In order to really understand this relatively simple code, I need to go through each of those intermediate objects. IntelliJ has proved more useful than the docs here, simply because IntelliJ will tell me every applicable method rather than forcing me to climb through all the relevant class hierarchy docs just to see what my options are.\n\nAnd Java is being thrown onto embedded devices these days. The way you do things in Java isn't really any higher level than C (some newer features excepted). But it isn't as understandable what you are really doing because of all the abstraction. So you're doing things the old way, but you don't really get to understand how it's all working. It's certainly not an ideal language for low level stuff, but it's being used that way and had some amount of consideration for such uses built-in to it.", "aSentId": 41047, "answer": "I feel like lambdas may fix your issue with tons of anonymous classes? Or at least in the typical cases I can think of.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41048, "question": "I feel like lambdas may fix your issue with tons of anonymous classes? Or at least in the typical cases I can think of.", "aSentId": 41049, "answer": "If I said anonymous classes I really meant anonymous objects. It's mostly been with some kind of input/output stream, and to get to some method I end up having to go through several intermediary classes. That itself isn't that bad, it's just the number of abstractions I have a problem with.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41050, "question": "If I said anonymous classes I really meant anonymous objects. It's mostly been with some kind of input/output stream, and to get to some method I end up having to go through several intermediary classes. That itself isn't that bad, it's just the number of abstractions I have a problem with.", "aSentId": 41051, "answer": "What language do you prefer, on a \"reality\" level, aka not Brainfuck.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41052, "question": "What language do you prefer, on a \"reality\" level, aka not Brainfuck.", "aSentId": 41053, "answer": "Recently I've been very taken with Ada. In a lot of ways it's similar to C/C++/Java/etc, but it has (and has had for some time) some of the nicer things we're starting to see in modern C++ and Java, such as the C++11 range-based for loop. On top of that, it's got a very powerful type system that's pretty great (in my opinion, at least).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41040, "question": "The fact that those things are the \"worst\" of the two languages is an opinion. I find the explicit type declaration in languages like C++ to be good and did not like the way variables and types were handled in Python, when I found myself having to explicitly cast things in odd places.\n\nAnd in Java, what exactly is buried under any abstraction? You can easily read the source for the classes Oracle provides, or, just simply not use them... C++ has similar libraries for Strings, etc.\n\nAnd every tool has a different job. If you are trying to do fairly low level stuff in Java, you are going to have a bad time. Similar to if you attempted to pave a road with a hammer...", "aSentId": 41055, "answer": "&gt; If you are trying to do fairly low level stuff in Java, you are going to have a bad time. Similar to if you attempted to pave a road with a hammer...\n\nmy first job involved reading a binary telemetry stream in java and parsing out words from major and minor frames in a giant state machine.  I loved every minute of it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41057, "question": "I'm aware of other languages but am pretty happy with Java. The other language I'm most familiar with is Python, but I've also done real work in JS and PHP, and hobby work in C++, Racket and Rust. The Java community can (sometimes) be quite amazing, and the tooling is (generally) really nice. There are some things about it that are less great, like lack of properties, but in general I enjoy working in Java. (As long as the codebase was written with care, of course.)", "aSentId": 41058, "answer": "Interesting. Did you start with Java or something else?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41059, "question": "Interesting. Did you start with Java or something else?", "aSentId": 41060, "answer": "Learned C++ first, but did actual work in PHP first. Then Python. To me Java is just a nice, straightforward language with static types and a big community.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41062, "question": "As a C++ developer, I never quite understood this. I've tried programming once or twice in Java. It just never jumped out at me as a much easier language. I didn't feel like I was writing programs faster, or more easily. If anything, it was slower for me, because I had to look up function names constantly. Python on the other hand really did feel easier and that you do more with less. \n\nBut then I always use std::vector and std::string in C++ instead of raw arrays and raw strings, and I suspect 90% of complaints with C++ come from that.  By the way, std::vector and std::string check indexes, so if you try to access an element outside the array, you will get a nice assertion instead of a memory corruption.\n\nThe only thing I like in Java is the nice stack trace you get in a crash. You can't get that in C++ unfortunately.", "aSentId": 41063, "answer": "Yep, that's pretty much been my experience. The way you write the bits of code that actually do things is very similar to C++, but it still comes with all the hidden complexity of something like Python. But Python makes it very easy to do common things, so you don't end up writing that same kind of basic \"do something\" code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41065, "question": "I started out with Python and used it for most of my time back in college, and I love Java!\n\nI've programmed in Clojure, Scala, Ruby, Javascript, and C. In fact, most of my professional work outside of Java is using Scala and Clojure. ", "aSentId": 41066, "answer": "Man, I find it so hard to believe that. I mean, I do believe you, of course. It's just that I just find Java... so absolutely horrific that I can't imagine liking it. It's like at every step Java works to make my life harder.\n\nIt's got the explicitness of C++ with all the hidden magic of Python, plus a ton of just stupid restrictions. It's basically the worst of all worlds.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41068, "question": "&gt; But how much of that lack of hate stems from just not being aware of other languages?\n\nI can't answer that personally since I've programmed in (in chronological order of first exposure) BASIC, Pascal, C, assembly language, Modula 2, Rexx, C++, Bourne shell, awk, Perl, Java, Haskell, PHP, Javascript, and C#.\n\nI wouldn't say I think of Java as an ideal language, but it's not bad, and I certainly don't hate using it. It has some parts that could've been done better, but overall I like it pretty well. It's not going to win any prizes for conciseness, but it's not intended to be very high-level.", "aSentId": 41069, "answer": "I don't generally care much for conciseness. Recently I've been a bit obsessed with Ada, which nobody is going to think of calling concise. At the same time, Java seems overly verbose to me. It's not that I care about the typing/reading, it's that most of the verboseness comes from repeating information that doesn't actually make anything easier to read or understand.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41071, "question": "&gt; But how much of that lack of hate stems from just not being aware of other languages?\n\nAnecdote: I also do Python/JS/PHP, and would readily use those non-Java choices for small personal projects... But when it comes to a big multi-team project or something which will outlive generations of hires, I'd really rather be faced with something I can statically-check and confidently refactor.\n\n", "aSentId": 41072, "answer": "Java is hardly the only statically typed language though. If you want to look at additional tools then yeah, Java has more of that sort of stuff built up around it than some other languages.\n\nIt's not even that great at being typed though. It's marginally worse than C++ just due to it's lack of unsigned, and C++ is hardly the poster child for a strong type system.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41074, "question": "So before HN, Reddit, and other places C++ devs had more knowledge of other languages than modern Java devs? Yeah right.", "aSentId": 41075, "answer": "Do you really think the average dev out there spends time reading HN, r/programming, etc.? I'm not convinced that's the case.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41076, "question": "Do you really think the average dev out there spends time reading HN, r/programming, etc.? I'm not convinced that's the case.", "aSentId": 41077, "answer": "Doesn't have to be those two. The level of news and info available these days blows the mid 90s out of the water by at least 4-5 orders of maginitude for any topic, and especially for programming. There's literally no way that a 90's programmer would know about alternative choices and yet a 2015 dev wouldn't.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41078, "question": "Doesn't have to be those two. The level of news and info available these days blows the mid 90s out of the water by at least 4-5 orders of maginitude for any topic, and especially for programming. There's literally no way that a 90's programmer would know about alternative choices and yet a 2015 dev wouldn't.", "aSentId": 41079, "answer": "I don't mean that Java devs would be unaware that alternatives existed, but rather that they might have actually spent much time looking at them or trying to use them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41082, "question": "People get paid to write crap like that?", "aSentId": 41083, "answer": "I used to get paid to write Java, but I escaped in a balloon during the George W. Bush administration.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41084, "question": "I used to get paid to write Java, but I escaped in a balloon during the George W. Bush administration.", "aSentId": 41085, "answer": "I was of course talking about that article. It's just rambling.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41086, "question": "I was of course talking about that article. It's just rambling.", "aSentId": 41087, "answer": "Protip: It's Quora ported to a site.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41088, "question": "Protip: It's Quora ported to a site.", "aSentId": 41089, "answer": "Ah, so it's basically one level below blogspam.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41090, "question": "Ah, so it's basically one level below blogspam.", "aSentId": 41091, "answer": "I'd go with more than 1 level.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41090, "question": "Ah, so it's basically one level below blogspam.", "aSentId": 41093, "answer": "And a level above twitter aggregate bots, yep. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41084, "question": "I used to get paid to write Java, but I escaped in a balloon during the George W. Bush administration.", "aSentId": 41095, "answer": "I work at Rails/Ruby shop (although we also have people writing Python, Go, Scala and C#) and while I wouldn't call Ruby or Rails perfect, the ecosystem, the language, the tools. . . everything is so much more freaking pleasant than Java.  It's crazy.\n\nFor example, comparing the bundler/rubygems/rake stack with Maven. . . I suddenly don't want to kill myself on a daily basis.  It's like magic.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41096, "question": "I work at Rails/Ruby shop (although we also have people writing Python, Go, Scala and C#) and while I wouldn't call Ruby or Rails perfect, the ecosystem, the language, the tools. . . everything is so much more freaking pleasant than Java.  It's crazy.\n\nFor example, comparing the bundler/rubygems/rake stack with Maven. . . I suddenly don't want to kill myself on a daily basis.  It's like magic.", "aSentId": 41097, "answer": "Maven is unpleasant, but it's not Java.\n\nI can't think of a reason why you'd ever want to use Maven instead of [Gradle](https://gradle.org/) at this point.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41098, "question": "Maven is unpleasant, but it's not Java.\n\nI can't think of a reason why you'd ever want to use Maven instead of [Gradle](https://gradle.org/) at this point.", "aSentId": 41099, "answer": "Agreed, if I were using Java now and had the ability to choose, I would use Gradle.  At my last job, I didn't have any control over the toolsets being used.  Our release engineer pushed hard for Gradle too but was shot down on that front.\r\r\rRegardless, Maven is still heavily entrenched in the Java world so I consider it to be a standard part of the ecosystem.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41100, "question": "Agreed, if I were using Java now and had the ability to choose, I would use Gradle.  At my last job, I didn't have any control over the toolsets being used.  Our release engineer pushed hard for Gradle too but was shot down on that front.\r\r\rRegardless, Maven is still heavily entrenched in the Java world so I consider it to be a standard part of the ecosystem.", "aSentId": 41101, "answer": "The thing about rubygems and bundler is that they were kind of the first things to show up for Ruby. They didn't have to displace technologies as widespread as maven and ivy.\n\nJava has ant, ivy, maven... and maven is pretty obtuse to work with but theres so much knowledge and man hours poured into it that people are afraid to lose that investment.\n\nThat being said, the combination of bundler gems rake and rvm is pretty much the standard i compare every other language's tools to.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41102, "question": "The thing about rubygems and bundler is that they were kind of the first things to show up for Ruby. They didn't have to displace technologies as widespread as maven and ivy.\n\nJava has ant, ivy, maven... and maven is pretty obtuse to work with but theres so much knowledge and man hours poured into it that people are afraid to lose that investment.\n\nThat being said, the combination of bundler gems rake and rvm is pretty much the standard i compare every other language's tools to.", "aSentId": 41103, "answer": "Yes, excellent points and that's where I am now.  I prefer the Ruby tools over Python's virtualenv too.  I hear good things about the tooling around Go and node too but I haven't used them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41096, "question": "I work at Rails/Ruby shop (although we also have people writing Python, Go, Scala and C#) and while I wouldn't call Ruby or Rails perfect, the ecosystem, the language, the tools. . . everything is so much more freaking pleasant than Java.  It's crazy.\n\nFor example, comparing the bundler/rubygems/rake stack with Maven. . . I suddenly don't want to kill myself on a daily basis.  It's like magic.", "aSentId": 41105, "answer": "Oh. My. God. No. \n\nRoR is so nice and cute starting, but if you try to do complex things it turns into a nightmare. It's too opinionated, too intertwined, and too DRY, like almost every piece of Ruby code I'v seen. And add in performance concerns and it's a nightmare.\n\nAnd that's ignoring the hellstorm that is getting the right version of Ruby installed, and the fact that probably 30% of Ruby libraries are shims into C code. Good bloody luck installing half the things you need on a mac, enjoy compiling QT or god knows what C/C++ lib on your CI boxes to match your dev setup.\n\nJava at least you download a JAR and you're done with the deps bit.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41106, "question": "Oh. My. God. No. \n\nRoR is so nice and cute starting, but if you try to do complex things it turns into a nightmare. It's too opinionated, too intertwined, and too DRY, like almost every piece of Ruby code I'v seen. And add in performance concerns and it's a nightmare.\n\nAnd that's ignoring the hellstorm that is getting the right version of Ruby installed, and the fact that probably 30% of Ruby libraries are shims into C code. Good bloody luck installing half the things you need on a mac, enjoy compiling QT or god knows what C/C++ lib on your CI boxes to match your dev setup.\n\nJava at least you download a JAR and you're done with the deps bit.", "aSentId": 41107, "answer": "Well I may be in my Rails honeymoon phase still, but I find the Java ecosystem to be much more painful.  For example, Rake is about a 100 times easier to grok and use than Maven or Ant.  For me at least.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41106, "question": "Oh. My. God. No. \n\nRoR is so nice and cute starting, but if you try to do complex things it turns into a nightmare. It's too opinionated, too intertwined, and too DRY, like almost every piece of Ruby code I'v seen. And add in performance concerns and it's a nightmare.\n\nAnd that's ignoring the hellstorm that is getting the right version of Ruby installed, and the fact that probably 30% of Ruby libraries are shims into C code. Good bloody luck installing half the things you need on a mac, enjoy compiling QT or god knows what C/C++ lib on your CI boxes to match your dev setup.\n\nJava at least you download a JAR and you're done with the deps bit.", "aSentId": 41109, "answer": "Let github know of your concerns.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41096, "question": "I work at Rails/Ruby shop (although we also have people writing Python, Go, Scala and C#) and while I wouldn't call Ruby or Rails perfect, the ecosystem, the language, the tools. . . everything is so much more freaking pleasant than Java.  It's crazy.\n\nFor example, comparing the bundler/rubygems/rake stack with Maven. . . I suddenly don't want to kill myself on a daily basis.  It's like magic.", "aSentId": 41111, "answer": "I have heard Maven problems will be solved with AbstractMavenFactory. \n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41112, "question": "I have heard Maven problems will be solved with AbstractMavenFactory. \n\n", "aSentId": 41113, "answer": "That didn't turn out so great, but now they're working on ConcreteMavenIncinerator. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41112, "question": "I have heard Maven problems will be solved with AbstractMavenFactory. \n\n", "aSentId": 41115, "answer": "Do I need dependency injection for that?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41116, "question": "Do I need dependency injection for that?", "aSentId": 41117, "answer": "You are in luck! you can either choose dependency injection or service locator. They have abstracted these.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41118, "question": "You are in luck! you can either choose dependency injection or service locator. They have abstracted these.", "aSentId": 41119, "answer": "Awesome, time to roll out my AbstractMavenFactoryImpl class.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41121, "question": "What's your issue with Maven?  I find it pleasant, but maybe I have Stockholm syndrome and don't know it?", "aSentId": 41122, "answer": "Verbose, awkward XML syntax, difficult to learn. . .\r\rThis is my opinion and I'm not trying to sway you or anyone but I'll say this, try a different tool and see what you think.  For me right now I'm using Rake and Bundler, which comprise the Ruby equivalent of Maven - it's a night and day difference in usability.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41123, "question": "Verbose, awkward XML syntax, difficult to learn. . .\r\rThis is my opinion and I'm not trying to sway you or anyone but I'll say this, try a different tool and see what you think.  For me right now I'm using Rake and Bundler, which comprise the Ruby equivalent of Maven - it's a night and day difference in usability.", "aSentId": 41124, "answer": "Yeah that's totally fair.  I probably have a blub paradox going on with build and dependency management tools.  I know maven pretty well, second to ant, grunt, npm, Leiningen, ivy, lineman then rake, in that order.  Rake is a situation where I learned it 5+ years ago and haven't used it since, so I barely know it.\n\nWhat I like about maven is that it's opinionated enough that I can jump right in to any pom.xml and understand how the build works (because I already got past the learning curve) and it's flexible enough to achieve anything I've ever wanted.\n\nAs the build complexity increases, the maven build file gets linearly complex (or better).  Whereas, the grunt and ant build files seem to get exponentially more complex.  But, I can't speak for Rake and Blunder because I don't have real experience with them.  Maybe they're just as good in these ways minus the high learning curve.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41126, "question": "You must be joking.\n\nSure, Maven's documentation sucks and XML sucks. Yes, its a pain in the ass to migrate legacy Ant projects to Maven and getting them to fit into Maven's lifecycle. But once you make the migration, you understand that the constraints that Maven puts on your project make your build so incredibly rock-solid. We had a build that required a 20 page IDE configuration guide complete with FAQ and troubleshooting sections for onboarding and half the time it wouldn't work anyway back when we had Ant. We went from that to one-click effortless builds for everyone including CI once we deployed Maven.\n\nHave the Maven libraries? Have a modern JDK? Have a working connection to a repo with all your deps and plugins? Then it just fucking works and that is such a Godsend that you have no idea.\n\nLiterally the only way you could improve on Maven would be to move away from XML configs and make it easier to write plugins. Otherwise, it's pretty close to perfection, if you agree with its constrictive design choices.", "aSentId": 41127, "answer": "I support your right to disagree with me.  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41129, "question": "And don't forget rvm, but seriously, gotta give it to RoR, it's very pleasant to use, it just works, even if you fuckup it sometimes might work", "aSentId": 41130, "answer": "Believe it or not, but I work primarily on Windows so no RVM for me.  :( In case  you're wondering, I hate Windows.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41131, "question": "Believe it or not, but I work primarily on Windows so no RVM for me.  :( In case  you're wondering, I hate Windows.", "aSentId": 41132, "answer": "you're doing RoR on windows? what went wrong in your life? Install a Linux virtual machine at least. \n\nI wrote a little detailed documentation for myself that explains how to make Ubuntu RoR production server, I can share it with you if want, but for the love of god stop what you are doing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41133, "question": "you're doing RoR on windows? what went wrong in your life? Install a Linux virtual machine at least. \n\nI wrote a little detailed documentation for myself that explains how to make Ubuntu RoR production server, I can share it with you if want, but for the love of god stop what you are doing.", "aSentId": 41134, "answer": "I know and love Linux, you don't need to convince me.  It's beyond my control and honestly it's not that bad (we're talking first world problems here) but yes I would run Linux if I could.  I do run it at home on my laptop.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41082, "question": "People get paid to write crap like that?", "aSentId": 41136, "answer": "Not much, this is a \"contributor\" article. I believe they make a small % based on clicks. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41138, "question": "I like the part where he talks about how people dont know shit about how command line or their computer works and then makes it clear through his explanation of java and mvn and comparison with other programming language that he has no idea how computers work.", "aSentId": 41139, "answer": "I agree with some of the stuff he wrote. But you have a point here. \n\n&gt; Maven informed me that I needed to specify one of its entirely too many (30, by my count) ambiguously named \u201cgoals\u201d. [...] \u201cjust compile the damned thing,\u201d\n\nUhm, how about \"mvn compile\"?\n\n(NB: I actually don't like maven, but that's another story)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41140, "question": "I agree with some of the stuff he wrote. But you have a point here. \n\n&gt; Maven informed me that I needed to specify one of its entirely too many (30, by my count) ambiguously named \u201cgoals\u201d. [...] \u201cjust compile the damned thing,\u201d\n\nUhm, how about \"mvn compile\"?\n\n(NB: I actually don't like maven, but that's another story)", "aSentId": 41141, "answer": "I defense of the original author, maven is garbage.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41138, "question": "I like the part where he talks about how people dont know shit about how command line or their computer works and then makes it clear through his explanation of java and mvn and comparison with other programming language that he has no idea how computers work.", "aSentId": 41143, "answer": "Those statements came from different authors. (The article switches to a different Quora answer on page 2.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41138, "question": "I like the part where he talks about how people dont know shit about how command line or their computer works and then makes it clear through his explanation of java and mvn and comparison with other programming language that he has no idea how computers work.", "aSentId": 41145, "answer": "I found this in contrast with what he says earlier. Doesn't he complain that a single line of Java declaring + initializing a hash map makes his mind dull - that he would rather spend time reasoning what a shorter (and possibly more cryptic) line of code does. Then he goes on to complain about maven, ant/xml, etc. and even declares in some case that he doesn't even try to understand what's going on. Seems a bit of a contrast in what he's preaching.\n\nI thought the article started with some interesting points, especially about the Java culture and community - which I've felt always has been lacking or underdeveloped. Most internet searches for java related problems I've looked into will (if you're lucky) get hits on Stack Overflow. Otherwise you have answers dated ~a decade ago hosted on forums last updated around the same time (Java Ranch?!). I was disappointed that these thoughts weren't developed in the article, instead diving into nitpicks about the verbosity of the language and development/build tools.\n\nI think that article clearly states how much he dislikes using Java, but has little foundation for its claims.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41147, "question": "I'm going to address some of the points from the first page because I can't be bothered to read the rest.\n\n&gt; [..] a VM that has a macroscopic startup time [..]\n\nThat doesn't mean anything for applications with a measurable runtime. If you're writing a web service, you don't really care about the 2 extra milliseconds it may need to start up. Meanwhile, overall system performance tends to be excellent.\n\n&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nNope. Haven't run into a situation where that was necessary. At worst you need to increase the maximum heap size for a program that needs a lot of memory. That's not fine tuning. That's common sense.\n\n&gt; The language sucks, [..]\n\nLiterally nothing else said to back that opinion.\n\n&gt; [..] Java culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory classes dominating.\n\nJuvenile.\n\n&gt; [..] top Scala engineers [..] are really freaking good.\n\nSo are the top Java engineers. What's your point?\n\nThe only real issue brushed by is that there tends to be a large number of bad to mediocre developers working with Java. I don't know why that's Java's fault. Bad programmers follow success. Whichever language is in high demand (and so has the most jobs), has to bear the cross of having the worst programmers around it.", "aSentId": 41148, "answer": "&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nI've seen stories where massive services will have a bit of JVM tuning done to be more efficient.  Good for them.  Seriously, what's the alternative?  Running a slower language like ruby?  The usual workflow I see is write something in ruby (or some other scripting language) just to get it up, switch to java for performance as many companies have done (Twitter, Google, Foursquare, etc.), and then do performance tuning because why use X machines when you could do the same work on half of them?  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41149, "question": "&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nI've seen stories where massive services will have a bit of JVM tuning done to be more efficient.  Good for them.  Seriously, what's the alternative?  Running a slower language like ruby?  The usual workflow I see is write something in ruby (or some other scripting language) just to get it up, switch to java for performance as many companies have done (Twitter, Google, Foursquare, etc.), and then do performance tuning because why use X machines when you could do the same work on half of them?  ", "aSentId": 41150, "answer": "Engineers at Twitter have forked OpenJDK and run a modified JVM with an extra generation in the memory model.  It's a clever optimisation alright, but it still would have worked without it.  When you get to Twitter-scale shaving 5% of run-time equals quite a lot of saved cash.\n\nBut exactly as you say, what's the alternative?  Re-write everything in C and do all memory management manually?  That would almost certainly work too, but at the moment they have good performance and a high-level language (mostly Scala rather than Java, but still valid as it was JVM tuning we were talking about).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41149, "question": "&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nI've seen stories where massive services will have a bit of JVM tuning done to be more efficient.  Good for them.  Seriously, what's the alternative?  Running a slower language like ruby?  The usual workflow I see is write something in ruby (or some other scripting language) just to get it up, switch to java for performance as many companies have done (Twitter, Google, Foursquare, etc.), and then do performance tuning because why use X machines when you could do the same work on half of them?  ", "aSentId": 41152, "answer": "My rails apps run on the JVM now. Still tuning but much faster. Kind of a pain to roll the servers, but all in all, thanks java!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41153, "question": "My rails apps run on the JVM now. Still tuning but much faster. Kind of a pain to roll the servers, but all in all, thanks java!", "aSentId": 41154, "answer": "Out of curiosity, why do you think it's painful? \n\nFrom my experience all you really have to do is copy over JDK (as in, copy the files, don't even have to 'install' it), copy over the application, update `JAVA_HOME` and `PATH` and hit `start.sh` for the application (if you have special needs the workflow needs to be changed, of course). \n\nSince you can put your application with *all* of its dependencies in a single package, the ease of (repeatable, predictable) deployment is miles and miles ahead of some systems associated with other languages (looking at you, `virtualenv`) - no manual updates on each of the boxes, no binary incompatibility with a binary blob you have to `dlopen` and so on.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41155, "question": "Out of curiosity, why do you think it's painful? \n\nFrom my experience all you really have to do is copy over JDK (as in, copy the files, don't even have to 'install' it), copy over the application, update `JAVA_HOME` and `PATH` and hit `start.sh` for the application (if you have special needs the workflow needs to be changed, of course). \n\nSince you can put your application with *all* of its dependencies in a single package, the ease of (repeatable, predictable) deployment is miles and miles ahead of some systems associated with other languages (looking at you, `virtualenv`) - no manual updates on each of the boxes, no binary incompatibility with a binary blob you have to `dlopen` and so on.", "aSentId": 41156, "answer": "Oh no, I'm talking about how long it takes torque box to roll over when I'm doing a code push. Annoying. And the jit takes a while to kick in after that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41147, "question": "I'm going to address some of the points from the first page because I can't be bothered to read the rest.\n\n&gt; [..] a VM that has a macroscopic startup time [..]\n\nThat doesn't mean anything for applications with a measurable runtime. If you're writing a web service, you don't really care about the 2 extra milliseconds it may need to start up. Meanwhile, overall system performance tends to be excellent.\n\n&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nNope. Haven't run into a situation where that was necessary. At worst you need to increase the maximum heap size for a program that needs a lot of memory. That's not fine tuning. That's common sense.\n\n&gt; The language sucks, [..]\n\nLiterally nothing else said to back that opinion.\n\n&gt; [..] Java culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory classes dominating.\n\nJuvenile.\n\n&gt; [..] top Scala engineers [..] are really freaking good.\n\nSo are the top Java engineers. What's your point?\n\nThe only real issue brushed by is that there tends to be a large number of bad to mediocre developers working with Java. I don't know why that's Java's fault. Bad programmers follow success. Whichever language is in high demand (and so has the most jobs), has to bear the cross of having the worst programmers around it.", "aSentId": 41158, "answer": "You kidding about the lack of need for JVM tuning?  I've made a ton of money over the last decade specializing in performance/stability/scalability analysis and repair of JVM-based application servers.  It's admittedly gotten a lot better over that time out of the box, but if you aren't doing some profiling (including with stress/load testing), you ain't doing it right.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41147, "question": "I'm going to address some of the points from the first page because I can't be bothered to read the rest.\n\n&gt; [..] a VM that has a macroscopic startup time [..]\n\nThat doesn't mean anything for applications with a measurable runtime. If you're writing a web service, you don't really care about the 2 extra milliseconds it may need to start up. Meanwhile, overall system performance tends to be excellent.\n\n&gt; For real-world production servers, it tends to require a fair amount of JVM tuning.\n\nNope. Haven't run into a situation where that was necessary. At worst you need to increase the maximum heap size for a program that needs a lot of memory. That's not fine tuning. That's common sense.\n\n&gt; The language sucks, [..]\n\nLiterally nothing else said to back that opinion.\n\n&gt; [..] Java culture is one of mediocrity and bad taste, with MetaModelVibratorVisitorFactory classes dominating.\n\nJuvenile.\n\n&gt; [..] top Scala engineers [..] are really freaking good.\n\nSo are the top Java engineers. What's your point?\n\nThe only real issue brushed by is that there tends to be a large number of bad to mediocre developers working with Java. I don't know why that's Java's fault. Bad programmers follow success. Whichever language is in high demand (and so has the most jobs), has to bear the cross of having the worst programmers around it.", "aSentId": 41160, "answer": "As a professional android developer, I don't mind it. It's not my idea of a \"perfect\" language, but it is more than adequate for what I need it for", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41164, "question": "&gt; 2 extra milliseconds it may need to start up\n\nMore like 4s in my experience. Even if it \"doesn't make that big of a difference\" it's still needless and should really be tuned/tweaked. Want to write a command-line program in Java? Hope you enjoy the mandatory startup lag... (Same with GUI, etc.)", "aSentId": 41165, "answer": "4 seconds? I don't mean to go off topic but are you running Java 1.4 on a 15 year old machine? That shouldn't happen unless you're doing 4 seconds of initialization, probably with disk and network IO, at program start-up.\n\nAlso, for command line programs, the startup delay is unnoticeable. From what I remember reading, most humans perceive a visual delay of less than 100 milliseconds as instantaneous. So if you wrote a command line program in Java, it would appear to have started up instantaneously.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41166, "question": "4 seconds? I don't mean to go off topic but are you running Java 1.4 on a 15 year old machine? That shouldn't happen unless you're doing 4 seconds of initialization, probably with disk and network IO, at program start-up.\n\nAlso, for command line programs, the startup delay is unnoticeable. From what I remember reading, most humans perceive a visual delay of less than 100 milliseconds as instantaneous. So if you wrote a command line program in Java, it would appear to have started up instantaneously.", "aSentId": 41167, "answer": "This assertion is pretty easy to test as well.\n\n    cat &lt;&lt;'EOF' &gt; hello.scala\n    #!/usr/bin/env bash\n    exec scala -savecompiled \"$0\" \"$@\"\n    !#\n\n    println(\"Hello World\")\n    EOF\n    \n    chmod u+x ./hello.scala\n    time ./hello.scala\n\nWhich produces: \n\n    $ time ./hello.scala                                                                               \n    Hello World                                                                                                 \n                                                                                                            \n    real    0m0.833s                                                                                            \n    user    0m0.513s                                                                                            \n    sys     0m0.054s\n    $\nand on the second run after compilation:\n\n    $ time ./hello.scala                                                                               \n    Hello World                                                                                                 \n                                                                                                            \n    real    0m0.387s                                                                                            \n    user    0m0.361s                                                                                            \n    sys     0m0.048s\n\nMind you the version of scala I have installed to my path right now is ancient and an actual Java Hello world would start up in less time:\n\n    $ scala -version                                                                                   \n    Scala code runner version 2.9.2 -- Copyright 2002-2011, LAMP/EPFL                                           \n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41168, "question": "This assertion is pretty easy to test as well.\n\n    cat &lt;&lt;'EOF' &gt; hello.scala\n    #!/usr/bin/env bash\n    exec scala -savecompiled \"$0\" \"$@\"\n    !#\n\n    println(\"Hello World\")\n    EOF\n    \n    chmod u+x ./hello.scala\n    time ./hello.scala\n\nWhich produces: \n\n    $ time ./hello.scala                                                                               \n    Hello World                                                                                                 \n                                                                                                            \n    real    0m0.833s                                                                                            \n    user    0m0.513s                                                                                            \n    sys     0m0.054s\n    $\nand on the second run after compilation:\n\n    $ time ./hello.scala                                                                               \n    Hello World                                                                                                 \n                                                                                                            \n    real    0m0.387s                                                                                            \n    user    0m0.361s                                                                                            \n    sys     0m0.048s\n\nMind you the version of scala I have installed to my path right now is ancient and an actual Java Hello world would start up in less time:\n\n    $ scala -version                                                                                   \n    Scala code runner version 2.9.2 -- Copyright 2002-2011, LAMP/EPFL                                           \n", "aSentId": 41169, "answer": "The discussion was specifically about java.\n\nScala has a longer startup time because it has to load its (bigger) standard library.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41170, "question": "The discussion was specifically about java.\n\nScala has a longer startup time because it has to load its (bigger) standard library.", "aSentId": 41171, "answer": "&gt;The discussion was specifically about java.\n\nThe discussion was specifically about the start-up time of the JVM and the Java runtime.\n\n&gt; Scala has a longer startup time because it has to load its (bigger) standard library.\n\nI already mentioned this fact, but that's not why a Scala's Hello World would take longer to startup. The number of classes you have on the classes you have on the class path is irrelevant, classes are only loaded on the JVM as they're used. In this case [Predef.scala](https://github.com/scala/scala/blob/v2.11.5/src/library/scala/Predef.scala) and [Console.scala](https://github.com/scala/scala/blob/v2.11.5/src/library/scala/Console.scala) are the only extra classes used.\n\nScala would take longer to startup because of the `scala` shell script  executable which runs [MainGenericRunner](https://github.com/scala/scala/blob/5e0880fe05fb65a8757721be7e5be6a3259c19a8/src/repl/scala/tools/nsc/MainGenericRunner.scala), bootrapping the compiler before running our hello world script that was already compiled.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41172, "question": "&gt;The discussion was specifically about java.\n\nThe discussion was specifically about the start-up time of the JVM and the Java runtime.\n\n&gt; Scala has a longer startup time because it has to load its (bigger) standard library.\n\nI already mentioned this fact, but that's not why a Scala's Hello World would take longer to startup. The number of classes you have on the classes you have on the class path is irrelevant, classes are only loaded on the JVM as they're used. In this case [Predef.scala](https://github.com/scala/scala/blob/v2.11.5/src/library/scala/Predef.scala) and [Console.scala](https://github.com/scala/scala/blob/v2.11.5/src/library/scala/Console.scala) are the only extra classes used.\n\nScala would take longer to startup because of the `scala` shell script  executable which runs [MainGenericRunner](https://github.com/scala/scala/blob/5e0880fe05fb65a8757721be7e5be6a3259c19a8/src/repl/scala/tools/nsc/MainGenericRunner.scala), bootrapping the compiler before running our hello world script that was already compiled.", "aSentId": 41173, "answer": "&gt;The discussion was specifically about the start-up time of the JVM and the Java runtime.\n\nYes but a large number of Clojure devs complain about JVM startup when it's caused boostrapping their core library.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41164, "question": "&gt; 2 extra milliseconds it may need to start up\n\nMore like 4s in my experience. Even if it \"doesn't make that big of a difference\" it's still needless and should really be tuned/tweaked. Want to write a command-line program in Java? Hope you enjoy the mandatory startup lag... (Same with GUI, etc.)", "aSentId": 41175, "answer": "Woop de fucking do. 4s (a gross over-estimation) is nothing for a web service, and most web frameworks would *love* a 4s startup. The last RoR project I was on was in the 10s range.\n\nEdit: Also I'm calling BS on 4s. Clojure is in the ~2.5s range. There is no way Java is slower than Clojure on the startup front.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41176, "question": "Woop de fucking do. 4s (a gross over-estimation) is nothing for a web service, and most web frameworks would *love* a 4s startup. The last RoR project I was on was in the 10s range.\n\nEdit: Also I'm calling BS on 4s. Clojure is in the ~2.5s range. There is no way Java is slower than Clojure on the startup front.", "aSentId": 41177, "answer": "The point is that it's a bit of a killer for command line apps. Compare Maven start time to e.g. something like Fabric.\n\nAlthough you're right calling me on my BS, I actually *was* thinking of Clojure. Whoops!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41179, "question": "The developer from quora who is reading interview code in java but doesn't even know how to build a java program without manually downloading jars and manually building a class path probably isn't qualified to be judging someone's java code. Seriously, not knowing the value of a build tool and a dependency management tool is what you'd expect from a novice. Maven is not really very difficult. Just because you didn't understand it immediately without reading a single word of documentation doesn't mean that it's shit. Also, there is more than just ant and maven out there: there's also Gradle and SBT. If you're going to talk trash, at least educate yourself first. Learn how professionals build their software: they're not manually building classpaths, I promise you that.", "aSentId": 41180, "answer": "Agreed!\nIn case of gradle there is esspecially gradle wrapper which is checked into version control and would download all dependencies out of the box on any system.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41182, "question": "What a shitty article.\n\nPlease find me a language that has:\n\n1. Comparable tooling\n2. A set of 3rd party libraries as rich as Java's\n3. Non-retarded standard library\n\nThis article doesn't even use modern Java... This:\n\n&gt; HashMap&lt;String, Set&gt; depMap = new HashMap();\n\nShould be written like this:\n\n&gt; Map&lt;String, Set&gt; depMap = new HashMap&lt;&gt;();\n\nI can't fucking understand what the author is suggesting. C and C++ absolutely *can't* be used where Java is used. OCaml has a rather small community. Haskell is just too hard to work with for most projects: it becomes a restriction, not a tool.\n\nEdit: fixed code example, thanks /u/TomRK1089!", "aSentId": 41183, "answer": "Take a look around on the JVM. You have Clojure and Scala which are both very nice languages. They get the benefits of the exact same tooling and libraries. On top of that you get some nice tooling you don't get in Java. For example, Clojure allows doing REPL driven development and IDEs provide structural code editing. The JVM is a great platform, but there are very few compelling reasons to use Java the language today.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41184, "question": "Take a look around on the JVM. You have Clojure and Scala which are both very nice languages. They get the benefits of the exact same tooling and libraries. On top of that you get some nice tooling you don't get in Java. For example, Clojure allows doing REPL driven development and IDEs provide structural code editing. The JVM is a great platform, but there are very few compelling reasons to use Java the language today.", "aSentId": 41185, "answer": "I've used both Clojure and Scala, and I want to try Groovy next (although I'll wait a bit and see if it dies out since Pivotal is no longer behind it).\n\nClojure gave me a very bad first impression. I liked the language, but the implementation is horrible. Doing something incorrectly results in the compiler throwing exceptions instead of showing what in the code caused the problem. Documentation on some of the more advanced language features was scarce at the time.\n\nScala has different problems. Or at least it had the last time I used it (I doubt the situation improved though). Compilation is slow, IDEs are mindbogglingly slow and unstable and the language seems to love abusing operator overloading for everything. Oh, and I still don't understand why they chose Pascal-style syntax for variables, parameters, etc...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41186, "question": "I've used both Clojure and Scala, and I want to try Groovy next (although I'll wait a bit and see if it dies out since Pivotal is no longer behind it).\n\nClojure gave me a very bad first impression. I liked the language, but the implementation is horrible. Doing something incorrectly results in the compiler throwing exceptions instead of showing what in the code caused the problem. Documentation on some of the more advanced language features was scarce at the time.\n\nScala has different problems. Or at least it had the last time I used it (I doubt the situation improved though). Compilation is slow, IDEs are mindbogglingly slow and unstable and the language seems to love abusing operator overloading for everything. Oh, and I still don't understand why they chose Pascal-style syntax for variables, parameters, etc...", "aSentId": 41187, "answer": "&gt;Clojure gave me a very bad first impression. I liked the language, but the implementation is horrible. Doing something incorrectly results in the compiler throwing exceptions instead of showing what in the code caused the problem. \n\nI've been using Clojure professionally for the past 4 years and I can definitively tell you there's nothing wrong with its implementation. The error messages certainly could be better, but figuring them out is not all that difficult once you learn what the errors mean. My experience has been that errors do trace precisely where the problem occurred vast majority of the time. In fact I've practically never had a reason to use a debugger when working with Clojure, something that I relied on constantly with Java.\n\nI also find that the REPL completely eliminates the whole compile/run cycle. I can see what the functions are doing as I'm writing them and I don't have to compile and run the whole application any time I make a change. This means that I'm not building up a lot of code before I'm testing to see whether it does what I want. This keeps the context that I need to keep in my head at any one time very small.\n\nI don't know when you last tried Clojure, but there's a lot of documentation available today and there are a number of great books discussing its advanced features.\n\nNot being a Scala user myself I can't really say what the situation is like there. Lots of companies appear to be using it happily though, so can't be all bad. :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41188, "question": "&gt;Clojure gave me a very bad first impression. I liked the language, but the implementation is horrible. Doing something incorrectly results in the compiler throwing exceptions instead of showing what in the code caused the problem. \n\nI've been using Clojure professionally for the past 4 years and I can definitively tell you there's nothing wrong with its implementation. The error messages certainly could be better, but figuring them out is not all that difficult once you learn what the errors mean. My experience has been that errors do trace precisely where the problem occurred vast majority of the time. In fact I've practically never had a reason to use a debugger when working with Clojure, something that I relied on constantly with Java.\n\nI also find that the REPL completely eliminates the whole compile/run cycle. I can see what the functions are doing as I'm writing them and I don't have to compile and run the whole application any time I make a change. This means that I'm not building up a lot of code before I'm testing to see whether it does what I want. This keeps the context that I need to keep in my head at any one time very small.\n\nI don't know when you last tried Clojure, but there's a lot of documentation available today and there are a number of great books discussing its advanced features.\n\nNot being a Scala user myself I can't really say what the situation is like there. Lots of companies appear to be using it happily though, so can't be all bad. :)", "aSentId": 41189, "answer": "&gt;I've been using Clojure professionally for the past 4 years and I can definitively tell you there's nothing wrong with its implementation. The error messages certainly could be better, but figuring them out is not all that difficult once you learn what the errors mean. My experience has been that errors do trace precisely where the problem occurred vast majority of the time. In fact I've practically never had a reason to use a debugger when working with Clojure, something that I relied on constantly with Java.\n\nWhen I first used it I kept getting NullPointerExceptions. Maybe you don't use macros that much, but the first thing I did was try to implement a DSL based on Clojure and it was very frustrating.\n\nThat said, if/when they do fix the stupid compiler, I will give it another go, because I really like the concept.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41190, "question": "&gt;I've been using Clojure professionally for the past 4 years and I can definitively tell you there's nothing wrong with its implementation. The error messages certainly could be better, but figuring them out is not all that difficult once you learn what the errors mean. My experience has been that errors do trace precisely where the problem occurred vast majority of the time. In fact I've practically never had a reason to use a debugger when working with Clojure, something that I relied on constantly with Java.\n\nWhen I first used it I kept getting NullPointerExceptions. Maybe you don't use macros that much, but the first thing I did was try to implement a DSL based on Clojure and it was very frustrating.\n\nThat said, if/when they do fix the stupid compiler, I will give it another go, because I really like the concept.", "aSentId": 41191, "answer": "Using macros is generally discouraged and vast majority of problems can be solved with regular functions. Beginners often get overexcited about using macros and that's a mistake in my opinion. Macros are a useful tool, but that's really not the main appeal of Clojure. If you look at popular Clojure libraries in the wild you'll see that there are very few macros in them. As the style guide says: [don't write a macro if function will do](https://github.com/bbatsov/clojure-style-guide).\n\nOne of the main benefits I see using Clojure over Java is actually how rare null pointers happen, typically when doing Java interop. Since all the standard library functions handle nil values intelligently, they simply bubble up to the top in most cases. Instead of having to pepper null pointer checks all over the place, you can simply check for a value at the end of the transformation.\n\nAgain, I'm not sure what you mean by \"fix the compiler\". The compiler works exactly as it's supposed to, but you have to understand the intricacies of the language in order to use the most advanced features. \n\nMacros require you to understand the details of how the reader and the evaluator work, what macro expansion is, when it happens, how macros interact with one another and so on. It's hands down the most complex feature of the language and I definitely would not recommend focusing on it as a beginner.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41192, "question": "Using macros is generally discouraged and vast majority of problems can be solved with regular functions. Beginners often get overexcited about using macros and that's a mistake in my opinion. Macros are a useful tool, but that's really not the main appeal of Clojure. If you look at popular Clojure libraries in the wild you'll see that there are very few macros in them. As the style guide says: [don't write a macro if function will do](https://github.com/bbatsov/clojure-style-guide).\n\nOne of the main benefits I see using Clojure over Java is actually how rare null pointers happen, typically when doing Java interop. Since all the standard library functions handle nil values intelligently, they simply bubble up to the top in most cases. Instead of having to pepper null pointer checks all over the place, you can simply check for a value at the end of the transformation.\n\nAgain, I'm not sure what you mean by \"fix the compiler\". The compiler works exactly as it's supposed to, but you have to understand the intricacies of the language in order to use the most advanced features. \n\nMacros require you to understand the details of how the reader and the evaluator work, what macro expansion is, when it happens, how macros interact with one another and so on. It's hands down the most complex feature of the language and I definitely would not recommend focusing on it as a beginner.", "aSentId": 41193, "answer": "&gt;Using macros is generally discouraged and vast majority of problems can be solved with regular functions. Beginners often get overexcited about using macros and that's a mistake in my opinion. Macros are a useful tool, but that's really not the main appeal of Clojure. If you look at popular Clojure libraries in the wild you'll see that there are very few macros in them. As the style guide says: don't write a macro if function will do[1] .\n\nIt wasn't enough in my case. Why would I waste my time on fighting macros if it were?\n\n&gt;One of the main benefits I see using Clojure over Java is actually how rare null pointers happen, typically when doing Java interop. Since all the standard library functions handle nil values intelligently, they simply bubble up to the top in most cases. Instead of having to pepper null pointer checks all over the place, you can simply check for a value at the end of the transformation.\n\nBut the compiler still nullpointed.\n\n&gt;Again, I'm not sure what you mean by \"fix the compiler\". The compiler works exactly as it's supposed to, but you have to understand the intricacies of the language in order to use the most advanced features.\n\nThrowing NullPointerExceptions instead of syntax errors isn't \"working as it is supposed to\" in my book.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41194, "question": "&gt;Using macros is generally discouraged and vast majority of problems can be solved with regular functions. Beginners often get overexcited about using macros and that's a mistake in my opinion. Macros are a useful tool, but that's really not the main appeal of Clojure. If you look at popular Clojure libraries in the wild you'll see that there are very few macros in them. As the style guide says: don't write a macro if function will do[1] .\n\nIt wasn't enough in my case. Why would I waste my time on fighting macros if it were?\n\n&gt;One of the main benefits I see using Clojure over Java is actually how rare null pointers happen, typically when doing Java interop. Since all the standard library functions handle nil values intelligently, they simply bubble up to the top in most cases. Instead of having to pepper null pointer checks all over the place, you can simply check for a value at the end of the transformation.\n\nBut the compiler still nullpointed.\n\n&gt;Again, I'm not sure what you mean by \"fix the compiler\". The compiler works exactly as it's supposed to, but you have to understand the intricacies of the language in order to use the most advanced features.\n\nThrowing NullPointerExceptions instead of syntax errors isn't \"working as it is supposed to\" in my book.", "aSentId": 41195, "answer": "&gt;It wasn't enough in my case. Why would I waste my time on fighting macros if it were?\n\nThere's nothing that macros let you do that can't be done without macros. They're a way to template code when you see repetitive patterns. You still haven't described what it is that you were trying to do in the first place.\n\n&gt;But the compiler still nullpointed.\n\nI'm not sure what you mean by \"compiler nullpointed\", are saying you crashed the compiler. I've certainly never seen that happen myself.\n\n&gt;Throwing NullPointerExceptions instead of syntax errors isn't \"working as it is supposed to\" in my book.\n\nAgain, perhaps you could actually described exactly you did and how you got a null pointer. Perhaps you can paste your code. I have a rather hard time believing that you managed to crash the compiler.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41196, "question": "&gt;It wasn't enough in my case. Why would I waste my time on fighting macros if it were?\n\nThere's nothing that macros let you do that can't be done without macros. They're a way to template code when you see repetitive patterns. You still haven't described what it is that you were trying to do in the first place.\n\n&gt;But the compiler still nullpointed.\n\nI'm not sure what you mean by \"compiler nullpointed\", are saying you crashed the compiler. I've certainly never seen that happen myself.\n\n&gt;Throwing NullPointerExceptions instead of syntax errors isn't \"working as it is supposed to\" in my book.\n\nAgain, perhaps you could actually described exactly you did and how you got a null pointer. Perhaps you can paste your code. I have a rather hard time believing that you managed to crash the compiler.", "aSentId": 41197, "answer": "&gt;Again, perhaps you could actually described exactly you did and how you got a null pointer. Perhaps you can paste your code. I have a rather hard time believing that you managed to crash the compiler.\n\nI don't have the code anymore, that happened 1.5 years ago and I pretty much threw away the project.\n\n&gt;There's nothing that macros let you do that can't be done without macros. They're a way to template code when you see repetitive patterns. You still haven't described what it is that you were trying to do in the first place.\n\nYes, but it would be considerably harder to do. If I recall correctly, macros in Clojure are actually implemented in Clojure, so yes...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41198, "question": "&gt;Again, perhaps you could actually described exactly you did and how you got a null pointer. Perhaps you can paste your code. I have a rather hard time believing that you managed to crash the compiler.\n\nI don't have the code anymore, that happened 1.5 years ago and I pretty much threw away the project.\n\n&gt;There's nothing that macros let you do that can't be done without macros. They're a way to template code when you see repetitive patterns. You still haven't described what it is that you were trying to do in the first place.\n\nYes, but it would be considerably harder to do. If I recall correctly, macros in Clojure are actually implemented in Clojure, so yes...", "aSentId": 41199, "answer": "Right, so not knowing what you were trying to do it's really hard to say what went wrong there. As I said, understanding how a macro works can often be non-trivial. There are tools like `macroexpand` that help you see what the resulting code will look like, but they can be difficult to reason about. This is the reason macro use is discouraged unless it's strictly necessary.\n\nMy point is that it's far more likely that you simply didn't understand what the code templated by the macro was doing than there being any actual problem with the compiler.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41182, "question": "What a shitty article.\n\nPlease find me a language that has:\n\n1. Comparable tooling\n2. A set of 3rd party libraries as rich as Java's\n3. Non-retarded standard library\n\nThis article doesn't even use modern Java... This:\n\n&gt; HashMap&lt;String, Set&gt; depMap = new HashMap();\n\nShould be written like this:\n\n&gt; Map&lt;String, Set&gt; depMap = new HashMap&lt;&gt;();\n\nI can't fucking understand what the author is suggesting. C and C++ absolutely *can't* be used where Java is used. OCaml has a rather small community. Haskell is just too hard to work with for most projects: it becomes a restriction, not a tool.\n\nEdit: fixed code example, thanks /u/TomRK1089!", "aSentId": 41201, "answer": "You have your diamonds backwards. The diamond operator infers the RHS type based on the LHS declaration. It annoys some people; I don't particularly mind.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41202, "question": "You have your diamonds backwards. The diamond operator infers the RHS type based on the LHS declaration. It annoys some people; I don't particularly mind.", "aSentId": 41203, "answer": "Woups... Thank you, fixed it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41182, "question": "What a shitty article.\n\nPlease find me a language that has:\n\n1. Comparable tooling\n2. A set of 3rd party libraries as rich as Java's\n3. Non-retarded standard library\n\nThis article doesn't even use modern Java... This:\n\n&gt; HashMap&lt;String, Set&gt; depMap = new HashMap();\n\nShould be written like this:\n\n&gt; Map&lt;String, Set&gt; depMap = new HashMap&lt;&gt;();\n\nI can't fucking understand what the author is suggesting. C and C++ absolutely *can't* be used where Java is used. OCaml has a rather small community. Haskell is just too hard to work with for most projects: it becomes a restriction, not a tool.\n\nEdit: fixed code example, thanks /u/TomRK1089!", "aSentId": 41205, "answer": "C#. \n\nMainly because you didn't ask for portability. Which is coming soon anyway. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41206, "question": "C#. \n\nMainly because you didn't ask for portability. Which is coming soon anyway. ", "aSentId": 41207, "answer": "&gt; A set of 3rd party libraries as rich as Java's\n\nI love C#, but when it comes to 3rd party libs, you can find anything for Java. They even have a git implementation in \"pure Java\", C# had 2 projects but they both died. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41208, "question": "&gt; A set of 3rd party libraries as rich as Java's\n\nI love C#, but when it comes to 3rd party libs, you can find anything for Java. They even have a git implementation in \"pure Java\", C# had 2 projects but they both died. ", "aSentId": 41209, "answer": "&gt; I love C#, \n\nEveryone does. At least everyone who's been exposed to it, and compares it to anything like java. \n\nYou don't see any articles sayin *\"C# Makes Programmers Want To Do Absolutely Anything Else With Their Time\"* anywhere.\n\n&gt; but when it comes to 3rd party libs, you can find anything for Java\n\nWhich means you can make it run on the CLR by using IKVM or by using an automated java to C# code converter, since java is basically a retarded subset of C# 2.0 from 2005.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41210, "question": "&gt; I love C#, \n\nEveryone does. At least everyone who's been exposed to it, and compares it to anything like java. \n\nYou don't see any articles sayin *\"C# Makes Programmers Want To Do Absolutely Anything Else With Their Time\"* anywhere.\n\n&gt; but when it comes to 3rd party libs, you can find anything for Java\n\nWhich means you can make it run on the CLR by using IKVM or by using an automated java to C# code converter, since java is basically a retarded subset of C# 2.0 from 2005.", "aSentId": 41211, "answer": "&gt; Which means you can make it run on the CLR by using IKVM or by using an automated java to C# code converter, since java is basically a retarded subset of C# 2.0 from 2005.\n\nYou certainly can, but that is additional complexity. Something that Java gets a lot of slack for.\n\nHave you ever done that? Use a Java library with IKVM from C#? Or an automated java to C# code converter?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41206, "question": "C#. \n\nMainly because you didn't ask for portability. Which is coming soon anyway. ", "aSentId": 41213, "answer": "&gt; C#\n\nC# is a great language, but not a great platform. It's tooling is significantly worse than Java's, the standard library is utter shit and there aren't that many 3rd party libraries (and a lot of them are just half-complete ports of Java libraries).\n\nThe only thing I upgrade by switching from Java from C# is the language itself. Everything else is a downgrade. And yes, I've used it.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41214, "question": "&gt; C#\n\nC# is a great language, but not a great platform. It's tooling is significantly worse than Java's, the standard library is utter shit and there aren't that many 3rd party libraries (and a lot of them are just half-complete ports of Java libraries).\n\nThe only thing I upgrade by switching from Java from C# is the language itself. Everything else is a downgrade. And yes, I've used it.\n\n", "aSentId": 41215, "answer": "Also, tough its tooling is basically only VS, it's really great. Maybe your point is only based on your personal taste", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41214, "question": "&gt; C#\n\nC# is a great language, but not a great platform. It's tooling is significantly worse than Java's, the standard library is utter shit and there aren't that many 3rd party libraries (and a lot of them are just half-complete ports of Java libraries).\n\nThe only thing I upgrade by switching from Java from C# is the language itself. Everything else is a downgrade. And yes, I've used it.\n\n", "aSentId": 41217, "answer": "Why do you think the standard library is utter shit? At least in C# we don't have to use some 3rd party libs to work with dates. We also have LINQ, which is great. I can't get your point", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41218, "question": "Why do you think the standard library is utter shit? At least in C# we don't have to use some 3rd party libs to work with dates. We also have LINQ, which is great. I can't get your point", "aSentId": 41219, "answer": "&gt; At least in C# we don't have to use some 3rd party libs to work with dates\n\nNeither do we. Java 8 has an amazing date time API.\n\n&gt; We also have LINQ, which is great. \n\nAnd we have streams. And?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41220, "question": "&gt; At least in C# we don't have to use some 3rd party libs to work with dates\n\nNeither do we. Java 8 has an amazing date time API.\n\n&gt; We also have LINQ, which is great. \n\nAnd we have streams. And?", "aSentId": 41221, "answer": "And why C# standard lib is utter shit? Can you point something?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41222, "question": "And why C# standard lib is utter shit? Can you point something?", "aSentId": 41223, "answer": "Treating paths as strings, for example. In Java, we have classes like File (the old class) and Path (the new, generic class). In C#, a path is a string and you modify it by calling static methods.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41220, "question": "&gt; At least in C# we don't have to use some 3rd party libs to work with dates\n\nNeither do we. Java 8 has an amazing date time API.\n\n&gt; We also have LINQ, which is great. \n\nAnd we have streams. And?", "aSentId": 41225, "answer": "But streams suck compared to enumerables, the nice thing about IEnumerable is that it's for collections and streams. So you don't have to collect anything unless you're casting to a collection, you can make extension methods that work on all collections and streams, and the syntax is way nicer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41228, "question": "Go's standard library is way less retarded then Java's. It's got a pretty extensive set of 3rd party libraries (not as good as Java, but considering how young it is it's really impressive).\n\nI don't know about the tooling, but it is definitely an easy language to parse (unlike C++ for example), so I imagine you could do pretty much anything you wanted. E.g. it has *EASY* built in support for unit tests and documentation. For Java I imagine you need to download some third party tool and write some XML nonsense.\n\n&gt; C and C++ absolutely can't be used where Java is used. \n\nWhat? Why not?", "aSentId": 41229, "answer": "&gt;Go's standard library is way less retarded then Java's. It's got a pretty extensive set of 3rd party libraries (not as good as Java, but considering how young it is it's really impressive).\n\nGo, as a language, is retarded. Generics worse than Java's (bwahaha), shitty error handling system, etc...\n\n&gt;I don't know about the tooling, but it is definitely an easy language to parse (unlike C++ for example), so I imagine you could do pretty much anything you wanted. E.g. it has EASY built in support for unit tests and documentation. For Java I imagine you need to download some third party tool and write some XML nonsense.\n\nIs JUnit too hard? And Javadoc? Also, you don't need any XML anymore. Maven can be replaced by Gradle and frameworks like Spring have pure Java configuration nowadays.\n\n&gt;What? Why not?\n\nWhen safety, compilation speed and other factors regarding development speed are important, it's best not to use C and C++ because they are simply a time waste and an overall security risk.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41231, "question": "I will read this at work because in my own time I won't be reading about Java", "aSentId": 41232, "answer": "\"Ey guys, i hate java too! Am i cool yet?\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41233, "question": "\"Ey guys, i hate java too! Am i cool yet?\"", "aSentId": 41234, "answer": "\"Ey guys, this guy is just a HIPSTER for disliking Java, LOL UPVOTE ME\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41235, "question": "\"Ey guys, this guy is just a HIPSTER for disliking Java, LOL UPVOTE ME\"", "aSentId": 41236, "answer": "I will read this at work because in my own time i won't be reading baits.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41239, "question": "The author mistakenly states that Python can't do parallelism as it has a 'GIL'.\n\nPython does parallelism.\nPython does NOT have a Global Interpreter Lock.\nJython (Python on the JVM) has no GIL.\nIronPython (Python for .net) has no GIL.\nC-Python has a GIL, and does parallelism.\n\nParallelism and Python needs more than an incorrect throw - away comment.", "aSentId": 41240, "answer": "&gt; C-Python has a GIL, and does parallelism.\n\nC-Python does concurrency. Parallelism, not so much.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41243, "question": "Strange...I've never encountered these types of problems nor those types of programmers yet. I'm not sure I understand the frustration with the logger, but I can understand that Maven has a learning curve and its own way of doing things. But Maven grew out of Ant, which had its own problems where things tended to not be uniform between different organizations' code.\n\n\nI understand that Java has issues that are resolved by other languages, but I'm still not sure why it gets so much hate. Bad coding styles are due to bad programmers, not the language in itself. GoF patterns can be translated between languages; they aren't unique to Java. Such strong language, and yet I haven't seen anybody point to open-source, well-known code bases that are infected with techniques as such. There is a time and place for everything, and so even the hate on GoF seems unjustified; rather than the patterns being the problem, its the programmers' fault for abusing them.\n\nJava does attract a lot of sub-par programmers. But you know what? So does any other popular language. Programmers, no matter their skill level, need to make money and so learn marketable tools. I have met iOS app developers that didn't know the difference between a compiler and an IDE. Sound familiar? ", "aSentId": 41244, "answer": "In every language that I've used for more than a trivial project, I have met some 100% certifiable morons who love that language.  I think they must exist all the way up the power-spectrum of programming languages, I haven't met enough Haskell programmers to know for sure.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41246, "question": "So much to agree with this while I work on a code piece with probably 20 lines of logic in 500 lines of java code full of 40-50 char long variable names.", "aSentId": 41247, "answer": "Sounds like some exceptionally clean Java you got there.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41248, "question": "Sounds like some exceptionally clean Java you got there.", "aSentId": 41249, "answer": "Java isn't exactly concise. For example, the complete lack of operator overloading means one ends up writing a lot of \n\n    x.equals(y) || x.compareTo(z) == -1\n\ninstead of\n\n    x == y || x &lt; z", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41250, "question": "Java isn't exactly concise. For example, the complete lack of operator overloading means one ends up writing a lot of \n\n    x.equals(y) || x.compareTo(z) == -1\n\ninstead of\n\n    x == y || x &lt; z", "aSentId": 41251, "answer": "I know, joking.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41250, "question": "Java isn't exactly concise. For example, the complete lack of operator overloading means one ends up writing a lot of \n\n    x.equals(y) || x.compareTo(z) == -1\n\ninstead of\n\n    x == y || x &lt; z", "aSentId": 41253, "answer": "Perhaps you should brush up on your fundamentals then. If you want less than or equal to, you write \n\n    x.compareTo(z) &lt;= 0\n\n`compareTo` is defined as *any negative integer* being less than, not just -1. So, it's your own fault your code is verbose, and wrong, too.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41248, "question": "Sounds like some exceptionally clean Java you got there.", "aSentId": 41255, "answer": "I am not trying exaggerate but it is indeed considered clean and precise as it is not using elaborately designed generic framework of the main application which is like 2 dozen classes 1000s of lines of code to open and manage http / jms connections and this is with using all apache and what not jar libraries to provide core functionality. \n\nI should talk less as I am already considered bad developer for calling out shortcomings of framework as I do not see big picture.\n\nJava is way of life here where everything is planned for decades but craps out on first production load.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41256, "question": "I am not trying exaggerate but it is indeed considered clean and precise as it is not using elaborately designed generic framework of the main application which is like 2 dozen classes 1000s of lines of code to open and manage http / jms connections and this is with using all apache and what not jar libraries to provide core functionality. \n\nI should talk less as I am already considered bad developer for calling out shortcomings of framework as I do not see big picture.\n\nJava is way of life here where everything is planned for decades but craps out on first production load.", "aSentId": 41257, "answer": "/joking", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41246, "question": "So much to agree with this while I work on a code piece with probably 20 lines of logic in 500 lines of java code full of 40-50 char long variable names.", "aSentId": 41259, "answer": "Sounds like a problem created by the programmer and not the programming language.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41260, "question": "Sounds like a problem created by the programmer and not the programming language.", "aSentId": 41261, "answer": "Not only that but after mulling about this thread for a while I felt a renewed hate for \"clever\" developers who use single letter or similarly nondescriptive variable and function names.  When I write lisp I can't say those identifiers are any different than what I would do in c++/java", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41260, "question": "Sounds like a problem created by the programmer and not the programming language.", "aSentId": 41263, "answer": "When your language is not expressive then you have to map your problem to the available language constructs. This necessarily results in lots of boilerplate code. This is one of the primary reasons Java code tends to be so bloated.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41260, "question": "Sounds like a problem created by the programmer and not the programming language.", "aSentId": 41265, "answer": "It has to do with Java. See Java's servlet, AWT, date-time, io ( till very recently) and so many others are full of abstracted crap. If Sun/ Oracle engineer write such crap others just take cue from them \n\nAlmost all Apache Java projects I have worked with like Apache CXF, Axis etc...are also like that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41267, "question": "\"by Michael O Church\" \n\nConsider the source. Knowing this guy's work personally was enough to make me immediately stop reading the article. \n\nI'd really like it if r/programming stopped church-rolling me when I'm looking for actual well reasoned content. Stop feeding the troll, and maybe he'll end up somewhere else. ", "aSentId": 41268, "answer": "&gt; Knowing this guy's work personally was enough to make me immediately stop reading the article.\n\nAd-hominem attacks are a little bit uncouth.  Especially with no supporting evidence.  Does he have any publicly-visible code we could read?\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41269, "question": "&gt; Knowing this guy's work personally was enough to make me immediately stop reading the article.\n\nAd-hominem attacks are a little bit uncouth.  Especially with no supporting evidence.  Does he have any publicly-visible code we could read?\n", "aSentId": 41270, "answer": "This article? :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41267, "question": "\"by Michael O Church\" \n\nConsider the source. Knowing this guy's work personally was enough to make me immediately stop reading the article. \n\nI'd really like it if r/programming stopped church-rolling me when I'm looking for actual well reasoned content. Stop feeding the troll, and maybe he'll end up somewhere else. ", "aSentId": 41272, "answer": "Who's Michael Church? I only know about Zed \"Rails Is A Ghetto\" Shaw and Phil \"Suck my dick. Choke on it\" Fish.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41267, "question": "\"by Michael O Church\" \n\nConsider the source. Knowing this guy's work personally was enough to make me immediately stop reading the article. \n\nI'd really like it if r/programming stopped church-rolling me when I'm looking for actual well reasoned content. Stop feeding the troll, and maybe he'll end up somewhere else. ", "aSentId": 41274, "answer": "This is the second time I see something this guy wrote and a second time I see a comment that he should be ignored. In both cases the content supports the claim that he should be ignored.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41281, "question": "What is with all the Java and OOP hate here? It's all very useful despite what some editorial thinks. If it doesn't fit your needs, great! Go use soa or a functional or a procedural language and have more fun. I personally like coding in Java, I usually end up with less headaches than using C++. ", "aSentId": 41282, "answer": "Warning: You are going to take the hit for many others too, don't take it too personally. \n\nHere is what there is to it:\n\n- OOP is a butchered paradigm. It has been completely stripped in modern days of the fundationnal properties it had when invented, and has been travestied into something with absolutely none of the industry promises fullfilled.\n- Most of Java and OOP workforce is made of incompetent clones formatted by industry-standard training\n- The point is not C++ vs Java. You should broaden your horizon. The point is Java and C++ and others versus arguably better suited languages and paradigms for the challenges of today and tomorrow, notably concurrent and distributed systems, which are a nightmare to code right in Java or C++.\n- It is not about fun, it is about advancing the industry of computer programming, by picking interesting ideas from research.\n- The \"being useful\" argument is just leveling the field using the most common (smallest) denominator, staying in your comfort zone (aka stagnating and embracing mediocrity) and accepting to stick to \"the way things are\" despite the fact that the history of it is one of industrial compromises rather than technical excellence.\n\nYou are free to embrace mediocrity and stagnation. You are free to lock yourself voluntarily into a tiny sphere that becomes your IT universe. You are free to ignore attempts to make your field better, and rely on vendors and of-the-shelf corporate offerings.\n\nBut don't complain the day you realize that all you've done in your career is follow established rules you don't understand, leading you into obsolescence before you even realize it. And by all means, be my guest, it is only by contrast to the lowly mass of Java grunts that better, innovative, curious and ambitious programmer can shine.\n\nHaaaa... now let the downvotes pour in (I have no illusions, I am attacking far more people in this comment than the group I am going to get a smile from), feels good to vent a bit for a change.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41283, "question": "Warning: You are going to take the hit for many others too, don't take it too personally. \n\nHere is what there is to it:\n\n- OOP is a butchered paradigm. It has been completely stripped in modern days of the fundationnal properties it had when invented, and has been travestied into something with absolutely none of the industry promises fullfilled.\n- Most of Java and OOP workforce is made of incompetent clones formatted by industry-standard training\n- The point is not C++ vs Java. You should broaden your horizon. The point is Java and C++ and others versus arguably better suited languages and paradigms for the challenges of today and tomorrow, notably concurrent and distributed systems, which are a nightmare to code right in Java or C++.\n- It is not about fun, it is about advancing the industry of computer programming, by picking interesting ideas from research.\n- The \"being useful\" argument is just leveling the field using the most common (smallest) denominator, staying in your comfort zone (aka stagnating and embracing mediocrity) and accepting to stick to \"the way things are\" despite the fact that the history of it is one of industrial compromises rather than technical excellence.\n\nYou are free to embrace mediocrity and stagnation. You are free to lock yourself voluntarily into a tiny sphere that becomes your IT universe. You are free to ignore attempts to make your field better, and rely on vendors and of-the-shelf corporate offerings.\n\nBut don't complain the day you realize that all you've done in your career is follow established rules you don't understand, leading you into obsolescence before you even realize it. And by all means, be my guest, it is only by contrast to the lowly mass of Java grunts that better, innovative, curious and ambitious programmer can shine.\n\nHaaaa... now let the downvotes pour in (I have no illusions, I am attacking far more people in this comment than the group I am going to get a smile from), feels good to vent a bit for a change.", "aSentId": 41284, "answer": "I regret that I have but one upvote to give you", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41285, "question": "I regret that I have but one upvote to give you", "aSentId": 41286, "answer": "I take that for a smile, it's better than incrementing a not-so-important variable on reddit's servers :-)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41283, "question": "Warning: You are going to take the hit for many others too, don't take it too personally. \n\nHere is what there is to it:\n\n- OOP is a butchered paradigm. It has been completely stripped in modern days of the fundationnal properties it had when invented, and has been travestied into something with absolutely none of the industry promises fullfilled.\n- Most of Java and OOP workforce is made of incompetent clones formatted by industry-standard training\n- The point is not C++ vs Java. You should broaden your horizon. The point is Java and C++ and others versus arguably better suited languages and paradigms for the challenges of today and tomorrow, notably concurrent and distributed systems, which are a nightmare to code right in Java or C++.\n- It is not about fun, it is about advancing the industry of computer programming, by picking interesting ideas from research.\n- The \"being useful\" argument is just leveling the field using the most common (smallest) denominator, staying in your comfort zone (aka stagnating and embracing mediocrity) and accepting to stick to \"the way things are\" despite the fact that the history of it is one of industrial compromises rather than technical excellence.\n\nYou are free to embrace mediocrity and stagnation. You are free to lock yourself voluntarily into a tiny sphere that becomes your IT universe. You are free to ignore attempts to make your field better, and rely on vendors and of-the-shelf corporate offerings.\n\nBut don't complain the day you realize that all you've done in your career is follow established rules you don't understand, leading you into obsolescence before you even realize it. And by all means, be my guest, it is only by contrast to the lowly mass of Java grunts that better, innovative, curious and ambitious programmer can shine.\n\nHaaaa... now let the downvotes pour in (I have no illusions, I am attacking far more people in this comment than the group I am going to get a smile from), feels good to vent a bit for a change.", "aSentId": 41288, "answer": "Wow, you're full of frustration/hate ... Where does it come from?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41289, "question": "Wow, you're full of frustration/hate ... Where does it come from?", "aSentId": 41290, "answer": "Hate, no. Frustration, yes. It comes from 20 years of being the almost daily witness of what I described above, over and over again, and preaching in the desert almost 99% of the time to programmers, CTOs, CEOs and founders that it's not because \"everyone does it this way\" that it's how it should be done. RPC, ORM, PHP, OOP, manual management of locking and memory for complex systems, Merise, heavy waterfall project management for everything, you name it. And most of the time, it boils down to trivial cognitive biases like resistance to changement :-(\n\nedit: I hope you don't assume that everyone ranting on the internet is full of hate. That would be a _lot_ of hate.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41297, "question": "It's not the language, it's the environment,", "aSentId": 41298, "answer": "I've been doing Java for years and years and I've worked through several iterations of the tools. I feel pretty confident in saying that the language itself discourages me from using it for personal projects. Java 8 is making some real progress on this front, but there's still an awful lot of typing that feels repetitive. Personally, I think this is part of the reason I find Clojure so compelling.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41299, "question": "I've been doing Java for years and years and I've worked through several iterations of the tools. I feel pretty confident in saying that the language itself discourages me from using it for personal projects. Java 8 is making some real progress on this front, but there's still an awful lot of typing that feels repetitive. Personally, I think this is part of the reason I find Clojure so compelling.", "aSentId": 41300, "answer": "Oh I agree, I've moved on to Scala myself, but most of what is described in the article is not Java specific, more likely it is due to \"enterprise\"-y practices, not the language itself.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41297, "question": "It's not the language, it's the environment,", "aSentId": 41302, "answer": "Its the language.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41303, "question": "Its the language.", "aSentId": 41304, "answer": "Sure, if one doesn't understand grammar.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41306, "question": "So... should I not be learning java?", "aSentId": 41307, "answer": "Just make sure to learn some other languages as well.  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41306, "question": "So... should I not be learning java?", "aSentId": 41309, "answer": "Java is fine. This article is a non-majority opinion.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41306, "question": "So... should I not be learning java?", "aSentId": 41311, "answer": "Java is a very useful tool for helping you appreciate C#.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41319, "question": "\"HashMap&lt;String, Set&gt; depMap = new HashMap();\n\u2026I die a little on the inside. Because to me, that says, \u201cdepMap is a map, which is a map.\u201d\"\n\nSorta.  It's setting a reference of type HashMap to a new HashMap.", "aSentId": 41320, "answer": "Yes, Java can be more verbose, but that specific example is a very bad argument against it. That's basically how every other strongly typed language did (and some still do) things. Actually, that's not a very good argument either. So, here's more:\n\n* Polymorphism. The type on the left is what the following code expects to work with. The type on the right is the specific implementation. You could just as easily have `Map&lt;String, Set&gt;` on the left and `new TreeMap&lt;&gt;()` on the right. The lines that follow depend on `depMap` being a map, not a tree or hash map. This doesn't mean much for a silly example like this but in larger systems, it helps in more than one ways. Which brings me to,\n* Self-documenting. If you were able to do it without specifying the type, say something like `depMap := getDependencies()`, at a quick glance I can't tell what the type of `depMap` is. On the other hand, `Map&lt;String, Set&gt; depMap = getDependncies()` tells me exactly what's going on.\n* You don't really have to type it out manually. You'll be using an IDE. If you know how to use your IDE, you will type variable name equals to right hand side, press two extra keys, and let the IDE add the type -- selecting one if there are multiple viable options (because polymorphism).\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41321, "question": "Yes, Java can be more verbose, but that specific example is a very bad argument against it. That's basically how every other strongly typed language did (and some still do) things. Actually, that's not a very good argument either. So, here's more:\n\n* Polymorphism. The type on the left is what the following code expects to work with. The type on the right is the specific implementation. You could just as easily have `Map&lt;String, Set&gt;` on the left and `new TreeMap&lt;&gt;()` on the right. The lines that follow depend on `depMap` being a map, not a tree or hash map. This doesn't mean much for a silly example like this but in larger systems, it helps in more than one ways. Which brings me to,\n* Self-documenting. If you were able to do it without specifying the type, say something like `depMap := getDependencies()`, at a quick glance I can't tell what the type of `depMap` is. On the other hand, `Map&lt;String, Set&gt; depMap = getDependncies()` tells me exactly what's going on.\n* You don't really have to type it out manually. You'll be using an IDE. If you know how to use your IDE, you will type variable name equals to right hand side, press two extra keys, and let the IDE add the type -- selecting one if there are multiple viable options (because polymorphism).\n", "aSentId": 41322, "answer": "I think the argument is for compile time type inference, something every modern compiled language has, except java of course. Any IDE will tell you what the type is, without you having to type it out.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41323, "question": "I think the argument is for compile time type inference, something every modern compiled language has, except java of course. Any IDE will tell you what the type is, without you having to type it out.", "aSentId": 41324, "answer": "I mean it's not like it's technically infeasible to infer the type at compile time. The current approach is just a lot clearer (see the second point).\n\nFor example, a quick glance while scrolling through the code in a web-based code viewer shows you what type you're dealing with. You don't need to go into an IDE or follow the source code to figure this out. Basically what I'm getting at is that it's a feature, not a deficiency. \n\nAlso, IDEs kinda give you coding-time type inference and add the types to the source code for you. So you don't generally have to type it out.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41325, "question": "I mean it's not like it's technically infeasible to infer the type at compile time. The current approach is just a lot clearer (see the second point).\n\nFor example, a quick glance while scrolling through the code in a web-based code viewer shows you what type you're dealing with. You don't need to go into an IDE or follow the source code to figure this out. Basically what I'm getting at is that it's a feature, not a deficiency. \n\nAlso, IDEs kinda give you coding-time type inference and add the types to the source code for you. So you don't generally have to type it out.", "aSentId": 41326, "answer": "I strongly disagree that it's a feature. Java seems to have the mentality that it doesn't give you enough rope to hang yourself with, so it takes away all sorts of crucial features. The ostensible tradeoff is that your code is easier to understand as a result.\n\nBut in my experience with enterprise Java, bad developers will write awful code no matter how much you take away from them. The worst codebase I've ever seen, by far, was Java.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41327, "question": "I strongly disagree that it's a feature. Java seems to have the mentality that it doesn't give you enough rope to hang yourself with, so it takes away all sorts of crucial features. The ostensible tradeoff is that your code is easier to understand as a result.\n\nBut in my experience with enterprise Java, bad developers will write awful code no matter how much you take away from them. The worst codebase I've ever seen, by far, was Java.", "aSentId": 41328, "answer": "I'm not convinced, I believe there are simply more people writing Java thus we see more poor quality Java code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41327, "question": "I strongly disagree that it's a feature. Java seems to have the mentality that it doesn't give you enough rope to hang yourself with, so it takes away all sorts of crucial features. The ostensible tradeoff is that your code is easier to understand as a result.\n\nBut in my experience with enterprise Java, bad developers will write awful code no matter how much you take away from them. The worst codebase I've ever seen, by far, was Java.", "aSentId": 41330, "answer": "Agreed. Bad developers will write bad code regardless.  I'm not saying it prevents bad code.\n\nI think it's a feature because of the self-documenting nature of it.\n\nIn the end it's just a matter of personal opinion. I won't insist on attempting to change yours.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41325, "question": "I mean it's not like it's technically infeasible to infer the type at compile time. The current approach is just a lot clearer (see the second point).\n\nFor example, a quick glance while scrolling through the code in a web-based code viewer shows you what type you're dealing with. You don't need to go into an IDE or follow the source code to figure this out. Basically what I'm getting at is that it's a feature, not a deficiency. \n\nAlso, IDEs kinda give you coding-time type inference and add the types to the source code for you. So you don't generally have to type it out.", "aSentId": 41332, "answer": "If only we could do something to avoid this kind of lack of clarity. Like naming variables something descriptive that somehow makes the type obvious... :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41323, "question": "I think the argument is for compile time type inference, something every modern compiled language has, except java of course. Any IDE will tell you what the type is, without you having to type it out.", "aSentId": 41334, "answer": "Java has thousands of libraries packaged up in jar files. Not many languages have that. Languages sometimes expose libraries in source-code format. With a binary-like format, information could be lost. So languages like Java that make declaring types extremely redundant may help the IDEs with figuring out the types of those variables. :-)\n\nAlso, one of the goals they may have had for Java was to make competing implementations compatible. Dumbing down the language may have been an effort to make that less difficult. It seems that even new languages are willing to go in that direction so they can help with multiple implementation goals.\n\nLanguages that do a great deal of type inference may end up with only their reference implementations. Although perhaps we shouldn't have blamed the type inferencing as the whole cause of it. I think languages willing to break backward compatibility with every other release may not be too enticing for mainstream use. Hence they ending up with just their reference implementations.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41335, "question": "Java has thousands of libraries packaged up in jar files. Not many languages have that. Languages sometimes expose libraries in source-code format. With a binary-like format, information could be lost. So languages like Java that make declaring types extremely redundant may help the IDEs with figuring out the types of those variables. :-)\n\nAlso, one of the goals they may have had for Java was to make competing implementations compatible. Dumbing down the language may have been an effort to make that less difficult. It seems that even new languages are willing to go in that direction so they can help with multiple implementation goals.\n\nLanguages that do a great deal of type inference may end up with only their reference implementations. Although perhaps we shouldn't have blamed the type inferencing as the whole cause of it. I think languages willing to break backward compatibility with every other release may not be too enticing for mainstream use. Hence they ending up with just their reference implementations.", "aSentId": 41336, "answer": "What sort of argument against type inference is this?!?\n\nType inference just requires signatures, which should well be present in any precompiled library (linking is otherwise impossible). In principle Java has nothing that would prevent type inference, precisely like *var* in C#.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41337, "question": "What sort of argument against type inference is this?!?\n\nType inference just requires signatures, which should well be present in any precompiled library (linking is otherwise impossible). In principle Java has nothing that would prevent type inference, precisely like *var* in C#.", "aSentId": 41338, "answer": "&gt; What sort of argument against type inference is this?!?\n\nI'd argue that IDEA's struggle to provide correct and meaningful Scala   type information (the best form of type checking can often yield false positives) is a good argument against it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41337, "question": "What sort of argument against type inference is this?!?\n\nType inference just requires signatures, which should well be present in any precompiled library (linking is otherwise impossible). In principle Java has nothing that would prevent type inference, precisely like *var* in C#.", "aSentId": 41340, "answer": "I don't know how to respond to that. I think that ultimately the proof  is in the pudding. Or as in Jerry Maguire: \"Show me the money!\" If type inference is no problem for libraries, multiple competing implementations, backward compatibility, etc, show me the money! :-)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41341, "question": "I don't know how to respond to that. I think that ultimately the proof  is in the pudding. Or as in Jerry Maguire: \"Show me the money!\" If type inference is no problem for libraries, multiple competing implementations, backward compatibility, etc, show me the money! :-)", "aSentId": 41342, "answer": "The compiler absolutely must know the type of every variable, because otherwise it couldn't possibly give you a mismatched type error.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41343, "question": "The compiler absolutely must know the type of every variable, because otherwise it couldn't possibly give you a mismatched type error.", "aSentId": 41344, "answer": "Yes. But it's the work of following the dependency to the original types that must be considered too. In some languages types can be inferred in a lot of places. More so than just local to a function. That extra work is not always advisable. Many languages in the Java ecosystem can share the libraries thanks to the effort that Java put into making the libraries easier to share. But once the library follows the Java standards, they may lose some unique informations as required by some languages in the source-code. Information that could implicitly depend on private types even. So language designers are sometimes skeptical of how much information can be leaked in type inference support.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41341, "question": "I don't know how to respond to that. I think that ultimately the proof  is in the pudding. Or as in Jerry Maguire: \"Show me the money!\" If type inference is no problem for libraries, multiple competing implementations, backward compatibility, etc, show me the money! :-)", "aSentId": 41346, "answer": "Scala already does this.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41319, "question": "\"HashMap&lt;String, Set&gt; depMap = new HashMap();\n\u2026I die a little on the inside. Because to me, that says, \u201cdepMap is a map, which is a map.\u201d\"\n\nSorta.  It's setting a reference of type HashMap to a new HashMap.", "aSentId": 41348, "answer": "This bit of code annoys me for several reasons:\n\n- Unless you're using something specific to the implementation type, you could use the interface: Map&lt;String,Set&gt; depMap = new HashMap();\n- He's not using the diamond for the generic types: Map&lt;String,Set&gt; depMap = new HashMap&lt;&gt;();\n- He's not typing the Set: Map&lt;String,Set&lt;String&gt;&gt; depMap = HashMap&lt;&gt;();\n- Could use Guava to abstract the inner collection: Multimap&lt;String,String&gt; depMap = HashMultimap.create();\n\nArticles/comments like these constantly annoy me. They're written by people who really aren't that familiar with clean, modern Java. Lambdas, ORM, libraries of annotations... there's so much stuff out there to simply how much Java you write and make it much cleaner than all these examples people use of why Java is bad.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41349, "question": "This bit of code annoys me for several reasons:\n\n- Unless you're using something specific to the implementation type, you could use the interface: Map&lt;String,Set&gt; depMap = new HashMap();\n- He's not using the diamond for the generic types: Map&lt;String,Set&gt; depMap = new HashMap&lt;&gt;();\n- He's not typing the Set: Map&lt;String,Set&lt;String&gt;&gt; depMap = HashMap&lt;&gt;();\n- Could use Guava to abstract the inner collection: Multimap&lt;String,String&gt; depMap = HashMultimap.create();\n\nArticles/comments like these constantly annoy me. They're written by people who really aren't that familiar with clean, modern Java. Lambdas, ORM, libraries of annotations... there's so much stuff out there to simply how much Java you write and make it much cleaner than all these examples people use of why Java is bad.", "aSentId": 41350, "answer": "There needs to be a Poe's Law for Java, because it is impossible for me to tell when people who comment about the 'right way' to express Java aren't just trolling with things like Map&lt;String,Set&lt;String&gt;&gt; depMap = HashMap&lt;&gt;();\n\n\nSort of the same way there's very little difference between code in this library:\nhttps://github.com/goldmansachs/gs-collections\n\nAnd this one:\nhttps://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41351, "question": "There needs to be a Poe's Law for Java, because it is impossible for me to tell when people who comment about the 'right way' to express Java aren't just trolling with things like Map&lt;String,Set&lt;String&gt;&gt; depMap = HashMap&lt;&gt;();\n\n\nSort of the same way there's very little difference between code in this library:\nhttps://github.com/goldmansachs/gs-collections\n\nAnd this one:\nhttps://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition\n", "aSentId": 41352, "answer": "Remember that this\n\n    Map&lt;String, Set&lt;String&gt;&gt; depMap = new HashMap&lt;&gt;();\n\nReplaces this\n\n    Map&lt;String, Set&lt;String&gt;&gt; depMap = new HashMap&lt;String, Set&lt;String&gt;&gt;();\n\nSo it is obviously perceived as an improvement. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41351, "question": "There needs to be a Poe's Law for Java, because it is impossible for me to tell when people who comment about the 'right way' to express Java aren't just trolling with things like Map&lt;String,Set&lt;String&gt;&gt; depMap = HashMap&lt;&gt;();\n\n\nSort of the same way there's very little difference between code in this library:\nhttps://github.com/goldmansachs/gs-collections\n\nAnd this one:\nhttps://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition\n", "aSentId": 41354, "answer": "looking at that FizzBuzzEnterpriseEdition repo gave me cancer, thanks a lot.\n\nI know plenty of people like it, but I think I'd rather find another profession if I could only ever program in Java for the rest of my life.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41355, "question": "looking at that FizzBuzzEnterpriseEdition repo gave me cancer, thanks a lot.\n\nI know plenty of people like it, but I think I'd rather find another profession if I could only ever program in Java for the rest of my life.", "aSentId": 41356, "answer": "Keep in mind that the Enterprise FizzBuzz is a product of a certain environment, which does happen to favor Java (and C#). There are plenty of other environments which do use these languages without needing that huge, over engineered cruft. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41319, "question": "\"HashMap&lt;String, Set&gt; depMap = new HashMap();\n\u2026I die a little on the inside. Because to me, that says, \u201cdepMap is a map, which is a map.\u201d\"\n\nSorta.  It's setting a reference of type HashMap to a new HashMap.", "aSentId": 41358, "answer": "First, you forgot the diamond (\"new HashMap&lt;&gt;()\"). Second, you should never assign to concrete types if possible. Always use an interface or abstract where possible (simply Map in this case). This makes it easier to swap out implementations later! ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41360, "question": "Your example only shows you dont know Java, nothing about Java itself.", "aSentId": 41361, "answer": "I'm quoting the author.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41363, "question": "&gt; new HashMap();\n\nnew HashMap &lt;String, Set&gt;();", "aSentId": 41364, "answer": "new HashMap&lt;&gt;();", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41363, "question": "&gt; new HashMap();\n\nnew HashMap &lt;String, Set&gt;();", "aSentId": 41366, "answer": "&gt;&gt; new HashMap();\n\n&gt;new HashMap &lt;String, Set&gt;();\n\nnew HashMap&lt;&gt;();", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41363, "question": "&gt; new HashMap();\n\nnew HashMap &lt;String, Set&gt;();", "aSentId": 41368, "answer": "Some time ago, they allowed the template (or whatever Java calls them) variables to be inferred from the variable declaration, so you no longer have to type that part out.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41385, "question": "&gt; Java Makes Programmers Want To Do Absolutely Anything Else With Their Time\n\nBUT! BUT! It haz this \"monitoring\" thing with lots of gauges and gadgets!! lolo\n\nBUT it is 0.0023% faster than anything elses!!!! lololo\n\nBUT it haz real timez! and it powers airports and banks and all the \"important\" thingz!!! lolo!!! \n\n - /u/pron98\n\n(4realz) yeah, java is a [professional](http://core0.staticworld.net/images/article/2013/07/java-ask-toolbar-100047090-gallery.png) programming platform for professional developers doing professional work... there's no \"joy\" or any kind of satisfaction in using it, seeking satisfaction from your daily work is juvenile and shows how you're an immature unprofessional person. \n\nYou should get over the fact that **work is not to be enjoyed**, do something else with your life such as riding a bike or playing guitar.", "aSentId": 41386, "answer": "See, agleiv, I know we had this special S&amp;M relationship between us, where you enjoyed me humiliating you in public, but last time you tried to hurt my feelings, so I'd appreciate it if you stop mentioning me in your insane rants again. I'm sure there are many other people on Reddit who'd be happy to shame you if you ask nicely, especially as it takes so little effort (tell them you do all the work yourself; they just need to supply a punchline). Thank you.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41387, "question": "See, agleiv, I know we had this special S&amp;M relationship between us, where you enjoyed me humiliating you in public, but last time you tried to hurt my feelings, so I'd appreciate it if you stop mentioning me in your insane rants again. I'm sure there are many other people on Reddit who'd be happy to shame you if you ask nicely, especially as it takes so little effort (tell them you do all the work yourself; they just need to supply a punchline). Thank you.", "aSentId": 41388, "answer": "LOL. As if I would give any fucks about what a dinosaur cobol developer from the 40's thinks. Go home take a rest, grandpa.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41390, "question": "Hello World in 450+ programming languages (plus several \"real\" ones)", "aSentId": 41391, "answer": "Uh, comments are possible in Brainfuck.  Any character that isn't ,.&lt;&gt;[]+- is a comment.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41392, "question": "Uh, comments are possible in Brainfuck.  Any character that isn't ,.&lt;&gt;[]+- is a comment.", "aSentId": 41393, "answer": "that asshole!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41394, "question": "that asshole!", "aSentId": 41395, "answer": "--------E\n\nHere's your pitchfork, friend", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41396, "question": "--------E\n\nHere's your pitchfork, friend", "aSentId": 41397, "answer": "gon' git'im", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41392, "question": "Uh, comments are possible in Brainfuck.  Any character that isn't ,.&lt;&gt;[]+- is a comment.", "aSentId": 41399, "answer": "Additionally, you can also write a comment loop at the start of any bf code.  A begin-loop character will skip the contents if the current cell is 0.  As long as all the brackets are matched up, you can write arbitrary text including all of the control characters inside.  This also works after any other loop, as, at the time the previous loop has finished executing, the selected cell must be 0.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41390, "question": "Hello World in 450+ programming languages (plus several \"real\" ones)", "aSentId": 41401, "answer": "Also see: http://rosettacode.org/wiki/Rosetta_Code", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41390, "question": "Hello World in 450+ programming languages (plus several \"real\" ones)", "aSentId": 41403, "answer": "wut\n\n    Hello World in BIT.\n    No comments possible.\n    \n    LINENUMBERZEROCODEPRINTZEROGOTOONELINENUMBERONECODEPRINTONEGOTOONEZEROLINENUMBE\n    RONEZEROCODEPRINTZEROGOTOONEONELINENUMBERONEONECODEPRINTZEROGOTOONEZEROZEROLINE\n    NUMBERONEZEROZEROCODEPRINTONEGOTOONEZEROONELINENUMBERONEZEROONECODEPRINTZEROGOT\n    OONEONEZEROLINENUMBERONEONEZEROCODEPRINTZEROGOTOONEONEONELINENUMBERONEONEONECOD\n    EPRINTZEROGOTOONEZEROZEROZEROLINENUMBERONEZEROZEROZEROCODEPRINTZEROGOTOONEZEROZ\n    EROONELINENUMBERONEZEROZEROONECODEPRINTONEGOTOONEZEROONEZEROLINENUMBERONEZEROON\n    EZEROCODEPRINTONEGOTOONEZEROONEONELINENUMBERONEZEROONEONECODEPRINTZEROGOTOONEON\n    EZEROZEROLINENUMBERONEONEZEROZEROCODEPRINTZEROGOTOONEONEZEROONELINENUMBERONEONE\n    ZEROONECODEPRINTONEGOTOONEONEONEZEROLINENUMBERONEONEONEZEROCODEPRINTZEROGOTOONE\n    ONEONEONELINENUMBERONEONEONEONECODEPRINTONEGOTOONEZEROZEROZEROZEROLINENUMBERONE\n    ZEROZEROZEROZEROCODEPRINTZEROGOTOONEZEROZEROZEROONELINENUMBERONEZEROZEROZEROONE\n    CODEPRINTONEGOTOONEZEROZEROONEZEROLINENUMBERONEZEROZEROONEZEROCODEPRINTONEGOTOO\n    NEZEROZEROONEONELINENUMBERONEZEROZEROONEONECODEPRINTZEROGOTOONEZEROONEZEROZEROL\n    INENUMBERONEZEROONEZEROZEROCODEPRINTONEGOTOONEZEROONEZEROONELINENUMBERONEZEROON\n    EZEROONECODEPRINTONEGOTOONEZEROONEONEZEROLINENUMBERONEZEROONEONEZEROCODEPRINTZE\n    ROGOTOONEZEROONEONEONELINENUMBERONEZEROONEONEONECODEPRINTZEROGOTOONEONEZEROZERO\n    ZEROLINENUMBERONEONEZEROZEROZEROCODEPRINTZEROGOTOONEONEZEROZEROONELINENUMBERONE\n    ONEZEROZEROONECODEPRINTONEGOTOONEONEZEROONEZEROLINENUMBERONEONEZEROONEZEROCODEP\n    RINTONEGOTOONEONEZEROONEONELINENUMBERONEONEZEROONEONECODEPRINTZEROGOTOONEONEONE\n    ZEROZEROLINENUMBERONEONEONEZEROZEROCODEPRINTONEGOTOONEONEONEZEROONELINENUMBERON\n    EONEONEZEROONECODEPRINTONEGOTOONEONEONEONEZEROLINENUMBERONEONEONEONEZEROCODEPRI\n    NTZEROGOTOONEONEONEONEONELINENUMBERONEONEONEONEONECODEPRINTZEROGOTOONEZEROZEROZ\n    EROZEROZEROLINENUMBERONEZEROZEROZEROZEROZEROCODEPRINTZEROGOTOONEZEROZEROZEROZER\n    OONELINENUMBERONEZEROZEROZEROZEROONECODEPRINTONEGOTOONEZEROZEROZEROONEZEROLINEN\n    UMBERONEZEROZEROZEROONEZEROCODEPRINTONEGOTOONEZEROZEROZEROONEONELINENUMBERONEZE\n    ROZEROZEROONEONECODEPRINTZEROGOTOONEZEROZEROONEZEROZEROLINENUMBERONEZEROZEROONE\n    ZEROZEROCODEPRINTONEGOTOONEZEROZEROONEZEROONELINENUMBERONEZEROZEROONEZEROONECOD\n    EPRINTONEGOTOONEZEROZEROONEONEZEROLINENUMBERONEZEROZEROONEONEZEROCODEPRINTONEGO\n    TOONEZEROZEROONEONEONELINENUMBERONEZEROZEROONEONEONECODEPRINTONEGOTOONEZEROONEZ\n    EROZEROZEROLINENUMBERONEZEROONEZEROZEROZEROCODEPRINTZEROGOTOONEZEROONEZEROZEROO\n    NELINENUMBERONEZEROONEZEROZEROONECODEPRINTZEROGOTOONEZEROONEZEROONEZEROLINENUMB\n    ERONEZEROONEZEROONEZEROCODEPRINTONEGOTOONEZEROONEZEROONEONELINENUMBERONEZEROONE\n    ZEROONEONECODEPRINTZEROGOTOONEZEROONEONEZEROZEROLINENUMBERONEZEROONEONEZEROZERO\n    CODEPRINTZEROGOTOONEZEROONEONEZEROONELINENUMBERONEZEROONEONEZEROONECODEPRINTZER\n    OGOTOONEZEROONEONEONEZEROLINENUMBERONEZEROONEONEONEZEROCODEPRINTZEROGOTOONEZERO\n    ONEONEONEONELINENUMBERONEZEROONEONEONEONECODEPRINTZEROGOTOONEONEZEROZEROZEROZER\n    OLINENUMBERONEONEZEROZEROZEROZEROCODEPRINTZEROGOTOONEONEZEROZEROZEROONELINENUMB\n    ERONEONEZEROZEROZEROONECODEPRINTONEGOTOONEONEZEROZEROONEZEROLINENUMBERONEONEZER\n    OZEROONEZEROCODEPRINTONEGOTOONEONEZEROZEROONEONELINENUMBERONEONEZEROZEROONEONEC\n    ODEPRINTONEGOTOONEONEZEROONEZEROZEROLINENUMBERONEONEZEROONEZEROZEROCODEPRINTZER\n    OGOTOONEONEZEROONEZEROONELINENUMBERONEONEZEROONEZEROONECODEPRINTONEGOTOONEONEZE\n    ROONEONEZEROLINENUMBERONEONEZEROONEONEZEROCODEPRINTONEGOTOONEONEZEROONEONEONELI\n    NENUMBERONEONEZEROONEONEONECODEPRINTONEGOTOONEONEONEZEROZEROZEROLINENUMBERONEON\n    EONEZEROZEROZEROCODEPRINTZEROGOTOONEONEONEZEROZEROONELINENUMBERONEONEONEZEROZER\n    OONECODEPRINTONEGOTOONEONEONEZEROONEZEROLINENUMBERONEONEONEZEROONEZEROCODEPRINT\n    ONEGOTOONEONEONEZEROONEONELINENUMBERONEONEONEZEROONEONECODEPRINTZEROGOTOONEONEO\n    NEONEZEROZEROLINENUMBERONEONEONEONEZEROZEROCODEPRINTONEGOTOONEONEONEONEZEROONEL\n    INENUMBERONEONEONEONEZEROONECODEPRINTONEGOTOONEONEONEONEONEZEROLINENUMBERONEONE\n    ONEONEONEZEROCODEPRINTONEGOTOONEONEONEONEONEONELINENUMBERONEONEONEONEONEONECODE\n    PRINTONEGOTOONEZEROZEROZEROZEROZEROZEROLINENUMBERONEZEROZEROZEROZEROZEROZEROCOD\n    EPRINTZEROGOTOONEZEROZEROZEROZEROZEROONELINENUMBERONEZEROZEROZEROZEROZEROONECOD\n    EPRINTONEGOTOONEZEROZEROZEROZEROONEZEROLINENUMBERONEZEROZEROZEROZEROONEZEROCODE\n    PRINTONEGOTOONEZEROZEROZEROZEROONEONELINENUMBERONEZEROZEROZEROZEROONEONECODEPRI\n    NTONEGOTOONEZEROZEROZEROONEZEROZEROLINENUMBERONEZEROZEROZEROONEZEROZEROCODEPRIN\n    TZEROGOTOONEZEROZEROZEROONEZEROONELINENUMBERONEZEROZEROZEROONEZEROONECODEPRINTZ\n    EROGOTOONEZEROZEROZEROONEONEZEROLINENUMBERONEZEROZEROZEROONEONEZEROCODEPRINTONE\n    GOTOONEZEROZEROZEROONEONEONELINENUMBERONEZEROZEROZEROONEONEONECODEPRINTZEROGOTO\n    ONEZEROZEROONEZEROZEROZEROLINENUMBERONEZEROZEROONEZEROZEROZEROCODEPRINTZEROGOTO\n    ONEZEROZEROONEZEROZEROONELINENUMBERONEZEROZEROONEZEROZEROONECODEPRINTONEGOTOONE\n    ZEROZEROONEZEROONEZEROLINENUMBERONEZEROZEROONEZEROONEZEROCODEPRINTONEGOTOONEZER\n    OZEROONEZEROONEONELINENUMBERONEZEROZEROONEZEROONEONECODEPRINTZEROGOTOONEZEROZER\n    OONEONEZEROZEROLINENUMBERONEZEROZEROONEONEZEROZEROCODEPRINTONEGOTOONEZEROZEROON\n    EONEZEROONELINENUMBERONEZEROZEROONEONEZEROONECODEPRINTONEGOTOONEZEROZEROONEONEO\n    NEZEROLINENUMBERONEZEROZEROONEONEONEZEROCODEPRINTZEROGOTOONEZEROZEROONEONEONEON\n    ELINENUMBERONEZEROZEROONEONEONEONECODEPRINTZEROGOTOONEZEROONEZEROZEROZEROZEROLI\n    NENUMBERONEZEROONEZEROZEROZEROZEROCODEPRINTZEROGOTOONEZEROONEZEROZEROZEROONELIN\n    ENUMBERONEZEROONEZEROZEROZEROONECODEPRINTONEGOTOONEZEROONEZEROZEROONEZEROLINENU\n    MBERONEZEROONEZEROZEROONEZEROCODEPRINTONEGOTOONEZEROONEZEROZEROONEONELINENUMBER\n    ONEZEROONEZEROZEROONEONECODEPRINTZEROGOTOONEZEROONEZEROONEZEROZEROLINENUMBERONE\n    ZEROONEZEROONEZEROZEROCODEPRINTZEROGOTOONEZEROONEZEROONEZEROONELINENUMBERONEZER\n    OONEZEROONEZEROONECODEPRINTONEGOTOONEZEROONEZEROONEONEZEROLINENUMBERONEZEROONEZ\n    EROONEONEZEROCODEPRINTZEROGOTOONEZEROONEZEROONEONEONELINENUMBERONEZEROONEZEROON\n    EONEONECODEPRINTZEROGOTOONEZEROONEONEZEROZEROZEROLINENUMBERONEZEROONEONEZEROZER\n    OZEROCODEPRINTZEROGOTOONEZEROONEONEZEROZEROONELINENUMBERONEZEROONEONEZEROZEROON\n    ECODEPRINTZEROGOTOONEZEROONEONEZEROONEZEROLINENUMBERONEZEROONEONEZEROONEZEROCOD\n    EPRINTONEGOTOONEZEROONEONEZEROONEONELINENUMBERONEZEROONEONEZEROONEONECODEPRINTZ\n    EROGOTOONEZEROONEONEONEZEROZEROLINENUMBERONEZEROONEONEONEZEROZEROCODEPRINTZEROG\n    OTOONEZEROONEONEONEZEROONELINENUMBERONEZEROONEONEONEZEROONECODEPRINTZEROGOTOONE\n    ZEROONEONEONEONEZEROLINENUMBERONEZEROONEONEONEONEZEROCODEPRINTZEROGOTOONEZEROON\n    EONEONEONEONELINENUMBERONEZEROONEONEONEONEONECODEPRINTONE\n    ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41404, "question": "wut\n\n    Hello World in BIT.\n    No comments possible.\n    \n    LINENUMBERZEROCODEPRINTZEROGOTOONELINENUMBERONECODEPRINTONEGOTOONEZEROLINENUMBE\n    RONEZEROCODEPRINTZEROGOTOONEONELINENUMBERONEONECODEPRINTZEROGOTOONEZEROZEROLINE\n    NUMBERONEZEROZEROCODEPRINTONEGOTOONEZEROONELINENUMBERONEZEROONECODEPRINTZEROGOT\n    OONEONEZEROLINENUMBERONEONEZEROCODEPRINTZEROGOTOONEONEONELINENUMBERONEONEONECOD\n    EPRINTZEROGOTOONEZEROZEROZEROLINENUMBERONEZEROZEROZEROCODEPRINTZEROGOTOONEZEROZ\n    EROONELINENUMBERONEZEROZEROONECODEPRINTONEGOTOONEZEROONEZEROLINENUMBERONEZEROON\n    EZEROCODEPRINTONEGOTOONEZEROONEONELINENUMBERONEZEROONEONECODEPRINTZEROGOTOONEON\n    EZEROZEROLINENUMBERONEONEZEROZEROCODEPRINTZEROGOTOONEONEZEROONELINENUMBERONEONE\n    ZEROONECODEPRINTONEGOTOONEONEONEZEROLINENUMBERONEONEONEZEROCODEPRINTZEROGOTOONE\n    ONEONEONELINENUMBERONEONEONEONECODEPRINTONEGOTOONEZEROZEROZEROZEROLINENUMBERONE\n    ZEROZEROZEROZEROCODEPRINTZEROGOTOONEZEROZEROZEROONELINENUMBERONEZEROZEROZEROONE\n    CODEPRINTONEGOTOONEZEROZEROONEZEROLINENUMBERONEZEROZEROONEZEROCODEPRINTONEGOTOO\n    NEZEROZEROONEONELINENUMBERONEZEROZEROONEONECODEPRINTZEROGOTOONEZEROONEZEROZEROL\n    INENUMBERONEZEROONEZEROZEROCODEPRINTONEGOTOONEZEROONEZEROONELINENUMBERONEZEROON\n    EZEROONECODEPRINTONEGOTOONEZEROONEONEZEROLINENUMBERONEZEROONEONEZEROCODEPRINTZE\n    ROGOTOONEZEROONEONEONELINENUMBERONEZEROONEONEONECODEPRINTZEROGOTOONEONEZEROZERO\n    ZEROLINENUMBERONEONEZEROZEROZEROCODEPRINTZEROGOTOONEONEZEROZEROONELINENUMBERONE\n    ONEZEROZEROONECODEPRINTONEGOTOONEONEZEROONEZEROLINENUMBERONEONEZEROONEZEROCODEP\n    RINTONEGOTOONEONEZEROONEONELINENUMBERONEONEZEROONEONECODEPRINTZEROGOTOONEONEONE\n    ZEROZEROLINENUMBERONEONEONEZEROZEROCODEPRINTONEGOTOONEONEONEZEROONELINENUMBERON\n    EONEONEZEROONECODEPRINTONEGOTOONEONEONEONEZEROLINENUMBERONEONEONEONEZEROCODEPRI\n    NTZEROGOTOONEONEONEONEONELINENUMBERONEONEONEONEONECODEPRINTZEROGOTOONEZEROZEROZ\n    EROZEROZEROLINENUMBERONEZEROZEROZEROZEROZEROCODEPRINTZEROGOTOONEZEROZEROZEROZER\n    OONELINENUMBERONEZEROZEROZEROZEROONECODEPRINTONEGOTOONEZEROZEROZEROONEZEROLINEN\n    UMBERONEZEROZEROZEROONEZEROCODEPRINTONEGOTOONEZEROZEROZEROONEONELINENUMBERONEZE\n    ROZEROZEROONEONECODEPRINTZEROGOTOONEZEROZEROONEZEROZEROLINENUMBERONEZEROZEROONE\n    ZEROZEROCODEPRINTONEGOTOONEZEROZEROONEZEROONELINENUMBERONEZEROZEROONEZEROONECOD\n    EPRINTONEGOTOONEZEROZEROONEONEZEROLINENUMBERONEZEROZEROONEONEZEROCODEPRINTONEGO\n    TOONEZEROZEROONEONEONELINENUMBERONEZEROZEROONEONEONECODEPRINTONEGOTOONEZEROONEZ\n    EROZEROZEROLINENUMBERONEZEROONEZEROZEROZEROCODEPRINTZEROGOTOONEZEROONEZEROZEROO\n    NELINENUMBERONEZEROONEZEROZEROONECODEPRINTZEROGOTOONEZEROONEZEROONEZEROLINENUMB\n    ERONEZEROONEZEROONEZEROCODEPRINTONEGOTOONEZEROONEZEROONEONELINENUMBERONEZEROONE\n    ZEROONEONECODEPRINTZEROGOTOONEZEROONEONEZEROZEROLINENUMBERONEZEROONEONEZEROZERO\n    CODEPRINTZEROGOTOONEZEROONEONEZEROONELINENUMBERONEZEROONEONEZEROONECODEPRINTZER\n    OGOTOONEZEROONEONEONEZEROLINENUMBERONEZEROONEONEONEZEROCODEPRINTZEROGOTOONEZERO\n    ONEONEONEONELINENUMBERONEZEROONEONEONEONECODEPRINTZEROGOTOONEONEZEROZEROZEROZER\n    OLINENUMBERONEONEZEROZEROZEROZEROCODEPRINTZEROGOTOONEONEZEROZEROZEROONELINENUMB\n    ERONEONEZEROZEROZEROONECODEPRINTONEGOTOONEONEZEROZEROONEZEROLINENUMBERONEONEZER\n    OZEROONEZEROCODEPRINTONEGOTOONEONEZEROZEROONEONELINENUMBERONEONEZEROZEROONEONEC\n    ODEPRINTONEGOTOONEONEZEROONEZEROZEROLINENUMBERONEONEZEROONEZEROZEROCODEPRINTZER\n    OGOTOONEONEZEROONEZEROONELINENUMBERONEONEZEROONEZEROONECODEPRINTONEGOTOONEONEZE\n    ROONEONEZEROLINENUMBERONEONEZEROONEONEZEROCODEPRINTONEGOTOONEONEZEROONEONEONELI\n    NENUMBERONEONEZEROONEONEONECODEPRINTONEGOTOONEONEONEZEROZEROZEROLINENUMBERONEON\n    EONEZEROZEROZEROCODEPRINTZEROGOTOONEONEONEZEROZEROONELINENUMBERONEONEONEZEROZER\n    OONECODEPRINTONEGOTOONEONEONEZEROONEZEROLINENUMBERONEONEONEZEROONEZEROCODEPRINT\n    ONEGOTOONEONEONEZEROONEONELINENUMBERONEONEONEZEROONEONECODEPRINTZEROGOTOONEONEO\n    NEONEZEROZEROLINENUMBERONEONEONEONEZEROZEROCODEPRINTONEGOTOONEONEONEONEZEROONEL\n    INENUMBERONEONEONEONEZEROONECODEPRINTONEGOTOONEONEONEONEONEZEROLINENUMBERONEONE\n    ONEONEONEZEROCODEPRINTONEGOTOONEONEONEONEONEONELINENUMBERONEONEONEONEONEONECODE\n    PRINTONEGOTOONEZEROZEROZEROZEROZEROZEROLINENUMBERONEZEROZEROZEROZEROZEROZEROCOD\n    EPRINTZEROGOTOONEZEROZEROZEROZEROZEROONELINENUMBERONEZEROZEROZEROZEROZEROONECOD\n    EPRINTONEGOTOONEZEROZEROZEROZEROONEZEROLINENUMBERONEZEROZEROZEROZEROONEZEROCODE\n    PRINTONEGOTOONEZEROZEROZEROZEROONEONELINENUMBERONEZEROZEROZEROZEROONEONECODEPRI\n    NTONEGOTOONEZEROZEROZEROONEZEROZEROLINENUMBERONEZEROZEROZEROONEZEROZEROCODEPRIN\n    TZEROGOTOONEZEROZEROZEROONEZEROONELINENUMBERONEZEROZEROZEROONEZEROONECODEPRINTZ\n    EROGOTOONEZEROZEROZEROONEONEZEROLINENUMBERONEZEROZEROZEROONEONEZEROCODEPRINTONE\n    GOTOONEZEROZEROZEROONEONEONELINENUMBERONEZEROZEROZEROONEONEONECODEPRINTZEROGOTO\n    ONEZEROZEROONEZEROZEROZEROLINENUMBERONEZEROZEROONEZEROZEROZEROCODEPRINTZEROGOTO\n    ONEZEROZEROONEZEROZEROONELINENUMBERONEZEROZEROONEZEROZEROONECODEPRINTONEGOTOONE\n    ZEROZEROONEZEROONEZEROLINENUMBERONEZEROZEROONEZEROONEZEROCODEPRINTONEGOTOONEZER\n    OZEROONEZEROONEONELINENUMBERONEZEROZEROONEZEROONEONECODEPRINTZEROGOTOONEZEROZER\n    OONEONEZEROZEROLINENUMBERONEZEROZEROONEONEZEROZEROCODEPRINTONEGOTOONEZEROZEROON\n    EONEZEROONELINENUMBERONEZEROZEROONEONEZEROONECODEPRINTONEGOTOONEZEROZEROONEONEO\n    NEZEROLINENUMBERONEZEROZEROONEONEONEZEROCODEPRINTZEROGOTOONEZEROZEROONEONEONEON\n    ELINENUMBERONEZEROZEROONEONEONEONECODEPRINTZEROGOTOONEZEROONEZEROZEROZEROZEROLI\n    NENUMBERONEZEROONEZEROZEROZEROZEROCODEPRINTZEROGOTOONEZEROONEZEROZEROZEROONELIN\n    ENUMBERONEZEROONEZEROZEROZEROONECODEPRINTONEGOTOONEZEROONEZEROZEROONEZEROLINENU\n    MBERONEZEROONEZEROZEROONEZEROCODEPRINTONEGOTOONEZEROONEZEROZEROONEONELINENUMBER\n    ONEZEROONEZEROZEROONEONECODEPRINTZEROGOTOONEZEROONEZEROONEZEROZEROLINENUMBERONE\n    ZEROONEZEROONEZEROZEROCODEPRINTZEROGOTOONEZEROONEZEROONEZEROONELINENUMBERONEZER\n    OONEZEROONEZEROONECODEPRINTONEGOTOONEZEROONEZEROONEONEZEROLINENUMBERONEZEROONEZ\n    EROONEONEZEROCODEPRINTZEROGOTOONEZEROONEZEROONEONEONELINENUMBERONEZEROONEZEROON\n    EONEONECODEPRINTZEROGOTOONEZEROONEONEZEROZEROZEROLINENUMBERONEZEROONEONEZEROZER\n    OZEROCODEPRINTZEROGOTOONEZEROONEONEZEROZEROONELINENUMBERONEZEROONEONEZEROZEROON\n    ECODEPRINTZEROGOTOONEZEROONEONEZEROONEZEROLINENUMBERONEZEROONEONEZEROONEZEROCOD\n    EPRINTONEGOTOONEZEROONEONEZEROONEONELINENUMBERONEZEROONEONEZEROONEONECODEPRINTZ\n    EROGOTOONEZEROONEONEONEZEROZEROLINENUMBERONEZEROONEONEONEZEROZEROCODEPRINTZEROG\n    OTOONEZEROONEONEONEZEROONELINENUMBERONEZEROONEONEONEZEROONECODEPRINTZEROGOTOONE\n    ZEROONEONEONEONEZEROLINENUMBERONEZEROONEONEONEONEZEROCODEPRINTZEROGOTOONEZEROON\n    EONEONEONEONELINENUMBERONEZEROONEONEONEONEONECODEPRINTONE\n    ", "aSentId": 41405, "answer": "That one was my favorite until...\n\n\n    Hello world in Ecstatic. No comments are possible in this language.\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    (followed by another 24,866,256,684,781,338,733,321,022,194,929,619,017,923,951,399,467,222,375,071,721,694,990,877,932,162,871,254,860,704 exclamation points)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41406, "question": "That one was my favorite until...\n\n\n    Hello world in Ecstatic. No comments are possible in this language.\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    (followed by another 24,866,256,684,781,338,733,321,022,194,929,619,017,923,951,399,467,222,375,071,721,694,990,877,932,162,871,254,860,704 exclamation points)", "aSentId": 41407, "answer": "A... unary programming language?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41410, "question": "wow, this is the largest collection of hello worlds I have ever seen.", "aSentId": 41411, "answer": "I actually know one they missed. Need to knock that together.\n\nEdit for the the curious...\n\n    // Hello World in ACPI Source Language (ASL)\n    // Following would print to ACPI Machine Language Interpreter's\n    // (AMLI) Debug channel on any transition from a sleeping state\n    \n    Scope(\\) {\n    \tMethod(_WAK) {\n        \tStore(\"Hello World\", Debug)\n    \t\tReturn(Package(2) {0x00000000, 0})\n    \t}\t\n    }\n    \n\nDisclaimer: I am rusty with that stuff so it may be completely wrong :-)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41412, "question": "I actually know one they missed. Need to knock that together.\n\nEdit for the the curious...\n\n    // Hello World in ACPI Source Language (ASL)\n    // Following would print to ACPI Machine Language Interpreter's\n    // (AMLI) Debug channel on any transition from a sleeping state\n    \n    Scope(\\) {\n    \tMethod(_WAK) {\n        \tStore(\"Hello World\", Debug)\n    \t\tReturn(Package(2) {0x00000000, 0})\n    \t}\t\n    }\n    \n\nDisclaimer: I am rusty with that stuff so it may be completely wrong :-)", "aSentId": 41413, "answer": "Cobra?  Also Nim?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41414, "question": "Cobra?  Also Nim?", "aSentId": 41415, "answer": "I can't find languages with dependent types like ATS or Idris. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41416, "question": "I can't find languages with dependent types like ATS or Idris. ", "aSentId": 41417, "answer": "To be fair, they only want submissions for \"real\" programming languages where \"real\" links to the Wikipedia page for Turing completeness...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41414, "question": "Cobra?  Also Nim?", "aSentId": 41419, "answer": "Nope. Something used every day on millions of machines.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41420, "question": "Nope. Something used every day on millions of machines.", "aSentId": 41421, "answer": "I noticed that they are missing Vim script, which surprised me. That can't be what you're referring to, though.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41420, "question": "Nope. Something used every day on millions of machines.", "aSentId": 41423, "answer": "Well?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41420, "question": "Nope. Something used every day on millions of machines.", "aSentId": 41425, "answer": "Bash?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41426, "question": "Bash?", "aSentId": 41427, "answer": "It's listed as Unix Shell", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41412, "question": "I actually know one they missed. Need to knock that together.\n\nEdit for the the curious...\n\n    // Hello World in ACPI Source Language (ASL)\n    // Following would print to ACPI Machine Language Interpreter's\n    // (AMLI) Debug channel on any transition from a sleeping state\n    \n    Scope(\\) {\n    \tMethod(_WAK) {\n        \tStore(\"Hello World\", Debug)\n    \t\tReturn(Package(2) {0x00000000, 0})\n    \t}\t\n    }\n    \n\nDisclaimer: I am rusty with that stuff so it may be completely wrong :-)", "aSentId": 41429, "answer": "Rust?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41412, "question": "I actually know one they missed. Need to knock that together.\n\nEdit for the the curious...\n\n    // Hello World in ACPI Source Language (ASL)\n    // Following would print to ACPI Machine Language Interpreter's\n    // (AMLI) Debug channel on any transition from a sleeping state\n    \n    Scope(\\) {\n    \tMethod(_WAK) {\n        \tStore(\"Hello World\", Debug)\n    \t\tReturn(Package(2) {0x00000000, 0})\n    \t}\t\n    }\n    \n\nDisclaimer: I am rusty with that stuff so it may be completely wrong :-)", "aSentId": 41431, "answer": "Not like it's hard to make the program and send them an email. I just sent one for Elm.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41432, "question": "Not like it's hard to make the program and send them an email. I just sent one for Elm.", "aSentId": 41433, "answer": "It would involve interrupting my 'Game of Thrones' DVD commentary marathon though.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41437, "question": "Was very disappointed to see Chicken not listed.", "aSentId": 41438, "answer": "Send them an email with the code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41440, "question": "Several of these are wrong.\n\nThe APL example is trying to be:\n\n    \u235d This is the hello world program\n    \u2395\u2190'Hello World'\n\nbut nobody is going to do that. They'll just say:\n\n    'Hello World'\n\nJ can also do this.\n\nASPxxx and ASP.net are interesting, but neglect the fact that simply:\n\n    Hello World\n\nis enough.\n\nAsterisk is wrong, because it requires input first. It should be:\n\n    exten =&gt; s,1,NoOp(Hello World)\n\nIn Awk, the \"exit\" is superfluous.\n\nForth is wrong; definition isn't required. Just:\n\n    .\" Hello World\" CR\n\nis enough. ICL SCL has the same problem; should just begin with:\n\n    BEGIN\n\nand not a function definition.\n\nJavaScript doesn't usually go `document.write()` unless it's in a browser; `console.log()` would have been better. Or just the fact that it prints what you return.\n\nK should say K3. In K4/Q/KDB you write:\n\n    1\"Hello World\\n\"\n\nIn K5 it's:\n\n    1'\"Hello World\\n\"\n\nLisp should be Common-Lisp and is still wrong. No definition is required. Simply:\n\n    (print \"Hello World\")\n\nis enough.\n\nM4 produces the wrong output. Should be:\n\n    dnl this is a comment\n    Hello world\n\nPHP the close `?&gt;` is unnecessary; a `\"\\n\"` should have been better in the string.\n\nPython is wrong. It should say python2. In Python3 you must write:\n\n    print(\"Hello World\")\n\nThe SQL-Oracle example is unnecessary; the SQL example works fine.\n\n[Urbit](http://urbit.org/) has hoon, which is notably missing:\n\n    :: this is hello world\n    !:(\"Hello World\")\n", "aSentId": 41441, "answer": "&gt; console.log() would have been better.\n\nThat probably did not exist when they wrote the list\n\nPascal one is wrong, too, at least for current version:\n\n    {Hello World in Pascal}\n\n    program HelloWorld;\n    begin\n      WriteLn('Hello World!');\n    end.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41446, "question": "Fj\u00f6lnir definitely had to be one of the stranger ones that I saw. It's not trying to be esoteric, but it still manages to look pretty weird.\n\n    ;; Hello world in Fj\u00f6lnir\n    \n    \"hello\" &lt; main\n    {\n        main -&gt;\n        stef(;)\n        stofn\n            skrifastreng(;\"Hello, world!\"),\n        stofnlok\n    }\n    *\n    \"GRUNNUR\"\n    ;\n", "aSentId": 41447, "answer": "It's Icelandic?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41448, "question": "It's Icelandic?", "aSentId": 41449, "answer": "Yup. GRUNNUR became some sort of /prog/-meme", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41448, "question": "It's Icelandic?", "aSentId": 41451, "answer": "I have no idea whether it is, but \"skrifastreng\" means \"write string\" in pretty much any Scandinavian language.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41457, "question": "Whats the point of this? Only to look cool. It's like being able to say hello in every Human Language and nothing else. ", "aSentId": 41458, "answer": "I agree with you. Hello world is a useless metric of pretty much everything, so it doesn't really make sense to compare it across languages. With that said, this is an impressive collection and has merit based on that alone. As you say, it's cool.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41457, "question": "Whats the point of this? Only to look cool. It's like being able to say hello in every Human Language and nothing else. ", "aSentId": 41460, "answer": "Fun. Remember fun? That thing you have between bug triage, scrums, code reviews, iteration planning sessions and roadmaps.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41463, "question": "Replicating SQLite using Raft Consensus", "aSentId": 41464, "answer": "I have to use a HTTP API? This kills the whole idea for me. I'd rather just put the db file on a replicated network filesystem or use nbd (and the performance would be better).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41463, "question": "Replicating SQLite using Raft Consensus", "aSentId": 41466, "answer": "Christ, the latency..", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41468, "question": "How I learned to program in 10 years", "aSentId": 41469, "answer": "I've been at it for 40 years. No luck so far.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41468, "question": "How I learned to program in 10 years", "aSentId": 41471, "answer": "15+ years and just starting to learn how little I know.\n\nArticles like this make such a nice honest refreshing change from the usual macho posturing culture of \"gurus\" and \"rockstars\".", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41472, "question": "15+ years and just starting to learn how little I know.\n\nArticles like this make such a nice honest refreshing change from the usual macho posturing culture of \"gurus\" and \"rockstars\".", "aSentId": 41473, "answer": "I suppose I've been learning for about 30 years, but I tend not to think about how little I know, rather how many avenues there are to get into new things should I choose them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41474, "question": "I suppose I've been learning for about 30 years, but I tend not to think about how little I know, rather how many avenues there are to get into new things should I choose them.", "aSentId": 41475, "answer": "That's a nice positive way to look at it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41468, "question": "How I learned to program in 10 years", "aSentId": 41477, "answer": "I have not read the article as of yet, but the title [reminds me of this classic](http://norvig.com/21-days.html)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41478, "question": "I have not read the article as of yet, but the title [reminds me of this classic](http://norvig.com/21-days.html)", "aSentId": 41479, "answer": "That was a good read. Gusteau's critic is spot on btw. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41478, "question": "I have not read the article as of yet, but the title [reminds me of this classic](http://norvig.com/21-days.html)", "aSentId": 41481, "answer": "The 24 hours aren't meant as 24 actual hours. They are referring to a set of 24 lessons, each approximately one hour long, between which you should get plenty practise on your own, solve the exercises and so on.\n\nAt least that's how I've read all those \"in 24 hours\" books.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41485, "question": "Programming feeds me for last 13 years. Before that was \"learning\" programming for 5 years.\n\nI must say, the only my experience that really makes difference is from like last 3 years. Everything before that looks like misguided baby steps.\n\nAnd in five years from now, for sure, my current deeds will look no less stupid to the future me.\n", "aSentId": 41486, "answer": "Well, there's having ten years of experience, and then there's having one year of experience ten times. \n\nEffective learning seldom happens on accident. Unless you actually study your mistakes and draw conclusions from them in at least a quasi-methodical fashion, chances are you're only very slightly more experienced than you were when you started.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41492, "question": "A method to quantify the quality of software", "aSentId": 41493, "answer": "I think that the maintenance index formulas tell the story. Measure software quality with LOC, and even worse, comment/LOC ratio? Anyone who actually programs knows that this measures can easily be abused (for comment ratios, just spam \"i+=1; /* increment i */\" etc.).\n\nCyclomatic complexity is no better: \"oh, it looks like the cyclomatic complexity is already high; lets not check for malloc failures, mallocs never fail anyway\".\n\nThese formulas are BS. They make bean counting managers because they have a nice formula to enter in their spreadsheet, and they make programmers happy because its easy to manipulate their output.\n\nDo we measure the \"quality\" of a building by making the sum of the square root of the dimensions of its rooms? Or the sinus of its windows/doors ratio? No, that would be ludicrous. So let humans judge the quality of software too.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41492, "question": "A method to quantify the quality of software", "aSentId": 41495, "answer": "There's a better way to quantify the quality of software. To do that you have to identify what the software is supposed to do. The quantification works like this: If the program satisfies every requirement you have then it's good software.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 41492, "question": "A method to quantify the quality of software", "aSentId": 41497, "answer": "You all criticizing these formulas, but I say that I would be glad if my company used them. Any of them. \n\nYou see, I work in IT production, our job is to make the operating system digest whatever crap development division give us to feed it.\n\nFor example, application creates gigs of temporary files it never deletes? We have to make a script to clean them up, because fixing it is not a requirement.\n\nUpdate the O.S.? Well you can't, because there is call to function X which have changed to Y, and the code is spaghetti will take an year for development to fix it.\n\nIf they just put one formula of these into their requirements, oh god life would be so much easier.", "corpus": "reddit"}]