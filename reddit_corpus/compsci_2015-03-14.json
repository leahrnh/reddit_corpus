[{"docID": "t5_2qhmr", "qSentId": 15318, "question": "Context Free Grammar", "aSentId": 15319, "answer": "first off, i don't think all palindromes over {0,1} can be given by a regex. how could you possibly recognize them all with a DFA?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15320, "question": "first off, i don't think all palindromes over {0,1} can be given by a regex. how could you possibly recognize them all with a DFA?", "aSentId": 15321, "answer": "Indeed, they can't.  Pumping lemma yields an easy formal proof, or informally you need either infinite states (violating the Finite part of DFA) or some sort of separate memory, which a DFA doesn't have.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15322, "question": "Indeed, they can't.  Pumping lemma yields an easy formal proof, or informally you need either infinite states (violating the Finite part of DFA) or some sort of separate memory, which a DFA doesn't have.", "aSentId": 15323, "answer": "sadly i never got comfortable with the pumping lemma in my automata class so i just try and reason through pitfalls you might encounter building a recognizer.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15320, "question": "first off, i don't think all palindromes over {0,1} can be given by a regex. how could you possibly recognize them all with a DFA?", "aSentId": 15325, "answer": "&gt; i don't think all palindromes over {0,1} can be given by a regex\n\nThe question as phrased was to find a CFG for palindromes, not a regex.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15326, "question": "&gt; i don't think all palindromes over {0,1} can be given by a regex\n\nThe question as phrased was to find a CFG for palindromes, not a regex.", "aSentId": 15327, "answer": "i know, i just figured that since this is a learning exercise i would point out that OP seems to be confused about what constitutes a regular language or the definition of a palindrome. if that's the case, it would certainly be worth taking some time to get solid on regular languages before he struggles with CFGs.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15318, "question": "Context Free Grammar", "aSentId": 15329, "answer": "let S be the inital non-terminal.\nS -&gt;1S1, 0S0, e \n(e is the empty string)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15331, "question": "Uncertain about master degree and job", "aSentId": 15332, "answer": "Well theres jobs for all of those fields.  Data engineering I feel is unessecary to specialize in, I would think most software at some point is going to interface to a database - you're going to learn that anyway and usually pretty quickly.\n\nI can only speak to Software Engineering - there are plenty of jobs.  I've never been without a job.  Rates are usually based on experience, I started at $45, now at around $100, and I expect to cap out around 120 or 130 - unless you get into some really specialized areas.\n\nI personally like embedded systems and do them for fun ( building a car counter at the moment , seems like there is so much traffic on my street ), but I have heard they pay less.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15333, "question": "Well theres jobs for all of those fields.  Data engineering I feel is unessecary to specialize in, I would think most software at some point is going to interface to a database - you're going to learn that anyway and usually pretty quickly.\n\nI can only speak to Software Engineering - there are plenty of jobs.  I've never been without a job.  Rates are usually based on experience, I started at $45, now at around $100, and I expect to cap out around 120 or 130 - unless you get into some really specialized areas.\n\nI personally like embedded systems and do them for fun ( building a car counter at the moment , seems like there is so much traffic on my street ), but I have heard they pay less.", "aSentId": 15334, "answer": "&gt; Rates are usually based on experience, I started at $67, now at around $110, and I expect to cap out around 120 or 130 - unless you get into some really specialized areas.\n\nIs this per hour?  Thousands per year?  You need to specify units.  Also area for COL.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15335, "question": "&gt; Rates are usually based on experience, I started at $67, now at around $110, and I expect to cap out around 120 or 130 - unless you get into some really specialized areas.\n\nIs this per hour?  Thousands per year?  You need to specify units.  Also area for COL.", "aSentId": 15336, "answer": "&gt; Is this per hour? Thousands per year? You need to specify units. Also area for COL.\n\nAll numbers are annual salary.  This is in Texas where COL is cheap, expect more in dense cities etc.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15331, "question": "Uncertain about master degree and job", "aSentId": 15338, "answer": "Honestly, just do the one that you will enjoy the most. The soft.eng masters is probably a waste of time. If you get a dev position then they will teach you how to program properly. It's not the sort of thing you can learn in a university.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15339, "question": "Honestly, just do the one that you will enjoy the most. The soft.eng masters is probably a waste of time. If you get a dev position then they will teach you how to program properly. It's not the sort of thing you can learn in a university.", "aSentId": 15340, "answer": "How does that work exactly?  All the postings I see seem to assume you've already built a bunch of stuff in undergrad and are a pretty competent programmer.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15341, "question": "How does that work exactly?  All the postings I see seem to assume you've already built a bunch of stuff in undergrad and are a pretty competent programmer.", "aSentId": 15342, "answer": "YMMV\n\nYou have to know some programming (I presume you get this from comp.eng) but when we interview it's generally assumed that we'll have to teach juniors a lot. I think academic qualifications in soft.eng are pretty useless but of course it depends on the syllabus. Your time is probably better spent doing computer science / maths / stats / engineering. \n\nMy team is composed of mathematicians, physicist, economists, biologists etc. And almost all of them have learnt to program 'properly' on the job.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15343, "question": "YMMV\n\nYou have to know some programming (I presume you get this from comp.eng) but when we interview it's generally assumed that we'll have to teach juniors a lot. I think academic qualifications in soft.eng are pretty useless but of course it depends on the syllabus. Your time is probably better spent doing computer science / maths / stats / engineering. \n\nMy team is composed of mathematicians, physicist, economists, biologists etc. And almost all of them have learnt to program 'properly' on the job.", "aSentId": 15344, "answer": "I would agree with this 100%, focus on the STEM stuff - the programming can be taught on the job.\n\nAlso what are they teaching you in school??  Not programming it sounds like ?  Software is one of those things that is best learnt by doing - so just build as much software as you can.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15346, "question": "Where can you learn the things a CS degree teaches you, but not at a regular university? (more details inside)", "aSentId": 15347, "answer": "As a guy who started somewhat where you are, let me give you a great tutorial on where to start to get to the point that you can actually start feeling like a programmer.\n\n  Step 1. CodeAcadamy.com Start there. Don't worry about doing ALL the different programs they do, just start with Python. Do Python from beginning to end. That should take you between 4 days and a couple weeks depending on the amount of time you have to invest. REMEMBER!! You aren't doing this so you can code in Python, you are doing this FIRST because python is a super easy language that can allow you to learn the basics of variables, statements, and user input without needed useless syntax.\n\n Step 2. Go to edx.org and make a profile. Enroll in Harvards cs50 class. It has taught me more about coding than anything else. They say you don't need any coding experience to start, but having taken CodeAcademy's python course will help you understand things MUCH better.\n\nStep 3. Don't rush through cs50. Know it's meant for someone who lives, breathes, and eats school. I've been working on this for about 3 months and I'm barely over halfway through because I'm married, have a job, and have a life. Don't limit yourself to just learning through cs50 either. Go to /r/cs50 if you need help with anything. Don't cheat. This isn't about getting a good grade, it's about learning. You WILL get stuck. If Harvard students need a staff of 100 people to help them pass this class, doing it alone is near impossible.\n\nStep 4. Make connections. Everyone says networking is so important, and that's because it is. I asked myself, \"Where do I start with networking??\" And you'll be surprised where I did. I happened to know a guy who runs the local newspapers website. I spent a day watching him at work. Then I went to Starbucks the next day (My wife works there) and saw a guy coding on his computer. I'd seen him before, always coding. I said, \"Hey man, if you're busy let me know, but mind if I ask a couple questions about what you're working on?\" Boom. Connection made. He knew my friend from the newspaper, and now he and I are in contact about job shadowing and him mentoring me. It's that simple. If you see someone coding, politely ask if you can ask questions, and ALWAYS swap contact info. Don't be annoying though.\n\nAfter that, you have some contacts who you can call about mentoring. \"Hey man, remember me? We talked a while back about programming. Yeah, I got some free time every week and I'm looking to learn more about coding in a real world sense. Would it be cool if I spent a day with you, watching you code and asking questions?\" It might be a boring day, but bring a pencil and paper. When they do something you don't understand, ask them why they did it. You can't learn a language by studying a dictionary, you need to hear people speak it. Just the same, you need need to watch people code, and code yourself to really understand how to put it all together.\n\n  Sorry about the wall of text. I've just devoted like 6 hrs a day to learning CS lately, and this is what helped me get to where I am today. Don't take my advice as the only way to do it, it's just what worked for me. I now understand why the code I write is the way it is. I'm also gonna be starting college this fall. Anywho, good luck.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15348, "question": "As a guy who started somewhat where you are, let me give you a great tutorial on where to start to get to the point that you can actually start feeling like a programmer.\n\n  Step 1. CodeAcadamy.com Start there. Don't worry about doing ALL the different programs they do, just start with Python. Do Python from beginning to end. That should take you between 4 days and a couple weeks depending on the amount of time you have to invest. REMEMBER!! You aren't doing this so you can code in Python, you are doing this FIRST because python is a super easy language that can allow you to learn the basics of variables, statements, and user input without needed useless syntax.\n\n Step 2. Go to edx.org and make a profile. Enroll in Harvards cs50 class. It has taught me more about coding than anything else. They say you don't need any coding experience to start, but having taken CodeAcademy's python course will help you understand things MUCH better.\n\nStep 3. Don't rush through cs50. Know it's meant for someone who lives, breathes, and eats school. I've been working on this for about 3 months and I'm barely over halfway through because I'm married, have a job, and have a life. Don't limit yourself to just learning through cs50 either. Go to /r/cs50 if you need help with anything. Don't cheat. This isn't about getting a good grade, it's about learning. You WILL get stuck. If Harvard students need a staff of 100 people to help them pass this class, doing it alone is near impossible.\n\nStep 4. Make connections. Everyone says networking is so important, and that's because it is. I asked myself, \"Where do I start with networking??\" And you'll be surprised where I did. I happened to know a guy who runs the local newspapers website. I spent a day watching him at work. Then I went to Starbucks the next day (My wife works there) and saw a guy coding on his computer. I'd seen him before, always coding. I said, \"Hey man, if you're busy let me know, but mind if I ask a couple questions about what you're working on?\" Boom. Connection made. He knew my friend from the newspaper, and now he and I are in contact about job shadowing and him mentoring me. It's that simple. If you see someone coding, politely ask if you can ask questions, and ALWAYS swap contact info. Don't be annoying though.\n\nAfter that, you have some contacts who you can call about mentoring. \"Hey man, remember me? We talked a while back about programming. Yeah, I got some free time every week and I'm looking to learn more about coding in a real world sense. Would it be cool if I spent a day with you, watching you code and asking questions?\" It might be a boring day, but bring a pencil and paper. When they do something you don't understand, ask them why they did it. You can't learn a language by studying a dictionary, you need to hear people speak it. Just the same, you need need to watch people code, and code yourself to really understand how to put it all together.\n\n  Sorry about the wall of text. I've just devoted like 6 hrs a day to learning CS lately, and this is what helped me get to where I am today. Don't take my advice as the only way to do it, it's just what worked for me. I now understand why the code I write is the way it is. I'm also gonna be starting college this fall. Anywho, good luck.", "aSentId": 15349, "answer": "Thanks for your reply! I don't mind the wall o text especially when it's informative. I'll check out the cs50 course, any specific you recommend that one specifically other than \"that's the one I used\"? ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15350, "question": "Thanks for your reply! I don't mind the wall o text especially when it's informative. I'll check out the cs50 course, any specific you recommend that one specifically other than \"that's the one I used\"? ", "aSentId": 15351, "answer": "Well for one, David Malan the instructor is phenomenal. Never boring. He teaches very quickly and speaks constantly, but his explanations are amazing. Since it's Harvard, you know the education is great. There are also SO many resources if you get stuck on something. A facebook page, a subreddit, twitter, the emails of like 10 teaching aids, the whole shebang. You get to watch both lectures they have at Harvard each week, then they have a section called \"Shorts\" which are shorter videos by the TA's who explain a specific detail needed for the problem set. They have things called \"Sections\" which is a roughly 1 hour long video of a TA who is with the class going over slides that have to do with info needed for the Problem set. It's like being in the class room. \n\n  I feel like if all intro to CS courses were as difficult yet thorough as this one, less people would be in CS, but those who could stick with it would begin with a better understanding. I'm currently working on problem set 5 (really hard one lol) and I am already implementing a data structure called a trie which most intro classes wouldn't even touch. We have been taught linked lists, hash tables, all that. Just get through the first 2 weeks of easy stuff, and I guarantee you will learn something and want to come back.\n\n  Last thought, in the professional world of CS, no one holds your hand. This class is like that. They teach you the basics of something, then tell you to do stuff they haven't necessarily taught you yet. In the real world, a lot of googling is needed. In cs50, you may need to traverse the subreddit a bit to figure out how to solve a problem set. Give it a go.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15346, "question": "Where can you learn the things a CS degree teaches you, but not at a regular university? (more details inside)", "aSentId": 15353, "answer": "Ok so here's my question for you; why do you want to learn this stuff? If it's for any reason other than just intellectual curiosity you should stop right now and rethink what you're doing.\n\nIf you want to learn this stuff because you think it will make you a better programmer for just run of the mill programming jobs, eh, not really.\n\nIf it's because you want to be able to get the kind of jobs that knowledge IS needed for, well you have a problem chief. You're gonna need a CS degree to get those jobs. They're not just gonna trust you that you know the stuff 'coz you say so in your cover letter. If you don't have a CS degree your resume's going in the trash pile.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15354, "question": "Ok so here's my question for you; why do you want to learn this stuff? If it's for any reason other than just intellectual curiosity you should stop right now and rethink what you're doing.\n\nIf you want to learn this stuff because you think it will make you a better programmer for just run of the mill programming jobs, eh, not really.\n\nIf it's because you want to be able to get the kind of jobs that knowledge IS needed for, well you have a problem chief. You're gonna need a CS degree to get those jobs. They're not just gonna trust you that you know the stuff 'coz you say so in your cover letter. If you don't have a CS degree your resume's going in the trash pile.\n", "aSentId": 15355, "answer": "Frankly, all I want is a fucking job. I've been stuck on the IT / Admin side of it for years and frankly I hate that shit. You can make a somewhat decent living at it but it's basically a glorified customer service job that pays MARGINALLY more. \n\nI really enjoy programming though. I like the breaking down a problem, coming up with a solution, and implementing it. I don't get the same problem solving / lateral thinking input in administration. It's all bitchy customers and password resets. And I can't stand the idea that my career will be 40+ years of something i'm not interested in, that doesn't actually contribute anything to world. \n\nThe \"plan\" was for once my wife got out of school she hopefully would be making enough money for me to either not work, or work part time. But while she's earning about the same I am now, we already are living paycheck to paycheck so we can't make ends met if I don't work.\n\nI've been trying for a year and a half to get an entry level dev job somewhere in my city. I live in a city of 3 million people, it's not like it doesn't exist. But I either never hear back or get turned down for some unspecified reason. All my interviews go very well, i'm super flexible on salary and schedule, I come professionally dressed, and i'm very well spoken. But even jobs that explicitly say \"Entry Level\" and don't require a degree I can't get. \n\nI'm kind of at the end of my rope here. It's not like i'm not enthusiastic or knowledgeable. I can learn anything I need to learn for the specific job, and i'm a really quick study. I feel like I have to be doing something wrong so i'm just trying to run down every possible thing I can try to learn in some capacity. \n\nIncidentally ignoring everything else I would be interested to learn it just out of intellectual curiosity, but no matter what job I worked, more knowledge is never a bad thing.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15356, "question": "Frankly, all I want is a fucking job. I've been stuck on the IT / Admin side of it for years and frankly I hate that shit. You can make a somewhat decent living at it but it's basically a glorified customer service job that pays MARGINALLY more. \n\nI really enjoy programming though. I like the breaking down a problem, coming up with a solution, and implementing it. I don't get the same problem solving / lateral thinking input in administration. It's all bitchy customers and password resets. And I can't stand the idea that my career will be 40+ years of something i'm not interested in, that doesn't actually contribute anything to world. \n\nThe \"plan\" was for once my wife got out of school she hopefully would be making enough money for me to either not work, or work part time. But while she's earning about the same I am now, we already are living paycheck to paycheck so we can't make ends met if I don't work.\n\nI've been trying for a year and a half to get an entry level dev job somewhere in my city. I live in a city of 3 million people, it's not like it doesn't exist. But I either never hear back or get turned down for some unspecified reason. All my interviews go very well, i'm super flexible on salary and schedule, I come professionally dressed, and i'm very well spoken. But even jobs that explicitly say \"Entry Level\" and don't require a degree I can't get. \n\nI'm kind of at the end of my rope here. It's not like i'm not enthusiastic or knowledgeable. I can learn anything I need to learn for the specific job, and i'm a really quick study. I feel like I have to be doing something wrong so i'm just trying to run down every possible thing I can try to learn in some capacity. \n\nIncidentally ignoring everything else I would be interested to learn it just out of intellectual curiosity, but no matter what job I worked, more knowledge is never a bad thing.", "aSentId": 15357, "answer": "The thing is that even an entry level dev job is expecting some experience programming. I know it's kinda bogus, how are you supposed to get programming experience if nobody will hire you. But there's plenty of people out there with experience that they can pick from, so you get screwed out of it.\n\nWhat kind of dev jobs are you looking for? Unfortunately anything but web dev is hard to get experience with on your own. If you're looking at web development jobs, make yourself a couple of personal sites and then volunteer to make ones for non-profits in your area. You should be able to do this on the weekend easily and once you have a portfolio you can show, and you can talk intelligently about programming concepts you will start to get offers.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15358, "question": "The thing is that even an entry level dev job is expecting some experience programming. I know it's kinda bogus, how are you supposed to get programming experience if nobody will hire you. But there's plenty of people out there with experience that they can pick from, so you get screwed out of it.\n\nWhat kind of dev jobs are you looking for? Unfortunately anything but web dev is hard to get experience with on your own. If you're looking at web development jobs, make yourself a couple of personal sites and then volunteer to make ones for non-profits in your area. You should be able to do this on the weekend easily and once you have a portfolio you can show, and you can talk intelligently about programming concepts you will start to get offers.", "aSentId": 15359, "answer": "See this is what I don't understand. How can an entry level job ask for experience? You are right on the money that basically everyone asks for X years of experience with X languages and that is basically impossible. \n\nSo far i've just had to rely on projects various tutorials give me and whatever arbitrary shit I can come up with. But that's no way to be motivated to stick to it because I know that it's all for naught.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15360, "question": "See this is what I don't understand. How can an entry level job ask for experience? You are right on the money that basically everyone asks for X years of experience with X languages and that is basically impossible. \n\nSo far i've just had to rely on projects various tutorials give me and whatever arbitrary shit I can come up with. But that's no way to be motivated to stick to it because I know that it's all for naught.", "aSentId": 15361, "answer": "&gt; See this is what I don't understand. How can an entry level job ask for experience? \n\nGithub.com.\n\nYou're expected to have a personal account, in which you put toys that you wrote for fun, or tools you wrote to make your job easier. And open source contributions. Bugfixes for projects you use, etc.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15362, "question": "&gt; See this is what I don't understand. How can an entry level job ask for experience? \n\nGithub.com.\n\nYou're expected to have a personal account, in which you put toys that you wrote for fun, or tools you wrote to make your job easier. And open source contributions. Bugfixes for projects you use, etc.", "aSentId": 15363, "answer": "See that part I can at least understand. But you can have a pretty fleshed out github profile without even a single interview. Additionally, I have not even once been asked to provide it. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15364, "question": "See that part I can at least understand. But you can have a pretty fleshed out github profile without even a single interview. Additionally, I have not even once been asked to provide it. ", "aSentId": 15365, "answer": "&gt;  Additionally, I have not even once been asked to provide it.\n\nYou provide it anyway.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15364, "question": "See that part I can at least understand. But you can have a pretty fleshed out github profile without even a single interview. Additionally, I have not even once been asked to provide it. ", "aSentId": 15367, "answer": "Seriously, take advantage of resources like github.com bitbucket.com or the likes.\n\nYou can build wathever you like and show it to people.\n\nThat's something so unique about computer science: you can be the architect _and_ the construction engineer of whatever you want.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15360, "question": "See this is what I don't understand. How can an entry level job ask for experience? You are right on the money that basically everyone asks for X years of experience with X languages and that is basically impossible. \n\nSo far i've just had to rely on projects various tutorials give me and whatever arbitrary shit I can come up with. But that's no way to be motivated to stick to it because I know that it's all for naught.", "aSentId": 15369, "answer": "Yeah tutorials aren't gonna get you anything. You need to actually have something you can show people.\n\nIf you're interested in web dev, volunteer to make sites for non profits in your area.\n\nIf you're interested in some other kind of dev, find some open source projects that you can maybe contribute small patches to.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15360, "question": "See this is what I don't understand. How can an entry level job ask for experience? You are right on the money that basically everyone asks for X years of experience with X languages and that is basically impossible. \n\nSo far i've just had to rely on projects various tutorials give me and whatever arbitrary shit I can come up with. But that's no way to be motivated to stick to it because I know that it's all for naught.", "aSentId": 15371, "answer": "Entry level means recent university grad. Sad but true. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15358, "question": "The thing is that even an entry level dev job is expecting some experience programming. I know it's kinda bogus, how are you supposed to get programming experience if nobody will hire you. But there's plenty of people out there with experience that they can pick from, so you get screwed out of it.\n\nWhat kind of dev jobs are you looking for? Unfortunately anything but web dev is hard to get experience with on your own. If you're looking at web development jobs, make yourself a couple of personal sites and then volunteer to make ones for non-profits in your area. You should be able to do this on the weekend easily and once you have a portfolio you can show, and you can talk intelligently about programming concepts you will start to get offers.", "aSentId": 15374, "answer": "&gt;Unfortunately anything but web dev is hard to get experience with on your own.\n\nWrite an iPhone or Android app.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15375, "question": "&gt;Unfortunately anything but web dev is hard to get experience with on your own.\n\nWrite an iPhone or Android app.", "aSentId": 15376, "answer": "Fair enough, those are pretty easy to do on your own as well.\n\nI was thinking more like if he wasn't going for web dev type jobs then maybe he was going for like enterprise java developer jobs, and saying getting THAT kind of experience on your own is pretty difficult.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15377, "question": "Fair enough, those are pretty easy to do on your own as well.\n\nI was thinking more like if he wasn't going for web dev type jobs then maybe he was going for like enterprise java developer jobs, and saying getting THAT kind of experience on your own is pretty difficult.", "aSentId": 15378, "answer": "Agreed. The nice thing about mobile apps is that the barrier to entry is low, the documentation is fantastic to help you get started, and employers tend to view it as a more impressive display of experience (in my limited interactions at least).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15356, "question": "Frankly, all I want is a fucking job. I've been stuck on the IT / Admin side of it for years and frankly I hate that shit. You can make a somewhat decent living at it but it's basically a glorified customer service job that pays MARGINALLY more. \n\nI really enjoy programming though. I like the breaking down a problem, coming up with a solution, and implementing it. I don't get the same problem solving / lateral thinking input in administration. It's all bitchy customers and password resets. And I can't stand the idea that my career will be 40+ years of something i'm not interested in, that doesn't actually contribute anything to world. \n\nThe \"plan\" was for once my wife got out of school she hopefully would be making enough money for me to either not work, or work part time. But while she's earning about the same I am now, we already are living paycheck to paycheck so we can't make ends met if I don't work.\n\nI've been trying for a year and a half to get an entry level dev job somewhere in my city. I live in a city of 3 million people, it's not like it doesn't exist. But I either never hear back or get turned down for some unspecified reason. All my interviews go very well, i'm super flexible on salary and schedule, I come professionally dressed, and i'm very well spoken. But even jobs that explicitly say \"Entry Level\" and don't require a degree I can't get. \n\nI'm kind of at the end of my rope here. It's not like i'm not enthusiastic or knowledgeable. I can learn anything I need to learn for the specific job, and i'm a really quick study. I feel like I have to be doing something wrong so i'm just trying to run down every possible thing I can try to learn in some capacity. \n\nIncidentally ignoring everything else I would be interested to learn it just out of intellectual curiosity, but no matter what job I worked, more knowledge is never a bad thing.", "aSentId": 15380, "answer": "Go to meetups. The Ruby community is especially friendly and welcoming.\n\nSeriously, that's it. Like fucking magic you'll get a programming job within a year. Or, you'll stop attending. But I've never seen anyone show up every month to a programming language meetup and not become a part of the community.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15381, "question": "Go to meetups. The Ruby community is especially friendly and welcoming.\n\nSeriously, that's it. Like fucking magic you'll get a programming job within a year. Or, you'll stop attending. But I've never seen anyone show up every month to a programming language meetup and not become a part of the community.", "aSentId": 15382, "answer": "I haven't used ruby myself personally but i'm sure there is groups of all kinds. Do you have a suggestion on how to find these other than google \"programming meetups $mycity\"?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15383, "question": "I haven't used ruby myself personally but i'm sure there is groups of all kinds. Do you have a suggestion on how to find these other than google \"programming meetups $mycity\"?", "aSentId": 15384, "answer": "Meetup.com", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15356, "question": "Frankly, all I want is a fucking job. I've been stuck on the IT / Admin side of it for years and frankly I hate that shit. You can make a somewhat decent living at it but it's basically a glorified customer service job that pays MARGINALLY more. \n\nI really enjoy programming though. I like the breaking down a problem, coming up with a solution, and implementing it. I don't get the same problem solving / lateral thinking input in administration. It's all bitchy customers and password resets. And I can't stand the idea that my career will be 40+ years of something i'm not interested in, that doesn't actually contribute anything to world. \n\nThe \"plan\" was for once my wife got out of school she hopefully would be making enough money for me to either not work, or work part time. But while she's earning about the same I am now, we already are living paycheck to paycheck so we can't make ends met if I don't work.\n\nI've been trying for a year and a half to get an entry level dev job somewhere in my city. I live in a city of 3 million people, it's not like it doesn't exist. But I either never hear back or get turned down for some unspecified reason. All my interviews go very well, i'm super flexible on salary and schedule, I come professionally dressed, and i'm very well spoken. But even jobs that explicitly say \"Entry Level\" and don't require a degree I can't get. \n\nI'm kind of at the end of my rope here. It's not like i'm not enthusiastic or knowledgeable. I can learn anything I need to learn for the specific job, and i'm a really quick study. I feel like I have to be doing something wrong so i'm just trying to run down every possible thing I can try to learn in some capacity. \n\nIncidentally ignoring everything else I would be interested to learn it just out of intellectual curiosity, but no matter what job I worked, more knowledge is never a bad thing.", "aSentId": 15386, "answer": "Aha!  So the truth comes out!  You should basically scratch all the excellent resources everyone has posted thus far because it puts you on the academic route.\n\nHere is my practical advice - learn about website programming with javascript.  So many references, examples, books on it.  You will pick up the basics (functions, loops, variables, etc) AND you will be able to ask very specific \"help I'm lost\" questions on forums about what you are trying to achieve.\n\nIt puts you down a money-making path, but, honestly, even this path you'll be doing a number on your brain for at least a year as you teach your mind to do new tricks...it's a different kind of thinking that takes practice, practice, practice. \n\nThe web side gives you enough to get your foot in the door.  After javascript go php (laravel is a good framework to work with).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15354, "question": "Ok so here's my question for you; why do you want to learn this stuff? If it's for any reason other than just intellectual curiosity you should stop right now and rethink what you're doing.\n\nIf you want to learn this stuff because you think it will make you a better programmer for just run of the mill programming jobs, eh, not really.\n\nIf it's because you want to be able to get the kind of jobs that knowledge IS needed for, well you have a problem chief. You're gonna need a CS degree to get those jobs. They're not just gonna trust you that you know the stuff 'coz you say so in your cover letter. If you don't have a CS degree your resume's going in the trash pile.\n", "aSentId": 15389, "answer": "&gt; You're gonna need a CS degree to get those jobs.\n\nNo, that's FUD.\n\n&gt; They're not just gonna trust you\n\nNot that they'll trust your fancy LinkedIn-to-docx resume either.\n\n&gt; cover letter. \n\nUuuuh! I loved those ... those things from the 1990s! (No. Those are fucked up.)\n\n&gt; If you don't have a CS degree your resume's going in the trash pile.\n\nOr not.\n\n\nSo, dear OP, \n\nGo build stuff, get into open source, become active in IT communities. Go read NANOG and IETF lists, go watch conference talks and lectures, attend meetups and learn to code. Join a project, volunteer, report bugs, test software, fix bugs, design programs, deliver features. Ship code. All the fancy stuff comes up anyways, just read up on them, ask questions, and get ready to follow a few hundred pages of dense proofs altogether.\n\nThere are a lot of distributed systems where a more scientific approach would be useful and welcomed. Cassandra is built on a paper, there are a lot of applied work regarding database consistency in the face of network failures. There is a lot of CS being done with regards to networks, from security to routing, from wireless data encoding (which is a lot more about antenna design and anti-interference techniques, but a robust DSP skillset is very much welcome there too) to figuring out clever congestion control algorithms.\n\nDo shit, enjoy it. \n\nIf your are good, you'll probably enjoy it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15390, "question": "&gt; You're gonna need a CS degree to get those jobs.\n\nNo, that's FUD.\n\n&gt; They're not just gonna trust you\n\nNot that they'll trust your fancy LinkedIn-to-docx resume either.\n\n&gt; cover letter. \n\nUuuuh! I loved those ... those things from the 1990s! (No. Those are fucked up.)\n\n&gt; If you don't have a CS degree your resume's going in the trash pile.\n\nOr not.\n\n\nSo, dear OP, \n\nGo build stuff, get into open source, become active in IT communities. Go read NANOG and IETF lists, go watch conference talks and lectures, attend meetups and learn to code. Join a project, volunteer, report bugs, test software, fix bugs, design programs, deliver features. Ship code. All the fancy stuff comes up anyways, just read up on them, ask questions, and get ready to follow a few hundred pages of dense proofs altogether.\n\nThere are a lot of distributed systems where a more scientific approach would be useful and welcomed. Cassandra is built on a paper, there are a lot of applied work regarding database consistency in the face of network failures. There is a lot of CS being done with regards to networks, from security to routing, from wireless data encoding (which is a lot more about antenna design and anti-interference techniques, but a robust DSP skillset is very much welcome there too) to figuring out clever congestion control algorithms.\n\nDo shit, enjoy it. \n\nIf your are good, you'll probably enjoy it.", "aSentId": 15391, "answer": "Dude, you're a fucking moron. You didn't even read any of what I wrote. You disagree with me and then basically said the exact same thing I said.\n\nWhat a dumbass.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15346, "question": "Where can you learn the things a CS degree teaches you, but not at a regular university? (more details inside)", "aSentId": 15393, "answer": "\"Testing\" and \"Automated Testing\" aren't really computer science topics; if anything they're \"software engineering\" topics.\n\nThe closest thing in the CompSci world would be mathematical proofs.\n\nIf you want to do study CompSci outside of a university system, here's what I suggest:\n\n1. Find a list of all courses for a university CompSci course plan.\n2. Find out what textbooks are for the classes and study up\n3. Find free online courses and decide to take them or not", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15394, "question": "\"Testing\" and \"Automated Testing\" aren't really computer science topics; if anything they're \"software engineering\" topics.\n\nThe closest thing in the CompSci world would be mathematical proofs.\n\nIf you want to do study CompSci outside of a university system, here's what I suggest:\n\n1. Find a list of all courses for a university CompSci course plan.\n2. Find out what textbooks are for the classes and study up\n3. Find free online courses and decide to take them or not", "aSentId": 15395, "answer": "My school requires a software engineering course for a CS degree that covers things like TDD. I guess it's not strictly \"computer science\" but it's important knowledge to have, and something you'd probably learn getting a CS degree. I definitely wouldn't discourage anybody from learning about it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15397, "question": "Well, you can start by googling these topics. There are a lot of online resources covering the basics for all the IT fields you've listed. Also, some top schools are offering their IT course material online for free. Google is your friend.", "aSentId": 15398, "answer": "Maybe I was unclear, while I can of course google those things. I mostly meant what other thing might I include. Having never gone through a CS program obviously so I don't know what I don't know.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15405, "question": "There are some great suggestions in this thread, but the truth is that you'll pick it up as you go as long as you read a lot. I barely did any of my CS degree before dropping out, and I've since at least touched on just about everything they would have taught me. The key is to be obsessively fascinated by what you do. If you don't have that, it's going to be difficult and you'll start to hate it as it becomes a chore. It sounds like you want to learn this stuff quickly to be able to answer interview questions. That's already a bit if a bad sign, so hopefully I've misconstrued that. If you're prepared to take your time absorbing everything you come across because you have a thirst for it, you'll probably be fine.", "aSentId": 15406, "answer": "I'm totally fine with it taking some time so long as there is at least PROGRESS and it feels like i've been running in place. A lot of these resources are... \"beneath me\" isn't the word, but mostly contain stuff I all already know. \n\nPersonally I think I could go out and get a Jr. Dev or DevOps job TODAY and I would be at least passable very quickly. That said, i'm nowhere near as prepared as I could be, and the only way I know to make myself a better candidate is to have a degree, but failing that be as close to it as possible.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15408, "question": "I'm a little confused as to how you can say you can program, but don't know how to make a basic algorithm. Do you ever use loops? Recursion? That's basically a form of algorithm right there. \n\nI'd recommend intro text books and books on data/discrete structures. I think you might know more than you think you do. ", "aSentId": 15409, "answer": "You are almost certainly right that I know more than I think I do. I do know loops and recursion. The problem lies in that I can explain the concept behind them, and even implement them in my own way, but I could not tell you what a specific type of algorithm is or does.\n\nBut if you asked me to make a loop to satisfy X conditions I COULD do it. But that's not how most interview questions are asked. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15410, "question": "You are almost certainly right that I know more than I think I do. I do know loops and recursion. The problem lies in that I can explain the concept behind them, and even implement them in my own way, but I could not tell you what a specific type of algorithm is or does.\n\nBut if you asked me to make a loop to satisfy X conditions I COULD do it. But that's not how most interview questions are asked. ", "aSentId": 15411, "answer": "I think you're stressing a little too much then. If you want a crash course on what algorithms are, look up the different types of sorting algorithms. Each one has a \"best case\", \"worst case\", and an efficiency equation. \n\nA common thing in mid-level CS classes is to create an array and sort it with different algorithms. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15413, "question": "Unfortunately, the amount of resources for learning algorithms, discrete math, and data structs hardly exist online. \n\nThe new, cuddly face of \" lol l2usepygame :DDD \" that is passed off as cs has killed the deeper resources. \n\nYour best bet is to buy/ torrent a textbook and teach yourself. \n\nLook on mit ocw, find the courses you want, read the syllabus, and get the textbook, then use that.", "aSentId": 15414, "answer": "It's sad that this comment is being down voted. The fact of the matter is that real computer science is just a branch of applied mathematics. All this fluffy feel-good OO programming and beginning programming crap is being passed off incorrectly. Call me elitest if you want, but that's the true reality of \"learning computer science\".\n\nIf I were in this guys shoes, I'd join the ACM ($99 a year) and use their resources to get access to their oreilly book collection and academic papers.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15418, "question": "Matching algorithm for addresses with multiple fields", "aSentId": 15419, "answer": "Interesting idea, trying to do a \"match\" by measuring the edit distance between the corresponding strings which make up the fields of two addresses which are being compared... But, no, this is not how it is done in the \"real world\" these days.\n\nYou need to look into CASS address standardization. In a nutshell, it will do exactly what you are looking to do: take addresses which may have minor stylistic variations and return a canonical form (which has been validated as well). These \"CASS'ed\" addresses can then be compared directly (i.e. character-for-character) to determine if there is a match or not.\n\nIn the marketing world, this is one of the primary methods employed for removing duplicate households from mailing lists and stuff like that. It is also used for identifying addresses which are not valid (e.g. an address which may be missing a suite or apartment number but requires it).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15421, "question": "Future Computer Engineering Student", "aSentId": 15422, "answer": "I'm going to go out on a limb here and reccomend [Elm](http://elm-lang.org/). My reasoning:\n\n* Starting with functional programming will teach your code well, even when you transition to imperative languages\n* Elm is great for games, because it's based on funtional reactive programming, a clever way of structuring interactive appllications\n* It's easy to get set up, and you can even [write code in the browser](http://share-elm.com/) (or [here)](http://elm-lang.org/try).\n* It's got an [amazing debugger](http://elm-lang.org/blog/Introducing-Elm-Reactor.elm) which will make it easy to figure out what your code is actually doing\n* You could potentially have a simple 2D or 3D game written by the end of the summer\n\nIf you're just looking for another language to put on your resume, Elm is not it. It's fairly new, under active development, and not well known.\nIf you're looking to get interesting experience, then I think it's a quick route that will have benefits in your future career.\n\nA few other things to consider:\n\n* Reviewing math, especially discrete math, is probably more valuable than learning programming. In particular, learn induction, set-theory, and discrete math. Computer science is not about learning language, it's about learning algorithms, principles of computation, and how languages work, so you can pick up many languages quickly.\n\n* Computer engineering might not be the area for you if games programming is your area. Computer Engineering is more focused on hardware, systems, and low-level stuff. For Games, maybe focus more on software-engineering or computer science. Though, it's possible the vector-math focus of an engineering degree will pay off in graphics/animation.\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15421, "question": "Future Computer Engineering Student", "aSentId": 15424, "answer": "First of all, work on your grammar. An enormous part of work and school is communicating with others. You will not be taken seriously if you do not use proper sentence structure, capitalization, and punctuation.  \n\nIf you're planning on working on games professionally, you should be in a computer science or software engineering program, not computer engineering. Computer engineering is essentially electrical engineering with computer science concepts.  \n\nTo prepare, start looking over concepts in discrete math. Discrete math provides you with a way to think about computer concepts, since most computer science concepts use discrete math concepts.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15426, "question": "Who here knows a good amount about C++ ?", "aSentId": 15427, "answer": "/r/cpp_questions is the place for this.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15428, "question": "/r/cpp_questions is the place for this.", "aSentId": 15429, "answer": "Thank you mate.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15426, "question": "Who here knows a good amount about C++ ?", "aSentId": 15431, "answer": "You aren't initializing i to a value. Do:\n\n int i = 0;\n\nYou also aren't giving your parameters names, and are then trying to use the typename instead of the variable name. Try ostream&amp; os, then do os &lt;&lt; array[i] &lt;&lt; endl;", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15433, "question": "UK Students the Graduate Recruitment Bureau is linking students (and graduates) up with jobs, so they can start work the second they graduate. COMPSCI DEMAND. You will be set up with a personal consultant who will work with you, we have a ZERO email spam policy. Check it out, sign up today.", "aSentId": 15434, "answer": "People will believe a no spam policy more if you don't use all caps in your title and write a less clickbait-ish headline. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15433, "question": "UK Students the Graduate Recruitment Bureau is linking students (and graduates) up with jobs, so they can start work the second they graduate. COMPSCI DEMAND. You will be set up with a personal consultant who will work with you, we have a ZERO email spam policy. Check it out, sign up today.", "aSentId": 15436, "answer": "My friend was talking about this, i was wondering how the consultant system works, do they meet up with you?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15437, "question": "My friend was talking about this, i was wondering how the consultant system works, do they meet up with you?", "aSentId": 15438, "answer": "Hi thanks for you're interest, \nOnce signed up you will be assigned a personal consultant based on your degree scheme, during this time they will offer you help through your CV and applications as well as choosing jobs which match what YOU want.\n\nWhen possible jobs application appear we will ring you up (or other communication methods if you prefer) and discuss with you what your best steps are, if you choose to follow that career path", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15433, "question": "UK Students the Graduate Recruitment Bureau is linking students (and graduates) up with jobs, so they can start work the second they graduate. COMPSCI DEMAND. You will be set up with a personal consultant who will work with you, we have a ZERO email spam policy. Check it out, sign up today.", "aSentId": 15440, "answer": "Graduate Recruitment Bureau is a leading recruitment consultancy placing graduates into graduate jobs. We provide a free career matchmaking service for students and graduates.\n\nWhile also providing you the latest Graduate Jobs and Graduate Schemes, the GRB will support you in your job applications with graduate CV help, Graduate Job advice and all the graduate recruitment industry knowledge you need from recruitment professionals who understand the competitive nature of the graduate job market and graduate schemes.\n\n+ GRB are real consultants you talk to\n+ We're not just another one of those jobs websites that send loads of emails\n+ That means a zero spam policy\n+ Specialist teams for each degree field\n+ 17+ years leading the recruitment industry\n+ Exclusive opportunities you won't find anywhere else", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15442, "question": "Could hand calculations be completely replaced by computers?", "aSentId": 15443, "answer": "Maths are useful to know. Wolfram is working on this type of thing btw.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15442, "question": "Could hand calculations be completely replaced by computers?", "aSentId": 15445, "answer": "&gt; Perhaps handwriting itself could practically go extinct with further convergence with computing\n\nMine sure did. I always had bad handwriting. Once computers came along I stopped writing longhand completely. These days I can only block print and write my signature. I can't remember the last time I handwrote script.\n\n\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15446, "question": "&gt; Perhaps handwriting itself could practically go extinct with further convergence with computing\n\nMine sure did. I always had bad handwriting. Once computers came along I stopped writing longhand completely. These days I can only block print and write my signature. I can't remember the last time I handwrote script.\n\n\n\n", "aSentId": 15447, "answer": "Whiteboarding is the only thing that has improved my handwriting over the years.\n\nIt's still chicken scratch, but improving. My cursive is flawless, but useless.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15442, "question": "Could hand calculations be completely replaced by computers?", "aSentId": 15449, "answer": "You are,  perhaps,  misunderstanding the purpose of maths.\n\nMaths is used to describe and model situations.  It is the purpose of these equations to allow us to make deductions and reason in a way which is abstracted from the physical world.  By understanding the ways in which an equation can be re-arranged and modified we are able to work things out.\n\nWhat I am trying to say is you have it backwards.  Maths IS a programming language (some would argue *the* programming language).  Computer science is merely the study of how to modify the way we perform the computations and the benefits different choices convey to us - think computational science,  the science of improving the way mathematicians compute.\n\n---\n\nSo,  what I think you are looking for is some kind of IDE for Maths,  so that humans are still doing the major reasoning but the program handles the trivial background calculation.  This is something along the lines of Mathmatica or such.\n\nWe don't currently have something that can take away the larger reasoning portion,  but the stufy of AI may lead us to that point - a point where many think AI management (not CS) will come to dominate all fields.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15450, "question": "You are,  perhaps,  misunderstanding the purpose of maths.\n\nMaths is used to describe and model situations.  It is the purpose of these equations to allow us to make deductions and reason in a way which is abstracted from the physical world.  By understanding the ways in which an equation can be re-arranged and modified we are able to work things out.\n\nWhat I am trying to say is you have it backwards.  Maths IS a programming language (some would argue *the* programming language).  Computer science is merely the study of how to modify the way we perform the computations and the benefits different choices convey to us - think computational science,  the science of improving the way mathematicians compute.\n\n---\n\nSo,  what I think you are looking for is some kind of IDE for Maths,  so that humans are still doing the major reasoning but the program handles the trivial background calculation.  This is something along the lines of Mathmatica or such.\n\nWe don't currently have something that can take away the larger reasoning portion,  but the stufy of AI may lead us to that point - a point where many think AI management (not CS) will come to dominate all fields.", "aSentId": 15451, "answer": "That's definitely true too. There are two semi-parallel points, one is that people could stand to benefit from transferring calculation duties to a computer, and the other is that one could even develop manual calculation methods that work easily with a keyboard/touchscreen/mouse. \n\nI also strongly agree with the prediction regarding AI. Even if it weren't for math education, I still would strongly support an educational program that makes computer programming as vital as learning english or history.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15454, "question": "Recursion", "aSentId": 15455, "answer": "Since you're into Java, check out A book called *Thinking Recursively with Java*.  It really helped me with, well, thinking about recursion.\n\nThe other thing I would suggest is to actually write out the entire call stack for a few recursive functions. Start with something simple like a factorial, then do Fibonacci, then move on to something like merge sort, binary search, or DFS. And here is the key: don't cheat yourself by stopping early! Literally trace the execution as if you were the interpreter, writing out every call and then following the recursion until you get to a terminating case that will be passed back up the stack.  See what happens to the arguments (I.e problem size) with each recursive call. See how much work the CPU must do before being able to return. \n\nThere may be people out there who just grok recursion without doing this, but that was the only way I got it. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15456, "question": "Since you're into Java, check out A book called *Thinking Recursively with Java*.  It really helped me with, well, thinking about recursion.\n\nThe other thing I would suggest is to actually write out the entire call stack for a few recursive functions. Start with something simple like a factorial, then do Fibonacci, then move on to something like merge sort, binary search, or DFS. And here is the key: don't cheat yourself by stopping early! Literally trace the execution as if you were the interpreter, writing out every call and then following the recursion until you get to a terminating case that will be passed back up the stack.  See what happens to the arguments (I.e problem size) with each recursive call. See how much work the CPU must do before being able to return. \n\nThere may be people out there who just grok recursion without doing this, but that was the only way I got it. ", "aSentId": 15457, "answer": "Writing out the call stack did it for me! Everything started to click after that.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15454, "question": "Recursion", "aSentId": 15459, "answer": "I usually introduce two interpretations of recursion:\n\nThe **operational interpretation** focuses on *how* recursive function calls behave.  If you understand how recursive calls evaluate, then you can trace through code that uses recursion.\n\nFor example, with a *substitutive model of computation*, if factorial is defined as:\n\n    factorial 0 = 1\n    factorial n = n * factorial n-1\n\nThen the following is how `factorial 3` evaluates according to this model:\n\n      factorial 3\n    -&gt; 3 * factorial (3-1)\n    -&gt; 3 * factorial 2\n    -&gt; 3 * (2 * factorial (2-1))\n    -&gt; 3 * (2 * factorial 1)\n    -&gt; 3 * (2 * (1 * factorial (1-1)))\n    -&gt; 3 * (2 * (1 * factorial 0))\n    -&gt; 3 * (2 * (1 * 1))\n    -&gt; 3 * (2 * 1)\n    -&gt; 3 * 2\n    -&gt; 6\n\nThe key insight is that function calls (in the absence of side-effects) act like arithmetic expressions.  They perform some calculation and the result of that calculation is substituted for the function call.\n\nThe **semantic interpretation** focuses on applying recursive thinking to problem solving.  Here, I like to focus on *structural recursion* and *recursively-defined data* as a stepping stone.\n\nConsider a recursive definition of a linked list.  A linked list is either:\n\n1. Empty (`Nil`) or\n2. Non-empty (`Cons`) with an element at the front of the list followed the rest of the list.\n\nNow, how might we compute the length of such a list?  Rather than using iteration, let's do *case analysis* on the possible forms of the linked list to see if that helps us make progress:\n\n1. If the list is empty, then the length is 0.\n2. If the list is non-empty, then we know there is at least one element in the list.  So the length must be one plus the length of the rest of the list.\n\nThe *length of the rest of the list* part is exactly the recursive call, *e.g.*, in Haskell:\n\n    length :: [a] -&gt; Int\n    length [] = 0\n    length (x:xs) = 1 + length xs\n\nSo thinking about solutions recursively comes about by exercising the same decomposition skills you learned when you learned about (non-recursive) functions.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15454, "question": "Recursion", "aSentId": 15461, "answer": "Recursion is a thing you *will* have to grok in the field. You will very likely be tested on this in interviews, and I've used it a few times in my career (which is only about a year of interning and a few months full-time, so far), in real-world applications.\n\nThat having been said, I think it's something that you will very likely pick up throughout your college career, just because it'll be in a bunch of different things you learn. I agree with /u/rossdub, though, maybe play around with a few standard examples of recursion and you'll likely start to get it.\n\nIt takes a bit of practice to start to think about algorithms in a generalized sense. Like, \"Okay, for most cases, this algorithm will have to do X and then it'll have to do X again on a smaller subset of the data. Cool, I'll just have the function call itself.\" Basically you then have to only think about when that sort of thinking doesn't work, like base cases.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15462, "question": "Recursion is a thing you *will* have to grok in the field. You will very likely be tested on this in interviews, and I've used it a few times in my career (which is only about a year of interning and a few months full-time, so far), in real-world applications.\n\nThat having been said, I think it's something that you will very likely pick up throughout your college career, just because it'll be in a bunch of different things you learn. I agree with /u/rossdub, though, maybe play around with a few standard examples of recursion and you'll likely start to get it.\n\nIt takes a bit of practice to start to think about algorithms in a generalized sense. Like, \"Okay, for most cases, this algorithm will have to do X and then it'll have to do X again on a smaller subset of the data. Cool, I'll just have the function call itself.\" Basically you then have to only think about when that sort of thinking doesn't work, like base cases.", "aSentId": 15463, "answer": "Is there ever any benefit to using recursion?  Does it have any benefits?  I thought it had poor performance, poor readability, and poor troubleshooting.  It's even impossible to do on some platforms iirc.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15464, "question": "Is there ever any benefit to using recursion?  Does it have any benefits?  I thought it had poor performance, poor readability, and poor troubleshooting.  It's even impossible to do on some platforms iirc.", "aSentId": 15465, "answer": "I'd argue it's more readable in some instances. Completely up to preference, though.\n\nThe biggest use of 'recursion' that I can think of in my career was actually implemented iteratively (in a while-true-if-break style loop) but the theory behind the idea was recursive on a dataset. So while not technically true recursion, knowing how recursion worked helped in formulating a solution.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15476, "question": "Can you apply Kruskal's algorithm to a matrix?", "aSentId": 15477, "answer": "From what I understand and have been able to research online, I think you can it just its efficient becuase of assess time for the information needed is increased. The stack overflow link below maybe able to clear it up better then I can.\nhttp://stackoverflow.com/questions/9092339/time-efficiency-in-kruskals-algorithm-using-adjacency-matrix-as-data-structure", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15476, "question": "Can you apply Kruskal's algorithm to a matrix?", "aSentId": 15479, "answer": "Get list of edged from the matrix.\n\nApply Kruskal.\n\n???\n\nPROFIT!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15481, "question": "Why is it sufficient for a language to be recognizable to be recursively enumerable?", "aSentId": 15482, "answer": "If I understand you correctly, you ask why semi-decidability and enumerability are equivalent?\n\nFrom RE to semi-rec, you can just enumerate all words until you find the input.\n\nThe other direction is more complicated. The idea is to execute the semi-deciding TM in parallel on multiple words. You first let it run on the first word in some order (e.g. the empty word) for one step. If it accepts, the enumerator outputs it. Then you let it run on the first and second word for 2 steps and output those which are accepted. Then for 3 words and 3 steps and so on.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15481, "question": "Why is it sufficient for a language to be recognizable to be recursively enumerable?", "aSentId": 15484, "answer": "Dovetailing. You'll find a more detail in any introductory book (or lecture notes) on computation theory.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15486, "question": "I can prove P = NP with a constructive proof", "aSentId": 15487, "answer": "&gt; I can prove P = NP with a constructive proof\n\nNo you can't.\n\n&gt;  I am not connected to any academic community and am facing a problem with understanding how to publish to a peer-reviewed journal.\n\nAs a general rule, you follow their submission guidelines, and send them your paper. Most journals will accept submissions from anyone. I suggest spending some time in a library, reading journals, studying the structure and process of papers, and researching this subject. You might even discover why your proof is wrong (and it almost certainly is- don't feel bad), and save yourself the embarrassment of rejection.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15488, "question": "&gt; I can prove P = NP with a constructive proof\n\nNo you can't.\n\n&gt;  I am not connected to any academic community and am facing a problem with understanding how to publish to a peer-reviewed journal.\n\nAs a general rule, you follow their submission guidelines, and send them your paper. Most journals will accept submissions from anyone. I suggest spending some time in a library, reading journals, studying the structure and process of papers, and researching this subject. You might even discover why your proof is wrong (and it almost certainly is- don't feel bad), and save yourself the embarrassment of rejection.", "aSentId": 15489, "answer": "I won't be embarrassed if rejected. I look forward to learning either way about what I could have done wrong.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15486, "question": "I can prove P = NP with a constructive proof", "aSentId": 15491, "answer": "If you're worried about somebody  stealing your work without crediting you, all you have to do is get proof that you wrote it first.\n\nPrint it out and get it notarized with the date. Publish it in a newspaper. Whatever floats your boat.\n\nThen go to a professor.  Bet them $20 you have a proof of P=NP. If they're not interested, bump it to $50. They'll laugh. They'll take your money. They'll read it. They'll tell you what's wrong. \n\nIf they publish a proof that P=NP in the next few years, sue them with your proof. \n\nBam! Only cost you $50.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15492, "question": "If you're worried about somebody  stealing your work without crediting you, all you have to do is get proof that you wrote it first.\n\nPrint it out and get it notarized with the date. Publish it in a newspaper. Whatever floats your boat.\n\nThen go to a professor.  Bet them $20 you have a proof of P=NP. If they're not interested, bump it to $50. They'll laugh. They'll take your money. They'll read it. They'll tell you what's wrong. \n\nIf they publish a proof that P=NP in the next few years, sue them with your proof. \n\nBam! Only cost you $50.", "aSentId": 15493, "answer": "I belive publishing on arXiv stands and proof of concept, no need for a notary. (http://arxiv.org/) and this way the entire community would have input on the work.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15492, "question": "If you're worried about somebody  stealing your work without crediting you, all you have to do is get proof that you wrote it first.\n\nPrint it out and get it notarized with the date. Publish it in a newspaper. Whatever floats your boat.\n\nThen go to a professor.  Bet them $20 you have a proof of P=NP. If they're not interested, bump it to $50. They'll laugh. They'll take your money. They'll read it. They'll tell you what's wrong. \n\nIf they publish a proof that P=NP in the next few years, sue them with your proof. \n\nBam! Only cost you $50.", "aSentId": 15495, "answer": "I like the way you think.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15492, "question": "If you're worried about somebody  stealing your work without crediting you, all you have to do is get proof that you wrote it first.\n\nPrint it out and get it notarized with the date. Publish it in a newspaper. Whatever floats your boat.\n\nThen go to a professor.  Bet them $20 you have a proof of P=NP. If they're not interested, bump it to $50. They'll laugh. They'll take your money. They'll read it. They'll tell you what's wrong. \n\nIf they publish a proof that P=NP in the next few years, sue them with your proof. \n\nBam! Only cost you $50.", "aSentId": 15497, "answer": "50$, and of course ten time that in notary fee.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15486, "question": "I can prove P = NP with a constructive proof", "aSentId": 15499, "answer": "Email Scott Aaronson. In one of his talks he says he gets these emails all the time. He's happy to receive claims of P=NP because all he does in response is sends them a huge number and tells them to factor it for him. Should be easy since you have it implemented and it will get your foot in the door with him.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15500, "question": "Email Scott Aaronson. In one of his talks he says he gets these emails all the time. He's happy to receive claims of P=NP because all he does in response is sends them a huge number and tells them to factor it for him. Should be easy since you have it implemented and it will get your foot in the door with him.", "aSentId": 15501, "answer": "A prime number cannot be factored ;) ... but I understand what you are saying.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15502, "question": "A prime number cannot be factored ;) ... but I understand what you are saying.", "aSentId": 15503, "answer": "You beat my edit!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15504, "question": "You beat my edit!", "aSentId": 15505, "answer": "One problem I've got is that I can solve one specific NP-Complete problem in polynomial time. I don't know how to reduce Integer Factorization to it, but I could get him to give me a big 3SAT problem!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15514, "question": "This list may be informative: http://gepwnage.nl/new/?p=linkdump&amp;id=10647", "aSentId": 15515, "answer": "Yeah, in particular, there are many other purported \"proofs\" on there that use polynomial solutions to the \"Clique\" problem.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15518, "question": "C++ Code help!!", "aSentId": 15519, "answer": "If I'm understanding this right, considering there's only one output, it looks you need a program to find these numbers, not just print them. However, I don't think you need a computer as using mathematical logic 941\\*852\\*763 would be best, so just print that. I might not be understanding what your task is though.\n\nEDIT: I can explain my reasoning for this if you want.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15520, "question": "If I'm understanding this right, considering there's only one output, it looks you need a program to find these numbers, not just print them. However, I don't think you need a computer as using mathematical logic 941\\*852\\*763 would be best, so just print that. I might not be understanding what your task is though.\n\nEDIT: I can explain my reasoning for this if you want.", "aSentId": 15521, "answer": "Yeah, the programs supposed to find those numbers though. Its beyond ridiculous, but its for an assignment. I have no clue where to start\n\nEDIT: if you could explain, that would be awesome :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15522, "question": "Yeah, the programs supposed to find those numbers though. Its beyond ridiculous, but its for an assignment. I have no clue where to start\n\nEDIT: if you could explain, that would be awesome :)", "aSentId": 15523, "answer": "Alright, here's the reasoning.\n\nThe first digit of each number should be the 3 largest possible numbers, which are 7,8,9. The second digits should be the second largest, which are 4,5,6. Third digits are 1,2,3. I did a semi-proof in my brain for this, but intuitively it makes and I don't want to go into that. Next remember the basic rule that if a + b = n (for some fixed n), then a\\*b is maximized when a = b. For example, let's say n = 6:\n\na|b|a+b|a\\*b\n:--|:--|:--|:-- \n0|6|6|0\n1|5|6|5\n2|4|6|8\n3|3|6|9\n4|2|6|8\n5|1|6|5\n6|0|6|0\n\n(This isn't hard to prove, but I won't do it here). So what does this mean? Notice that _any_ 3 numbers we choose (with the above constraint) will add to the same number (namely, 2556).This means that we want the largest digits to be placed on the smallest numbers, and vice versa for the largest numbers, to make the numbers \"closer\" to each other. So, the number whose first digit is 9 should have a second digit of 4, and third digit of 1, and so on for the rest, while the smallest number (whose first digit is 7) will be followed by the largest (EDIT: typo) possible digits, namely a 6, then 3. \n\nThis gives 941 \\* 852 \\* 763 as the maximum. \n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15524, "question": "Alright, here's the reasoning.\n\nThe first digit of each number should be the 3 largest possible numbers, which are 7,8,9. The second digits should be the second largest, which are 4,5,6. Third digits are 1,2,3. I did a semi-proof in my brain for this, but intuitively it makes and I don't want to go into that. Next remember the basic rule that if a + b = n (for some fixed n), then a\\*b is maximized when a = b. For example, let's say n = 6:\n\na|b|a+b|a\\*b\n:--|:--|:--|:-- \n0|6|6|0\n1|5|6|5\n2|4|6|8\n3|3|6|9\n4|2|6|8\n5|1|6|5\n6|0|6|0\n\n(This isn't hard to prove, but I won't do it here). So what does this mean? Notice that _any_ 3 numbers we choose (with the above constraint) will add to the same number (namely, 2556).This means that we want the largest digits to be placed on the smallest numbers, and vice versa for the largest numbers, to make the numbers \"closer\" to each other. So, the number whose first digit is 9 should have a second digit of 4, and third digit of 1, and so on for the rest, while the smallest number (whose first digit is 7) will be followed by the largest (EDIT: typo) possible digits, namely a 6, then 3. \n\nThis gives 941 \\* 852 \\* 763 as the maximum. \n", "aSentId": 15525, "answer": "OMG!! :D That actually makes sense! Thanks mate. Now I just have to figure out how to code this and get it working. \nBut i really do appreciate the help :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15518, "question": "C++ Code help!!", "aSentId": 15527, "answer": "Try r/learnprogramming", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15528, "question": "Try r/learnprogramming", "aSentId": 15529, "answer": "Will do! Thanks :D", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15518, "question": "C++ Code help!!", "aSentId": 15531, "answer": "The algorithm would be the same in any language. So that's where you have to start, with the algorithm.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15533, "question": "Are there lecture notes on the more recent developments in Complexity Theory (i.e., within the last 5-10 years)?", "aSentId": 15534, "answer": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15535, "question": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "aSentId": 15536, "answer": "Overall I enjoyed that book, but some of the later chapters have an enormous amount of typos and errors that made it more difficult to read than it should be.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15535, "question": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "aSentId": 15538, "answer": "Note in one of the online appendices it includes an outline of Ryan Williams's recent proof that NEXP does not have nonuniform ACC circuits. However, I personally like Ryan's writeup better: http://arxiv.org/abs/1111.1261", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15539, "question": "Note in one of the online appendices it includes an outline of Ryan Williams's recent proof that NEXP does not have nonuniform ACC circuits. However, I personally like Ryan's writeup better: http://arxiv.org/abs/1111.1261", "aSentId": 15540, "answer": "Here's a lecture script on ACC: http://eccc.hpi-web.de/static/books/A_taste_of_Curcuit_Complexity/", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15541, "question": "Here's a lecture script on ACC: http://eccc.hpi-web.de/static/books/A_taste_of_Curcuit_Complexity/", "aSentId": 15542, "answer": "On an unrelated note, that set of lecture notes has a really nice exposition on matrix rigidity! ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15535, "question": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "aSentId": 15544, "answer": "Thank you for that, I have read some of it before. However, I heard that there were a lot of grammatical errors, such as what /u/shitalwayshappens has said.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15545, "question": "Thank you for that, I have read some of it before. However, I heard that there were a lot of grammatical errors, such as what /u/shitalwayshappens has said.", "aSentId": 15546, "answer": "There are. But I've never found a thick, contemporary, graduate-level textbook that doesn't have the same problem. I worked through the fourth printing of *Machine Learning: A Probabilistic Perspective* recently, and came out the other side with a list of a hundred mistakes. Simple fact is that there's a very small pool of people qualified to proofread such books, and they've all got better things to do.\n\nUsually errors get fixed in later printings thanks to reader errata, but I bought my copy years ago so I can't confirm  that's happened with CC:AMA.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15547, "question": "There are. But I've never found a thick, contemporary, graduate-level textbook that doesn't have the same problem. I worked through the fourth printing of *Machine Learning: A Probabilistic Perspective* recently, and came out the other side with a list of a hundred mistakes. Simple fact is that there's a very small pool of people qualified to proofread such books, and they've all got better things to do.\n\nUsually errors get fixed in later printings thanks to reader errata, but I bought my copy years ago so I can't confirm  that's happened with CC:AMA.", "aSentId": 15548, "answer": "Murphy's book is full of mistakes. I found Koller's book much easier to read.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15533, "question": "Are there lecture notes on the more recent developments in Complexity Theory (i.e., within the last 5-10 years)?", "aSentId": 15550, "answer": "You can take a look at some of Subhash Khot's more recent surveys on the Unique Games Conjecture which may be of interest. Very active research area, and Khot just released a preprint with a candidate Lasserre hierarchy to confirm the conjecture. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15552, "question": "Discrete Math help?", "aSentId": 15553, "answer": "can you be more specific about what is confusing to you? the procedure is just a pseudo-code definition of a function that takes a list of numbers (of length n) as input and returns the largest value in the list as output.\n\nthe question at the bottom of the page is phrased \"if we run maximum(3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4) what is the value of _n_?\"\n\nif we interpret the question very literally then we should conclude that _n_ is the length of the list of numbers, so in this case its 11 since length([3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4]) is 11. if we interpret the question to mean \"what is the result of this procedure call?\" then the answer would be that the procedure returns the value 14, which is the largest value in the list. \n\nI'm inclined to go with the more literal interpretation here since the question seems incredibly simple and looks a little like a trick question just to check that you're understanding the terminology and reading carefully enough to find the trick.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15554, "question": "can you be more specific about what is confusing to you? the procedure is just a pseudo-code definition of a function that takes a list of numbers (of length n) as input and returns the largest value in the list as output.\n\nthe question at the bottom of the page is phrased \"if we run maximum(3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4) what is the value of _n_?\"\n\nif we interpret the question very literally then we should conclude that _n_ is the length of the list of numbers, so in this case its 11 since length([3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4]) is 11. if we interpret the question to mean \"what is the result of this procedure call?\" then the answer would be that the procedure returns the value 14, which is the largest value in the list. \n\nI'm inclined to go with the more literal interpretation here since the question seems incredibly simple and looks a little like a trick question just to check that you're understanding the terminology and reading carefully enough to find the trick.", "aSentId": 15555, "answer": "You are correct with the answer being 11. We didn't have a full understanding of what it was asking and since the answer was so simple we just over complicated and confused ourselves. Thank you for the help!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15552, "question": "Discrete Math help?", "aSentId": 15557, "answer": "Well, the procedure is taking a list of numbers as the parameter \"a1...an\", and then analyzing each number to determine the maximum. So \"n\" is the number of numbers passed in as parameters.\n\nIn other words, how many numbers are being analyzed in that procedure call?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15558, "question": "Well, the procedure is taking a list of numbers as the parameter \"a1...an\", and then analyzing each number to determine the maximum. So \"n\" is the number of numbers passed in as parameters.\n\nIn other words, how many numbers are being analyzed in that procedure call?", "aSentId": 15559, "answer": "11", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15558, "question": "Well, the procedure is taking a list of numbers as the parameter \"a1...an\", and then analyzing each number to determine the maximum. So \"n\" is the number of numbers passed in as parameters.\n\nIn other words, how many numbers are being analyzed in that procedure call?", "aSentId": 15561, "answer": "Thank you for the help. We over complicated it and ended up confusing ourselves not realizing how easy it was.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15563, "question": "Is my understanding of pipeline forwarding correct?", "aSentId": 15564, "answer": "&gt; The general idea is that, if I have an instruction that performs arithmetic and then writes to memory, the ALU can \"keep\" the result of the operation and use it in the next pipeline cycle, rather than waiting for the memory to be written right?\n\nYes. Also works that way with registers.\n\n&gt; but if the ALU must read from memory, then we add a \"bubble\" to give the last cycle time to write to memory before the result can be sent back to the ALU.\n\nOnce you're at the point of using the ALU to compute an arithmetic instruction's result, you should already know what address its memory operand is coming from. (Otherwise, how would you get it to the ALU?) Depending on how your pipeline is set up, you may also already know the address the previous instruction is writing to. (What stage of your pipeline computes the target address?) If so, that's enough to decide whether you need to actually stall while you read from memory what the program has as a memory operand or just get it from a recent instruction via forwarding. \n\nBut really, the details of when you need to stall vs when you can forward (or when you must do some combination of both) depend on your particular pipeline. There is no universal \"an arithmetic instruction can forward its result to the next instruction\" -- even that depends on the pipeline (x86 has been spending multiple pipeline stages in a single ALU for a while now).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15565, "question": "&gt; The general idea is that, if I have an instruction that performs arithmetic and then writes to memory, the ALU can \"keep\" the result of the operation and use it in the next pipeline cycle, rather than waiting for the memory to be written right?\n\nYes. Also works that way with registers.\n\n&gt; but if the ALU must read from memory, then we add a \"bubble\" to give the last cycle time to write to memory before the result can be sent back to the ALU.\n\nOnce you're at the point of using the ALU to compute an arithmetic instruction's result, you should already know what address its memory operand is coming from. (Otherwise, how would you get it to the ALU?) Depending on how your pipeline is set up, you may also already know the address the previous instruction is writing to. (What stage of your pipeline computes the target address?) If so, that's enough to decide whether you need to actually stall while you read from memory what the program has as a memory operand or just get it from a recent instruction via forwarding. \n\nBut really, the details of when you need to stall vs when you can forward (or when you must do some combination of both) depend on your particular pipeline. There is no universal \"an arithmetic instruction can forward its result to the next instruction\" -- even that depends on the pipeline (x86 has been spending multiple pipeline stages in a single ALU for a while now).", "aSentId": 15566, "answer": "&gt;There is no universal \"an arithmetic instruction can forward its result to the next instruction\".   \n    \nThat's why I'm so confused, my textbook is implying that there is. The homework problems give me a series of MIPS instructions and nothing else, and asks me to identify hazards and add no-ops. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15567, "question": "&gt;There is no universal \"an arithmetic instruction can forward its result to the next instruction\".   \n    \nThat's why I'm so confused, my textbook is implying that there is. The homework problems give me a series of MIPS instructions and nothing else, and asks me to identify hazards and add no-ops. ", "aSentId": 15568, "answer": "The book is probably talking specifically about MIPS in some parts, probably the 5-stage (well... three and two halves, perhaps) version.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15563, "question": "Is my understanding of pipeline forwarding correct?", "aSentId": 15570, "answer": "it makes sense to me at first glance\n\nnon pipelined: time between instructions = number of stages * length of each stage (this should be obvious)\n\npipelined: time between instruction = length of a stage (you'll assume for now that each stage takes the same length until you get into more advances stuff like scoreboarding / tomasulos algorithm if im not mistaking).\n\ndo you see how number of pipe stages cancels out?\n\nto be extra clear\n\n     time between instructions = time between instruction (non-pipelined) / number of pipe stages \n     where: time between instructions (non-pipelined) = time it takes to complete one stage (usually x number of clock cycles?) * number of pipe stages \n     so substituting that back in to the original: \n     time between instructions = (time it takes to complete one stage * number of pipe stages) / number of pipe stages\n \n\nbasically with pipelining the first instruction will be in stage 1, then when it gets to stage 2 the second instruction will be in stage 2 and the first one will be in stage 1, then the third one will go to stage one, second instruction to stage two, etc... so the time it takes to get an instruction into the pipeline (in the best case) is == length of the pipeline stage. \n\nyou are correct that stalls will change this, but given a set of mips instructions you should be able to detect these data hazards and show where to insert the stalls, and how many cycles that would add.\n\n\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15572, "question": "Workshop exercises for an industry audience involving the use of SAT solvers?", "aSentId": 15573, "answer": "Throw in some planning problems and use some SAT based planners.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15572, "question": "Workshop exercises for an industry audience involving the use of SAT solvers?", "aSentId": 15575, "answer": "Register allocation is a tough problem that should encode well into SAT. I also know a much more obscure reduction of the problem of existence of LPO (an interesting order over logic expressions) into SAT, can provide the ref if needed.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15576, "question": "Register allocation is a tough problem that should encode well into SAT. I also know a much more obscure reduction of the problem of existence of LPO (an interesting order over logic expressions) into SAT, can provide the ref if needed.", "aSentId": 15577, "answer": "Also, with SMT solvers that support bitvectors, a lot of low level problems can be encoded. Not exactly SAT, but a nice extension.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15576, "question": "Register allocation is a tough problem that should encode well into SAT. I also know a much more obscure reduction of the problem of existence of LPO (an interesting order over logic expressions) into SAT, can provide the ref if needed.", "aSentId": 15579, "answer": "Graph-coloring register allocation is a fantastic example for my scenario -- thanks a lot!  I'd love to read the reference that you mention if you could dig it up.  As for propositional encoding of bit-vector transformations, the workshop later covers SMT and the Bit-Vector theory, so I'll shy away from being too copious with that type of exercise -- but a few to whet the appetite would work well.  Maybe some exercises modelling boolean conditionals from C too.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15581, "question": "Where can we find free developer swag?", "aSentId": 15582, "answer": "University career fairs. I get a lot of my gym shirts there.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15581, "question": "Where can we find free developer swag?", "aSentId": 15584, "answer": "Hackathons, university career fairs, and all sorts of places where people might want to tempt you into applying to their company.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15581, "question": "Where can we find free developer swag?", "aSentId": 15586, "answer": "Conferences and internships are good places along with those already mentioned.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15588, "question": "How do you manage research idea lists?", "aSentId": 15589, "answer": "I use [workflowy](https://workflowy.com/) and have about 1200 \"nodes\" (not all distinct ideas obviously) in my *research ideas* subtree. It's indispensable for me, and could only be improved by allowing LaTeX formatting.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15588, "question": "How do you manage research idea lists?", "aSentId": 15591, "answer": "Either with Google Keep or [this](https://snim2.wordpress.com/2014/07/02/research-diaries-and-lab-notes/). The advantage of the second option is that it is easier to turn rough notes into papers if the rough notes are already in LaTeX.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15593, "question": "So You Want to be a Game Developer? Tips for Coders", "aSentId": 15594, "answer": "I don't like how general the article is. It sounds like he wants to tell you more and expand on his points with actual advice but never does.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15596, "question": "The Ghost in the MP3", "aSentId": 15597, "answer": "TIL lossy compression loses things", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15596, "question": "The Ghost in the MP3", "aSentId": 15599, "answer": "The idea that the difference between perceptually encoded data and the source it was encoded from reveals some flaw isn't just wrong, it begs the question. That there is a difference is the entire premise of perceptual encoding. If there is any point to be made you have to start with proving that the difference is registered and significant to the human ear. And nothing in this project addresses that in any way.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15600, "question": "The idea that the difference between perceptually encoded data and the source it was encoded from reveals some flaw isn't just wrong, it begs the question. That there is a difference is the entire premise of perceptual encoding. If there is any point to be made you have to start with proving that the difference is registered and significant to the human ear. And nothing in this project addresses that in any way.", "aSentId": 15601, "answer": "I don't think this page tries to imply that the encoding is flawed in any way. Recovering data lost through lossy compression and presenting it in a form that is hearable to the user, in my opinion, makes for a fascinating art piece.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15600, "question": "The idea that the difference between perceptually encoded data and the source it was encoded from reveals some flaw isn't just wrong, it begs the question. That there is a difference is the entire premise of perceptual encoding. If there is any point to be made you have to start with proving that the difference is registered and significant to the human ear. And nothing in this project addresses that in any way.", "aSentId": 15603, "answer": "I don't think its relevant to this application whether the perceptual coding is effective or not. It is interesting in itself to hear components of sound that are considered to have no impact on the perception of a particular song. It also would be interesting to hear the presumably differeent impact of other formats such as the real audio, microsoft and apple lossy formats.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15596, "question": "The Ghost in the MP3", "aSentId": 15605, "answer": "This is an interesting exploration of how MP3's lossy compression was developed and how it's being misused in many situations nowadays.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 15608, "question": "Does soundcloud even stream audio in 320kbps?", "aSentId": 15609, "answer": "Not even close.", "corpus": "reddit"}]
