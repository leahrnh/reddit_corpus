[{"docID": "t5_2fwo","qSentId": 44404,"question": "How to encode 6 bits by flipping just 1 out of 64 random bits","aSentId": 44405,"answer": "I like to consider myself to be a relatively intelligent person.\n\nThat being said, I call this witchcraft.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44406,"question": "I like to consider myself to be a relatively intelligent person.\n\nThat being said, I call this witchcraft.","aSentId": 44407,"answer": "I like to consider myself a genius, and also I am a wizard who is great with magic and witchcraft.\n\nThis shit is still insane.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44404,"question": "How to encode 6 bits by flipping just 1 out of 64 random bits","aSentId": 44409,"answer": "This *is* sortof cheating, in that your pre-agreed parity scheme for the board counts as information.  You and your friend also need to be able to have the same orientation of the board, so if the jailer sits your friend at a different side than he sat you, you're fucked.\n\nPretty cool nonetheless.  This un-intuitive property also shows up usefully in PAR2 archives, often seen on usenet (which is historically unreliable) to transfer large files.  \n\nYou split the data up into N sections and then add an arbitrary amount of parity data, say 10%.  Now you can lose up to 10% of that data in transit due to missing files or corruption, anywhere in the set, and you'll be able to recover the missing data from what you have.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44404,"question": "How to encode 6 bits by flipping just 1 out of 64 random bits","aSentId": 44411,"answer": "That's awesome, is this sort of thing used for compression over a network?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44413,"question": "I really don't get the conclusion. My friend will not know the natural parity of the board, so how can he use XOR to find the magic square?","aSentId": 44414,"answer": "He doesn't need to know the natural parity or use xor.  You're able to leave him any number from 0 to 63, he just needs to decode it, and that's the number of the square he should pick.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44413,"question": "I really don't get the conclusion. My friend will not know the natural parity of the board, so how can he use XOR to find the magic square?","aSentId": 44416,"answer": "The entire state of the board is being used to encode the magic square. What the parity/XOR setup allows is for any encoding to be achieved by flipping only one coin, so friend doesn't have to know anything but the board state on arrival. That it's randomized is a minor detail: the computation looks trickier, but the same technique applies to an empty board.\n\n(In a practical sense, computing this correctly on both ends would be incredibly error prone, but this is mathematics world where people don't have trouble computing things, I guess.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44413,"question": "I really don't get the conclusion. My friend will not know the natural parity of the board, so how can he use XOR to find the magic square?","aSentId": 44418,"answer": "You and your friend agree on the parity patterns beforehand. That is, you both know how to read a 6-digit binary number off a chessboard.\n\nThe jailer places coins onto the chessboard. This creates the \"natural parity\" of the board. That is, it creates some 6-digit binary number A. You look at the board, look at the magic square and determine what 6-digit binary number B should be read off to point to said magic square. You then need to alter none/some/all of the six bits of A to turn it into B. Because of the pattern you and your friend agreed upon, you can change none/some/all of the 6 bits of the number by flipping one single coin.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44422,"question": "Here's a related problem: suppose that there are infinitely many gnomes, one for each integer. Each one is assigned a hat which is either black or white. Each gnome can see the color of every other gnome's hat, and based on those colors, must guess their own hat's color. If all but finitely many gnomes guess correctly, they all win.\n\nIf you make a (fairly natural) mathematical assumption, it is possible for the gnomes to agree on a strategy and win. I don't want to say what the assumption is, though, because it would give too much away.","aSentId": 44423,"answer": "Givien finite count of colors and infinite number of gnomes, then count of each color should be equal. So it is easy to see which color is missing one, which is \"my\" color.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44424,"question": "Givien finite count of colors and infinite number of gnomes, then count of each color should be equal. So it is easy to see which color is missing one, which is \"my\" color.","aSentId": 44425,"answer": "I don't think that works. Since there are infinitely many gnomes, there could be infinitely many wearing each color, in which case you can't tell which color is missing.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44424,"question": "Givien finite count of colors and infinite number of gnomes, then count of each color should be equal. So it is easy to see which color is missing one, which is \"my\" color.","aSentId": 44427,"answer": "Nice one.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44422,"question": "Here's a related problem: suppose that there are infinitely many gnomes, one for each integer. Each one is assigned a hat which is either black or white. Each gnome can see the color of every other gnome's hat, and based on those colors, must guess their own hat's color. If all but finitely many gnomes guess correctly, they all win.\n\nIf you make a (fairly natural) mathematical assumption, it is possible for the gnomes to agree on a strategy and win. I don't want to say what the assumption is, though, because it would give too much away.","aSentId": 44429,"answer": "Cue the AoC flamewar.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44422,"question": "Here's a related problem: suppose that there are infinitely many gnomes, one for each integer. Each one is assigned a hat which is either black or white. Each gnome can see the color of every other gnome's hat, and based on those colors, must guess their own hat's color. If all but finitely many gnomes guess correctly, they all win.\n\nIf you make a (fairly natural) mathematical assumption, it is possible for the gnomes to agree on a strategy and win. I don't want to say what the assumption is, though, because it would give too much away.","aSentId": 44431,"answer": "Axiom of Choice is not a fairly natural mathematical assumption, at least for the layman.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44434,"question": "Meet Walter Pitts, the Homeless Genius Who Revolutionized Artificial Intelligence","aSentId": 44435,"answer": "One of the many human stories hidden in the world of computer sciences. These pioneers were so ahead of their time it's scary. They were able to envision problems and solutions that will not be technologically feasible for another 50 years (or even today!). I think it should be part of any engineering endeavour to learn the story of your field and to recognise the genius and the madness with the insight that time always gives you.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44436,"question": "One of the many human stories hidden in the world of computer sciences. These pioneers were so ahead of their time it's scary. They were able to envision problems and solutions that will not be technologically feasible for another 50 years (or even today!). I think it should be part of any engineering endeavour to learn the story of your field and to recognise the genius and the madness with the insight that time always gives you.","aSentId": 44437,"answer": "I feel bad for them. I genuinely do. So many ideas that the hardware simply couldn't do yet.\n\nPeople so frequently complain that so much of modern programming is just recycling ideas from the 60s and 70s, and that's partially true, but I don't think it's because we lack creativity... I think it's because it took 50 years for the hardware to catch up and for us to properly try the ideas out, with enough ease that we can get a proper OODA improvement loop going on them.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44438,"question": "I feel bad for them. I genuinely do. So many ideas that the hardware simply couldn't do yet.\n\nPeople so frequently complain that so much of modern programming is just recycling ideas from the 60s and 70s, and that's partially true, but I don't think it's because we lack creativity... I think it's because it took 50 years for the hardware to catch up and for us to properly try the ideas out, with enough ease that we can get a proper OODA improvement loop going on them.","aSentId": 44439,"answer": "&gt; I think it's because it took 50 years for the hardware to catch up and for us to properly try the ideas out,\n\nYeah, once the basic principles of computer architecture were outlined, it was probably just a matter of defining the problem space to fit. You could plan out fifty lifetimes worth of problems that would remain largely out of reach until technology advanced to give computers sufficient RAM and flops to properly address them.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44438,"question": "I feel bad for them. I genuinely do. So many ideas that the hardware simply couldn't do yet.\n\nPeople so frequently complain that so much of modern programming is just recycling ideas from the 60s and 70s, and that's partially true, but I don't think it's because we lack creativity... I think it's because it took 50 years for the hardware to catch up and for us to properly try the ideas out, with enough ease that we can get a proper OODA improvement loop going on them.","aSentId": 44441,"answer": "massive portions of our advances as a species have been made by a handful of people its amazing. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44442,"question": "massive portions of our advances as a species have been made by a handful of people its amazing. ","aSentId": 44443,"answer": "This is completely false. A handful of people get the credit in popular culture. Advances are made through massive portions of trial and error.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44444,"question": "This is completely false. A handful of people get the credit in popular culture. Advances are made through massive portions of trial and error.","aSentId": 44445,"answer": "If you collect them all up, the people that were actually key in the advances are still not a lot.  More than the handful people celebrate, but in a lot of cases, it 2 or 3 people during a period of time that really advanced a given set of things.\n\nTake Newton and Leibniz away, and what do you get?  People were working on the problem of planetary motion for a really long time and they made the leap that allowed all the rest of us to be able to do it too.\n\nTake away their contributions, and all of the rest of the population of humans is back to waiting for someone to solve it.  Lots of people did work on it, and some of that work did directly contribute, and some of that work indirectly contributed by making it a societal thing that \"people did this kind of thing\", and that is crucial.\n\nStill, when it comes down to it you could probably (if you had the historic evidence) take almost every advancement made and specify maybe 10000 or so people throughout all of our history that made those advances really happen.\n\nWork that doesnt advance things still needs to happen though, and incremental improvements are always important, and there is the thing that when a breakthrough is required more resources are put into it, and negative results matter, but its still worth trying to understand where the people actually push it over the edge as being an important thing worth studying differently than all that other stuff.\n\nThis is also a division of theory and execution.  Most of the celebrated people were celebrated from their changes in theory.  Most of the uncelebrated people did all of the actual execution.  Tesla is one of the few people just celebrated for performing amazing execution of Maxwell's work.  More people should be celebrated for this, but it's hard because there usually are teams and companies obscuring the view.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44436,"question": "One of the many human stories hidden in the world of computer sciences. These pioneers were so ahead of their time it's scary. They were able to envision problems and solutions that will not be technologically feasible for another 50 years (or even today!). I think it should be part of any engineering endeavour to learn the story of your field and to recognise the genius and the madness with the insight that time always gives you.","aSentId": 44447,"answer": "I can't begin to imagine what they would be able to do with todays hardware.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44448,"question": "I can't begin to imagine what they would be able to do with todays hardware.","aSentId": 44449,"answer": "I have the theory that they will disappear in the mass. Having to learn the million details to get everything up and running in an advanced enough engineering (think of Clarke's \"magic\") could soak up all the creative energy. It's a pity. For me cars and aeroplanes are examples of this. The Wright brother's where able to build an aeroplane from 0, today we know too much. If you build one now from zero you are not contributing to the advance of anything apart from your ego ;) ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44450,"question": "I have the theory that they will disappear in the mass. Having to learn the million details to get everything up and running in an advanced enough engineering (think of Clarke's \"magic\") could soak up all the creative energy. It's a pity. For me cars and aeroplanes are examples of this. The Wright brother's where able to build an aeroplane from 0, today we know too much. If you build one now from zero you are not contributing to the advance of anything apart from your ego ;) ","aSentId": 44451,"answer": "That's the thing, though. The Wright brothers didn't invent internal combustion engines. They didn't invent cloth. They didn't invent the woodworking techniques.\n\nThey, too, stood on the shoulders of giants. We all do.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44452,"question": "That's the thing, though. The Wright brothers didn't invent internal combustion engines. They didn't invent cloth. They didn't invent the woodworking techniques.\n\nThey, too, stood on the shoulders of giants. We all do.","aSentId": 44453,"answer": "To really build an airplane from scratch you'd need to start as a feral caveman and work your way up from there.\n\n^(Not to mention inventing the universe.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44454,"question": "To really build an airplane from scratch you'd need to start as a feral caveman and work your way up from there.\n\n^(Not to mention inventing the universe.)","aSentId": 44455,"answer": "Am I the only one who would love to play a video game where you did this? Spore was so disappointing...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44454,"question": "To really build an airplane from scratch you'd need to start as a feral caveman and work your way up from there.\n\n^(Not to mention inventing the universe.)","aSentId": 44457,"answer": "And you'd have to invent whatever invented the universe.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44452,"question": "That's the thing, though. The Wright brothers didn't invent internal combustion engines. They didn't invent cloth. They didn't invent the woodworking techniques.\n\nThey, too, stood on the shoulders of giants. We all do.","aSentId": 44459,"answer": "Yes.  There was an excellent show called Connections, and Connections 2 that really delved into seemingly unrelated discoveries and inventions.  ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44460,"question": "Yes.  There was an excellent show called Connections, and Connections 2 that really delved into seemingly unrelated discoveries and inventions.  ","aSentId": 44461,"answer": "Back in the late '70s, James Burke spend a little over 2 years doing the research for the first season of Connections.  His premise was that each inventor was only able to work with what they knew at the time.  It became his passion to trace back each successive connection to link our modern day items with their vital past required technology. \n\nToday, I often come across threads in reddit that crowd-sources thousands of man-hours of research into a neat little read. - And you can search the Internet to do your own instant fact checking.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44450,"question": "I have the theory that they will disappear in the mass. Having to learn the million details to get everything up and running in an advanced enough engineering (think of Clarke's \"magic\") could soak up all the creative energy. It's a pity. For me cars and aeroplanes are examples of this. The Wright brother's where able to build an aeroplane from 0, today we know too much. If you build one now from zero you are not contributing to the advance of anything apart from your ego ;) ","aSentId": 44463,"answer": "I disagree. Genius is like light emitted from the headlight of a train going 99% the speed of light. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44434,"question": "Meet Walter Pitts, the Homeless Genius Who Revolutionized Artificial Intelligence","aSentId": 44465,"answer": "Really well written and a nice (or rather sad) story.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44466,"question": "Really well written and a nice (or rather sad) story.","aSentId": 44467,"answer": "Too bad they put it up on a page with at least one pop-up ad, so I'll never get to read it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44468,"question": "Too bad they put it up on a page with at least one pop-up ad, so I'll never get to read it.","aSentId": 44469,"answer": "There were ads on this? Thanks, Adblock.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44470,"question": "There were ads on this? Thanks, Adblock.","aSentId": 44471,"answer": "I don't think there were - I don't use adblock, and my reading experience was uninterrupted.\n\nI think /u/SlightlyMadman might just have malware.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44472,"question": "I don't think there were - I don't use adblock, and my reading experience was uninterrupted.\n\nI think /u/SlightlyMadman might just have malware.","aSentId": 44473,"answer": "There's a single ad asking you to subscribe when you first open the page, but that appears even with AdBlock and once it's closed it doesn't re-appear.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44474,"question": "There's a single ad asking you to subscribe when you first open the page, but that appears even with AdBlock and once it's closed it doesn't re-appear.","aSentId": 44475,"answer": "Oh, that - I closed it when the page loaded, then swapped to another tab before coming back to read. I'd hardly call the page \"full of pop-up ads\" based on that...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44476,"question": "Oh, that - I closed it when the page loaded, then swapped to another tab before coming back to read. I'd hardly call the page \"full of pop-up ads\" based on that...","aSentId": 44477,"answer": "That's fair. Where I see one pop-up, I assume there's more (since that's generally the case), but I'll edit my post.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44478,"question": "That's fair. Where I see one pop-up, I assume there's more (since that's generally the case), but I'll edit my post.","aSentId": 44479,"answer": "It was hardly even worthy of being called a popup. I dislike them blocking the content for the 5 seconds it takes to click off of the subscription request as much as the next guy, but it's really not that big of a deal.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44474,"question": "There's a single ad asking you to subscribe when you first open the page, but that appears even with AdBlock and once it's closed it doesn't re-appear.","aSentId": 44481,"answer": "Thanks, I didn't even read it. As soon as I see a pop-up, I close the tab.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44482,"question": "Thanks, I didn't even read it. As soon as I see a pop-up, I close the tab.","aSentId": 44483,"answer": "It wasn't a pop up, pop ups open in new windows/tabs. It was just a subscription nag for the website that hosted the article, I don't see anything wrong with that.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44482,"question": "Thanks, I didn't even read it. As soon as I see a pop-up, I close the tab.","aSentId": 44485,"answer": "I'm not trying to be pedantic, but just to help you avoid the kind of miscommunication that happened in this thread, those things are called \"modal windows\".  They take control of the window until they're closed, as opposed to pop ups which pop up an independent window (or sometimes tab).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44470,"question": "There were ads on this? Thanks, Adblock.","aSentId": 44487,"answer": "For real though. I sometimes link people to articles and get complaints about advertisements cutting right through the paragraphs.\n\nAnd I'm always like, oh shoot, never noticed thanks to uBlock","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44466,"question": "Really well written and a nice (or rather sad) story.","aSentId": 44489,"answer": "I have to go - what did he revolutionise?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44490,"question": "I have to go - what did he revolutionise?","aSentId": 44491,"answer": "Read the article later.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44434,"question": "Meet Walter Pitts, the Homeless Genius Who Revolutionized Artificial Intelligence","aSentId": 44493,"answer": "While some people have sold neural networks as a biomimetic form of computation distinct from finite state machines, finite state machines were originally developed in an attempt to abstractly answer the question \"what can a neural network compute?\".  (Kleene's notation on this topic may be easier to read than McCulloch &amp; Pitts')","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44494,"question": "While some people have sold neural networks as a biomimetic form of computation distinct from finite state machines, finite state machines were originally developed in an attempt to abstractly answer the question \"what can a neural network compute?\".  (Kleene's notation on this topic may be easier to read than McCulloch &amp; Pitts')","aSentId": 44495,"answer": "I took the same realization away from the article. Funny how these two paradigms have informed one another over the last 50 years.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44496,"question": "I took the same realization away from the article. Funny how these two paradigms have informed one another over the last 50 years.","aSentId": 44497,"answer": "This article seems to highlight that genius and insanity are not mutually exclusive.\n\nThese guys had amazingly out there thoughts, and amazingly capable minds.  Their talents were fueled by their insanity, but it almost seems to burn them out when they get so far.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44499,"question": "1. What an amazing read.\n2. The excerpts of the letters among the players are also amazing reads on their own. No one writes so elegantly anymore.","aSentId": 44500,"answer": "[Well, some do.](http://stevenpinker.com/publications/sense-style-thinking-persons-guide-writing-21st-century)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44503,"question": "Coming away from this article, I feel very angry about Margaret Weiner. What a bitch. :/","aSentId": 44504,"answer": "Sounds like the side effect of a woman who wanted to spend more time with her husband. Strong argument for more grad assistants. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44505,"question": "Sounds like the side effect of a woman who wanted to spend more time with her husband. Strong argument for more grad assistants. ","aSentId": 44506,"answer": "That is an utterly terrible defense of her actions. It's a strong argument for not being a deplorable liar, and that's about it. She ruined Pitts's life.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44507,"question": "That is an utterly terrible defense of her actions. It's a strong argument for not being a deplorable liar, and that's about it. She ruined Pitts's life.","aSentId": 44508,"answer": "Not defending at *all*. I cried when I read how Walter Pitts died. Just saying that's probably why it happened, and wouldn't it be nice if professors had enough grad assistants so they could spend some time at home with the fam. Lord knows there is a huge supply of grad students who need tuition assistance and research experience. Sounds like a win-win to me.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44509,"question": "Not defending at *all*. I cried when I read how Walter Pitts died. Just saying that's probably why it happened, and wouldn't it be nice if professors had enough grad assistants so they could spend some time at home with the fam. Lord knows there is a huge supply of grad students who need tuition assistance and research experience. Sounds like a win-win to me.","aSentId": 44510,"answer": "I just disagree with the logical leap you're making. She disapproved of behavior for *moral* reasons, and made up a lie to get those supposedly bad influences out of her (and her husband's) life, and your deduction is, \"She just wanted more time with her husband because graduate studies take up all of your time.\"\n\nI don't think it had *anything* to do with wanting more time with her husband and much more to do with her being an uptight conservative who thought the ends justified the means.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44511,"question": "I just disagree with the logical leap you're making. She disapproved of behavior for *moral* reasons, and made up a lie to get those supposedly bad influences out of her (and her husband's) life, and your deduction is, \"She just wanted more time with her husband because graduate studies take up all of your time.\"\n\nI don't think it had *anything* to do with wanting more time with her husband and much more to do with her being an uptight conservative who thought the ends justified the means.","aSentId": 44512,"answer": "That's fair. \n\nI just happen to know a few college professors, and I can see how their workload (especially in this particular case) may cause a strain in their relationship at home, and over the years, strain becomes jealousy, jealousy becomes rage, and what you're left with is a woman who would rather destroy the relationship that her husband has with someone he probably likes more than her than come to terms with the fact that maybe marriage to this guy isn't in her best interest. I used the words 'side-effect', but perhaps the better word would have been 'result'. \n\nNot to be patronizing, but you have to remember it was a toooootally different time socially, and I can tell you from talking with my grandparents, who were hitting their social peak right around the time all this was going down, divorce simply was not done. Taboo to the point of maintaining loveless marriages like the one that ended up costing us all of Walter Pitts' dissertation work, not to mention ruining what was certainly the meaningful and productive friendship between two colleagues, as well as the eventual death of Dr. Pitts. Only if a partner was unfaithful or if the man became abusive was divorce considered appropriate, and even then it was frowned upon. There was no such language as 'irreconcilable differences'. And it fucking made people crazy, as I am saying happened in this case. \n\nI can see your point, certainly, but I feel it's a little ignorant of the circumstances to say that wanting more time with her husband was not something that led to her discontent and eventual lie. You use the words 'uptight conservative' to explain away her behavior, but aren't you being dismissive by doing so? Aren't you generalizing to the point of absurdity to pin her actions purely on that aspect of her personality? You don't think not him being there (and probably some kind of jealousy by proxy of the closeness with his colleague) had *anything* to do with it?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44513,"question": "That's fair. \n\nI just happen to know a few college professors, and I can see how their workload (especially in this particular case) may cause a strain in their relationship at home, and over the years, strain becomes jealousy, jealousy becomes rage, and what you're left with is a woman who would rather destroy the relationship that her husband has with someone he probably likes more than her than come to terms with the fact that maybe marriage to this guy isn't in her best interest. I used the words 'side-effect', but perhaps the better word would have been 'result'. \n\nNot to be patronizing, but you have to remember it was a toooootally different time socially, and I can tell you from talking with my grandparents, who were hitting their social peak right around the time all this was going down, divorce simply was not done. Taboo to the point of maintaining loveless marriages like the one that ended up costing us all of Walter Pitts' dissertation work, not to mention ruining what was certainly the meaningful and productive friendship between two colleagues, as well as the eventual death of Dr. Pitts. Only if a partner was unfaithful or if the man became abusive was divorce considered appropriate, and even then it was frowned upon. There was no such language as 'irreconcilable differences'. And it fucking made people crazy, as I am saying happened in this case. \n\nI can see your point, certainly, but I feel it's a little ignorant of the circumstances to say that wanting more time with her husband was not something that led to her discontent and eventual lie. You use the words 'uptight conservative' to explain away her behavior, but aren't you being dismissive by doing so? Aren't you generalizing to the point of absurdity to pin her actions purely on that aspect of her personality? You don't think not him being there (and probably some kind of jealousy by proxy of the closeness with his colleague) had *anything* to do with it?","aSentId": 44514,"answer": "Appropriate username.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44509,"question": "Not defending at *all*. I cried when I read how Walter Pitts died. Just saying that's probably why it happened, and wouldn't it be nice if professors had enough grad assistants so they could spend some time at home with the fam. Lord knows there is a huge supply of grad students who need tuition assistance and research experience. Sounds like a win-win to me.","aSentId": 44516,"answer": "Too bad graduate level education is a scam and a hazing ritual.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44509,"question": "Not defending at *all*. I cried when I read how Walter Pitts died. Just saying that's probably why it happened, and wouldn't it be nice if professors had enough grad assistants so they could spend some time at home with the fam. Lord knows there is a huge supply of grad students who need tuition assistance and research experience. Sounds like a win-win to me.","aSentId": 44518,"answer": "On the other hand, the use of grad students to relieve the burden of their PI is why PhDs are taking longer and longer.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44505,"question": "Sounds like the side effect of a woman who wanted to spend more time with her husband. Strong argument for more grad assistants. ","aSentId": 44520,"answer": "Good argument. Plus, in her defense (I like to play devils' advocate, ESPECIALLY when it feels difficult), there was probably just less available/allowed in general for women living then to occupy their time, other than \"quality time with hubby\". If she felt her role at the time was one of the few available to her, she would probably be resentful about it being taken away or hindered. She may also not have had many friends herself, and was likely jealous of her husband's outgoing-ness or success. Again, not much of an excuse, but it's a human weakness that can lead to certain negative behaviors.\n\nBut still... That was a mean, low-down, rotten thing to do, on her part. Not the most constructive solution, but brutally effective... at the cost of untold discoveries, and some livelihood of others... who died having had no idea.\n\nYou kind of start to wonder how often something like that actually happens. One day the shit hits the fan real bad, and you go to the grave having *no idea* it was all engineered by some jealous bitch who was hell-bent on schadenfreude.\n\nIf this was my wife, and I found out BEFORE I died... man. I think I'd have to divorce her. Ruined my joyous friendships with a lie which I believed without question, just so I would rely on her more... It's so evilly human. It's like that nurse who made patients sick in the hospital and then \"saved\" them, just for the attention...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44521,"question": "Good argument. Plus, in her defense (I like to play devils' advocate, ESPECIALLY when it feels difficult), there was probably just less available/allowed in general for women living then to occupy their time, other than \"quality time with hubby\". If she felt her role at the time was one of the few available to her, she would probably be resentful about it being taken away or hindered. She may also not have had many friends herself, and was likely jealous of her husband's outgoing-ness or success. Again, not much of an excuse, but it's a human weakness that can lead to certain negative behaviors.\n\nBut still... That was a mean, low-down, rotten thing to do, on her part. Not the most constructive solution, but brutally effective... at the cost of untold discoveries, and some livelihood of others... who died having had no idea.\n\nYou kind of start to wonder how often something like that actually happens. One day the shit hits the fan real bad, and you go to the grave having *no idea* it was all engineered by some jealous bitch who was hell-bent on schadenfreude.\n\nIf this was my wife, and I found out BEFORE I died... man. I think I'd have to divorce her. Ruined my joyous friendships with a lie which I believed without question, just so I would rely on her more... It's so evilly human. It's like that nurse who made patients sick in the hospital and then \"saved\" them, just for the attention...","aSentId": 44522,"answer": "Or, you know, maybe she wasn't lying?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44503,"question": "Coming away from this article, I feel very angry about Margaret Weiner. What a bitch. :/","aSentId": 44524,"answer": "Women: \"...something far worse than that: It defied logic.\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44525,"question": "Women: \"...something far worse than that: It defied logic.\"","aSentId": 44526,"answer": "oh, gratuitous misogyny\n\ncool","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44528,"question": "More \"invented\" than recolutionized.","aSentId": 44529,"answer": "&gt; recolutionized\n\neven Pitts couldn't manage that word...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44531,"question": "Mother of God! This would make for an awesome movie! \nCumberbatch might accept a challenge?! \ud83d\ude2e ","aSentId": 44532,"answer": "Parts of it ring of Good Will Hunting.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44533,"question": "Parts of it ring of Good Will Hunting.","aSentId": 44534,"answer": "I wonder if it was modeled off that actually. The similarities are disturbing. Pitt's main professor friend was mostly a psychologist at some random college, and his MIT professor/advisor was a top mathematician. And Pitt's background and drinking.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44531,"question": "Mother of God! This would make for an awesome movie! \nCumberbatch might accept a challenge?! \ud83d\ude2e ","aSentId": 44536,"answer": "agreed, would see 10/10","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44543,"question": "Living in a home with friends isn't homeless.","aSentId": 44544,"answer": "What are you talking about? It clearly says he was homeless from fifteen to eighteen. And even after he was taken in, if you're taken into a home that you otherwise have no claim to and if you were turned out you'd have nowhere else to go, I've got news for you, that's still homelessness. You don't have to be sleeping in a cardboard box to be homeless.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44543,"question": "Living in a home with friends isn't homeless.","aSentId": 44546,"answer": "If my math is correct, he ran away to Chicago 3 years before he moved in with McCulloch.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44549,"question": "Hi Walter","aSentId": 44550,"answer": "I kekked ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44552,"question": "[r/ProgrammingTools] New subreddit where programmers can share tools, apps or websites they use to make their programming lives easier.","aSentId": 44553,"answer": "This seems like a good idea :)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44552,"question": "[r/ProgrammingTools] New subreddit where programmers can share tools, apps or websites they use to make their programming lives easier.","aSentId": 44555,"answer": "This is awesome... Let's get this to blow up!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44552,"question": "[r/ProgrammingTools] New subreddit where programmers can share tools, apps or websites they use to make their programming lives easier.","aSentId": 44557,"answer": "Is there a similar thing for libraries maybe?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44561,"question": "Apple's libc shells out to Perl to implement wordexp","aSentId": 44562,"answer": "Whyyyy","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44563,"question": "Whyyyy","aSentId": 44564,"answer": "I'm pretty sure a lot of thought must have gone into making this decision. ;)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44565,"question": "I'm pretty sure a lot of thought must have gone into making this decision. ;)","aSentId": 44566,"answer": "What, like *\"Ah fuck it, we'll do it live!\"* ?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44563,"question": "Whyyyy","aSentId": 44568,"answer": "Because it's a function nobody uses (or *should* use) and there's no point spending much time on implementing it if there is a quicker trick you can use instead.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44561,"question": "Apple's libc shells out to Perl to implement wordexp","aSentId": 44570,"answer": "I'm not exactly sure I know what the problem is...  Maybe I'm missing something but it doesn't have to be fast and it is explicitly not secure (which is also explained in the comments). Is it so in other libcs?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44572,"question": "Using Eigenfaces and StanfordNLP, built a program that fully automates Tinder","aSentId": 44573,"answer": "Quite nice work. Eigenfaces have long intrigued me but i can't ever think of a good use for them.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44572,"question": "Using Eigenfaces and StanfordNLP, built a program that fully automates Tinder","aSentId": 44575,"answer": "Although there's a link in the post, here's a shortcut to the Github: https://github.com/crockpotveggies/tinderbox.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44572,"question": "Using Eigenfaces and StanfordNLP, built a program that fully automates Tinder","aSentId": 44577,"answer": "Reminds me of [High Frequency Dating](http://robrhinehart.com/?p=1005). I though it was satire back then :)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44579,"question": "Snake, implemented using only C++ templates","aSentId": 44580,"answer": "&gt; Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44581,"question": "&gt; Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.","aSentId": 44582,"answer": "&gt; Including Common Lisp","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44581,"question": "&gt; Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.","aSentId": 44584,"answer": "Does it count if we did it on purpose in my program? (Technically we actually implemented a bug-ridden slow implementation of Scheme ...)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44585,"question": "Does it count if we did it on purpose in my program? (Technically we actually implemented a bug-ridden slow implementation of Scheme ...)","aSentId": 44586,"answer": "No love for guile? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44587,"question": "No love for guile? ","aSentId": 44588,"answer": "Even better, we HAVE embedded guile as well at this point. (Years ago at this point.) And to add insult to injury, we had a project to make it into a web app (it's a \"green screen\" type app except the servers are actually Windows.) and as part of that we used Chicken and we have an easter egg on the site that runs a javascript version of Conway's Game of Life.\n\nWe are pretty sure one day the application will lead the robot revolution.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44589,"question": "Even better, we HAVE embedded guile as well at this point. (Years ago at this point.) And to add insult to injury, we had a project to make it into a web app (it's a \"green screen\" type app except the servers are actually Windows.) and as part of that we used Chicken and we have an easter egg on the site that runs a javascript version of Conway's Game of Life.\n\nWe are pretty sure one day the application will lead the robot revolution.","aSentId": 44590,"answer": "I for one welcome our new robot overlords. Cool stuff.  I wish I could convince anyone I knew ever to even take an interest in lisp. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44579,"question": "Snake, implemented using only C++ templates","aSentId": 44592,"answer": "What just happened?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44579,"question": "Snake, implemented using only C++ templates","aSentId": 44594,"answer": "This is a good example of when monospace should be used","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44596,"question": "Ok, serious question:\n\nIs it possible to debug code like this in a sensible way?","aSentId": 44597,"answer": "It's not possible to write code like this in a coherent way so I'm going to go with no.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44596,"question": "Ok, serious question:\n\nIs it possible to debug code like this in a sensible way?","aSentId": 44599,"answer": "Template errors from compilers generally produce a stack trace for you (i.e. the failed template expansion). Learning how to read all that gobbldy-gook, however, is a skill you have to refine.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44600,"question": "Template errors from compilers generally produce a stack trace for you (i.e. the failed template expansion). Learning how to read all that gobbldy-gook, however, is a skill you have to refine.","aSentId": 44601,"answer": "Still, I find it very annoying to debug errors in template magic even for real-world applications. Don't want to imagine how hard it would be to find an error in this kind of code.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44600,"question": "Template errors from compilers generally produce a stack trace for you (i.e. the failed template expansion). Learning how to read all that gobbldy-gook, however, is a skill you have to refine.","aSentId": 44603,"answer": "Compilers have gotten better at this and continue to do so!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44605,"question": "Not sure if it's worth the effort (I would rewrite it from scratch) but this is my C implementation of several years ago: \n\nhttps://github.com/clamiax/misc/blobmaster/worm.c\n","aSentId": 44606,"answer": "&gt; blobmaster\n\nBEHOLD","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44605,"question": "Not sure if it's worth the effort (I would rewrite it from scratch) but this is my C implementation of several years ago: \n\nhttps://github.com/clamiax/misc/blobmaster/worm.c\n","aSentId": 44608,"answer": "You might want to double check that URL. 404 error.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44609,"question": "You might want to double check that URL. 404 error.","aSentId": 44610,"answer": "Here's a working URL.\nhttps://github.com/clamiax/misc/blob/master/worm.c","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44611,"question": "Here's a working URL.\nhttps://github.com/clamiax/misc/blob/master/worm.c","aSentId": 44612,"answer": "Yes, thank you.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44609,"question": "You might want to double check that URL. 404 error.","aSentId": 44614,"answer": "Not sure how it has happened (since I copy-pasted the URI). Thanks!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44615,"question": "Not sure how it has happened (since I copy-pasted the URI). Thanks!","aSentId": 44616,"answer": "Github uses history pushing so they may have put the wrong URL into the history.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44619,"question": "There are so many reasons not to use templates unless you really must.","aSentId": 44620,"answer": "Agreed. But still, it's impressive what you can do with it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44621,"question": "Agreed. But still, it's impressive what you can do with it.","aSentId": 44622,"answer": "Yeah, TMP is pretty fun as a spectacle, but I liken it to something like an obfuscated code competition :)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44619,"question": "There are so many reasons not to use templates unless you really must.","aSentId": 44624,"answer": "On the flip side -- I'd claim templates (especially the STL collections) are the single biggest advantage C++ has over C.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44625,"question": "On the flip side -- I'd claim templates (especially the STL collections) are the single biggest advantage C++ has over C.","aSentId": 44626,"answer": "It's a tough call for me between templates and namespaces. And RAII.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44627,"question": "It's a tough call for me between templates and namespaces. And RAII.","aSentId": 44628,"answer": "I'm also a fan of operator overloading -- when used sensibly. I agree that it's not *as big* an advantage as some of the others, though.  \nStill, being able to use + to add vectors or bigint classes, using shared_ptr/unique_ptr and similar using the regular \\* and -&gt; operators, using == to compare strings (and just about everything else), etc. is very nice.\n\nHeck, the fact that [] can be overloaded and combined with initializer lists to make this:\n\n\tstd::map&lt;std::vector&lt;std::string&gt;, std::string&gt; map;\n\tmap[{\"1\", \"2\"}] = \"Hello\";\n\nvalid is pretty amazing compared to how something like that would look in C (after you've found or written a library for the required types).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44629,"question": "I'm also a fan of operator overloading -- when used sensibly. I agree that it's not *as big* an advantage as some of the others, though.  \nStill, being able to use + to add vectors or bigint classes, using shared_ptr/unique_ptr and similar using the regular \\* and -&gt; operators, using == to compare strings (and just about everything else), etc. is very nice.\n\nHeck, the fact that [] can be overloaded and combined with initializer lists to make this:\n\n\tstd::map&lt;std::vector&lt;std::string&gt;, std::string&gt; map;\n\tmap[{\"1\", \"2\"}] = \"Hello\";\n\nvalid is pretty amazing compared to how something like that would look in C (after you've found or written a library for the required types).","aSentId": 44630,"answer": "I agree, I didn't even think of that.\n\nSome people say that operator overloading makes C++ harder to read, but I'd always rather read less code.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44629,"question": "I'm also a fan of operator overloading -- when used sensibly. I agree that it's not *as big* an advantage as some of the others, though.  \nStill, being able to use + to add vectors or bigint classes, using shared_ptr/unique_ptr and similar using the regular \\* and -&gt; operators, using == to compare strings (and just about everything else), etc. is very nice.\n\nHeck, the fact that [] can be overloaded and combined with initializer lists to make this:\n\n\tstd::map&lt;std::vector&lt;std::string&gt;, std::string&gt; map;\n\tmap[{\"1\", \"2\"}] = \"Hello\";\n\nvalid is pretty amazing compared to how something like that would look in C (after you've found or written a library for the required types).","aSentId": 44632,"answer": "Boost spirit is a brilliant bastardization of operator overloading","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44627,"question": "It's a tough call for me between templates and namespaces. And RAII.","aSentId": 44634,"answer": "Namespaces are pretty unimportant. They're good, in many ways, but they only really become useful when combined with other parts of C++. There's little that adding namespaces to C would add that you can't get with the underscore character.\n\nBut RAII? Templates? Operator overloading? They're all great. Particularly RAII. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44625,"question": "On the flip side -- I'd claim templates (especially the STL collections) are the single biggest advantage C++ has over C.","aSentId": 44636,"answer": "Templates seem, to me, like mostly just a set of hacks which really didn't work.\n\nThey are useful, but here's what essentially happened: the standards writers wanted a way to do some relatively simple things, but accidentally ended up making a 100% turing complete language by accident, within C++'s specs itself.\n\nIt's just stepping over the bounds. At this point, it would've made more sense if they just had a keyword to automatically run any normal C++ code at compile time.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44637,"question": "Templates seem, to me, like mostly just a set of hacks which really didn't work.\n\nThey are useful, but here's what essentially happened: the standards writers wanted a way to do some relatively simple things, but accidentally ended up making a 100% turing complete language by accident, within C++'s specs itself.\n\nIt's just stepping over the bounds. At this point, it would've made more sense if they just had a keyword to automatically run any normal C++ code at compile time.","aSentId": 44638,"answer": "&gt;At this point, it would've made more sense if they just had a keyword to automatically run any normal C++ code at compile time.\n\nconstexpr? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44639,"question": "&gt;At this point, it would've made more sense if they just had a keyword to automatically run any normal C++ code at compile time.\n\nconstexpr? ","aSentId": 44640,"answer": "&gt; constexpr\n\nYes - but that was only added in C++11, far after templates. I'm talking about the past tense.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44637,"question": "Templates seem, to me, like mostly just a set of hacks which really didn't work.\n\nThey are useful, but here's what essentially happened: the standards writers wanted a way to do some relatively simple things, but accidentally ended up making a 100% turing complete language by accident, within C++'s specs itself.\n\nIt's just stepping over the bounds. At this point, it would've made more sense if they just had a keyword to automatically run any normal C++ code at compile time.","aSentId": 44642,"answer": "\"turing complete\" is so easy to obtainm that it is actually hard not to fulfill it with only a subset of any programming language","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44643,"question": "\"turing complete\" is so easy to obtainm that it is actually hard not to fulfill it with only a subset of any programming language","aSentId": 44644,"answer": "As a security consideration, it's usually worth it to make that effort. Plenty of things don't need to be Turing-complete.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44643,"question": "\"turing complete\" is so easy to obtainm that it is actually hard not to fulfill it with only a subset of any programming language","aSentId": 44646,"answer": "Turing completeness *at compile time* is hard to obtain.  Example: C isn't Turing complete at compile time.\n\nA programming language that isn't Turing complete *at run time* arguably isn't a programming language at all.  And yes, with runtime TCness, you can often shed most of the language without losing TCness.  I've heard that a language consisting only of a single \"Decrement accumulator and branch if zero\" instruction is Turing complete.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44637,"question": "Templates seem, to me, like mostly just a set of hacks which really didn't work.\n\nThey are useful, but here's what essentially happened: the standards writers wanted a way to do some relatively simple things, but accidentally ended up making a 100% turing complete language by accident, within C++'s specs itself.\n\nIt's just stepping over the bounds. At this point, it would've made more sense if they just had a keyword to automatically run any normal C++ code at compile time.","aSentId": 44648,"answer": "If you understand the runtime performance implications that templates allow for, you would understand.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44649,"question": "If you understand the runtime performance implications that templates allow for, you would understand.","aSentId": 44650,"answer": "When I first learned about things like lazy evaluation and curiously recurring templates, I was blown away, and committed myself to learning how to use templates competently.\n\nI'm no master of templates yet, but every time I find myself itching to copy/paste a chunk of code from somewhere else in the source and just change around a couple of class types, I stop myself and I create a templated function to use in both places. It improves maintainability since changes only have to be made to the single templated function, and I have more motivation to carefully document that templated function because it's responsible for a significant workload with how often it'll get reused. Code quality improvements all around!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44651,"question": "When I first learned about things like lazy evaluation and curiously recurring templates, I was blown away, and committed myself to learning how to use templates competently.\n\nI'm no master of templates yet, but every time I find myself itching to copy/paste a chunk of code from somewhere else in the source and just change around a couple of class types, I stop myself and I create a templated function to use in both places. It improves maintainability since changes only have to be made to the single templated function, and I have more motivation to carefully document that templated function because it's responsible for a significant workload with how often it'll get reused. Code quality improvements all around!","aSentId": 44652,"answer": "The only thing I still want from templates is to not have to implement the templated functions in the headers.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44653,"question": "The only thing I still want from templates is to not have to implement the templated functions in the headers.","aSentId": 44654,"answer": "You can always write the implementation in a .impl file,  which you then include in the header. Not perfect, but it does separate interface and implementation on a source code level","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44655,"question": "You can always write the implementation in a .impl file,  which you then include in the header. Not perfect, but it does separate interface and implementation on a source code level","aSentId": 44656,"answer": "It still exposes the implementation.  ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44653,"question": "The only thing I still want from templates is to not have to implement the templated functions in the headers.","aSentId": 44658,"answer": "You read my mind! Having them on the headers eases a lot the making of spaghetti code. Too bad very few notice this problem since many don't care about clean headers, even more, they expose too much implementation details.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44660,"question": "The beauty of C++ is that it offers a million different options, but forces you to use none.","aSentId": 44661,"answer": "\"beauty\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44662,"question": "\"beauty\"","aSentId": 44663,"answer": "It's like bitching about Home Depot having so many different tools available, even though you only go there to buy a few tools. This reminds me of at the steel mill I work at, where we have a set of electricians tools that are used for 95% of the jobs we work on, yet maybe once every few months we pull out a very specific tool that is superior for the job we have for it. The C++ standard and the STL are the same way; they offer many tools and features that are available for certain, but not all, jobs. No one forces you to use them.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44665,"question": "There's that, and it also blows your code cache when you go template-happy.","aSentId": 44666,"answer": "It doesn't blow it anymore than the alternative.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44667,"question": "It doesn't blow it anymore than the alternative.","aSentId": 44668,"answer": "Sure it does. Do a template instantiated with 2 different types and you'll get 2x the code generated.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44669,"question": "Sure it does. Do a template instantiated with 2 different types and you'll get 2x the code generated.","aSentId": 44670,"answer": "This is false, the following template instantiated with two different types will not produce 2x the generated code:\n\n    template&lt;typename T&gt;\n    bool Compare(const T* lhs, const T* rhs) {\n      return lhs &lt; rhs;\n    }\n\nAll the well known C++ compilers including MSVC, GCC, Clang, ICC, Solaris so on so forth... produce code for one instantiation and reuse that code for every type.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44671,"question": "This is false, the following template instantiated with two different types will not produce 2x the generated code:\n\n    template&lt;typename T&gt;\n    bool Compare(const T* lhs, const T* rhs) {\n      return lhs &lt; rhs;\n    }\n\nAll the well known C++ compilers including MSVC, GCC, Clang, ICC, Solaris so on so forth... produce code for one instantiation and reuse that code for every type.","aSentId": 44672,"answer": "That's a fairly simplistic example, as it is a good candidate for inlining. Use a template with multiple call sites and a large enough body, and you'll get code bloat.\n\nThe most obvious example of this is the STL container types (e.g. vector, list, etc). ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44673,"question": "That's a fairly simplistic example, as it is a good candidate for inlining. Use a template with multiple call sites and a large enough body, and you'll get code bloat.\n\nThe most obvious example of this is the STL container types (e.g. vector, list, etc). ","aSentId": 44674,"answer": "It's not simplistic, it's simple, there is a difference.  It's meant to be a simple example to clearly and demonstrably establish that your original statement is factually incorrect.\n\nYou mention STL containers, consider that what I posted generalizes to such containers so that the following instantiations reuse the **exact** same code:\n\n    std::vector&lt;A*&gt;\n    std::vector&lt;B*&gt;\n    std::vector&lt;C*&gt;\n    ...\n\nDespite the simplicity, this is nevertheless a common use case for std::vector.  It's true that the following instantiations will produce slightly different code:\n\n    std::vector&lt;A&gt;\n    std::vector&lt;B&gt;\n    std::vector&lt;C&gt;\n\nBut it won't be 3x the code because a lot of the code in vector&lt;A&gt; can be reused by vector&lt;B&gt; and vector&lt;C&gt;.\n\nAnd even with respect to where they differ, my original point was that it doesn't result in anymore code bloat than the alternative, meaning that manually writing a vector/list for a class of type A and then a separate one for a class of type B and a class for type C does not result in less code-bloat than just using an std::vector.\n\nIn other words if you need a vector for classes of type A, B and C, it's not like you're doing yourself any favors in terms of code bloat by writing it out manually:\n\n    HandWrittenVectorA ...\n    HandWrittenVectorB ...\n    ...\n\nYou may as well stick to std::vector.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44675,"question": "It's not simplistic, it's simple, there is a difference.  It's meant to be a simple example to clearly and demonstrably establish that your original statement is factually incorrect.\n\nYou mention STL containers, consider that what I posted generalizes to such containers so that the following instantiations reuse the **exact** same code:\n\n    std::vector&lt;A*&gt;\n    std::vector&lt;B*&gt;\n    std::vector&lt;C*&gt;\n    ...\n\nDespite the simplicity, this is nevertheless a common use case for std::vector.  It's true that the following instantiations will produce slightly different code:\n\n    std::vector&lt;A&gt;\n    std::vector&lt;B&gt;\n    std::vector&lt;C&gt;\n\nBut it won't be 3x the code because a lot of the code in vector&lt;A&gt; can be reused by vector&lt;B&gt; and vector&lt;C&gt;.\n\nAnd even with respect to where they differ, my original point was that it doesn't result in anymore code bloat than the alternative, meaning that manually writing a vector/list for a class of type A and then a separate one for a class of type B and a class for type C does not result in less code-bloat than just using an std::vector.\n\nIn other words if you need a vector for classes of type A, B and C, it's not like you're doing yourself any favors in terms of code bloat by writing it out manually:\n\n    HandWrittenVectorA ...\n    HandWrittenVectorB ...\n    ...\n\nYou may as well stick to std::vector.","aSentId": 44676,"answer": "Well, that's sort of my point.\n\nTemplates are designed such that it's easy to create classes/functions that work with arbitrary types (e.g. a vector of shorts, versus a vector of pointers). If you're going to use the same type in each template instantiation then you're totally right, there's no code bloat. But you're also not taking using templates for what they're designed for: easily working with *disparate* types.\n\nIf you're just going to use one type in your instantiation of the template, then why bother with templates at all?\n\nI don't believe your \"code in vector&lt;A&gt; can be reused by vector&lt;B&gt;\" argument either, because the moment you introduce a different type, the code doubles. For example:\n\n    #include &lt;cstdint&gt;\n    #include &lt;vector&gt;\n    \n    int foo(std::vector&lt;uint32_t&gt; &amp;vec, uint32_t x)\n    {\n        vec.push_back(x);\n    }\n\n    int bar(std::vector&lt;int32_t&gt; &amp;vec, int32_t x)\n    {\n        vec.push_back(x);\n    }\n    \n    int main(int argc, char **argv)\n    {\n        std::vector&lt;uint32_t&gt; u32_test;\n        std::vector&lt;int32_t&gt; i32_test;\n        foo(u32_test, 1);\n        bar(i32_test, 2);\n        return 0;\n    }\n\nThis generates: http://pastebin.ca/2922332\n\nWhat code was reused between std::vector&lt;int32_t&gt; and std::vector&lt;uint32_t&gt;? The signatures don't match, so it won't share any code between them.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44677,"question": "Well, that's sort of my point.\n\nTemplates are designed such that it's easy to create classes/functions that work with arbitrary types (e.g. a vector of shorts, versus a vector of pointers). If you're going to use the same type in each template instantiation then you're totally right, there's no code bloat. But you're also not taking using templates for what they're designed for: easily working with *disparate* types.\n\nIf you're just going to use one type in your instantiation of the template, then why bother with templates at all?\n\nI don't believe your \"code in vector&lt;A&gt; can be reused by vector&lt;B&gt;\" argument either, because the moment you introduce a different type, the code doubles. For example:\n\n    #include &lt;cstdint&gt;\n    #include &lt;vector&gt;\n    \n    int foo(std::vector&lt;uint32_t&gt; &amp;vec, uint32_t x)\n    {\n        vec.push_back(x);\n    }\n\n    int bar(std::vector&lt;int32_t&gt; &amp;vec, int32_t x)\n    {\n        vec.push_back(x);\n    }\n    \n    int main(int argc, char **argv)\n    {\n        std::vector&lt;uint32_t&gt; u32_test;\n        std::vector&lt;int32_t&gt; i32_test;\n        foo(u32_test, 1);\n        bar(i32_test, 2);\n        return 0;\n    }\n\nThis generates: http://pastebin.ca/2922332\n\nWhat code was reused between std::vector&lt;int32_t&gt; and std::vector&lt;uint32_t&gt;? The signatures don't match, so it won't share any code between them.","aSentId": 44678,"answer": "&gt; Well, that's sort of my point.\n\nYour point was that using templates results in code bloat, my point is that a common optimization used on templates is to fold multiple function templates whose instructions are identical together into one single function, so that the only code bloat produced by templates is the same kind of code bloat you'd see if you wrote things out manually.\n\n&gt; If you're just going to use one type in your instantiation of the template, then why bother with templates at all?\n\nFor type safety.\n\n    std::vector&lt;A*&gt; vA;\n    std::vector&lt;B*&gt; vB;\n\nOnly objects of type A* may go into vA, and only objects of type B* may go into vB.  Despite those two vectors producing identical instructions, I still wish to use templates to ensure type safety.\n\n&gt;I don't believe your \"code in vector&lt;A&gt; can be reused by vector&lt;B&gt;\" argument either, because the moment you introduce a different type, the code doubles.\n\nJust testing the generated code in MSVC, several methods get reused between vector&lt;A&gt; and vector&lt;B&gt; including begin(), end(), front(), back(), swap(), data() and several others.  In fact in the case of std::vector&lt;uint32_t&gt; and std::vector&lt;int32_t&gt;, MSVC also reuses a great deal more including clear(), erase() and other member functions.  This is likely because uint32_t and int32_t have the same size, and are POD types, so they can share the same code for deallocation.\n\nThe reason why the code generated in your pastebin gives the impression of distinct functions is because the stripping of functions whose instructions are identical is done at the linking phase.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44679,"question": "&gt; Well, that's sort of my point.\n\nYour point was that using templates results in code bloat, my point is that a common optimization used on templates is to fold multiple function templates whose instructions are identical together into one single function, so that the only code bloat produced by templates is the same kind of code bloat you'd see if you wrote things out manually.\n\n&gt; If you're just going to use one type in your instantiation of the template, then why bother with templates at all?\n\nFor type safety.\n\n    std::vector&lt;A*&gt; vA;\n    std::vector&lt;B*&gt; vB;\n\nOnly objects of type A* may go into vA, and only objects of type B* may go into vB.  Despite those two vectors producing identical instructions, I still wish to use templates to ensure type safety.\n\n&gt;I don't believe your \"code in vector&lt;A&gt; can be reused by vector&lt;B&gt;\" argument either, because the moment you introduce a different type, the code doubles.\n\nJust testing the generated code in MSVC, several methods get reused between vector&lt;A&gt; and vector&lt;B&gt; including begin(), end(), front(), back(), swap(), data() and several others.  In fact in the case of std::vector&lt;uint32_t&gt; and std::vector&lt;int32_t&gt;, MSVC also reuses a great deal more including clear(), erase() and other member functions.  This is likely because uint32_t and int32_t have the same size, and are POD types, so they can share the same code for deallocation.\n\nThe reason why the code generated in your pastebin gives the impression of distinct functions is because the stripping of functions whose instructions are identical is done at the linking phase.","aSentId": 44680,"answer": "Fair point about linking, although I did still get duplication even with a linked binary: http://pastebin.ca/2922987\n\nNote the duplication of code between:\n\n    00000000004008e0 &lt;void std::vector&lt;unsigned int, std::allocator&lt;unsigned int&gt; &gt;::_M_emplace_back_aux&lt;unsigned int const&amp;&gt;(unsigned int const&amp;)&gt;:\n\nand\n\n    00000000004009d0 &lt;void std::vector&lt;int, std::allocator&lt;int&gt; &gt;::_M_emplace_back_aux&lt;int const&amp;&gt;(int const&amp;)&gt;:\n\nThe instructions are identical, but the function signatures are different, and that's enough for the linker to keep the duplicate code around.\n\nI do agree about the type safety point. But it all depends on what priorities you have for your projects. The things I work on are performance-critical, so using features like templates, runtime type information, exceptions, etc. are just not an option.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44625,"question": "On the flip side -- I'd claim templates (especially the STL collections) are the single biggest advantage C++ has over C.","aSentId": 44682,"answer": "In large codebases, I believe OOP and memory \"safety\" (and I use that word loosely as C++ still hasn't got it right) are the big two and most other things people want are subsets or side-effects of those 2 issues.\n\nWithout memory safety, we cant do jack and without encapsulation (the real benefit of from OOP) it's really hard to write a large codebase.\n\nWe can live without the STL or templates. A lot folk (embedded and gamedev) don't use STL much (actually a lot of really big game outfits like EA have their own custom STL implementation - we tend to think only embedded uses its own stdlibs but gamedev does as well).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44683,"question": "In large codebases, I believe OOP and memory \"safety\" (and I use that word loosely as C++ still hasn't got it right) are the big two and most other things people want are subsets or side-effects of those 2 issues.\n\nWithout memory safety, we cant do jack and without encapsulation (the real benefit of from OOP) it's really hard to write a large codebase.\n\nWe can live without the STL or templates. A lot folk (embedded and gamedev) don't use STL much (actually a lot of really big game outfits like EA have their own custom STL implementation - we tend to think only embedded uses its own stdlibs but gamedev does as well).","aSentId": 44684,"answer": "If i had to choose I'd take generic over oop in a heartbeat","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44683,"question": "In large codebases, I believe OOP and memory \"safety\" (and I use that word loosely as C++ still hasn't got it right) are the big two and most other things people want are subsets or side-effects of those 2 issues.\n\nWithout memory safety, we cant do jack and without encapsulation (the real benefit of from OOP) it's really hard to write a large codebase.\n\nWe can live without the STL or templates. A lot folk (embedded and gamedev) don't use STL much (actually a lot of really big game outfits like EA have their own custom STL implementation - we tend to think only embedded uses its own stdlibs but gamedev does as well).","aSentId": 44686,"answer": "I've found the conservative approaches to developing of the studios I've worked at to be a detriment to the code quality, maintainability and development speed though. I'm not advocating STL, exceptions, or templates, but the only reasons I were given for not using them were very out of date.\n\nThen again, I left the industry to earn more money and work on more interesting codebases.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44687,"question": "I've found the conservative approaches to developing of the studios I've worked at to be a detriment to the code quality, maintainability and development speed though. I'm not advocating STL, exceptions, or templates, but the only reasons I were given for not using them were very out of date.\n\nThen again, I left the industry to earn more money and work on more interesting codebases.","aSentId": 44688,"answer": "&gt;I'm not advocating STL, exceptions, or templates\n\nWhy not? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44689,"question": "&gt;I'm not advocating STL, exceptions, or templates\n\nWhy not? ","aSentId": 44690,"answer": "So that I don't have to argue with people who hold differing opinions and focus on the main point of my post. I did advocate them all when I was in the industry! Now I'm out of the C++ world so I don't have the energy to fight that fight anymore. I miss C++ now I work with web languages...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44619,"question": "There are so many reasons not to use templates unless you really must.","aSentId": 44694,"answer": "&gt; There are so many reasons not to ~~use~~ write templates unless you really must.\n\nA good template library may be hard to write but should be easy to use.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44700,"question": "This is Snake using a lot of C++ templates, not Snake using only C++ templates.","aSentId": 44701,"answer": "aside from the pedantic difference, if you're right, it's just barely.  The only things that don't use templates are the main function (which obviously was an assumption since that's how c++ works) and a bunch of strongly typed enums.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44705,"question": "Naming a class 'cons_t'? *shudders*","aSentId": 44706,"answer": "Similarities to 'const' aside, it's the same naming convention for type aliases used in the c and c++ standard libraries. Think size_t, nullptr_t, etc.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44708,"question": "Can somenoe ELI5 what is impressive about this? I am pretty sure I could do the same thing in an after noon in java in a couple hours with my 1 semester of AP CompSci. Sorry for my ignorance.","aSentId": 44709,"answer": "The point is that the game 'runs' at compile-time (non-interactive, of course). The template-syntax of C++ is so powerful that you can actually use it to let the compiler do stuff like this while it compiles your program.\n\nSo the impressive part is not that he implemented Snake, but that he implemented a compile-time game using C++ templates.\n\nEdit:Typo","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44710,"question": "The point is that the game 'runs' at compile-time (non-interactive, of course). The template-syntax of C++ is so powerful that you can actually use it to let the compiler do stuff like this while it compiles your program.\n\nSo the impressive part is not that he implemented Snake, but that he implemented a compile-time game using C++ templates.\n\nEdit:Typo","aSentId": 44711,"answer": "It's impressive for the same reason doing the same in say, brainfuck is impressive (Using a stupidly arduous language to perform a task). The fact that it is at compile time is irrelevant really, as there are languages with FAR better compile time programming features like Haxe or D that don't restrict you to a crazy meta language to convince the compiler to do something simple \n\nStill, I always love seeing examples of pointless complexity ````^^````\n\n--- ignore next part if you don't care, just an example if interested\n\nEg in case of Haxe, want to write a game of snake that runs at compile time? Take your code for a game of snake that runs at runtime and assuming you can feed it data without runtime dependencies... you just call it at compile time, heck even save those inputs in a text field and load it from disk at compile time. Things like metaprogramming are done by executing normal Haxe code that happens to work on expressions as plain ol data, returning plain ol data that compiler can inject back into the call site etc\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44710,"question": "The point is that the game 'runs' at compile-time (non-interactive, of course). The template-syntax of C++ is so powerful that you can actually use it to let the compiler do stuff like this while it compiles your program.\n\nSo the impressive part is not that he implemented Snake, but that he implemented a compile-time game using C++ templates.\n\nEdit:Typo","aSentId": 44713,"answer": "Hm... sadly I still do not understand the gravity of it. Your explination seems to be very well compiled (no pun intended) though.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44714,"question": "Hm... sadly I still do not understand the gravity of it. Your explination seems to be very well compiled (no pun intended) though.","aSentId": 44715,"answer": "It's one of those things you don't truly appreciate until you get into it yourself. You're not writing C++; you're teaching your compiler how to write C++.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44714,"question": "Hm... sadly I still do not understand the gravity of it. Your explination seems to be very well compiled (no pun intended) though.","aSentId": 44717,"answer": "imagine if **compiling** your program code caused the code to be modified so that the game state is advanced. Clearly this is not a sane design pattern and this is why the article is interesting. He's obviiusly done it for research purposes and not for production.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44719,"question": "Today I Am Releasing Ten Million Passwords","aSentId": 44720,"answer": "Shit, my passwords are in there, but I'm too lazy.\n\nCan someone change them for me, then pm me the new ones?  Thanks.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44721,"question": "Shit, my passwords are in there, but I'm too lazy.\n\nCan someone change them for me, then pm me the new ones?  Thanks.\n","aSentId": 44722,"answer": "Just type them here and they'll show up as stars:\n\n&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;\n\nSee!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44723,"question": "Just type them here and they'll show up as stars:\n\n&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;\n\nSee!","aSentId": 44724,"answer": "\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*    \nWhoa, it works, neat.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44725,"question": "\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*    \nWhoa, it works, neat.","aSentId": 44726,"answer": "hunter2\n\nDid it work?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44723,"question": "Just type them here and they'll show up as stars:\n\n&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;&amp;#42;\n\nSee!","aSentId": 44728,"answer": "But what if my password is all stars?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44719,"question": "Today I Am Releasing Ten Million Passwords","aSentId": 44730,"answer": "\"Why the FBI Shouldn\u2019t Arrest Me\" hahaha sold!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44732,"question": "Calypso D/C++ interface: Using std::vector and std::string directly from D code","aSentId": 44733,"answer": "Neat!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44732,"question": "Calypso D/C++ interface: Using std::vector and std::string directly from D code","aSentId": 44735,"answer": "Will this not indirectly discourage the creation of high quality libraries in D if one can simply use existing C++ libraries?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44736,"question": "Will this not indirectly discourage the creation of high quality libraries in D if one can simply use existing C++ libraries?","aSentId": 44737,"answer": "You could say the same thing about C in regards to C++ and we all know that C++ did just fine.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44736,"question": "Will this not indirectly discourage the creation of high quality libraries in D if one can simply use existing C++ libraries?","aSentId": 44739,"answer": "A high-quality binding to a high-quality C or C++ library is just as good for the D community as a high-quality library implemented in D. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44736,"question": "Will this not indirectly discourage the creation of high quality libraries in D if one can simply use existing C++ libraries?","aSentId": 44741,"answer": "I think the opposite is true. This is more of a way to allow D to have all of the C++ functionality so that it can be adopted for general use earlier, while also allowing parallel D libraries to be written by those who wish to use D native libs.\n\nIt's basically what the JavaScript community would call polyfill.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44745,"question": "Building and Running .NET's CoreCLR on OS X","aSentId": 44746,"answer": "Can't get over that .exe extension on mac. ..","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44747,"question": "Can't get over that .exe extension on mac. ..","aSentId": 44748,"answer": "PE is finally portable.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44749,"question": "PE is finally portable.","aSentId": 44750,"answer": "[a thousand frustrated PE/COFF engineers through out the last decade just wept a bit.](https://github.com/dotnet/coreclr/blob/cbf46fb0b6a0b209ed1caf4a680910b383e68cba/src/utilcode/pedecoder.cpp)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44751,"question": "[a thousand frustrated PE/COFF engineers through out the last decade just wept a bit.](https://github.com/dotnet/coreclr/blob/cbf46fb0b6a0b209ed1caf4a680910b383e68cba/src/utilcode/pedecoder.cpp)","aSentId": 44752,"answer": "and [here](https://github.com/dotnet/coreclr/blob/cbf46fb0b6a0b209ed1caf4a680910b383e68cba/src/inc/pedecoder.inl) also [here](https://github.com/dotnet/coreclr/blob/cbf46fb0b6a0b209ed1caf4a680910b383e68cba/src/inc/pedecoder.h)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44747,"question": "Can't get over that .exe extension on mac. ..","aSentId": 44754,"answer": "I know, I almost shed a very manly programming tear when I saw it...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44747,"question": "Can't get over that .exe extension on mac. ..","aSentId": 44756,"answer": "I know it's extremely petty, but that has been a *constant* annoyance for me with Mono as well, and part of the reason I won't use it. It looks so incredibly out of place and wrong anywhere but on Windows, and exists for no particular reason at all. On Windows it makes sense, since it generates an executable that starts the .NET VM for you, but on Linux and Mac it's just pointless.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44757,"question": "I know it's extremely petty, but that has been a *constant* annoyance for me with Mono as well, and part of the reason I won't use it. It looks so incredibly out of place and wrong anywhere but on Windows, and exists for no particular reason at all. On Windows it makes sense, since it generates an executable that starts the .NET VM for you, but on Linux and Mac it's just pointless.","aSentId": 44758,"answer": "How is this different than shipping Java apps with a .jar extension?\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44759,"question": "How is this different than shipping Java apps with a .jar extension?\n\n","aSentId": 44760,"answer": "Well, with those it's not pointlessly enforcing one platform's standards on every other platform, they just made up a new one that looks equally out of place everywhere, which I have much less of a problem with.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44761,"question": "Well, with those it's not pointlessly enforcing one platform's standards on every other platform, they just made up a new one that looks equally out of place everywhere, which I have much less of a problem with.","aSentId": 44762,"answer": "Oh. I think I get what you mean. Like, a .jar file is a Java file everywhere, but a .exe is not necessarily a .NET binary everywhere and there's (currently) no clear distinction between a regular native Win32 PE and a .NET one?\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44763,"question": "Oh. I think I get what you mean. Like, a .jar file is a Java file everywhere, but a .exe is not necessarily a .NET binary everywhere and there's (currently) no clear distinction between a regular native Win32 PE and a .NET one?\n","aSentId": 44764,"answer": "confirmed sarcasm.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44757,"question": "I know it's extremely petty, but that has been a *constant* annoyance for me with Mono as well, and part of the reason I won't use it. It looks so incredibly out of place and wrong anywhere but on Windows, and exists for no particular reason at all. On Windows it makes sense, since it generates an executable that starts the .NET VM for you, but on Linux and Mac it's just pointless.","aSentId": 44766,"answer": "While I won't disagree with you on the ugliness point, I will say it's not so bad since most OS X apps are put in .app packages that hide implementation details like these in subfolders. That is to say, a CLR mac app doesn't look any different than an Xcode one.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44767,"question": "While I won't disagree with you on the ugliness point, I will say it's not so bad since most OS X apps are put in .app packages that hide implementation details like these in subfolders. That is to say, a CLR mac app doesn't look any different than an Xcode one.","aSentId": 44768,"answer": "And on Linux they'll probably be hidden behind a starter script. But I'll know of the ugliness behind it. I'll know of it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44745,"question": "Building and Running .NET's CoreCLR on OS X","aSentId": 44770,"answer": "So I tried this on my ubuntu machine. It works until after the compilation. When I want to run it, I get this error:\n\n&gt; {0x7fdd32fb2780-0x7fdd31a2dad0} ASSERT [MISC   ] at [...]/coreclr/src/pal/src/misc/fmtmessage.cpp.239: Unable to continue due to missing library.\n\nI can run the file directly, but it runs on monos vm. (I have installed mono-devel)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44771,"question": "So I tried this on my ubuntu machine. It works until after the compilation. When I want to run it, I get this error:\n\n&gt; {0x7fdd32fb2780-0x7fdd31a2dad0} ASSERT [MISC   ] at [...]/coreclr/src/pal/src/misc/fmtmessage.cpp.239: Unable to continue due to missing library.\n\nI can run the file directly, but it runs on monos vm. (I have installed mono-devel)","aSentId": 44772,"answer": "My guess is that you're missing \"the rest\" of the BCL. mscorlib gives you strings and such, but most of the good stuff is in other assemblies. You will have to get them into the path that you point corerun at.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44773,"question": "My guess is that you're missing \"the rest\" of the BCL. mscorlib gives you strings and such, but most of the good stuff is in other assemblies. You will have to get them into the path that you point corerun at.","aSentId": 44774,"answer": "So which library is missing? So far I only want a HelloWorld example.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44775,"question": "So which library is missing? So far I only want a HelloWorld example.","aSentId": 44776,"answer": "Ah for hello world you should be ok. Sorry the errors are quite obtuse right now. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44771,"question": "So I tried this on my ubuntu machine. It works until after the compilation. When I want to run it, I get this error:\n\n&gt; {0x7fdd32fb2780-0x7fdd31a2dad0} ASSERT [MISC   ] at [...]/coreclr/src/pal/src/misc/fmtmessage.cpp.239: Unable to continue due to missing library.\n\nI can run the file directly, but it runs on monos vm. (I have installed mono-devel)","aSentId": 44778,"answer": "Ubuntu doesn't have that library, bummer.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44745,"question": "Building and Running .NET's CoreCLR on OS X","aSentId": 44780,"answer": "Ummmm, I thought the C# compiler was open source and written in C#? Surely that would make it easy to use on Mac now, rather than using Mono?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44781,"question": "Ummmm, I thought the C# compiler was open source and written in C#? Surely that would make it easy to use on Mac now, rather than using Mono?","aSentId": 44782,"answer": "Yes the new compiler is now open source. The mono compiler is also written in c#. Pick whichever. :-)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44786,"question": "&gt;That is to say, for now, this is still Microsoft\u2019s CLR. I am curious to see if it ever becomes ours.\n\nHow can you be a participant in the .NET community and not see that this is a common pattern.\n\nNHibernate exists for YEARS. EntityFramework comes out and people swarm to it like flies on shit (in v1/2, it's an accurate metaphor).\n\nBesides, there's already interplay between Mono and CoreCLR with both looking to borrow from the other.","aSentId": 44787,"answer": "EF is a hell of a lot easier to configure and the ability to just code-and-go for new projects or prototypes makes it a lot easier to use.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44788,"question": "EF is a hell of a lot easier to configure and the ability to just code-and-go for new projects or prototypes makes it a lot easier to use.","aSentId": 44789,"answer": "My comment isn't even a commentary on which is better or easier to use.\n\nAnd also, Code Ahead wasn't even in the initial release, so more to my point...\n\nDownvoters apparently don't remember Castle, NHibernate, NancyFX or any of the other largely abandoned projects as MS releases the \"official version\".\n\nOtherwise, don't know why I'm being downvoted. I'm wathcing Miguel and .NET devs exchanging code and ideas already on GitHub and Twitter. But keeps spreading the FUD , I guess.\n\nFucking reddit today man.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44790,"question": "My comment isn't even a commentary on which is better or easier to use.\n\nAnd also, Code Ahead wasn't even in the initial release, so more to my point...\n\nDownvoters apparently don't remember Castle, NHibernate, NancyFX or any of the other largely abandoned projects as MS releases the \"official version\".\n\nOtherwise, don't know why I'm being downvoted. I'm wathcing Miguel and .NET devs exchanging code and ideas already on GitHub and Twitter. But keeps spreading the FUD , I guess.\n\nFucking reddit today man.","aSentId": 44791,"answer": "The NIH Syndrome at MSFT makes me extremely wary of everything they do. I left the platform to jump into the deep end of OSS non-MSFT Dev in 2009 after a decade on the platform was hard but worth breaking those chains. Opening the CLR is great but I'm still waiting for the dust to settle over the coming months, they're still pulling the same old games with tools like Chocolatey and the coming App Store. They know where their money is printed and it isn't OSS.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44792,"question": "The NIH Syndrome at MSFT makes me extremely wary of everything they do. I left the platform to jump into the deep end of OSS non-MSFT Dev in 2009 after a decade on the platform was hard but worth breaking those chains. Opening the CLR is great but I'm still waiting for the dust to settle over the coming months, they're still pulling the same old games with tools like Chocolatey and the coming App Store. They know where their money is printed and it isn't OSS.","aSentId": 44793,"answer": "Downvotes don't mean it ain't true. I lived and breathed the platform for a decade. They did it with msbuild vs nant, msunit/msunit vs nunit/nunit runner, and a couple other things I can't quite recall at the moment. The linq2sql vs EF was last straw for me. Heck, that and the constant forced obsolescence of vs.net every time they released a new .net and forced devs into paid upgrades. Express was a joke and they intentionally squeezed the plugin makers for working around the limitations to the point of threatening legal action. Deal with it and quit pretending it wasn't a shit sandwich.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44786,"question": "&gt;That is to say, for now, this is still Microsoft\u2019s CLR. I am curious to see if it ever becomes ours.\n\nHow can you be a participant in the .NET community and not see that this is a common pattern.\n\nNHibernate exists for YEARS. EntityFramework comes out and people swarm to it like flies on shit (in v1/2, it's an accurate metaphor).\n\nBesides, there's already interplay between Mono and CoreCLR with both looking to borrow from the other.","aSentId": 44795,"answer": "It's a hopeful statement. Indeed Mono is borrowing a lot - more on the library side than the runtime.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44797,"question": "How I Start: Nim (Dennis Felsing)","aSentId": 44798,"answer": "That's one thorough article. I'd like to hear from people who have worked with Nim, is it production-ready yet?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44799,"question": "That's one thorough article. I'd like to hear from people who have worked with Nim, is it production-ready yet?","aSentId": 44800,"answer": "I first looked at Nim coming from C for the easy interop, so I don't use a lot of the more advanced language features (macros, effects system, etc.) that frequently.\n\nThat said, I've found it to be very pleasant and usable - I ran into a compiler issue maybe once or twice; the issues that I ran into were mostly due to me getting confused with memory layout (who owns what) when doing interop with C.\n\nEdit: That is to say, that's the type of mistakes that I make the most frequently and what causes friction for me when I'm trying to put the two together.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44799,"question": "That's one thorough article. I'd like to hear from people who have worked with Nim, is it production-ready yet?","aSentId": 44802,"answer": "If you avoid the experimental parts of the language (none of which appear in this article), it is ready for me. (I'm the author of the article.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44797,"question": "How I Start: Nim (Dennis Felsing)","aSentId": 44804,"answer": "This is a great article! I wonder if any C fans have tried out the language. I think nim is sort of targeting people who want something comparable to C but a little simpler and not as sharp around the edges. Do any C fans have opinions to share?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44797,"question": "How I Start: Nim (Dennis Felsing)","aSentId": 44806,"answer": "A comment to the author of the article: If you want to be taken seriously as a professional, avoid that kind of language. It's a non-starter outside of perhaps the brogrammer subset (maybe that's the target, but if not, get a better example).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44807,"question": "A comment to the author of the article: If you want to be taken seriously as a professional, avoid that kind of language. It's a non-starter outside of perhaps the brogrammer subset (maybe that's the target, but if not, get a better example).","aSentId": 44808,"answer": "You might want to take that up with Urban M\u00fcller instead. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44809,"question": "You might want to take that up with Urban M\u00fcller instead. ","aSentId": 44810,"answer": "The author of the post is responsible for the content. The choice of example was purely arbitrary - it's not a standard example like \"Hello, World!\"\n\nCommunities like Clojure, Scala, D, Rust, Go, Haskell, OCaml, ... do not rely on four-letter words to promote the language.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44811,"question": "The author of the post is responsible for the content. The choice of example was purely arbitrary - it's not a standard example like \"Hello, World!\"\n\nCommunities like Clojure, Scala, D, Rust, Go, Haskell, OCaml, ... do not rely on four-letter words to promote the language.","aSentId": 44812,"answer": "I've seen brainfuck implementations in each of these languages. \n\nJust kinda generally, while 'fuck' is still considered to be a rude word, at least in the US, it's not broadly a social faux pas to make use of it. More conservative areas will take issue but these aren't going to be populated enough to put your professional appearance at risk. \n\nMs. Manners will have a fit, but times are a changin'. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44811,"question": "The author of the post is responsible for the content. The choice of example was purely arbitrary - it's not a standard example like \"Hello, World!\"\n\nCommunities like Clojure, Scala, D, Rust, Go, Haskell, OCaml, ... do not rely on four-letter words to promote the language.","aSentId": 44814,"answer": "I run the How I Start site and I don't find brain fuck to be unprofessional.\n\nEdit: But you didn't include \"Erlang\" in your list of communities, we love four letter wrods.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44807,"question": "A comment to the author of the article: If you want to be taken seriously as a professional, avoid that kind of language. It's a non-starter outside of perhaps the brogrammer subset (maybe that's the target, but if not, get a better example).","aSentId": 44816,"answer": "Wow the hatred from D fanboys towards Nim fanboys goes deep.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44817,"question": "Wow the hatred from D fanboys towards Nim fanboys goes deep.","aSentId": 44818,"answer": "All sweeping generalizations are false.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44820,"question": "Swift 1.2 and Xcode 6.3 beta","aSentId": 44821,"answer": "I hope this fixes the annoying bugs with SourceKit crashing while developing. I know it's in Beta, but Christ! ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44823,"question": "Collection of useful .htaccess snippets","aSentId": 44824,"answer": "This is the most useful yet non-obvious (both to me, obv) htaccess snippet I've ever come across:\n\n    RewriteBase /\n    RewriteCond %{REQUEST_URI}::$1 ^(.*?/)(.*)::\\2$\n    RewriteRule ^(.*) - [E=BASE:%1]\n\nTaken from [here](http://stackoverflow.com/questions/21062290/set-rewritebase-to-the-current-folder-path-dynamically).\n\nThis allows you to get the same functionality as setting `RewriteBase` to the current path without actually having to hard-code the path in your htaccess file.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44823,"question": "Collection of useful .htaccess snippets","aSentId": 44826,"answer": "for the uninformed, what is the point of a .htaccess script?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44827,"question": "for the uninformed, what is the point of a .htaccess script?","aSentId": 44828,"answer": "In traditional shared web hosting (ie what GoDaddy, DreamHost, BlueHost, etc. provide and what was most popular before VPS' [eg. what's provided by Amazon] became widely available), the hosting company will usually run the Apache web server and configure it to host multiple sites from the same IP (doable by checking the desired domain name in HTTP requests). Apache lets you have a main configuration file that is loaded by the server at startup, but it also allows you to specify settings per-directory using `.htaccess` files. It's an old, inefficient, and hacky way to let site owners in shared hosting environments make their own server configurations.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44827,"question": "for the uninformed, what is the point of a .htaccess script?","aSentId": 44830,"answer": "It's not a scripting language, it's a configuration file.  Basically, the Apache server lets you write a config file both as a big, standalone monster (e.g. `httpd.conf`) as well as putting config file fragments that should apply to resources in specific directories in files named `.htaccess` in the corresponding directories.  This also has the side advantage that if you're in a situation where you don't have root access and can't modify that main `httpd.conf` file that lives somewhere under `/etc`, you can still customize Apache's behavior.\n\nThe name is a bit of a misnomer, implying that it has something to do with access control.  It does, in the sense that some of the config statements are absolutely related to access control, but that's only a fraction of what you can do.  Apache is very configurable and has a ton of configuration directives, making it possible to do all kinds of tricks.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44823,"question": "Collection of useful .htaccess snippets","aSentId": 44832,"answer": "How safe is the \"Auto UTF-8 Encode\" feature? Does anybody knows of some Service/Browser/Application that will break when using it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44837,"question": "The repeated deaths of OOP","aSentId": 44838,"answer": "I think the reason OOP survived this long is right there in the article:\n\n&gt; Looking at the big picture, I can see that object orientation is not a paradigm, but a set of mechanics we can cherry pick.\n\nThis. These set of mechanics that OOP languages provide have proven useful and usable in many paradigms. Even ECS can (and often does) piggyback on these OOP mechanics rather than replace them.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44839,"question": "I think the reason OOP survived this long is right there in the article:\n\n&gt; Looking at the big picture, I can see that object orientation is not a paradigm, but a set of mechanics we can cherry pick.\n\nThis. These set of mechanics that OOP languages provide have proven useful and usable in many paradigms. Even ECS can (and often does) piggyback on these OOP mechanics rather than replace them.","aSentId": 44840,"answer": "That is spot on. I've never understood the arguments about OOP vs Procedural vs Functional vs Dynamic. When I need something to be inherited, I use OOP. When I need something to be simple and immutable, I use functional. When I need to interact with a rapidly changing system I use Dynamic. \n\nI guess my choice of platform, .NET, is nice in that it allows me to use all 4 cleanly. So I've never really paid much attention to the whole \"OOP IS EVIL\" fad that keeps popping back up. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44841,"question": "That is spot on. I've never understood the arguments about OOP vs Procedural vs Functional vs Dynamic. When I need something to be inherited, I use OOP. When I need something to be simple and immutable, I use functional. When I need to interact with a rapidly changing system I use Dynamic. \n\nI guess my choice of platform, .NET, is nice in that it allows me to use all 4 cleanly. So I've never really paid much attention to the whole \"OOP IS EVIL\" fad that keeps popping back up. ","aSentId": 44842,"answer": "I find the majority of my projects use OOP.\n\nIf I have to write something simple, then sure, functional and other methodologies work fine.\n\nBut the big mega-projects that I do OOP keeps it consistent, and clean.  I shouldn't have to worry about what something is, or where I need it.  Objects keep it strict, and I never have to second guess myself.\n\nBut I do C#, C++, and Java.  None of those languages are going to be obsolete any time soon, and so many vendors continue to push out products in those languages.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44843,"question": "I find the majority of my projects use OOP.\n\nIf I have to write something simple, then sure, functional and other methodologies work fine.\n\nBut the big mega-projects that I do OOP keeps it consistent, and clean.  I shouldn't have to worry about what something is, or where I need it.  Objects keep it strict, and I never have to second guess myself.\n\nBut I do C#, C++, and Java.  None of those languages are going to be obsolete any time soon, and so many vendors continue to push out products in those languages.","aSentId": 44844,"answer": "You want proper modules, not OOP with its AbstractFactoryFactoryFactory and all that crap.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44841,"question": "That is spot on. I've never understood the arguments about OOP vs Procedural vs Functional vs Dynamic. When I need something to be inherited, I use OOP. When I need something to be simple and immutable, I use functional. When I need to interact with a rapidly changing system I use Dynamic. \n\nI guess my choice of platform, .NET, is nice in that it allows me to use all 4 cleanly. So I've never really paid much attention to the whole \"OOP IS EVIL\" fad that keeps popping back up. ","aSentId": 44846,"answer": "&gt; When I need something to be inherited, I use OOP.\n\nThose arguments are about how inheritance is the wrong abstraction for most problems, particularly code reuse. Parameterization is strictly more powerful.\n\nObjects are needed at large scale systems where message passing is needed between servers and such, but at the small scale, other paradigms work much better.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44847,"question": "&gt; When I need something to be inherited, I use OOP.\n\nThose arguments are about how inheritance is the wrong abstraction for most problems, particularly code reuse. Parameterization is strictly more powerful.\n\nObjects are needed at large scale systems where message passing is needed between servers and such, but at the small scale, other paradigms work much better.","aSentId": 44848,"answer": "&gt; Objects are needed at large scale systems where message passing is needed between servers and such,\n\nI'd suggest that that's an example where objects are a misguided approach.  \n\n Objects (where data and methods to operate on said data are bundled together) - are of little use passing messages between servers. It's unlikely the servers on each side will want to perform the same operations on that data (or else why even bother passing the message).   Better to pass just the data in those cross-server; and let each side define objects (if they want) that meet their needs.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44849,"question": "&gt; Objects are needed at large scale systems where message passing is needed between servers and such,\n\nI'd suggest that that's an example where objects are a misguided approach.  \n\n Objects (where data and methods to operate on said data are bundled together) - are of little use passing messages between servers. It's unlikely the servers on each side will want to perform the same operations on that data (or else why even bother passing the message).   Better to pass just the data in those cross-server; and let each side define objects (if they want) that meet their needs.","aSentId": 44850,"answer": "Sure, but the paradigm is irreducibly message passing. This is what objects were initially about: message recievers.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44851,"question": "Sure, but the paradigm is irreducibly message passing. This is what objects were initially about: message recievers.","aSentId": 44852,"answer": "Well - taken to that extreme; heck, you could even describe 'ls -l | grep wtf'  as \"object oriented\", passing an ugly-as-heck newline-and-space-delimited message.\n\nBut few would say that this is an example where \"objects are needed\".","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44851,"question": "Sure, but the paradigm is irreducibly message passing. This is what objects were initially about: message recievers.","aSentId": 44854,"answer": "Were initially about, maybe. But it's not what they are now. (If you want objects that pass messages between each other, you want actors)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44847,"question": "&gt; When I need something to be inherited, I use OOP.\n\nThose arguments are about how inheritance is the wrong abstraction for most problems, particularly code reuse. Parameterization is strictly more powerful.\n\nObjects are needed at large scale systems where message passing is needed between servers and such, but at the small scale, other paradigms work much better.","aSentId": 44856,"answer": "&gt; Parameterization is strictly more powerful\n\nCan you elaborate? Consider code like this:\n\n    void Button {\n        virtual void draw() {\n            drawLabel();\n        }\n    }\n\n    void BlueBorderedButton : Button {\n        virtual void draw() {\n            fillBlue();\n            super.draw();\n            drawBorder();\n        }\n    }\n\nHow would you express that using parametrization?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44857,"question": "&gt; Parameterization is strictly more powerful\n\nCan you elaborate? Consider code like this:\n\n    void Button {\n        virtual void draw() {\n            drawLabel();\n        }\n    }\n\n    void BlueBorderedButton : Button {\n        virtual void draw() {\n            fillBlue();\n            super.draw();\n            drawBorder();\n        }\n    }\n\nHow would you express that using parametrization?","aSentId": 44858,"answer": "void draw(Color color, Border border)\n{\n  drawLabel(color, border);\n}","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44857,"question": "&gt; Parameterization is strictly more powerful\n\nCan you elaborate? Consider code like this:\n\n    void Button {\n        virtual void draw() {\n            drawLabel();\n        }\n    }\n\n    void BlueBorderedButton : Button {\n        virtual void draw() {\n            fillBlue();\n            super.draw();\n            drawBorder();\n        }\n    }\n\nHow would you express that using parametrization?","aSentId": 44860,"answer": "This is fake syntax, but it hopefully captures the idea of how you could express the above without inheritance (but still using subtyping).\n\n    void DrawableButton(Drawer d) {\n        void draw() {\n            d.draw(this);\n        }\n    }\n\n    void Labeled: Drawer {\n        void draw(button: Button) {\n            drawLabel(button.label)\n        }\n    }\n\n    void BlueBorder(Drawer d): Drawer {\n        void draw(button: Button) {\n            fillBlue()\n            d.draw(button)\n            drawBorder()\n        }\n    }\n\n    Button b1 = DrawableButton(new Labeled())\n    Button b2 = DrawableButton(new BlueBorder(new Labeled()))\n\nIn this case, inheritance might be the better approach, but you can always replace inheritance with explicit dependencies.  \n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44857,"question": "&gt; Parameterization is strictly more powerful\n\nCan you elaborate? Consider code like this:\n\n    void Button {\n        virtual void draw() {\n            drawLabel();\n        }\n    }\n\n    void BlueBorderedButton : Button {\n        virtual void draw() {\n            fillBlue();\n            super.draw();\n            drawBorder();\n        }\n    }\n\nHow would you express that using parametrization?","aSentId": 44862,"answer": "Actually, I think your example is what solid OOP design is best for: libraries.\n\nIf you're *designing* libraries, you're gonna use OOP. If you're *using* libraries then it's less likely you'll need OOP.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44863,"question": "Actually, I think your example is what solid OOP design is best for: libraries.\n\nIf you're *designing* libraries, you're gonna use OOP. If you're *using* libraries then it's less likely you'll need OOP.","aSentId": 44864,"answer": "Subtype polymorphism is almost always inferior to parametric polymorphism. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44863,"question": "Actually, I think your example is what solid OOP design is best for: libraries.\n\nIf you're *designing* libraries, you're gonna use OOP. If you're *using* libraries then it's less likely you'll need OOP.","aSentId": 44866,"answer": "Wait, if you're using a library designed with an OOP structure... aren't you going to have to use OOP to use it? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44867,"question": "Wait, if you're using a library designed with an OOP structure... aren't you going to have to use OOP to use it? ","aSentId": 44868,"answer": "My point is there's a difference between designing and using libraries. Designing requires way more structure and scope. Using a library can be open-ended. No end in sight. The scope is always changing, so relations between objects are more challenging to keep in order.\n\nHowever, it's just a general rule of thumb I've heard somewhere. Obviously there are lots of exceptions, so take it with a grain of salt.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44863,"question": "Actually, I think your example is what solid OOP design is best for: libraries.\n\nIf you're *designing* libraries, you're gonna use OOP. If you're *using* libraries then it's less likely you'll need OOP.","aSentId": 44870,"answer": "Oh...god no.  Please no. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44871,"question": "Oh...god no.  Please no. ","aSentId": 44872,"answer": "Your comment made me laugh, but it's a shame you're too lazy to throw me a bone and suggest what's making you turn to a higher power based on my comment.\n\nThen again, I forgot this is Reddit, so let's just make jokes! Haha, PHP sucks!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44873,"question": "Your comment made me laugh, but it's a shame you're too lazy to throw me a bone and suggest what's making you turn to a higher power based on my comment.\n\nThen again, I forgot this is Reddit, so let's just make jokes! Haha, PHP sucks!","aSentId": 44874,"answer": "Look, all subclassing buys you is dynamic dispatch for polymorphic methods.  This is an inferior way of designing a library.  A type class based approach is *always* better unless for some weird reason you need dynamic dispatch, and the *only* reason you'd need that is if your library needs to be hot-swappable with running code! \n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44875,"question": "Look, all subclassing buys you is dynamic dispatch for polymorphic methods.  This is an inferior way of designing a library.  A type class based approach is *always* better unless for some weird reason you need dynamic dispatch, and the *only* reason you'd need that is if your library needs to be hot-swappable with running code! \n","aSentId": 44876,"answer": "Yeah, I can't argue with that. Thanks for humoring me.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44878,"question": "&gt; How would you express that using parametrization?\n\nBy making border a property of button,  then you can compose styles instead of having a type for every different border color.\n\nBorder color is a style not a behavior,  so shouldn't be modeled with inheritence.","aSentId": 44879,"answer": "&gt; By making border a property of button\n\nNo, this is the \"god object\" anti-pattern. You wind up with an all-knowing class with tons of properties. It's better to have a class that can be extended in novel ways, than to attempt to anticipate all possible usages and absorb them into a base class.\n\n&gt; Border color is a style not a behavior\n\nIt's reasonable to encapsulate this stuff into a \"Style\" class, but you immediately run into the same problems that inheritance solves.\n\nLook at HTML: you have a dozen or so border-styles, such as \"groove\" and \"outset\". Want to draw a custom border, or maybe just tweak how one of the borders looks? Too bad, you can't - you have to fake it with something else. There's no extensibility: you have to make do with what they give you, or abandon it entirely.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44880,"question": "&gt; By making border a property of button\n\nNo, this is the \"god object\" anti-pattern. You wind up with an all-knowing class with tons of properties. It's better to have a class that can be extended in novel ways, than to attempt to anticipate all possible usages and absorb them into a base class.\n\n&gt; Border color is a style not a behavior\n\nIt's reasonable to encapsulate this stuff into a \"Style\" class, but you immediately run into the same problems that inheritance solves.\n\nLook at HTML: you have a dozen or so border-styles, such as \"groove\" and \"outset\". Want to draw a custom border, or maybe just tweak how one of the borders looks? Too bad, you can't - you have to fake it with something else. There's no extensibility: you have to make do with what they give you, or abandon it entirely.","aSentId": 44881,"answer": "&gt; No, this is the \"god object\" anti-pattern. \n\nNot at all you still have a border class, it is still responsible for drawing itself, but it is a property of the button. \n\n&gt; It's reasonable to encapsulate this stuff into a \"Style\" class, but you immediately run into the same problems that inheritance solves.\n\nBut the responsibilities are separated better. The button has the behavior,  the style controls the look.\n\n&gt; Want to draw a custom border, or maybe just tweak how one of the borders looks? Too bad, you can't\n\nWell no, I haven't actually,  the primitives have always been good enough for me.  But if you really want to, you have the canvas element,  which behaves in a similar way to your example. \n\nAlso, how is \"faking it\" any different to draw lines and rectangles?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44841,"question": "That is spot on. I've never understood the arguments about OOP vs Procedural vs Functional vs Dynamic. When I need something to be inherited, I use OOP. When I need something to be simple and immutable, I use functional. When I need to interact with a rapidly changing system I use Dynamic. \n\nI guess my choice of platform, .NET, is nice in that it allows me to use all 4 cleanly. So I've never really paid much attention to the whole \"OOP IS EVIL\" fad that keeps popping back up. ","aSentId": 44883,"answer": "&gt; When I need something to be inherited, I use OOP. \n\nI use it when the alternative would be functions that require a tuple, list, or map containing specific fields. It's a lot easier and less error prone to say that a function takes a specific object. It's even easier and less error prone in most situations to make that function a member of the object that it operates on. \n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44884,"question": "&gt; When I need something to be inherited, I use OOP. \n\nI use it when the alternative would be functions that require a tuple, list, or map containing specific fields. It's a lot easier and less error prone to say that a function takes a specific object. It's even easier and less error prone in most situations to make that function a member of the object that it operates on. \n\n","aSentId": 44885,"answer": "I think you are somewhat confusing the two terms \"object\" and \"data type\". You don't need objects to define data types, and explicitly passing the data type as an argument to the function is more composable than calling the function on an object.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44886,"question": "I think you are somewhat confusing the two terms \"object\" and \"data type\". You don't need objects to define data types, and explicitly passing the data type as an argument to the function is more composable than calling the function on an object.","aSentId": 44887,"answer": "&gt;I think you are somewhat confusing the two terms \"object\" and \"data type\". \n\nI'm not. It just makes sense that once you have a structure holding data, that you would attach the methods meant to operate on that data to that data. It makes programming simpler (or at least easier for someone to use your code). It doesn't make it less composeable either. It's still fully composeable. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44888,"question": "&gt;I think you are somewhat confusing the two terms \"object\" and \"data type\". \n\nI'm not. It just makes sense that once you have a structure holding data, that you would attach the methods meant to operate on that data to that data. It makes programming simpler (or at least easier for someone to use your code). It doesn't make it less composeable either. It's still fully composeable. ","aSentId": 44889,"answer": "The common model in non-OOP languages is that you have a **module** that defines a set of related **data types** and their **operations**.  The module also controls **encapsulation** by deciding what things it exports and what it keeps private.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44890,"question": "The common model in non-OOP languages is that you have a **module** that defines a set of related **data types** and their **operations**.  The module also controls **encapsulation** by deciding what things it exports and what it keeps private.","aSentId": 44891,"answer": "If you're going to organize everything that way, then why not use objects? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44892,"question": "If you're going to organize everything that way, then why not use objects? ","aSentId": 44893,"answer": "1. I'm not always going to organize things that way:\n * Sometimes there are operations that don't logically belong to one specific type.  For example, connecting a data producer to a consumer: should that be a method of the producers or the consumers?\n * Sometimes I will think of new, useful operations for types in third-party modules that I cannot modify.  \n * More generally, a language should really try not to dictate how I organize the code.  Maybe the best way to organize one project is to have one module per type, and each module contains all the operations for its type.  Maybe it's best to organize it by having most of the types be in a smaller set of modules, and have lots of task-specific modules with operations for various tasks, all sharing the same family of core types.\n* I might have something in between, or even more than one of these at the same time.  Many module systems provide the ability for modules to re-export types or operations that they import, and often this ability is used to provide a friendly \"fa\u00e7ade\" module that exports the most common or useful functionality in a library.  Users who want to use the library for simple tasks import the fa\u00e7ade, those who want complex tasks can import the specific submodules.\n2. A module can define **multiple types** all in one unit of code, whereas one class = one type.  \n3. Objects force stuff on me that I don't want need most of the time, like dispatch tables.  And this stuff isn't always harmless\u2014a lot of the features that many OOP languages force on you to \"help\" you really should be opt-ins, not forced.  (The best example here is reflection, but that's a topic for another day.)\n\nBasically, OOP's concept of a \"class\" conflates several things: *types*, *modules*, *subtyping*, *dynamic dispatch* and *reflection*.  The non-OOP responses to this involve some mix of:\n\n* Arguing that one or more of those is a poor feature.  Subtyping is the one of those that garners the most criticism here.\n* Arguing that one or more of those features can be simulated with other, more fundamental language features.  Dynamic dispatch is the one that's most often criticized that way: the argument goes that if you have function references or first-class functions, it's trivial to implement dispatch tables as structs of functions.\n* Arguing that whichever of those features are good ought to be *opt-ins*.  If you want to opt in to dynamic dispatch, the language should not force reflection on you.  If you want modularity, the language should not force your module boundaries to be the same as your type boundaries.  And so on.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44888,"question": "&gt;I think you are somewhat confusing the two terms \"object\" and \"data type\". \n\nI'm not. It just makes sense that once you have a structure holding data, that you would attach the methods meant to operate on that data to that data. It makes programming simpler (or at least easier for someone to use your code). It doesn't make it less composeable either. It's still fully composeable. ","aSentId": 44895,"answer": "\"It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.\" \u2014Alan Perlis \u2014Michael Scott","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44839,"question": "I think the reason OOP survived this long is right there in the article:\n\n&gt; Looking at the big picture, I can see that object orientation is not a paradigm, but a set of mechanics we can cherry pick.\n\nThis. These set of mechanics that OOP languages provide have proven useful and usable in many paradigms. Even ECS can (and often does) piggyback on these OOP mechanics rather than replace them.","aSentId": 44900,"answer": "The reason you might say OOP is dying even while many of its pieces are thriving is that OOP as a whole is a bunch of bad default design choices. However vague it is, it still tends to focus on things like inheritance, polymorphism through late binding, and thinking in terms of a single object and its behavior.\n\nThese things tend to be harmful for code maintenance and readability. Yes, they do have their place (even the Linux kernel uses vtables for various systems), but they should never be the default choice, and they probably don't even need to be built into the language to be useful. The default should be simple functions that operate on plain old data at the scale that makes sense for the program, whether that's a single object or a huge collection (think databases, particle systems, etc. for examples of when you *definitely do not* want typical OOP).\n\nThey're also incredibly harmful for performance, and I don't mean performance in the petty \"but virtual calls are sloooooow!\" way- I mean it in the \"but now you can't hand this off to your Cell processor or GPU without rewriting the entire thing\" way. This is the other reason they shouldn't be the default- well-designed simple functions are easier to write, understand, and change, as well as easier to optimize when needed, because you just have raw data that you can reorganize whenever you need to without blowing up your whole object hierarchy.\n\nI also don't buy the \"but OOP forces good structure on huge projects\" argument either. The default tools of OOP can obfuscate the real functionality of the code by encouraging people to hide things behind separated virtual functions in an inheritance hierarchy. You have to be just as disciplined to get a good OOP codebase as you do to get a (simpler, more flexible) non-OOP codebase.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44901,"question": "The reason you might say OOP is dying even while many of its pieces are thriving is that OOP as a whole is a bunch of bad default design choices. However vague it is, it still tends to focus on things like inheritance, polymorphism through late binding, and thinking in terms of a single object and its behavior.\n\nThese things tend to be harmful for code maintenance and readability. Yes, they do have their place (even the Linux kernel uses vtables for various systems), but they should never be the default choice, and they probably don't even need to be built into the language to be useful. The default should be simple functions that operate on plain old data at the scale that makes sense for the program, whether that's a single object or a huge collection (think databases, particle systems, etc. for examples of when you *definitely do not* want typical OOP).\n\nThey're also incredibly harmful for performance, and I don't mean performance in the petty \"but virtual calls are sloooooow!\" way- I mean it in the \"but now you can't hand this off to your Cell processor or GPU without rewriting the entire thing\" way. This is the other reason they shouldn't be the default- well-designed simple functions are easier to write, understand, and change, as well as easier to optimize when needed, because you just have raw data that you can reorganize whenever you need to without blowing up your whole object hierarchy.\n\nI also don't buy the \"but OOP forces good structure on huge projects\" argument either. The default tools of OOP can obfuscate the real functionality of the code by encouraging people to hide things behind separated virtual functions in an inheritance hierarchy. You have to be just as disciplined to get a good OOP codebase as you do to get a (simpler, more flexible) non-OOP codebase.","aSentId": 44902,"answer": "The unnecessary use of objects always bugged me, but I thought I was wrong because everyone at the time insisted it was correct. Glad to hear that I'm not crazy. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44903,"question": "The unnecessary use of objects always bugged me, but I thought I was wrong because everyone at the time insisted it was correct. Glad to hear that I'm not crazy. ","aSentId": 44904,"answer": "[This presentation might interest you.](http://youtu.be/o9pEzgHorH0)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44903,"question": "The unnecessary use of objects always bugged me, but I thought I was wrong because everyone at the time insisted it was correct. Glad to hear that I'm not crazy. ","aSentId": 44906,"answer": "Real example in my current day job:\n\n    class StuffParser {\n    public:\n        StuffParser() {}\n        Stuff Parse(Input); // code in .cpp\n    }\n\n    // elsewhere\n    StuffParser sp;\n    sp.parse(input)\n\nI found another similar example, except it used 2 member variables that were never accessed outside the method that did the parsing.\n\nI promptly transformed those into a function and a namespace. And I\u00a0don't care that the guy who wrote this is my senior by more than a decade.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44907,"question": "Real example in my current day job:\n\n    class StuffParser {\n    public:\n        StuffParser() {}\n        Stuff Parse(Input); // code in .cpp\n    }\n\n    // elsewhere\n    StuffParser sp;\n    sp.parse(input)\n\nI found another similar example, except it used 2 member variables that were never accessed outside the method that did the parsing.\n\nI promptly transformed those into a function and a namespace. And I\u00a0don't care that the guy who wrote this is my senior by more than a decade.\n","aSentId": 44908,"answer": "Some possible reasons why StuffParser might be a class instead of a parseStuff() method:\n\n - Alternative implementations of StuffParser can be provided to users\n - The StuffParser implementation can be independently tested\n\nSometimes these things are useful. Sometimes.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44909,"question": "Some possible reasons why StuffParser might be a class instead of a parseStuff() method:\n\n - Alternative implementations of StuffParser can be provided to users\n - The StuffParser implementation can be independently tested\n\nSometimes these things are useful. Sometimes.","aSentId": 44910,"answer": "Don't forget encapsulation of state, which has all kinds of benefits. Consider a free parseStuff() function; it's likely this function will need some kind of state. At the very least some kind of read pointer, or a token stream or what have you, and of course the output structure that will be the result of the parse.\n\nNow, you could have all that as just local variables on the stack, sure. But likely your parser consists of multiple steps broken off into numerous helper functions, and those need access to the parser state. \"I can just pass it to them,\" you say, but that is going to quickly get out of hand if the parsing process is complex enough, and presents further difficulties and convolutions in languages that don't support passing by reference (e.g. Java).\n\nMaybe at some point you have the (poor) idea to just store all state statically, then. You've kind of sorted the access problem, but now you have a bunch of other problems such as having to deal with cleanup or risking contaminating future parses, and parallelism is completely out of the window.\n\nThen, you might make a state object and just pass that along everywhere... which is the same as an object except you're going about it in an unnecessarily circuitous way.\n\nAdded to this is of course all the benefits related to separation of responsibility and so forth. A parseStuff() method just sitting around within the context of something else is harder to work with and reason about than a class with a clearly defined interface. Small classes aren't bad. It's not like there's a huge cost associated with the StuffParser class existing in the project, and the benefits probably outweigh the costs.\n\n\nE: In this particular example, there is no additional state. But that doesn't detract from other benefits and it doesn't help code clarity to fold methods into other places just because you technically *could*. Also consider futureproofing - maybe one day you *will* require more state.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44911,"question": "Don't forget encapsulation of state, which has all kinds of benefits. Consider a free parseStuff() function; it's likely this function will need some kind of state. At the very least some kind of read pointer, or a token stream or what have you, and of course the output structure that will be the result of the parse.\n\nNow, you could have all that as just local variables on the stack, sure. But likely your parser consists of multiple steps broken off into numerous helper functions, and those need access to the parser state. \"I can just pass it to them,\" you say, but that is going to quickly get out of hand if the parsing process is complex enough, and presents further difficulties and convolutions in languages that don't support passing by reference (e.g. Java).\n\nMaybe at some point you have the (poor) idea to just store all state statically, then. You've kind of sorted the access problem, but now you have a bunch of other problems such as having to deal with cleanup or risking contaminating future parses, and parallelism is completely out of the window.\n\nThen, you might make a state object and just pass that along everywhere... which is the same as an object except you're going about it in an unnecessarily circuitous way.\n\nAdded to this is of course all the benefits related to separation of responsibility and so forth. A parseStuff() method just sitting around within the context of something else is harder to work with and reason about than a class with a clearly defined interface. Small classes aren't bad. It's not like there's a huge cost associated with the StuffParser class existing in the project, and the benefits probably outweigh the costs.\n\n\nE: In this particular example, there is no additional state. But that doesn't detract from other benefits and it doesn't help code clarity to fold methods into other places just because you technically *could*. Also consider futureproofing - maybe one day you *will* require more state.","aSentId": 44912,"answer": "You're conflating the bundling of state into a struct being passed around (which is a great idea) with OOP. OOP is way bigger than that and has too much of a siren call to start doing things like virtually-dispatching your parser methods instead of just expanding the parser, which is more readable and flexible anyway.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44913,"question": "You're conflating the bundling of state into a struct being passed around (which is a great idea) with OOP. OOP is way bigger than that and has too much of a siren call to start doing things like virtually-dispatching your parser methods instead of just expanding the parser, which is more readable and flexible anyway.","aSentId": 44914,"answer": "You're reading too much into what's being said. The question is: \"Why is StuffParser a class and not a free function\"? Encapsulated state is part of that reason. No one ever said anything about virtual methods (and they don't sound like a good fit for this use case) or OOP in general with regard to StuffParser.\n\nJust because the OOP toolbox has a hammer in it doesn't mean you should use it to drive screws. It's also disingenuous to suggest that because I used the hammer to pound in a nail that I'm somehow at risk for going on a screw-pounding spree.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44915,"question": "You're reading too much into what's being said. The question is: \"Why is StuffParser a class and not a free function\"? Encapsulated state is part of that reason. No one ever said anything about virtual methods (and they don't sound like a good fit for this use case) or OOP in general with regard to StuffParser.\n\nJust because the OOP toolbox has a hammer in it doesn't mean you should use it to drive screws. It's also disingenuous to suggest that because I used the hammer to pound in a nail that I'm somehow at risk for going on a screw-pounding spree.\n","aSentId": 44916,"answer": "&gt; Then, you might make a state object and just pass that along everywhere... which is the same as an object except you're going about it in an unnecessarily circuitous way.\n\nI'm saying that the state struct way is not \"unnecessarily circuitous\" (and it's how everyone did it before OOP) and also has the benefit of keeping the screws away from the hammer, so to speak.\n\nWhen you use a class with a method it's kind of like using a big multi-tool as hammer, with all the mental overhead that classes bring for all the features you're not using. This is the same argument of not making OOP a language-level default, applied at a smaller scale.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44917,"question": "&gt; Then, you might make a state object and just pass that along everywhere... which is the same as an object except you're going about it in an unnecessarily circuitous way.\n\nI'm saying that the state struct way is not \"unnecessarily circuitous\" (and it's how everyone did it before OOP) and also has the benefit of keeping the screws away from the hammer, so to speak.\n\nWhen you use a class with a method it's kind of like using a big multi-tool as hammer, with all the mental overhead that classes bring for all the features you're not using. This is the same argument of not making OOP a language-level default, applied at a smaller scale.","aSentId": 44918,"answer": "&gt; and it's how everyone did it before OOP\n\nThis is not an argument. Before high-level languages, we all wrote code in assembly, but I certainly hope you're not advocating we go back to that as the everyday general-purpose software development technique. \"We did it this way before and it worked for us, harrumph!\"\n\nNow...\n\n&gt; I'm saying that the state struct way is not \"unnecessarily circuitous\"\n\nIt is if you're actually within a language that has more appropriate conventions for dealing with that, which it sounds like this StuffParser class is. At the end of the day, a nonvirtual method call is just syntactic sugar for a free function call with an implicit state pointer as the first argument (*this* in Java/C++/C#, *self* in Python etc.) - but because the language was designed with objects and methods in mind, there are all sorts of benefits to actually working *with* the language instead of stubbornly refusing to do so out of some imagined fear that as soon as you start taking hammers to nails, it'll only be a matter of time before we start taking them to screws, window panes, and beloved pets!\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44913,"question": "You're conflating the bundling of state into a struct being passed around (which is a great idea) with OOP. OOP is way bigger than that and has too much of a siren call to start doing things like virtually-dispatching your parser methods instead of just expanding the parser, which is more readable and flexible anyway.","aSentId": 44920,"answer": "This discussion really is endless. When several ideas in CS are battling to the death for over a decade and none wins it's usually because they all have a lot of merit but unfortunately can't be fully merged, and I'm almost sure that is the case here.\n\nIn other words, none of them is better or worse, learning the strengths and weakness of all of them is the only true path to mastery, and even then nothing will keep you from making the wrong choice sometimes. These are deep fundamental tradeoffs and our squishy human brains and ever changing landscapes will never allows us to get away with something as easy as OOP is best or functional is all you need until you don't.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44911,"question": "Don't forget encapsulation of state, which has all kinds of benefits. Consider a free parseStuff() function; it's likely this function will need some kind of state. At the very least some kind of read pointer, or a token stream or what have you, and of course the output structure that will be the result of the parse.\n\nNow, you could have all that as just local variables on the stack, sure. But likely your parser consists of multiple steps broken off into numerous helper functions, and those need access to the parser state. \"I can just pass it to them,\" you say, but that is going to quickly get out of hand if the parsing process is complex enough, and presents further difficulties and convolutions in languages that don't support passing by reference (e.g. Java).\n\nMaybe at some point you have the (poor) idea to just store all state statically, then. You've kind of sorted the access problem, but now you have a bunch of other problems such as having to deal with cleanup or risking contaminating future parses, and parallelism is completely out of the window.\n\nThen, you might make a state object and just pass that along everywhere... which is the same as an object except you're going about it in an unnecessarily circuitous way.\n\nAdded to this is of course all the benefits related to separation of responsibility and so forth. A parseStuff() method just sitting around within the context of something else is harder to work with and reason about than a class with a clearly defined interface. Small classes aren't bad. It's not like there's a huge cost associated with the StuffParser class existing in the project, and the benefits probably outweigh the costs.\n\n\nE: In this particular example, there is no additional state. But that doesn't detract from other benefits and it doesn't help code clarity to fold methods into other places just because you technically *could*. Also consider futureproofing - maybe one day you *will* require more state.","aSentId": 44922,"answer": "In the particular case I described:\n\n- The only state the parser need are the input and the output.\n   + The output is build by modifying a singleton in place. (Singleton is ugly, but we only have one in our program.)\n   + The input is a file handle.\n\n- The parser takes less than 100 lines of code. There are a few iterations and no recursion. It fits in a single function. I would probably have broken it into several helper functions, but that would be it.\n\n- The parser state being implicit in the file handle position, and the singleton, it would be easy to \"pass\" it among the functions. Only major drawback: no backtracking allowed. Thankfully, the parsed format is very simple, and doesn't require that.\n\n- The interface of our parser is a single procedure. Or, a single method in a class. The former is a bit simpler.\n\n- The problem is not with the class being small. It is with it being essentially *stateless*, and therefore useless.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44909,"question": "Some possible reasons why StuffParser might be a class instead of a parseStuff() method:\n\n - Alternative implementations of StuffParser can be provided to users\n - The StuffParser implementation can be independently tested\n\nSometimes these things are useful. Sometimes.","aSentId": 44924,"answer": "Alternative implementations of parse with the same function type could be provided as well. \n\nA function can be independently tested, too.\n\nAlthough, a class may be more convenient if the parser required some kind of push-down automation (i.e. a stack).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44909,"question": "Some possible reasons why StuffParser might be a class instead of a parseStuff() method:\n\n - Alternative implementations of StuffParser can be provided to users\n - The StuffParser implementation can be independently tested\n\nSometimes these things are useful. Sometimes.","aSentId": 44926,"answer": "&gt; Alternative implementations of StuffParser can be provided to users\n\nChange `StuffParser` to `std::function&lt;Stuff(Input)&gt;` and again you can deal with multiple implementations.\n\n&gt; The StuffParser implementation can be independently tested\n\nThis already is true. Again if you want to do a series of tests that \"all StuffParser must pass\" then you can do the above and make it for functions.\n\nThe plus is that people using the function directly have a clearer understanding of what is happening and can handle it better. No need to generate an object instance that does nothing (but take up the vtable space).\n\nThis also allows you to send the function not just as a dynamic parameter, but also as a static template argument, which can be useful for inline or other things. Sometimes.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44930,"question": "Both points hold for functions too, even more so.\n\nJust pass around function pointers/closures. Maybe provide a `typedef Stuff (*StuffParser)(Input);` or `typedef std::function&lt;Stuff(Input)&gt; StuffParser;` (don't nail me on syntax).\n\nSingle method interfaces are unnecessary clutter when compared to functions in every possible way (except for having a real distinct type, not a typedef).","aSentId": 44931,"answer": "&gt; Just pass around function pointers/closures.\n\nWhy go to such unnecessary lengths when the language, as a *language feature*, already provides you with exactly the tools you need without having to resort to that? Function pointers have their purposes, but none of those purposes are \"clunkily reinvent what the language already does for you in a seamless way\". Work *with* your tools, not against them.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44932,"question": "&gt; Just pass around function pointers/closures.\n\nWhy go to such unnecessary lengths when the language, as a *language feature*, already provides you with exactly the tools you need without having to resort to that? Function pointers have their purposes, but none of those purposes are \"clunkily reinvent what the language already does for you in a seamless way\". Work *with* your tools, not against them.\n","aSentId": 44933,"answer": "Are you trying to tell me objects are more fundamental than function references, solely on the basis that you are more familiar with objects? Function references have been around for much longer, carry less overhead and so on and so forth. They are as much a feature of C++ as are objects.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44934,"question": "Are you trying to tell me objects are more fundamental than function references, solely on the basis that you are more familiar with objects? Function references have been around for much longer, carry less overhead and so on and so forth. They are as much a feature of C++ as are objects.","aSentId": 44935,"answer": "We don't judge something's usefulness by how \"fundamental\" it is, but by the benefits it affords us when used. I'm telling you that in C++, in the vast majority of use cases member function calls are more useful, easier to use, more expressive, and less error-prone than free function pointers. Again, this is not to say function pointers are not a useful tool - they certainly are - but the suggested use of them here is just a strange patch to achieve the same functionality as an existing language feature for no reason other than a pathological need to not use the language feature.\n\n&gt;  solely on the basis that you are more familiar with objects\n\nThis is a strawman and I'd like you not to claim I said things I never did.\n\n&gt; Function references have been around for much longer\n\nNot an argument. By that logic, using assembly is superior because it's been around even longer and is even *more* \"fundamental\" than *any* high-level construct.\n\n&gt; carry less overhead \n\nThis isn't even true.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44936,"question": "We don't judge something's usefulness by how \"fundamental\" it is, but by the benefits it affords us when used. I'm telling you that in C++, in the vast majority of use cases member function calls are more useful, easier to use, more expressive, and less error-prone than free function pointers. Again, this is not to say function pointers are not a useful tool - they certainly are - but the suggested use of them here is just a strange patch to achieve the same functionality as an existing language feature for no reason other than a pathological need to not use the language feature.\n\n&gt;  solely on the basis that you are more familiar with objects\n\nThis is a strawman and I'd like you not to claim I said things I never did.\n\n&gt; Function references have been around for much longer\n\nNot an argument. By that logic, using assembly is superior because it's been around even longer and is even *more* \"fundamental\" than *any* high-level construct.\n\n&gt; carry less overhead \n\nThis isn't even true.\n","aSentId": 44937,"answer": "I'm not claiming anything about you, I was asking you because I'm sure you know yourself better than me.\n\nI'm not trying to argue that the oldest is the bestest. I'm just saying that it seemed like you were dismissing function references as if they were some sort of cheap method call imitation, which is absolutely not the case. I much prefer to work with functions over methods, for pretty much the same reasons as you prefer to work with methods.\n\nI'm not trying to say function references are superior to methods, all I'm saying is that they aren't demonstrated to be inferior. They are just as valid a choice as methods.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44938,"question": "I'm not claiming anything about you, I was asking you because I'm sure you know yourself better than me.\n\nI'm not trying to argue that the oldest is the bestest. I'm just saying that it seemed like you were dismissing function references as if they were some sort of cheap method call imitation, which is absolutely not the case. I much prefer to work with functions over methods, for pretty much the same reasons as you prefer to work with methods.\n\nI'm not trying to say function references are superior to methods, all I'm saying is that they aren't demonstrated to be inferior. They are just as valid a choice as methods.","aSentId": 44939,"answer": "&gt; They are just as valid a choice as methods.\n\nIn the right context. There are many contexts where they are not. (By the way, let us not forget that member function pointers are function pointers too, and branching through a function pointer is not fundamentally different from branching through a vtable.) Function pointers are useful for a lot of things - predicates, callbacks, event handlers and more - but they're a syntactic obstruction in many more cases, especially when state is involved.\n\nI don't know where you got the idea that I was \"dismissing function references\" given that I've said twice before this post, and three times in total now, that function pointers are useful. But not universally so, and not when they're used in lieu of simpler and more expressive language features.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44907,"question": "Real example in my current day job:\n\n    class StuffParser {\n    public:\n        StuffParser() {}\n        Stuff Parse(Input); // code in .cpp\n    }\n\n    // elsewhere\n    StuffParser sp;\n    sp.parse(input)\n\nI found another similar example, except it used 2 member variables that were never accessed outside the method that did the parsing.\n\nI promptly transformed those into a function and a namespace. And I\u00a0don't care that the guy who wrote this is my senior by more than a decade.\n","aSentId": 44941,"answer": "I see this, too-- I can't remember nor seem to find who said it, but it has stuck with me: \"Everything is an object,\" which is generally a Good Thing, is not the same as \"Everything is implemented in an instance of a user-defined class.\"  That StuffParser seems like an example of the latter.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44907,"question": "Real example in my current day job:\n\n    class StuffParser {\n    public:\n        StuffParser() {}\n        Stuff Parse(Input); // code in .cpp\n    }\n\n    // elsewhere\n    StuffParser sp;\n    sp.parse(input)\n\nI found another similar example, except it used 2 member variables that were never accessed outside the method that did the parsing.\n\nI promptly transformed those into a function and a namespace. And I\u00a0don't care that the guy who wrote this is my senior by more than a decade.\n","aSentId": 44943,"answer": "A lot of that comes from the irrational fear of static methods. Far too many Java and C# developers are convinced that the are an unholy and untestable terror. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44944,"question": "A lot of that comes from the irrational fear of static methods. Far too many Java and C# developers are convinced that the are an unholy and untestable terror. ","aSentId": 44945,"answer": "That reminds me: with that colleague, the onus is on *me* to justify static methods over class instantiation. Which of course baffles my functional reflexes.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44946,"question": "That reminds me: with that colleague, the onus is on *me* to justify static methods over class instantiation. Which of course baffles my functional reflexes.\n","aSentId": 44947,"answer": "I wish I knew the solution to that. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44944,"question": "A lot of that comes from the irrational fear of static methods. Far too many Java and C# developers are convinced that the are an unholy and untestable terror. ","aSentId": 44949,"answer": "IMO, it's because static methods with IO are extremely difficult to avoid (e.g., stub/mock) when you're trying to test the code around them.  I think static methods without side effects are great.  In Java, I don't mind when someone uses `StringUtils.isBlank`, but I hate when someone uses `DatabaseConnection.executeUpdate`.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44951,"question": "Surprised it's not inheriting from an empty Parser class. ","aSentId": 44952,"answer": "If I let him refactor the code, it probably would have.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44954,"question": "What is the issue? An empty class should be optimized away\n\nBut I just found something similar that is problematic:\n\n    class StuffParser {\n    public:\n        StuffParser() {}\n        void Parse(Input); \n        Result Evaluate(Data);\n     private:\n        fields only used during parsing ... ;\n        fields only used during evaluation ... ;\n    }","aSentId": 44955,"answer": "This is not about optimization. It is about simplifying the interface as much as we possibly could. I don't care about the following being more optimized:\n\n    namespace StuffParser {\n        void Parse(Input); \n        Result Evaluate(Data);\n    }\n\nI care about it being _simpler_. Granted, only marginally so. But every bit helps.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44956,"question": "This is not about optimization. It is about simplifying the interface as much as we possibly could. I don't care about the following being more optimized:\n\n    namespace StuffParser {\n        void Parse(Input); \n        Result Evaluate(Data);\n    }\n\nI care about it being _simpler_. Granted, only marginally so. But every bit helps.","aSentId": 44957,"answer": "How does the input get to the result then?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44958,"question": "How does the input get to the result then?","aSentId": 44959,"answer": "Ah, my mistake:\n\n    Data Parse(Input); \n    Result Evaluate(Data);\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44961,"question": "Refactoring code simply because you disagree with the design decision of the original author rarely is a good use of time.  There are a number of reasons why this may have been designed as a class; if it isn't causing problems at the moment, best to just leave it as-is.\n ","aSentId": 44962,"answer": "I did that in passing, took me about 2 minutes (including the time it took to push the thing to the repository), and it cleaned up the call site a bit. Call site that **I** control.\n\nI'm confident this was just a design mistake, born out of OOP reflexes. It's simple, really: when you have 2 methods, one of which is `init()` (or the constructor), the thing has no business being a class.\n\nWorst case, it will take 2 minutes to get back to the ugly version, should it ever be needed. (But seriously, it won't. It's a simple parsing algorithm for a simple data format that is unlikely to change.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44961,"question": "Refactoring code simply because you disagree with the design decision of the original author rarely is a good use of time.  There are a number of reasons why this may have been designed as a class; if it isn't causing problems at the moment, best to just leave it as-is.\n ","aSentId": 44964,"answer": "&gt; Refactoring code simply because you disagree with the design decision of the original author rarely is a good use of time.\n\nBad code shouldn't be allowed to linger in an application, especially bad code that is so easily corrected.\n\n&gt; There are a number of reasons why this may have been designed as a class\n\nIf there are any legitimate reasons why it was designed that way, the compiler would have catch his change and flagged it as an error.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44901,"question": "The reason you might say OOP is dying even while many of its pieces are thriving is that OOP as a whole is a bunch of bad default design choices. However vague it is, it still tends to focus on things like inheritance, polymorphism through late binding, and thinking in terms of a single object and its behavior.\n\nThese things tend to be harmful for code maintenance and readability. Yes, they do have their place (even the Linux kernel uses vtables for various systems), but they should never be the default choice, and they probably don't even need to be built into the language to be useful. The default should be simple functions that operate on plain old data at the scale that makes sense for the program, whether that's a single object or a huge collection (think databases, particle systems, etc. for examples of when you *definitely do not* want typical OOP).\n\nThey're also incredibly harmful for performance, and I don't mean performance in the petty \"but virtual calls are sloooooow!\" way- I mean it in the \"but now you can't hand this off to your Cell processor or GPU without rewriting the entire thing\" way. This is the other reason they shouldn't be the default- well-designed simple functions are easier to write, understand, and change, as well as easier to optimize when needed, because you just have raw data that you can reorganize whenever you need to without blowing up your whole object hierarchy.\n\nI also don't buy the \"but OOP forces good structure on huge projects\" argument either. The default tools of OOP can obfuscate the real functionality of the code by encouraging people to hide things behind separated virtual functions in an inheritance hierarchy. You have to be just as disciplined to get a good OOP codebase as you do to get a (simpler, more flexible) non-OOP codebase.","aSentId": 44966,"answer": "If performance is your goal then you should not move beyond bits and bytes and assembly instructions. \n\nI think it is incorrect to say Cell can not support OOP patterns and therefore it is a bad design choice. If you are writing a game then by all means make choices that matter in game design but if you're designing a web service that shuttles data back and forth between different sub-systems with well-designed interfaces then encapsulating those sub-systems with objects is the most obvious way to go.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44967,"question": "If performance is your goal then you should not move beyond bits and bytes and assembly instructions. \n\nI think it is incorrect to say Cell can not support OOP patterns and therefore it is a bad design choice. If you are writing a game then by all means make choices that matter in game design but if you're designing a web service that shuttles data back and forth between different sub-systems with well-designed interfaces then encapsulating those sub-systems with objects is the most obvious way to go.","aSentId": 44968,"answer": "You can and should care about performance in many areas beyond \"bits and bytes and assembly.\" The beauty of languages like C is that you can continue to care about data layout and execution model while taking advantage of higher-level programming language tools.\n\nShuffling data around is in fact one of the main things any program does, games included. And OOP is a bad way to think about that, because it doesn't work in terms of the data or the interfaces the data travels through- it deals in terms of objects that often don't match up with the data patterns needed by the program. This is bad for performance on CPUs too, as well as readability/etc.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44969,"question": "You can and should care about performance in many areas beyond \"bits and bytes and assembly.\" The beauty of languages like C is that you can continue to care about data layout and execution model while taking advantage of higher-level programming language tools.\n\nShuffling data around is in fact one of the main things any program does, games included. And OOP is a bad way to think about that, because it doesn't work in terms of the data or the interfaces the data travels through- it deals in terms of objects that often don't match up with the data patterns needed by the program. This is bad for performance on CPUs too, as well as readability/etc.","aSentId": 44970,"answer": "We're just talking past each other. I've never had to care for any indirection introduced by any OOP languages and all my performance gains have been from implementing the right algorithm and going from exponential complexity to some polynomial one. A constant here and there is not relevant in the grand scheme of things. If that's your only argument against OOP then it's not much of an argument in my opinion.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44971,"question": "We're just talking past each other. I've never had to care for any indirection introduced by any OOP languages and all my performance gains have been from implementing the right algorithm and going from exponential complexity to some polynomial one. A constant here and there is not relevant in the grand scheme of things. If that's your only argument against OOP then it's not much of an argument in my opinion.","aSentId": 44972,"answer": "It's not my only argument, or even my first, though it is a good one for games and systems programming. The main problem that I spent most of my first post here talking about is that OOP makes things less readable and less flexible.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44839,"question": "I think the reason OOP survived this long is right there in the article:\n\n&gt; Looking at the big picture, I can see that object orientation is not a paradigm, but a set of mechanics we can cherry pick.\n\nThis. These set of mechanics that OOP languages provide have proven useful and usable in many paradigms. Even ECS can (and often does) piggyback on these OOP mechanics rather than replace them.","aSentId": 44974,"answer": "&gt; OOP languages provide have proven useful and usable in many paradigms\n\nNothing special about the \"OOP languages\" here.   Where those paradigms are useful, they're used even in non-OOP languages.\n\nI think a good example is how C's  \"FILE *\" type; and how it exposes the same interface regardless of whether you construct it with fopen() pointing at a file on disk, or with popen() doing inter-process communication.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44977,"question": "The author has taken a very rigid definition of OOP, proven it doesn't accurately describe the current landscape, and then uses that to explain that OOP is dying. No, the definition is changing. It, and its usage, are both becoming more abstract, as is the trend of the industry.","aSentId": 44978,"answer": "&gt; No, the definition is changing.\n\nYes, that is exactly what my article was saying. And that *bothers* me. \"OOP\" is changing meaning too quickly to be honest.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44837,"question": "The repeated deaths of OOP","aSentId": 44980,"answer": "solve the problem in a robust, easily understood, easily maintained, easily modified manner and i don't care how the hell you do it.\n\nTHAT should be the driving argument.  ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44981,"question": "solve the problem in a robust, easily understood, easily maintained, easily modified manner and i don't care how the hell you do it.\n\nTHAT should be the driving argument.  ","aSentId": 44982,"answer": "The problem, is easily maintained and understood _by whom_?\n\nSo many times I hear that OOP is more maintainable\u2026 (the subtext is, more maintainable than everything else, by the \"maintenance programmer\").\n\nSomehow, the maintenance programmer is always a junior programmer that doesn't understand math, and only learned OOP (as in, the favourite flavour of OOP of the person arguing against your idea).\n\nSo, that argument doesn't work. For it to really work, we need peer-reviewed experiments to back them up, or it's just a matter of who has the bigger mouth.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44983,"question": "The problem, is easily maintained and understood _by whom_?\n\nSo many times I hear that OOP is more maintainable\u2026 (the subtext is, more maintainable than everything else, by the \"maintenance programmer\").\n\nSomehow, the maintenance programmer is always a junior programmer that doesn't understand math, and only learned OOP (as in, the favourite flavour of OOP of the person arguing against your idea).\n\nSo, that argument doesn't work. For it to really work, we need peer-reviewed experiments to back them up, or it's just a matter of who has the bigger mouth.\n\n","aSentId": 44984,"answer": "peer reviewed experiments are never gonna happen.  it'd be interesting but stuff is too entrenched.\n\nme?  i solve problems for pay.  someone wanna pay me to create an overblown OOP solution?  ok.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44985,"question": "peer reviewed experiments are never gonna happen.  it'd be interesting but stuff is too entrenched.\n\nme?  i solve problems for pay.  someone wanna pay me to create an overblown OOP solution?  ok.","aSentId": 44986,"answer": "I think peer reviewed experiments must already be happening, I don't see big tech companies avoiding those kinds of decisions.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44987,"question": "I think peer reviewed experiments must already be happening, I don't see big tech companies avoiding those kinds of decisions.","aSentId": 44988,"answer": "Should the research be done, and given how long the issue has been out there it either has been done or won't be, I suspect the answer is something like, \"programers with few years experience may see some differences between approaches, but after that the most effective approach is the one the team is experienced in.\"\n\nNo strategy will make an inexperienced team more effective than an experienced team on their home turf except massive amounts of resources. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44989,"question": "Should the research be done, and given how long the issue has been out there it either has been done or won't be, I suspect the answer is something like, \"programers with few years experience may see some differences between approaches, but after that the most effective approach is the one the team is experienced in.\"\n\nNo strategy will make an inexperienced team more effective than an experienced team on their home turf except massive amounts of resources. ","aSentId": 44990,"answer": "Obviously what you are experienced in will dictate what you are good at. What's interesting is trying to get to the non-subjective factor by doing the experiments while controlling for experience level.\n\nIf it turns out that logic programming (to not step on anybodys toes) is 5% better than the other paradigms *while controlling for* experience level, *then* we can start making informed tradeoffs. \"Hey, if we retrain our team to use logic programming, their initial output will drop by 20 percent the first five months, but in the long term, their productivity will increase by 5 percent. Is this worth it?\"\n\n*That* is progress.\n\nIt was never about being able to say, \"Logic programming is best, screw the rest.\" It's always been about being able to make tradeoffs based on facts, not on wild guesses.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44985,"question": "peer reviewed experiments are never gonna happen.  it'd be interesting but stuff is too entrenched.\n\nme?  i solve problems for pay.  someone wanna pay me to create an overblown OOP solution?  ok.","aSentId": 44992,"answer": "I could never do that. I'd burn out in a couple months.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44993,"question": "I could never do that. I'd burn out in a couple months.","aSentId": 44994,"answer": "OOP isn't that challenging, its flaws are mostly it's not very efficient or elegant, somewhat less legible, sometimes, but a debugger usually sheds lights on any confusing areas pretty quickly (unless a lot of frameworks are involved.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44995,"question": "OOP isn't that challenging, its flaws are mostly it's not very efficient or elegant, somewhat less legible, sometimes, but a debugger usually sheds lights on any confusing areas pretty quickly (unless a lot of frameworks are involved.)","aSentId": 44996,"answer": "My problem is not with the \"OOP\" part I can survive that. I *do* survive that. It's the \"overblown\" part that kills me.\n\nSimply put, if the OOP solution is too suboptimal (too complex, bloated brittle etc\u2026), I simply won't do it, it would be too unethical.\n\nNow producing something *slightly* more complex than it could be, for the sake of my colleagues who don't understand anything besides OOP? I do that all day. 'Cause at the end of the day, what is optimal also depends on who reads the code. If I worked for Don Stewart (/u/dons) or Simon Peyton Jones, my code would be very different.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44985,"question": "peer reviewed experiments are never gonna happen.  it'd be interesting but stuff is too entrenched.\n\nme?  i solve problems for pay.  someone wanna pay me to create an overblown OOP solution?  ok.","aSentId": 44998,"answer": "Well, it is like murdering a lot of innocent children (not regular little shits) but I suppose some have the stomach for it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44981,"question": "solve the problem in a robust, easily understood, easily maintained, easily modified manner and i don't care how the hell you do it.\n\nTHAT should be the driving argument.  ","aSentId": 45000,"answer": "That's exactly what OOP fails to deliver, despite all the promises.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45001,"question": "That's exactly what OOP fails to deliver, despite all the promises.","aSentId": 45002,"answer": "i disagree.  i've seen workable/unworkable solutions using both procedural and OOP.\n\n\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45003,"question": "i disagree.  i've seen workable/unworkable solutions using both procedural and OOP.\n\n\n\n","aSentId": 45004,"answer": "&gt; both procedural and OOP\n\nThere are more things in heaven and earth, /u/anon0108, than are dreamt of in your philosophy.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45005,"question": "&gt; both procedural and OOP\n\nThere are more things in heaven and earth, /u/anon0108, than are dreamt of in your philosophy.","aSentId": 45006,"answer": "i use the groupings as they did in the article - basically procedural, OOP and everything else","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45003,"question": "i disagree.  i've seen workable/unworkable solutions using both procedural and OOP.\n\n\n\n","aSentId": 45008,"answer": "We may have different thresholds of what is \"robust, easily understood and easily maintained\". In my book, OOP fails almost everywhere, besides a very narrow and specific domain of the multi-agent simulations. Any other domain does not map on anything \"object\" at all.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45009,"question": "We may have different thresholds of what is \"robust, easily understood and easily maintained\". In my book, OOP fails almost everywhere, besides a very narrow and specific domain of the multi-agent simulations. Any other domain does not map on anything \"object\" at all.","aSentId": 45010,"answer": "we probably do.\n\nand i have always used a very loose, simplistic definition of OOP.\n\nso loose and simplistic, people selling training couldn't possibly make money on it - which is, i think, why some OOP solutions have become the behemoths they are.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45011,"question": "we probably do.\n\nand i have always used a very loose, simplistic definition of OOP.\n\nso loose and simplistic, people selling training couldn't possibly make money on it - which is, i think, why some OOP solutions have become the behemoths they are.","aSentId": 45012,"answer": "I don't care at all about OOP as a set of language features. What is really damaging is OOP as a way of thinking, as a design methodology. The real world is not made of hierarchies of objects communicating via messages, and any attempt of sledgehammering any real-world problem into this framework is disastrous.\n\n If you're only after some dynamic dispatch and a poor man substitute for the real modules and namespaces, OOP is ok.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45013,"question": "I don't care at all about OOP as a set of language features. What is really damaging is OOP as a way of thinking, as a design methodology. The real world is not made of hierarchies of objects communicating via messages, and any attempt of sledgehammering any real-world problem into this framework is disastrous.\n\n If you're only after some dynamic dispatch and a poor man substitute for the real modules and namespaces, OOP is ok.","aSentId": 45014,"answer": "&gt; What is really damaging is OOP as a way of thinking, as a design methodology.\n\nif you're talking about shoving every problem thru OOP to come up with a solution then yeah, i agree.\n\nthere is no 1 single design methodology applicable to *every* problem.  i think you are best off looking at the problem and deciding for yourself\n\nof course, that requires thought and people don't like thinking.\n\nhell of a lot easier to jam something into a design pattern and call it done\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45015,"question": "&gt; What is really damaging is OOP as a way of thinking, as a design methodology.\n\nif you're talking about shoving every problem thru OOP to come up with a solution then yeah, i agree.\n\nthere is no 1 single design methodology applicable to *every* problem.  i think you are best off looking at the problem and deciding for yourself\n\nof course, that requires thought and people don't like thinking.\n\nhell of a lot easier to jam something into a design pattern and call it done\n","aSentId": 45016,"answer": "&gt; there is no 1 single design methodology applicable to every problem\n\nPrecisely. So the only reasonable paradigm is to always choose a paradigm suitable for your task. If there is no fitting paradigm, invent one.\n\n&gt; of course, that requires thought and people don't like thinking\n\nOne of the promises of OOP/OOD was that modelling and thinking will become mechanical, that by simply applying all that design patterns and such one would be able to map a problem domain definition to a workable model. This never really happened neither.\n\nSo, yes, people do not want to think, and that's totally ok. But as a result they have to think much more to overcome all the deficiencies of their OOP designs.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45017,"question": "&gt; there is no 1 single design methodology applicable to every problem\n\nPrecisely. So the only reasonable paradigm is to always choose a paradigm suitable for your task. If there is no fitting paradigm, invent one.\n\n&gt; of course, that requires thought and people don't like thinking\n\nOne of the promises of OOP/OOD was that modelling and thinking will become mechanical, that by simply applying all that design patterns and such one would be able to map a problem domain definition to a workable model. This never really happened neither.\n\nSo, yes, people do not want to think, and that's totally ok. But as a result they have to think much more to overcome all the deficiencies of their OOP designs.","aSentId": 45018,"answer": "&gt; If there is no fitting paradigm, invent one.\n\ni agree.\n\nso why aren't we rich?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45019,"question": "&gt; If there is no fitting paradigm, invent one.\n\ni agree.\n\nso why aren't we rich?","aSentId": 45020,"answer": "Paradigms do not sell well. Unless it's a cult-like paradigm for which you can sell training courses, plant the resident gurus, publish tons of books, etc. Just the same as with any other religion.\n\nParadigms that work - well, they just work. Solve the problems.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45021,"question": "Paradigms do not sell well. Unless it's a cult-like paradigm for which you can sell training courses, plant the resident gurus, publish tons of books, etc. Just the same as with any other religion.\n\nParadigms that work - well, they just work. Solve the problems.","aSentId": 45022,"answer": "ok.  you be the guru, i'll go out and start spreading the word thru on site seminars ;-)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45003,"question": "i disagree.  i've seen workable/unworkable solutions using both procedural and OOP.\n\n\n\n","aSentId": 45024,"answer": "OOP is a bunch of default tools in people's thought processes that tend to make things a little more fragile, obfuscated, and brittle than they would be otherwise.\n\nThose tools are of course still useful when the tradeoff makes sense, but building them into the language and/or having \"OOP\" be a thing to collect them leads to their overuse.\n\nI'm all for a little OOP-bashing if it gets people to think about alternatives before they jump into building an inheritance hierarchy.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45025,"question": "OOP is a bunch of default tools in people's thought processes that tend to make things a little more fragile, obfuscated, and brittle than they would be otherwise.\n\nThose tools are of course still useful when the tradeoff makes sense, but building them into the language and/or having \"OOP\" be a thing to collect them leads to their overuse.\n\nI'm all for a little OOP-bashing if it gets people to think about alternatives before they jump into building an inheritance hierarchy.","aSentId": 45026,"answer": "&gt; OOP is a bunch of default tools \n\nwow.  how long has it been thought of/presented in that fashion?\n\n&gt; but building them into the language\n\ni think that's actually useful.  a buddy once worked on an OOP project written in COBOL.  that always seemed to me to be shoving a square peg into a round hole","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45027,"question": "&gt; OOP is a bunch of default tools \n\nwow.  how long has it been thought of/presented in that fashion?\n\n&gt; but building them into the language\n\ni think that's actually useful.  a buddy once worked on an OOP project written in COBOL.  that always seemed to me to be shoving a square peg into a round hole","aSentId": 45028,"answer": "\"Default tools\" is just as close as I can get to a good definition of OOP- languages classified as \"OOP\" tend to have some number of those tools built in, and other languages tend to have different tools built in (or at least emphasized more strongly).\n\nI do think that *not* building things into the language can be helpful in ways beyond de-emphasizing their use. It lets you use them in the simplest form needed for the problem at hand (like structs of function pointers in the Linux kernel, used for the VFS among other things) and with more flexibility (you can put those function pointers anywhere to optimize for cache usage or to use patterns other than strict inheritance hierarchies).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45001,"question": "That's exactly what OOP fails to deliver, despite all the promises.","aSentId": 45030,"answer": "In practice, most people think OOP is making everything an interface and inheriting from it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 44837,"question": "The repeated deaths of OOP","aSentId": 45032,"answer": "Why does it need to die? Maybe it's just evolving, like how knowledge evolves","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45033,"question": "Why does it need to die? Maybe it's just evolving, like how knowledge evolves","aSentId": 45034,"answer": "If evolution leads you to \"Don't do that. It's bad.\", then yes, OOP is dying.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45033,"question": "Why does it need to die? Maybe it's just evolving, like how knowledge evolves","aSentId": 45036,"answer": "Would you survive a complete reshaping of your brain and personality? I'd say you wouldn't. I just killed you, replacing you with another person I just created from scratch. The fact that I used your body matter to do that is irrelevant.\n\nThe same went for OOP. The same name were used for very different concepts and paradigms, some of which are now looked down upon. Insisting on keeping the name doesn't make much sense in my opinion.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45037,"question": "Would you survive a complete reshaping of your brain and personality? I'd say you wouldn't. I just killed you, replacing you with another person I just created from scratch. The fact that I used your body matter to do that is irrelevant.\n\nThe same went for OOP. The same name were used for very different concepts and paradigms, some of which are now looked down upon. Insisting on keeping the name doesn't make much sense in my opinion.\n","aSentId": 45038,"answer": "what the holy hell are you talking about","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45037,"question": "Would you survive a complete reshaping of your brain and personality? I'd say you wouldn't. I just killed you, replacing you with another person I just created from scratch. The fact that I used your body matter to do that is irrelevant.\n\nThe same went for OOP. The same name were used for very different concepts and paradigms, some of which are now looked down upon. Insisting on keeping the name doesn't make much sense in my opinion.\n","aSentId": 45040,"answer": "Holy shit I think you need some vitamin D, dude.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45042,"question": "The reason OOP is \"bad\" isn't because it's useless or it's not a good solution for some problems... it's \"bad\" because it gets shoehorned in as a solution to every problem, and frankly, it sucks at some of those.\n\nRan into this mistake early in my coding career, when I had learned on C++ and couldn't for the life of me figure out why people still used C. Meanwhile, I was spending a lot of time coming up with clever, super complicated solutions that fit the model (but could have been done very simply and elegantly by dropping it). This is because I had been told \"OOP is the future! Everybody should use it for everything\" and I see that attitude from many of the academic sorts... the ones that never code anything useful just talk about the \"best worst case for algorithm x\". When doing that kind of work, sure, taking out hard stuff like static typing, memory management, etc. might make sense, and while your program is small (and doesn't need \"multiple inheritance\") OOP is easy, but it fails hard in real world applications... and yet, here we still use it, because it's all we're taught. It's like forming modern military strategy around the phalanx* because that's what you learned in high school.\n\nIn the meantime, I'm eagerly awaiting Jonathan Blow finishing his programming language because every time he talks about it, he gives me new solutions to problems that, in many cases, I thought I'd just have to deal with for the rest of my life.\n\n*Note that this is not a useless or entirely outdated strategy. Modern police forces, for instance, still use this to great effect.","aSentId": 45043,"answer": "&gt; In the meantime, I'm eagerly awaiting Jonathan Blow finishing his programming language\n\nOh yes, that guy has some good ideas. Personally though, I may not wait for him. I have [other plans](http://loup-vaillant.fr/tutorials/earley-parsing/) regarding language construction, that I think are promising.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45045,"question": "&gt; Message The process by which an object sends Passing information or invokes a method.\n\n...\n\n&gt; Java don't really support messages. You can call methods of course, but those are just as synchronous as ordinary function calls.\n\nI wish the author had expounded on this. Going by the way he has defined \"Message\", particularly with \" . . . or invokes a method\", there doesn't seem to be anything that precludes Java from having Message Passing. I don't see how being synchronous or not has anything to do with it.","aSentId": 45046,"answer": "Even if the authors definition of messages means they have to be asynchronous you can still implement that in Java as a library. In fact there are libraries that support asynchronous messaging in Java. So really Java supports that paradigm, it just has to be implemented on top of the base language.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45047,"question": "Even if the authors definition of messages means they have to be asynchronous you can still implement that in Java as a library. In fact there are libraries that support asynchronous messaging in Java. So really Java supports that paradigm, it just has to be implemented on top of the base language.","aSentId": 45048,"answer": "Every language supports every paradigm. It's useful to talk about which ones are most convenient to use in certain languages.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45045,"question": "&gt; Message The process by which an object sends Passing information or invokes a method.\n\n...\n\n&gt; Java don't really support messages. You can call methods of course, but those are just as synchronous as ordinary function calls.\n\nI wish the author had expounded on this. Going by the way he has defined \"Message\", particularly with \" . . . or invokes a method\", there doesn't seem to be anything that precludes Java from having Message Passing. I don't see how being synchronous or not has anything to do with it.","aSentId": 45050,"answer": "This paradigm is now known as Actor-Oriented Programming.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45045,"question": "&gt; Message The process by which an object sends Passing information or invokes a method.\n\n...\n\n&gt; Java don't really support messages. You can call methods of course, but those are just as synchronous as ordinary function calls.\n\nI wish the author had expounded on this. Going by the way he has defined \"Message\", particularly with \" . . . or invokes a method\", there doesn't seem to be anything that precludes Java from having Message Passing. I don't see how being synchronous or not has anything to do with it.","aSentId": 45052,"answer": "Nothing precludes Java from having it, but it sounds like the author was saying it's not built-in.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45054,"question": "In the real world (and OOP started out mostly as a real world metaphor), when you send a message, you don't wait for the reply to continue living your life.\n\nThat's basically it. To really be deserving of the name \"message\", it pretty much has to be asynchronous. At least, that's how I define the term.\n\nNow if you *really* want messages in Java, you need to use threads, or processes. As far as I know that's not the default.","aSentId": 45055,"answer": "I don't see why you need any sort of multiprocessing for being asynchronous. You do need some kind of callback mechanism. Old Java could do it in a clumsy way with anonymous classes, and does it better now with lambdas. Meanwhile, JavaScript can do it with closures, even in the browser where everything runs in a single thread.\n\nI can also see benefits to the never-return-anything-ever model in certain situations. The Unix shell pipeline is an example of this, and it has certainly been successful in its niche. I have my doubts about its universal applicability, though.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45056,"question": "I don't see why you need any sort of multiprocessing for being asynchronous. You do need some kind of callback mechanism. Old Java could do it in a clumsy way with anonymous classes, and does it better now with lambdas. Meanwhile, JavaScript can do it with closures, even in the browser where everything runs in a single thread.\n\nI can also see benefits to the never-return-anything-ever model in certain situations. The Unix shell pipeline is an example of this, and it has certainly been successful in its niche. I have my doubts about its universal applicability, though.","aSentId": 45057,"answer": "&gt; I don't see why you need any sort of multiprocessing for being asynchronous.\n\nBecause\u2026 you don't? Sorry about that.\n\nMy main point stands however: asynchrony is not natively supported by the language: method calls are synchronous by default.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45059,"question": "\n&gt; [Speaking about lambdas] This is a severe blow to OOP.\n\nI really don't understand this. Lambdas are just syntactic sugar that makes specific portions of the code code easier to read. Java has had those since 1.1 (in a very verbose way), they are completely orthogonal with all the attributes that are often given to OO programs.\n\nIf anything, the adoption of lambdas by a growing number of OOP languages is a sign that these languages are going to stay around for a very, very long time because they are adapting.\n","aSentId": 45060,"answer": "The languages and the paradigm are two different things. It is a blow to the paradigm if the languages have to transform themselves beyond recognition.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45061,"question": "The languages and the paradigm are two different things. It is a blow to the paradigm if the languages have to transform themselves beyond recognition.\n","aSentId": 45062,"answer": "Where does it say that a language stops being OOP if it adopts lambdas?\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45063,"question": "Where does it say that a language stops being OOP if it adopts lambdas?\n","aSentId": 45064,"answer": "Nowhere. But given the similarity between closures and objects, it *does* say that the language designers officially acknowledge that OOP is not the best tool for every job.\n\nThat acknowledgement itself is a huge blow to OOP.  It used to be king. Now it's merely president.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45065,"question": "Nowhere. But given the similarity between closures and objects, it *does* say that the language designers officially acknowledge that OOP is not the best tool for every job.\n\nThat acknowledgement itself is a huge blow to OOP.  It used to be king. Now it's merely president.","aSentId": 45066,"answer": "&gt; Nowhere. But given the similarity between closures and objects, it does say that the language designers officially acknowledge that OOP is not the best tool for every job.\n\nI honestly have absolutely no idea how these two ideas follow.\n\nAgain, Java has had closures since the late 90s, the fact that it now has official syntactic sugar for them doesn't change in any way its OOP status.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45067,"question": "&gt; Nowhere. But given the similarity between closures and objects, it does say that the language designers officially acknowledge that OOP is not the best tool for every job.\n\nI honestly have absolutely no idea how these two ideas follow.\n\nAgain, Java has had closures since the late 90s, the fact that it now has official syntactic sugar for them doesn't change in any way its OOP status.\n","aSentId": 45068,"answer": "It didn't change its OOP status. It merely recognised that FP is sometimes the better path. Compare that with the hard dogmatic stance Java used to take.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45069,"question": "It didn't change its OOP status. It merely recognised that FP is sometimes the better path. Compare that with the hard dogmatic stance Java used to take.","aSentId": 45070,"answer": "What hard dogmatic stance? And do you have any sources for that?\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45071,"question": "What hard dogmatic stance? And do you have any sources for that?\n\n","aSentId": 45072,"answer": "Like, forcing everything into a class? Every class ultimately derive from `Object`, so whatever you do fit in a giant inheritance hierarchy? Clearly that was a \"Thy code shall be OO\" stance. The only exception were primitive types. Then generics. Then lambdas.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45075,"question": "OOP = 1) methods operating over a common context plus 2) a few goodies like inheritance and dynamic runtime dispatch.\n\nNo. 1 is such a pervasive idea, and No. 2 is invented and reinvented and emulated in languages w/o them (take a look at C's stdio FILE functions, Linux kernel) that OOP is never going to die, to the disdain of people who \"have seen the light\".\n\nHeck, Haskell's type-classes ~ interfaces, and a common design idiom in Haskell is passing around records of function values (hmmm, sounds suspiciously similar to vtables).\n\nOOP is alive and kicking.","aSentId": 45076,"answer": "Before OOP was ever formalized, the style was typically considered best-practice for pure procedural languages.  In C, the best practice for data types was abstact data types and functions that operate on them.  OOP formalizes that concept with type safety and namespacing.  It wasn't a revolution but an evolution.    \n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45077,"question": "Before OOP was ever formalized, the style was typically considered best-practice for pure procedural languages.  In C, the best practice for data types was abstact data types and functions that operate on them.  OOP formalizes that concept with type safety and namespacing.  It wasn't a revolution but an evolution.    \n","aSentId": 45078,"answer": "I'm not sure from where you get the type safety thing. Functions are every bit as type safe as methods on objects. The namespacing situation in C is definitely bad, but that has more to do with C than a lack of OOP.\n\nI personally prefer having functions that take \"their object\" as their first argument rather than calling methods on objects. There are two reasons for this, the first being that the functional way is simply more explicit. The second is that it is more composable. You could do something like this:\n\n    len = length;\n    len(arr)\n\nand get the length of an array. You can *not* do this:\n\n    len = length\n    arr.len()\n\nIt might look silly in this context, but it is actually a larger problem than one initially thinks. If you check the validity of a submission with `submission.validate()` you can't do something like `map(validate, submissions)` to validate a sequence of submissions.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45079,"question": "I'm not sure from where you get the type safety thing. Functions are every bit as type safe as methods on objects. The namespacing situation in C is definitely bad, but that has more to do with C than a lack of OOP.\n\nI personally prefer having functions that take \"their object\" as their first argument rather than calling methods on objects. There are two reasons for this, the first being that the functional way is simply more explicit. The second is that it is more composable. You could do something like this:\n\n    len = length;\n    len(arr)\n\nand get the length of an array. You can *not* do this:\n\n    len = length\n    arr.len()\n\nIt might look silly in this context, but it is actually a larger problem than one initially thinks. If you check the validity of a submission with `submission.validate()` you can't do something like `map(validate, submissions)` to validate a sequence of submissions.","aSentId": 45080,"answer": "&gt; you can't do something like `map(validate, submissions)` to validate a sequence of submissions.\n\nSure you can:\n\n    submissions.map(s -&gt; s.validate());\n\nAnd this is in Java 8, probably one of the crummier implementations of OOP.\n\nIn fact, functional languages like Haskell have created abstractions like monads, in particular, the State monad, to avoid having to manually thread context, implementing the idea in a more disciplined way than standard OOP, to be sure. Argument from authority, I know, but at least it goes to show it's not such a crazy idea. For some reason, people keep reinventing things like OOP.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45081,"question": "&gt; you can't do something like `map(validate, submissions)` to validate a sequence of submissions.\n\nSure you can:\n\n    submissions.map(s -&gt; s.validate());\n\nAnd this is in Java 8, probably one of the crummier implementations of OOP.\n\nIn fact, functional languages like Haskell have created abstractions like monads, in particular, the State monad, to avoid having to manually thread context, implementing the idea in a more disciplined way than standard OOP, to be sure. Argument from authority, I know, but at least it goes to show it's not such a crazy idea. For some reason, people keep reinventing things like OOP.","aSentId": 45082,"answer": "Oh, sure, you can create an anonymous closure, but to me that is unnecessary boilerplate that becomes mandatory *because* instance methods compose badly. It can get real ugly in more complex expressions.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45083,"question": "Oh, sure, you can create an anonymous closure, but to me that is unnecessary boilerplate that becomes mandatory *because* instance methods compose badly. It can get real ugly in more complex expressions.","aSentId": 45084,"answer": "Objects are essentially closures, and Haskell has shown that when implemented in a principled way, compose quite well. \n\nMost industrial OOP languages weren't designed this way, and some are trying to retroactively import some of these ideas.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45085,"question": "Objects are essentially closures, and Haskell has shown that when implemented in a principled way, compose quite well. \n\nMost industrial OOP languages weren't designed this way, and some are trying to retroactively import some of these ideas.","aSentId": 45086,"answer": "Fair enough. As a concept, collections of data associated with operations on said data isn't a bad idea. It's just that literally every OO language I've tried has executed it very poorly. It is telling to me that it takes a functional language like Haskell to do OO well.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45087,"question": "Fair enough. As a concept, collections of data associated with operations on said data isn't a bad idea. It's just that literally every OO language I've tried has executed it very poorly. It is telling to me that it takes a functional language like Haskell to do OO well.","aSentId": 45088,"answer": "It's all about the foundations and the principles that guide evolution. \n\nC++ was built on top of C, hacking on ideas pioneered in Simula, and other languages, like Java, tried to mimic C++, because it is successful. This was not done in a principled way, but in ways that promote mindshare (or profit).\n\nHaskell has always proceeded from theoretical soundness. As Simon Peyton Jones put it, Haskell has tried to avoid success at all costs.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45079,"question": "I'm not sure from where you get the type safety thing. Functions are every bit as type safe as methods on objects. The namespacing situation in C is definitely bad, but that has more to do with C than a lack of OOP.\n\nI personally prefer having functions that take \"their object\" as their first argument rather than calling methods on objects. There are two reasons for this, the first being that the functional way is simply more explicit. The second is that it is more composable. You could do something like this:\n\n    len = length;\n    len(arr)\n\nand get the length of an array. You can *not* do this:\n\n    len = length\n    arr.len()\n\nIt might look silly in this context, but it is actually a larger problem than one initially thinks. If you check the validity of a submission with `submission.validate()` you can't do something like `map(validate, submissions)` to validate a sequence of submissions.","aSentId": 45090,"answer": "You can do `map(Submission.validate, submissions)` in some languages.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45091,"question": "You can do `map(Submission.validate, submissions)` in some languages.","aSentId": 45092,"answer": "Yup. What you are essentially doing there is taking a method and turning it into a regular function, because functions compose better.\n\nIf you think about it, wherever you currently have `myEntry.validate()` you can, losslessly, replace it with `Submission::validate(myEntry)`. The same is not true for going the other way around. So if you, for the sake of consistence, replace every `myEntry.validate()` with `Submission::validate(myEntry)` you soon realise that the `validate` method doesn't need to be stuck in an object \u2013 you can make it a free-standing function in a `Submission` namespace instead. The transition is complete!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45077,"question": "Before OOP was ever formalized, the style was typically considered best-practice for pure procedural languages.  In C, the best practice for data types was abstact data types and functions that operate on them.  OOP formalizes that concept with type safety and namespacing.  It wasn't a revolution but an evolution.    \n","aSentId": 45094,"answer": "&gt; Before OOP was ever formalized, the style was typically considered best-practice for pure procedural languages. In C, the best practice for data types was abstact data types and functions that operate on them. OOP formalizes that concept with type safety and namespacing. It wasn't a revolution but an evolution.\n\nThat formalization had been accomplished long before OOP was a Thing With a Name--and Smalltalk, the language that gave the Thing the Name, does not have that formalization!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45075,"question": "OOP = 1) methods operating over a common context plus 2) a few goodies like inheritance and dynamic runtime dispatch.\n\nNo. 1 is such a pervasive idea, and No. 2 is invented and reinvented and emulated in languages w/o them (take a look at C's stdio FILE functions, Linux kernel) that OOP is never going to die, to the disdain of people who \"have seen the light\".\n\nHeck, Haskell's type-classes ~ interfaces, and a common design idiom in Haskell is passing around records of function values (hmmm, sounds suspiciously similar to vtables).\n\nOOP is alive and kicking.","aSentId": 45096,"answer": "&gt; Heck, Haskell's type-classes ~ interfaces, and a common design idiom in Haskell is passing around records of function values (hmmm, sounds suspiciously similar to vtables).\n\nYep, typeclasses in Haskell are basically vtables.  But they're a much different implementation of vtables.  In particular, whereas OO languages bundle the vtable in with your data, Haskell passes the vtable into whatever functions need it, completely unbundled from your data.\n\nSo, when we say something like:\n\n    class Num a where\n      (+) :: a -&gt; a -&gt; a\n      (*) :: a -&gt; a -&gt; a\n      ...\n      fromInteger :: Int -&gt; a\n\n    instance Num Int where\n      (+) = plusInt -- actual addition function for hardware ints, defined elsewhere\n      (*) = timesInt -- likewise\n      fromInteger x = integerToInt -- defined elsewhere\n\nand we have a function like\n\n    addTwo :: Num a =&gt; a -&gt; a\n    addTwo x = x + 2\n\nwhat that really looks like under the hood is something like\n\n    addTwo :: a -&gt; Num a -&gt; a\n    addTwo x numImpl = x (+ numImpl) (fromInteger numImpl 2)\n\nwe pass in a separate implementation dictionary, and get the implementation for + and fromInteger.  The interesting thing to note here is that fromInteger has a fixed input type, but a polymorphic return type.  So if I say something like \"(1 + 1) :: Int\",  I'll get back an Int, but if I say \"(1 + 1) :: Float\", I'll get a Float.  Type inference is pretty useful, here.\n\nOne of the other useful things about typeclasses is that they allow you to conditionally offer methods.  For example, I might have a class\n\n    class Monoid m where\n       (&lt;&gt;) :: m -&gt; m -&gt; m\n       i :: m\n\nfor which any instance should have &lt;&gt; be associative, and i should be the identity element for &lt;&gt;.  Given that, I can write something like\n\n    reduce :: Monoid m =&gt; [m] -&gt; m\n    reduce xs = foldr (&lt;&gt;) i xs\n\nNow, if I have a list of some monoidal type, I can just reduce it to a summary value.  If I have a list of some non-monoidal type, I just can't call that function.  In a traditional OO style, I'd have to make a MonoidList that only accepts things that implement the monoid interface.  That's pretty terrible, since you'd get a combinatorial explosion of FooBarBazLists for all of the conditionally available methods.\n\nOn the other hand, what OO really excels at is heterogeneous collections - you can have a collection of a number of different things that have some common parent class.  With basic typeclasses, though, there's no subtyping.  If I want a list of Show-ables (show is Haskell's version of toString), I can't just say\n\n    [1, \"foo\", 2.0, [1, 2.0]]\n\nInstead, I have 3 real options:\n\n* Just call the single method in Show:\n\n    [show 1, show \"foo\", show 2.0, show [show 1, show 2.0]]\n\nThis is decent in the case that you just want a list of showable or renderable objects, but doesn't scale well.\n\n* Use the Existential Typeclass Antipattern:\n\n    data Showable = forall s. Show s =&gt; Showable s\n\n    [Showable 1, Showable \"foo\", Showable 2.0, Showable [Showable 1, Showable 2.0]]\n\nThis basically has no advantages compared to the next approach:\n\n* Instead of a typeclass, just use a record of functions as you might in C.\n\nThis is why you see records of functions in Haskell - they work well with collections, and that's occasionally what you need.  I'm not sure whether I'd call it object *oriented*, though.  It's not really a style oriented to objects, just one that uses them infrequently.\n\nedit: fixed a function definition","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45097,"question": "&gt; Heck, Haskell's type-classes ~ interfaces, and a common design idiom in Haskell is passing around records of function values (hmmm, sounds suspiciously similar to vtables).\n\nYep, typeclasses in Haskell are basically vtables.  But they're a much different implementation of vtables.  In particular, whereas OO languages bundle the vtable in with your data, Haskell passes the vtable into whatever functions need it, completely unbundled from your data.\n\nSo, when we say something like:\n\n    class Num a where\n      (+) :: a -&gt; a -&gt; a\n      (*) :: a -&gt; a -&gt; a\n      ...\n      fromInteger :: Int -&gt; a\n\n    instance Num Int where\n      (+) = plusInt -- actual addition function for hardware ints, defined elsewhere\n      (*) = timesInt -- likewise\n      fromInteger x = integerToInt -- defined elsewhere\n\nand we have a function like\n\n    addTwo :: Num a =&gt; a -&gt; a\n    addTwo x = x + 2\n\nwhat that really looks like under the hood is something like\n\n    addTwo :: a -&gt; Num a -&gt; a\n    addTwo x numImpl = x (+ numImpl) (fromInteger numImpl 2)\n\nwe pass in a separate implementation dictionary, and get the implementation for + and fromInteger.  The interesting thing to note here is that fromInteger has a fixed input type, but a polymorphic return type.  So if I say something like \"(1 + 1) :: Int\",  I'll get back an Int, but if I say \"(1 + 1) :: Float\", I'll get a Float.  Type inference is pretty useful, here.\n\nOne of the other useful things about typeclasses is that they allow you to conditionally offer methods.  For example, I might have a class\n\n    class Monoid m where\n       (&lt;&gt;) :: m -&gt; m -&gt; m\n       i :: m\n\nfor which any instance should have &lt;&gt; be associative, and i should be the identity element for &lt;&gt;.  Given that, I can write something like\n\n    reduce :: Monoid m =&gt; [m] -&gt; m\n    reduce xs = foldr (&lt;&gt;) i xs\n\nNow, if I have a list of some monoidal type, I can just reduce it to a summary value.  If I have a list of some non-monoidal type, I just can't call that function.  In a traditional OO style, I'd have to make a MonoidList that only accepts things that implement the monoid interface.  That's pretty terrible, since you'd get a combinatorial explosion of FooBarBazLists for all of the conditionally available methods.\n\nOn the other hand, what OO really excels at is heterogeneous collections - you can have a collection of a number of different things that have some common parent class.  With basic typeclasses, though, there's no subtyping.  If I want a list of Show-ables (show is Haskell's version of toString), I can't just say\n\n    [1, \"foo\", 2.0, [1, 2.0]]\n\nInstead, I have 3 real options:\n\n* Just call the single method in Show:\n\n    [show 1, show \"foo\", show 2.0, show [show 1, show 2.0]]\n\nThis is decent in the case that you just want a list of showable or renderable objects, but doesn't scale well.\n\n* Use the Existential Typeclass Antipattern:\n\n    data Showable = forall s. Show s =&gt; Showable s\n\n    [Showable 1, Showable \"foo\", Showable 2.0, Showable [Showable 1, Showable 2.0]]\n\nThis basically has no advantages compared to the next approach:\n\n* Instead of a typeclass, just use a record of functions as you might in C.\n\nThis is why you see records of functions in Haskell - they work well with collections, and that's occasionally what you need.  I'm not sure whether I'd call it object *oriented*, though.  It's not really a style oriented to objects, just one that uses them infrequently.\n\nedit: fixed a function definition","aSentId": 45098,"answer": "I never understood why Haskell programmers show off Haskell features with Haskell code. This is unreadable if you don't already know Haskell.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45099,"question": "I never understood why Haskell programmers show off Haskell features with Haskell code. This is unreadable if you don't already know Haskell.","aSentId": 45100,"answer": "To understand recursion, first you must understand recursion.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45099,"question": "I never understood why Haskell programmers show off Haskell features with Haskell code. This is unreadable if you don't already know Haskell.","aSentId": 45102,"answer": "If you'd prefer, the monoid example is more-or-less equivalent to something like:\n\n    public interface MonoidImpl&lt;M&gt; {\n      public M op(M x, M y);\n      public M identity();\n    }\n\n    public class List&lt;E&gt; {\n      ...\n      public E reduce(MonoidImpl&lt;E&gt; monoidImpl) {\n        E accumulator = monoidimpl.ident;\n        for(E elem : this) {\n          accumulator = monoidImpl.op(accumulator, elem)\n        }\n        return accumulator;\n      }\n    }\n\nWith the important caveat of doing this in Java will result in a painfully large amount of passing around the implementation dictionaries, particularly when trying to keep code generic.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45103,"question": "If you'd prefer, the monoid example is more-or-less equivalent to something like:\n\n    public interface MonoidImpl&lt;M&gt; {\n      public M op(M x, M y);\n      public M identity();\n    }\n\n    public class List&lt;E&gt; {\n      ...\n      public E reduce(MonoidImpl&lt;E&gt; monoidImpl) {\n        E accumulator = monoidimpl.ident;\n        for(E elem : this) {\n          accumulator = monoidImpl.op(accumulator, elem)\n        }\n        return accumulator;\n      }\n    }\n\nWith the important caveat of doing this in Java will result in a painfully large amount of passing around the implementation dictionaries, particularly when trying to keep code generic.","aSentId": 45104,"answer": "For the sake of discussion you can pretend that Java has the features you lack. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45099,"question": "I never understood why Haskell programmers show off Haskell features with Haskell code. This is unreadable if you don't already know Haskell.","aSentId": 45106,"answer": "Haskell is the \"executable pseudocode\" of the functional programming world, just like Python fulfills the same purpose for procedural/OOP examples.\n\nThe question was also specifically about a Haskell feature.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45097,"question": "&gt; Heck, Haskell's type-classes ~ interfaces, and a common design idiom in Haskell is passing around records of function values (hmmm, sounds suspiciously similar to vtables).\n\nYep, typeclasses in Haskell are basically vtables.  But they're a much different implementation of vtables.  In particular, whereas OO languages bundle the vtable in with your data, Haskell passes the vtable into whatever functions need it, completely unbundled from your data.\n\nSo, when we say something like:\n\n    class Num a where\n      (+) :: a -&gt; a -&gt; a\n      (*) :: a -&gt; a -&gt; a\n      ...\n      fromInteger :: Int -&gt; a\n\n    instance Num Int where\n      (+) = plusInt -- actual addition function for hardware ints, defined elsewhere\n      (*) = timesInt -- likewise\n      fromInteger x = integerToInt -- defined elsewhere\n\nand we have a function like\n\n    addTwo :: Num a =&gt; a -&gt; a\n    addTwo x = x + 2\n\nwhat that really looks like under the hood is something like\n\n    addTwo :: a -&gt; Num a -&gt; a\n    addTwo x numImpl = x (+ numImpl) (fromInteger numImpl 2)\n\nwe pass in a separate implementation dictionary, and get the implementation for + and fromInteger.  The interesting thing to note here is that fromInteger has a fixed input type, but a polymorphic return type.  So if I say something like \"(1 + 1) :: Int\",  I'll get back an Int, but if I say \"(1 + 1) :: Float\", I'll get a Float.  Type inference is pretty useful, here.\n\nOne of the other useful things about typeclasses is that they allow you to conditionally offer methods.  For example, I might have a class\n\n    class Monoid m where\n       (&lt;&gt;) :: m -&gt; m -&gt; m\n       i :: m\n\nfor which any instance should have &lt;&gt; be associative, and i should be the identity element for &lt;&gt;.  Given that, I can write something like\n\n    reduce :: Monoid m =&gt; [m] -&gt; m\n    reduce xs = foldr (&lt;&gt;) i xs\n\nNow, if I have a list of some monoidal type, I can just reduce it to a summary value.  If I have a list of some non-monoidal type, I just can't call that function.  In a traditional OO style, I'd have to make a MonoidList that only accepts things that implement the monoid interface.  That's pretty terrible, since you'd get a combinatorial explosion of FooBarBazLists for all of the conditionally available methods.\n\nOn the other hand, what OO really excels at is heterogeneous collections - you can have a collection of a number of different things that have some common parent class.  With basic typeclasses, though, there's no subtyping.  If I want a list of Show-ables (show is Haskell's version of toString), I can't just say\n\n    [1, \"foo\", 2.0, [1, 2.0]]\n\nInstead, I have 3 real options:\n\n* Just call the single method in Show:\n\n    [show 1, show \"foo\", show 2.0, show [show 1, show 2.0]]\n\nThis is decent in the case that you just want a list of showable or renderable objects, but doesn't scale well.\n\n* Use the Existential Typeclass Antipattern:\n\n    data Showable = forall s. Show s =&gt; Showable s\n\n    [Showable 1, Showable \"foo\", Showable 2.0, Showable [Showable 1, Showable 2.0]]\n\nThis basically has no advantages compared to the next approach:\n\n* Instead of a typeclass, just use a record of functions as you might in C.\n\nThis is why you see records of functions in Haskell - they work well with collections, and that's occasionally what you need.  I'm not sure whether I'd call it object *oriented*, though.  It's not really a style oriented to objects, just one that uses them infrequently.\n\nedit: fixed a function definition","aSentId": 45108,"answer": "Actually, in Haskell, monads are very object oriented. Typeclasses are more like interfaces used to describe an abstraction, with the `Monad` typeclass describing an OOP-like abstraction (although more general and more powerful, IMHO). Esentially, in Haskell terms, methods are actions which are passed implicit state (like the implicit `this`). Even though the \"methods\" are separated from the \"instance data\", you still end up with very OOP definitions like:\n\n    data MyInstanceData = ...\n    type MyObject a = State MyInstanceData a\n\n    methodFunction :: MyObject a\n    methodFunction = do\n        this &lt;- gets\n        ...\n\nThe essence of a method in OOP is that the method operates in the context of the object. OOP languages hide the machinery required to bind the context to the method, usually by hiding `this` as the implicit first argument and hiding the machinery to extract values out of the object in the method so that they can be operated on.\n\nThe `State` monad is closest to OOP \"in spirit\", passing around state between actions (like `this`) actions and `return` sending an instance to the outside world. `runStateT` lets you put Haskell in \"OOP mode\".","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45109,"question": "Actually, in Haskell, monads are very object oriented. Typeclasses are more like interfaces used to describe an abstraction, with the `Monad` typeclass describing an OOP-like abstraction (although more general and more powerful, IMHO). Esentially, in Haskell terms, methods are actions which are passed implicit state (like the implicit `this`). Even though the \"methods\" are separated from the \"instance data\", you still end up with very OOP definitions like:\n\n    data MyInstanceData = ...\n    type MyObject a = State MyInstanceData a\n\n    methodFunction :: MyObject a\n    methodFunction = do\n        this &lt;- gets\n        ...\n\nThe essence of a method in OOP is that the method operates in the context of the object. OOP languages hide the machinery required to bind the context to the method, usually by hiding `this` as the implicit first argument and hiding the machinery to extract values out of the object in the method so that they can be operated on.\n\nThe `State` monad is closest to OOP \"in spirit\", passing around state between actions (like `this`) actions and `return` sending an instance to the outside world. `runStateT` lets you put Haskell in \"OOP mode\".","aSentId": 45110,"answer": "&gt; Actually, in Haskell, monads are very object oriented\n\nNot particularly.  With some particular monads, I'll take \"Kinda, sorta in a very very loose handwavy sense if you're squinting while doing a headstand\".\n\n&gt; The essence of a method in OOP is that the method operates in the context of the object. OOP languages hide the machinery required to bind the context to the method, usually by hiding this as the implicit first argument\n\nSure.  This is basically like having something more like\n\n    data MyClass = MyClass {\n        bar :: MyClass -&gt; Int,\n        baz :: MyClass -&gt; Float\n      }\n\nwhich is basically like an oddly constrained, typically impure version of Reader.\n\n&gt; The State monad is closest to OOP \"in spirit\"\n\nState, in Haskell, is a wrapper around functions of the type\n\n    state -&gt; (result, state)\n\nand provides a few methods like\n\n    return :: a -&gt; s -&gt; (a, s)\n    return a s = (a, s)\n\n    (&gt;&gt;=) :: (s -&gt; (a, s)) -&gt; (a -&gt; s -&gt; (b, s)) -&gt; (s -&gt; (b, s))\n    sas &gt;&gt;= asbs = \\s -&gt; (b, s'')\n      where (a, s') = sas s\n            (b,s'') = asbs a s'\n\nbecause manually threading around values like s'''' is verbose and error prone.\n\nIf you look, though, you'll see two big differences from OO: s can be anything, not just the record that contains you, and *you're actually returning the new state, not mutating things willy-nilly*.  Additionally, it's all just a bunch of library functions that are piping around values the right way; it's not like the language is implicitly piping things around behind your back.\n\nOn the other hand, lets look at a couple of other monad instances:\n\n    return :: a -&gt; Maybe a\n    return x = Just x\n\n    (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b\n    (Just x) &gt;&gt;= f = f x\n    Nothing &gt;&gt;= f = Nothing\n\n    return :: a -&gt; [a]\n    return x = [x]\n\n    (&gt;&gt;=) :: [a] -&gt; (a -&gt; [b]) -&gt; [b]\n    xs &gt;&gt;= f = concat $ map f xs\n\n    return :: a -&gt; Either b a\n    return x = Right x\n   \n    (&gt;&gt;=) :: Either a b -&gt; (b -&gt; Either a c) -&gt; Either a c\n    (Left x) &gt;&gt;= f = Left x\n    (Right x) &gt;&gt;= f = Right (f x)\n\nThere's not really very much \"operating in a context\" going on there...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45111,"question": "&gt; Actually, in Haskell, monads are very object oriented\n\nNot particularly.  With some particular monads, I'll take \"Kinda, sorta in a very very loose handwavy sense if you're squinting while doing a headstand\".\n\n&gt; The essence of a method in OOP is that the method operates in the context of the object. OOP languages hide the machinery required to bind the context to the method, usually by hiding this as the implicit first argument\n\nSure.  This is basically like having something more like\n\n    data MyClass = MyClass {\n        bar :: MyClass -&gt; Int,\n        baz :: MyClass -&gt; Float\n      }\n\nwhich is basically like an oddly constrained, typically impure version of Reader.\n\n&gt; The State monad is closest to OOP \"in spirit\"\n\nState, in Haskell, is a wrapper around functions of the type\n\n    state -&gt; (result, state)\n\nand provides a few methods like\n\n    return :: a -&gt; s -&gt; (a, s)\n    return a s = (a, s)\n\n    (&gt;&gt;=) :: (s -&gt; (a, s)) -&gt; (a -&gt; s -&gt; (b, s)) -&gt; (s -&gt; (b, s))\n    sas &gt;&gt;= asbs = \\s -&gt; (b, s'')\n      where (a, s') = sas s\n            (b,s'') = asbs a s'\n\nbecause manually threading around values like s'''' is verbose and error prone.\n\nIf you look, though, you'll see two big differences from OO: s can be anything, not just the record that contains you, and *you're actually returning the new state, not mutating things willy-nilly*.  Additionally, it's all just a bunch of library functions that are piping around values the right way; it's not like the language is implicitly piping things around behind your back.\n\nOn the other hand, lets look at a couple of other monad instances:\n\n    return :: a -&gt; Maybe a\n    return x = Just x\n\n    (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b\n    (Just x) &gt;&gt;= f = f x\n    Nothing &gt;&gt;= f = Nothing\n\n    return :: a -&gt; [a]\n    return x = [x]\n\n    (&gt;&gt;=) :: [a] -&gt; (a -&gt; [b]) -&gt; [b]\n    xs &gt;&gt;= f = concat $ map f xs\n\n    return :: a -&gt; Either b a\n    return x = Right x\n   \n    (&gt;&gt;=) :: Either a b -&gt; (b -&gt; Either a c) -&gt; Either a c\n    (Left x) &gt;&gt;= f = Left x\n    (Right x) &gt;&gt;= f = Right (f x)\n\nThere's not really very much \"operating in a context\" going on there...","aSentId": 45112,"answer": "&gt; Sure. This is basically like having something more like...\n\nNo, you're confusing classes with objects. \n\nAn object encapsulates process state, and in a statically typed OOP language, the process state would be encapsulated by the object's *instance variables*. In Haskell terms, this would be the `s` type bound of the `State` monad. The `s` is not arbitrary, and just like in OOP, where the compiler automatically threads `this`, the State monad automatically threads `s`.\n\nThe OOP class defines both the instance variables and methods together (in languages like C++ and Java), which doesn't make sense in Haskell. I suspect this is what you were trying to accomplish, which goes to show what happens when you try to directly translate an idiom in one language to another completely different language. You miss the forest for the trees. Think instead about what a method *does*, and you'll see it is exactly the same in principle to a monadic action.\n\nIn Haskell, the equivalent to a class would undoubtedly be the module. This is because you can export the type by name only so that it is impossible for code outside to pattern match on its fields, such that only functions defined in the module can access the type constructors. This is what a class *does*.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45109,"question": "Actually, in Haskell, monads are very object oriented. Typeclasses are more like interfaces used to describe an abstraction, with the `Monad` typeclass describing an OOP-like abstraction (although more general and more powerful, IMHO). Esentially, in Haskell terms, methods are actions which are passed implicit state (like the implicit `this`). Even though the \"methods\" are separated from the \"instance data\", you still end up with very OOP definitions like:\n\n    data MyInstanceData = ...\n    type MyObject a = State MyInstanceData a\n\n    methodFunction :: MyObject a\n    methodFunction = do\n        this &lt;- gets\n        ...\n\nThe essence of a method in OOP is that the method operates in the context of the object. OOP languages hide the machinery required to bind the context to the method, usually by hiding `this` as the implicit first argument and hiding the machinery to extract values out of the object in the method so that they can be operated on.\n\nThe `State` monad is closest to OOP \"in spirit\", passing around state between actions (like `this`) actions and `return` sending an instance to the outside world. `runStateT` lets you put Haskell in \"OOP mode\".","aSentId": 45114,"answer": "&gt; Actually, in Haskell, monads are very object oriented. [...] The essence of a method in OOP is that the method operates in the context of the object.\n\nOr in other terms: \"OOP invented encapsulation and nothing can claim to do encapsulation without paying tribute to OOP.\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45115,"question": "&gt; Actually, in Haskell, monads are very object oriented. [...] The essence of a method in OOP is that the method operates in the context of the object.\n\nOr in other terms: \"OOP invented encapsulation and nothing can claim to do encapsulation without paying tribute to OOP.\"","aSentId": 45116,"answer": "No need to be so dogmatic. \n\nOOP is one type of abstraction, and you can describe other abstractions in terms of OOP. Haskell overloads definitions like this all the time, depending on how you are looking at things. You can look at the State as a model of OOP, as a way of sequencing actions as a Monad, as a way of composing functions as a Functor, etc., etc. Just because State is a functor, doesn't mean we can't describe it as a monad without paying tribute to functors.\n\nAfter all, this is not a religion. These are all different models by which we analyze computations for different purposes.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45097,"question": "&gt; Heck, Haskell's type-classes ~ interfaces, and a common design idiom in Haskell is passing around records of function values (hmmm, sounds suspiciously similar to vtables).\n\nYep, typeclasses in Haskell are basically vtables.  But they're a much different implementation of vtables.  In particular, whereas OO languages bundle the vtable in with your data, Haskell passes the vtable into whatever functions need it, completely unbundled from your data.\n\nSo, when we say something like:\n\n    class Num a where\n      (+) :: a -&gt; a -&gt; a\n      (*) :: a -&gt; a -&gt; a\n      ...\n      fromInteger :: Int -&gt; a\n\n    instance Num Int where\n      (+) = plusInt -- actual addition function for hardware ints, defined elsewhere\n      (*) = timesInt -- likewise\n      fromInteger x = integerToInt -- defined elsewhere\n\nand we have a function like\n\n    addTwo :: Num a =&gt; a -&gt; a\n    addTwo x = x + 2\n\nwhat that really looks like under the hood is something like\n\n    addTwo :: a -&gt; Num a -&gt; a\n    addTwo x numImpl = x (+ numImpl) (fromInteger numImpl 2)\n\nwe pass in a separate implementation dictionary, and get the implementation for + and fromInteger.  The interesting thing to note here is that fromInteger has a fixed input type, but a polymorphic return type.  So if I say something like \"(1 + 1) :: Int\",  I'll get back an Int, but if I say \"(1 + 1) :: Float\", I'll get a Float.  Type inference is pretty useful, here.\n\nOne of the other useful things about typeclasses is that they allow you to conditionally offer methods.  For example, I might have a class\n\n    class Monoid m where\n       (&lt;&gt;) :: m -&gt; m -&gt; m\n       i :: m\n\nfor which any instance should have &lt;&gt; be associative, and i should be the identity element for &lt;&gt;.  Given that, I can write something like\n\n    reduce :: Monoid m =&gt; [m] -&gt; m\n    reduce xs = foldr (&lt;&gt;) i xs\n\nNow, if I have a list of some monoidal type, I can just reduce it to a summary value.  If I have a list of some non-monoidal type, I just can't call that function.  In a traditional OO style, I'd have to make a MonoidList that only accepts things that implement the monoid interface.  That's pretty terrible, since you'd get a combinatorial explosion of FooBarBazLists for all of the conditionally available methods.\n\nOn the other hand, what OO really excels at is heterogeneous collections - you can have a collection of a number of different things that have some common parent class.  With basic typeclasses, though, there's no subtyping.  If I want a list of Show-ables (show is Haskell's version of toString), I can't just say\n\n    [1, \"foo\", 2.0, [1, 2.0]]\n\nInstead, I have 3 real options:\n\n* Just call the single method in Show:\n\n    [show 1, show \"foo\", show 2.0, show [show 1, show 2.0]]\n\nThis is decent in the case that you just want a list of showable or renderable objects, but doesn't scale well.\n\n* Use the Existential Typeclass Antipattern:\n\n    data Showable = forall s. Show s =&gt; Showable s\n\n    [Showable 1, Showable \"foo\", Showable 2.0, Showable [Showable 1, Showable 2.0]]\n\nThis basically has no advantages compared to the next approach:\n\n* Instead of a typeclass, just use a record of functions as you might in C.\n\nThis is why you see records of functions in Haskell - they work well with collections, and that's occasionally what you need.  I'm not sure whether I'd call it object *oriented*, though.  It's not really a style oriented to objects, just one that uses them infrequently.\n\nedit: fixed a function definition","aSentId": 45118,"answer": "&gt; Yep, typeclasses in Haskell are basically vtables\n\nI can't follow. Vtables are used for dynamic (runtime) dispatch.\nAren't typeclasses fully static (compile time) mechanism?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45119,"question": "&gt; Yep, typeclasses in Haskell are basically vtables\n\nI can't follow. Vtables are used for dynamic (runtime) dispatch.\nAren't typeclasses fully static (compile time) mechanism?","aSentId": 45120,"answer": "&gt; I can't follow. Vtables are used for dynamic (runtime) dispatch. Aren't typeclasses fully static (compile time) mechanism?\n\nI just realized my previous explanation is probably confusing, so let me try this again.\n\n* There exist some exceptional uses of type classes which are impossible to eliminate at compilation time.\n* \"Simple\" uses of type classes, however, can *in principle* be compiled into static calls.\n* In practice, however, the compiler can't always do this.  You probably need whole program analysis to eliminate all such cases, and that means not being able to compile just files that have changed since the last compilation.\n* Because of this:\n 1. In the general case invocations of typeclass operations compile to a vtable dispatch.  \n 2. In the specific cases where the compiler can statially identify which the vtable, it will devirtualize the call.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45119,"question": "&gt; Yep, typeclasses in Haskell are basically vtables\n\nI can't follow. Vtables are used for dynamic (runtime) dispatch.\nAren't typeclasses fully static (compile time) mechanism?","aSentId": 45122,"answer": "&gt; I can't follow. Vtables are used for dynamic (runtime) dispatch. Aren't typeclasses fully static (compile time) mechanism?\n\nThe compiler tries to resolve the type classes at compilation time, but this isn't always possible.  When it can't, it falls back to runtime dispatch.\n\nThere's also techniques that force the compiler to use dynamic dispatch.  Most notable (and somewhat controversial) is the Existential Typeclass Antipattern, where you use a type system feature called *existential types* to create a value that contains:\n\n* An value of unknown type, but which nevertheless implements certain specified classes;\n* Implicit references to the relevant class dictionaries.\n\nWhich allows you to have, for example, a list of values of heterogeneous types, whose only thing in common is that they implement the classes in question.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45075,"question": "OOP = 1) methods operating over a common context plus 2) a few goodies like inheritance and dynamic runtime dispatch.\n\nNo. 1 is such a pervasive idea, and No. 2 is invented and reinvented and emulated in languages w/o them (take a look at C's stdio FILE functions, Linux kernel) that OOP is never going to die, to the disdain of people who \"have seen the light\".\n\nHeck, Haskell's type-classes ~ interfaces, and a common design idiom in Haskell is passing around records of function values (hmmm, sounds suspiciously similar to vtables).\n\nOOP is alive and kicking.","aSentId": 45125,"answer": "OOP's tools may not die, but I sure hope they become less of a default tool for people to reach for.\n\nC and Linux's structs of function pointers, Haskell's type classes, and other similar things, are not the first way people try to solve problems in those languages. They only go there when they actually need them (which is less than they think they do when they're in an \"OOP\" language), and have considered what other designs they're blocking off.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45127,"question": "The religious debates about purity of form in languages and applications is a bit ridiculous to me. No matter whether you call something a lambda, closure, object, virtual function, strongly typed, weakly typed, prototype or class -- it all compiles to the same machine code. The terms we use to talk about languages are nebulous, yet the concepts we are encoding when we use them are extremely well defined, so the debate itself just strikes me as silly. Most modern languages in use today pull the good ideas from many different \"pure\" paradigms (functional, imperative, declarative, object-oriented, etc etc etc). To throw away entire abstract concepts because they are impure is to artificially inhibit your own toolbox.","aSentId": 45128,"answer": "&gt; No matter whether you call something a lambda, closure, object, virtual function, strongly typed, weakly typed, prototype or class -- it all compiles to the same machine code.\n\nNot even close to being true. If you think a compiled Ruby function looks the same as a compiled Haskell function which looks the same as a compiled C function, you need to do more research. \n\nHow efficiently abstractions compile down may or may not be pertinent to your use case, but it's one of many things to consider when evaluating the worth of an abstraction. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45129,"question": "&gt; No matter whether you call something a lambda, closure, object, virtual function, strongly typed, weakly typed, prototype or class -- it all compiles to the same machine code.\n\nNot even close to being true. If you think a compiled Ruby function looks the same as a compiled Haskell function which looks the same as a compiled C function, you need to do more research. \n\nHow efficiently abstractions compile down may or may not be pertinent to your use case, but it's one of many things to consider when evaluating the worth of an abstraction. ","aSentId": 45130,"answer": "I think I didn't express my point very clearly, sorry -- my problem with the article is that it starts out with a facetious attack on the caricature of the average joe developer who isn't yet enlightened by the beauty of Haskell or what have you:\n\n    Procedural programming. Bad.\n    Object oriented programming. Good.\n    Wacky research stuff. Unproven, Scary, Unmaintainable.\n\nThen proceeds to try to throw out all of OOP simply because it's OOP and must therefore be bad, thus creating just as silly of a caricature:\n\n    Procedural programming: bad\n    Object oriented programming: bad\n    Strongly typed, pure functional stuff: good\n\nIt's a facile argument that ends up expressing the same attitude it initially mocks. There aren't many \"pure\" languages out there if you really get down to it, and throwing away all of the concepts of OOP just because some of them can be improved is nothing but religious reasoning.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45131,"question": "I think I didn't express my point very clearly, sorry -- my problem with the article is that it starts out with a facetious attack on the caricature of the average joe developer who isn't yet enlightened by the beauty of Haskell or what have you:\n\n    Procedural programming. Bad.\n    Object oriented programming. Good.\n    Wacky research stuff. Unproven, Scary, Unmaintainable.\n\nThen proceeds to try to throw out all of OOP simply because it's OOP and must therefore be bad, thus creating just as silly of a caricature:\n\n    Procedural programming: bad\n    Object oriented programming: bad\n    Strongly typed, pure functional stuff: good\n\nIt's a facile argument that ends up expressing the same attitude it initially mocks. There aren't many \"pure\" languages out there if you really get down to it, and throwing away all of the concepts of OOP just because some of them can be improved is nothing but religious reasoning.","aSentId": 45132,"answer": "I probably didn't express myself clearly.\n\n&gt; it starts out with a facetious attack on the caricature of the average joe developer who isn't yet enlightened\n\nThe attack was not facetious. That was not a caricature. Most programmers I have met in person *really* subscribe to the ridiculous worldview I have outlined. They would never say it in so many words, but it is clear from their day-to-day decisions: they nearly always chose something they can brand as \"OOP\", and dismiss the rest as \"procedural\", or \"unmaintainable\".\n\nI know it looks like a caricature, but I currently believe that currently, this is the *norm*. Hopefully you work in a more enlightened environment than mine. Also, the proggit audience is full of outliers, really.\n\n&gt; Then proceeds to try to throw out all of OOP simply because it's OOP and must therefore be bad, thus creating just as silly of a caricature\n\nMy arguments against OOP are not, actually against OOP. They are against imperative programming. And even then, a low dose of assignment statements is okay. It's just that we overdo it. FP is not the king of the hill, but in my opinion it is certainly a better default than the rest.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45133,"question": "I probably didn't express myself clearly.\n\n&gt; it starts out with a facetious attack on the caricature of the average joe developer who isn't yet enlightened\n\nThe attack was not facetious. That was not a caricature. Most programmers I have met in person *really* subscribe to the ridiculous worldview I have outlined. They would never say it in so many words, but it is clear from their day-to-day decisions: they nearly always chose something they can brand as \"OOP\", and dismiss the rest as \"procedural\", or \"unmaintainable\".\n\nI know it looks like a caricature, but I currently believe that currently, this is the *norm*. Hopefully you work in a more enlightened environment than mine. Also, the proggit audience is full of outliers, really.\n\n&gt; Then proceeds to try to throw out all of OOP simply because it's OOP and must therefore be bad, thus creating just as silly of a caricature\n\nMy arguments against OOP are not, actually against OOP. They are against imperative programming. And even then, a low dose of assignment statements is okay. It's just that we overdo it. FP is not the king of the hill, but in my opinion it is certainly a better default than the rest.\n\n","aSentId": 45134,"answer": "Perhaps I do work outside of the norm then, I do not share your experience of other programmers' attitudes on the subject. Sometimes the line between what is called imperative vs declarative can be blurry at the levels of abstraction we typically work in our day to day lives--some declarative abstractions are much more helpful than others depending on how much they leak and how much their imperative behavior coincides with what we expect (or hope) from them. Almost no abstraction is completely without leaks that will require you as a developer, at some point, to understand its imperative implementation (to which all programs are eventually reduced).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45135,"question": "Perhaps I do work outside of the norm then, I do not share your experience of other programmers' attitudes on the subject. Sometimes the line between what is called imperative vs declarative can be blurry at the levels of abstraction we typically work in our day to day lives--some declarative abstractions are much more helpful than others depending on how much they leak and how much their imperative behavior coincides with what we expect (or hope) from them. Almost no abstraction is completely without leaks that will require you as a developer, at some point, to understand its imperative implementation (to which all programs are eventually reduced).","aSentId": 45136,"answer": "For what it's worth, I at least share your experiences and don't think the norm is as it's being portrayed in the article. I am especially baffled by the assertion that \"Procedural code = bad\" is a common sentiment - rather, my impression has been that people are far too prone to fall back to (less well-structured) procedural code rather than consider the OO solution to the problem.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45138,"question": "From my article:\n\n&gt; OOP may live on, but \"OOP\" will die.\n\nSo I'm not sure if we even disagree. In any case, what would make a program *not* OOP in your opinion?","aSentId": 45139,"answer": "&gt;  In any case, what would make a program not OOP in your opinion?\n\nAllowing mutation of an object by publicly exposing subparts. For example, if `FILE` were not an opaque type and exposed a documented file descriptor field.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45140,"question": "&gt;  In any case, what would make a program not OOP in your opinion?\n\nAllowing mutation of an object by publicly exposing subparts. For example, if `FILE` were not an opaque type and exposed a documented file descriptor field.","aSentId": 45141,"answer": "Are you saying that Abstract Data Types, are *enough* to make a program OOP? If so, that's an awfully broad definition you have there. Broader than most definitions I have ever encountered. (Only your sibling comment is doing even broader.)\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45142,"question": "Are you saying that Abstract Data Types, are *enough* to make a program OOP? If so, that's an awfully broad definition you have there. Broader than most definitions I have ever encountered. (Only your sibling comment is doing even broader.)\n","aSentId": 45143,"answer": "&gt; Are you saying that Abstract Data Types, are enough to make a program OOP?\n\nNo. You asked about what would *not* make a program OOP. I answered with !ADT =&gt; !OOP. Now you've made the classical logical error by thinking that I said ADT =&gt; OOP. This is not how implication is negated.\n\nProperly negated, the implication is OOP =&gt; ADT, and yes, this is what I really mean.\n\nIOW, ADTs are *necessary* in an OOP program, but *not sufficient*.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45144,"question": "&gt; Are you saying that Abstract Data Types, are enough to make a program OOP?\n\nNo. You asked about what would *not* make a program OOP. I answered with !ADT =&gt; !OOP. Now you've made the classical logical error by thinking that I said ADT =&gt; OOP. This is not how implication is negated.\n\nProperly negated, the implication is OOP =&gt; ADT, and yes, this is what I really mean.\n\nIOW, ADTs are *necessary* in an OOP program, but *not sufficient*.","aSentId": 45145,"answer": "Sorry, you got me worried for a moment.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45138,"question": "From my article:\n\n&gt; OOP may live on, but \"OOP\" will die.\n\nSo I'm not sure if we even disagree. In any case, what would make a program *not* OOP in your opinion?","aSentId": 45147,"answer": "Not OOP: lack of identity, not even GUID, take away their noun-ness completely. Values are purely structural, so reasoning is equational. With identity, you can always sneak in properties even if you lack directly mutable state (since an immutable dictionary is sufficiently expressive to encode objects). \n\nIf your framework/program design involves anything called \"an object\" or some synonym of object, by the Treaty of Orlando, you are dealing with objects. \n\nThe only language where code is often written like this is hasekll (given that identity is not pure). ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45148,"question": "Not OOP: lack of identity, not even GUID, take away their noun-ness completely. Values are purely structural, so reasoning is equational. With identity, you can always sneak in properties even if you lack directly mutable state (since an immutable dictionary is sufficiently expressive to encode objects). \n\nIf your framework/program design involves anything called \"an object\" or some synonym of object, by the Treaty of Orlando, you are dealing with objects. \n\nThe only language where code is often written like this is hasekll (given that identity is not pure). ","aSentId": 45149,"answer": "In other words, all of imperative programming (which was invented, well, since the Von Neuman machine itself) is a *subset* of OOP?\n\nI'd never use such a broad definition.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45150,"question": "In other words, all of imperative programming (which was invented, well, since the Von Neuman machine itself) is a *subset* of OOP?\n\nI'd never use such a broad definition.\n","aSentId": 45151,"answer": "No, only those that refer to objects. Did you ever roll your own v tables in C to make records manageable?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45152,"question": "No, only those that refer to objects. Did you ever roll your own v tables in C to make records manageable?","aSentId": 45153,"answer": "I haven't written enough C to come to that. But honestly, I'd implement a template system (to have parametric polymorphism) first. Then I'd add sum types, and a special switch to handle them. *Then* I may consider v-table \u2014and even then, I'll probably just stick to simple closures.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45154,"question": "I haven't written enough C to come to that. But honestly, I'd implement a template system (to have parametric polymorphism) first. Then I'd add sum types, and a special switch to handle them. *Then* I may consider v-table \u2014and even then, I'll probably just stick to simple closures.","aSentId": 45155,"answer": "I used to roll my own v-tables all the time; heck, you'll find custom v-tables in the Linux kernel (anything for Linus to avoid C++ :) ). \n\nMy only point is that coming from the imperative procedural world, many people were doing OOP things before they had that term at all. I think it just naturally arises out of manipulating identified stateful things via aliases and such.\n\nIf you did functional programming back in the day, we didn't always have sum types either (well, except for those lucky enough to use SML). But algebraic datatypes just went well with programming with pure values, so even if you didn't have support for them in your language, you might just invent it. Same with monads and even functional orgami (list comprehensions). \n\nIf you wonder why some features go along with OOP and why some others go along with FP (keeping in mind that we often switch fluidly between the paradigms), then it is useful to look at why those features arose rather than assuming someone invented OOP or FP out of the void (or void*). ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45157,"question": "Waging war against another programming paradigm will not lead programmers adopt FP any time sooner. It's bad practice, especially if not accompanied by solid arguments.\n\nFor example, that c++ does not make every object class-based is not a valid argument against c++ not being an OOP programming language.\n\nThat Alan Key said \"I did not have C++ in mind\" does not make C++ a non OOP language.\n\nThat OOP means 'model real world entities' does not make OOP invalid. Objects can be modeled after real world entities, depending on context. Inheritance certainly does not mean 'model real world entities'.\n\nThat dynamic programming languages use test-driven development is totally unrelated to OOP.\n\nThat OOP cannot handle parallelism is wrong. The 'actor' model fits perfectly to OOP.\n\nThat the game industry is moving away from OOP could not be more false. I work in the industry, OOP is stronger than ever.\n\nThat GUI and simulations have solutions in the FP space remains to be seen. Personally, I haven't seen anything related. There are attempts to use reactive frameworks, but there are very few complete examples.\n\nI really don't get the way FP people think. Do you really want to impress us? gives us solutions. Writing articles with that many logical fallacies and false claims does nothing more than reenforce our stereotypes about FP.\n\n\n\n\n\n","aSentId": 45158,"answer": "The amount of OOP hate here and that I see pop up every few days on here is unreal.\n\nFunctional programming seems like a very good thing for *certain domains*.\n\nIt's not the end-all be-all just like object-oriented programming isn't. For fuck's sake, use the right tool for the right job and stop telling people their pliers are built on a faulty, shitty paradigm and that your two pivoting metal sticks are far superior.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45159,"question": "The amount of OOP hate here and that I see pop up every few days on here is unreal.\n\nFunctional programming seems like a very good thing for *certain domains*.\n\nIt's not the end-all be-all just like object-oriented programming isn't. For fuck's sake, use the right tool for the right job and stop telling people their pliers are built on a faulty, shitty paradigm and that your two pivoting metal sticks are far superior.","aSentId": 45160,"answer": "Can we just give up naming paradigms altogether? Nobody knows exactly what they mean\n\nCompletely useless:\n\n&gt; Functional programming makes coding easier.\n\nAre you talking about immutable variables? Type classes? Monads?\n\nMore useful:\n\n&gt; Avoiding side-effects and mutable variables makes coding easier.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45161,"question": "Can we just give up naming paradigms altogether? Nobody knows exactly what they mean\n\nCompletely useless:\n\n&gt; Functional programming makes coding easier.\n\nAre you talking about immutable variables? Type classes? Monads?\n\nMore useful:\n\n&gt; Avoiding side-effects and mutable variables makes coding easier.\n\n","aSentId": 45162,"answer": "I think the difference is that reasonable consideration of things is good and evangelism is bad (or at the very least not productive).\n\nPerson A: \"Hey, I'm gonna build a web app, what should I use?\"\n\nPerson B: \"Well there's a lot of popular frameworks right now, each have their own advantages and disadvant--\"\n\nPerson C: \"USE NODE.JS FOR EVERYTHING NODE.JS IS THE BEST EVERYONE IS USING NODE.JS HOW DO YOU NOT SEE HOW AWESOME NODE.JS IS!?\"\n\nNot a slight against node, it was just the first thing that came to mind. Touting your chosen tech for your specific problem at the exclusion of everything else is counterproductive if not destructive. There's no one technology to rule them all, there's no ultimate answer. There never is. Anyone telling you otherwise is a hack.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45157,"question": "Waging war against another programming paradigm will not lead programmers adopt FP any time sooner. It's bad practice, especially if not accompanied by solid arguments.\n\nFor example, that c++ does not make every object class-based is not a valid argument against c++ not being an OOP programming language.\n\nThat Alan Key said \"I did not have C++ in mind\" does not make C++ a non OOP language.\n\nThat OOP means 'model real world entities' does not make OOP invalid. Objects can be modeled after real world entities, depending on context. Inheritance certainly does not mean 'model real world entities'.\n\nThat dynamic programming languages use test-driven development is totally unrelated to OOP.\n\nThat OOP cannot handle parallelism is wrong. The 'actor' model fits perfectly to OOP.\n\nThat the game industry is moving away from OOP could not be more false. I work in the industry, OOP is stronger than ever.\n\nThat GUI and simulations have solutions in the FP space remains to be seen. Personally, I haven't seen anything related. There are attempts to use reactive frameworks, but there are very few complete examples.\n\nI really don't get the way FP people think. Do you really want to impress us? gives us solutions. Writing articles with that many logical fallacies and false claims does nothing more than reenforce our stereotypes about FP.\n\n\n\n\n\n","aSentId": 45164,"answer": "I\u00a0said that OOP *changed*, not that it was *bad*.  Well, I did, kinda, but that wasn't the main focus.\n\n&gt; For example, that c++ does not make every object class-based is not a valid argument against c++ not being an OOP programming language.\n\nI made no such argument. I just quoted Alan Kay *and*, this is very important, Bjarne \"C++\" Stroustrup himself. Doesn't that count for anything  when the very inventor of a language says it is not OOP?\n\n&gt; That OOP means 'model real world entities' does not make OOP invalid.\n\nI made no such argument. I just relayed the fragile base class argument against *inheritance*, specifically.\n\n&gt; Inheritance certainly does not mean 'model real world entities'.\n\nOf course not.  Where did I\u00a0ever say that?\n\n&gt; That dynamic programming languages use test-driven development is totally unrelated to OOP.\n\nWhy do you think I said OOP was such a protean term? Those languages brand themselves as OOP. TDD was merely an example of how *different* that brand of OOP is from whatever came before it.\n\n&gt; That the game industry is moving away from OOP could not be more false. I work in the industry, OOP is stronger than ever.\n\nYou mean, stronger than a decade ago, before ECS was even invented? I know many are still using OOP (I believe Unreal engine is still using a huge inheritance tree). Many others have moved towards data driven approaches such as ECS. Like Unity.\n\n&gt; That GUI and simulations have solutions in the FP space remains to be seen. Personally, I haven't seen anything related.\n\nI haven't looked closely, but LightTable is an adaptation of ECS for a GUI application (an IDE in this case).\n\n&gt; I really don't get the way FP people think. Do you really want to impress us? gives us solutions. Writing articles with that many logical fallacies and false claims does nothing more than reenforce our stereotypes about FP.\n\nThere is a point where the onus is on you to make the effort to learn. I don't care much about you, so I won't try to convince you. But if you dismiss something so many brilliant minds are excited about without taking a *serious* look, you're just being irrational.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45165,"question": "I\u00a0said that OOP *changed*, not that it was *bad*.  Well, I did, kinda, but that wasn't the main focus.\n\n&gt; For example, that c++ does not make every object class-based is not a valid argument against c++ not being an OOP programming language.\n\nI made no such argument. I just quoted Alan Kay *and*, this is very important, Bjarne \"C++\" Stroustrup himself. Doesn't that count for anything  when the very inventor of a language says it is not OOP?\n\n&gt; That OOP means 'model real world entities' does not make OOP invalid.\n\nI made no such argument. I just relayed the fragile base class argument against *inheritance*, specifically.\n\n&gt; Inheritance certainly does not mean 'model real world entities'.\n\nOf course not.  Where did I\u00a0ever say that?\n\n&gt; That dynamic programming languages use test-driven development is totally unrelated to OOP.\n\nWhy do you think I said OOP was such a protean term? Those languages brand themselves as OOP. TDD was merely an example of how *different* that brand of OOP is from whatever came before it.\n\n&gt; That the game industry is moving away from OOP could not be more false. I work in the industry, OOP is stronger than ever.\n\nYou mean, stronger than a decade ago, before ECS was even invented? I know many are still using OOP (I believe Unreal engine is still using a huge inheritance tree). Many others have moved towards data driven approaches such as ECS. Like Unity.\n\n&gt; That GUI and simulations have solutions in the FP space remains to be seen. Personally, I haven't seen anything related.\n\nI haven't looked closely, but LightTable is an adaptation of ECS for a GUI application (an IDE in this case).\n\n&gt; I really don't get the way FP people think. Do you really want to impress us? gives us solutions. Writing articles with that many logical fallacies and false claims does nothing more than reenforce our stereotypes about FP.\n\nThere is a point where the onus is on you to make the effort to learn. I don't care much about you, so I won't try to convince you. But if you dismiss something so many brilliant minds are excited about without taking a *serious* look, you're just being irrational.\n","aSentId": 45166,"answer": "&gt; Many others have moved towards data driven approaches such as ECS. Like Unity.\n\nI wouldn't say Unity is using an ECS. An ECS as used by t-machine who popularized the term, separates entities from data, and also separates the logic that processes them. Unity doesn't do any of that. Unity's component system has the logic and data inside the components together. More importantly Unity processes the entities with their components together, one by one. An ECS uses a \"system over a component\" style processing - where a whole set of entities are processed together.\n\nAdditionally you mention data driven - and I think you mean data oriented. Data driven in games development means something different from data oriented. Since we are talking about components I'm going to assume you meant data oriented - and in that context Unity's component system is no where near being a data oriented approach.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45167,"question": "&gt; Many others have moved towards data driven approaches such as ECS. Like Unity.\n\nI wouldn't say Unity is using an ECS. An ECS as used by t-machine who popularized the term, separates entities from data, and also separates the logic that processes them. Unity doesn't do any of that. Unity's component system has the logic and data inside the components together. More importantly Unity processes the entities with their components together, one by one. An ECS uses a \"system over a component\" style processing - where a whole set of entities are processed together.\n\nAdditionally you mention data driven - and I think you mean data oriented. Data driven in games development means something different from data oriented. Since we are talking about components I'm going to assume you meant data oriented - and in that context Unity's component system is no where near being a data oriented approach.\n\n","aSentId": 45168,"answer": "A non-data oriented ECS is still very much an ECS. Many game companies are still not doing DOD for their \"game objects\", but ECS has been in commonplace for a long time. I personally rearchitected Commandos in early 1997 from classical hierarchy into an ECS (with funny Spanish names :)), and classic descriptions like Scott Bilas' were published not too long after.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45167,"question": "&gt; Many others have moved towards data driven approaches such as ECS. Like Unity.\n\nI wouldn't say Unity is using an ECS. An ECS as used by t-machine who popularized the term, separates entities from data, and also separates the logic that processes them. Unity doesn't do any of that. Unity's component system has the logic and data inside the components together. More importantly Unity processes the entities with their components together, one by one. An ECS uses a \"system over a component\" style processing - where a whole set of entities are processed together.\n\nAdditionally you mention data driven - and I think you mean data oriented. Data driven in games development means something different from data oriented. Since we are talking about components I'm going to assume you meant data oriented - and in that context Unity's component system is no where near being a data oriented approach.\n\n","aSentId": 45170,"answer": "Ah, that's news. Thanks.\n\nOops, I did mean data oriented.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45165,"question": "I\u00a0said that OOP *changed*, not that it was *bad*.  Well, I did, kinda, but that wasn't the main focus.\n\n&gt; For example, that c++ does not make every object class-based is not a valid argument against c++ not being an OOP programming language.\n\nI made no such argument. I just quoted Alan Kay *and*, this is very important, Bjarne \"C++\" Stroustrup himself. Doesn't that count for anything  when the very inventor of a language says it is not OOP?\n\n&gt; That OOP means 'model real world entities' does not make OOP invalid.\n\nI made no such argument. I just relayed the fragile base class argument against *inheritance*, specifically.\n\n&gt; Inheritance certainly does not mean 'model real world entities'.\n\nOf course not.  Where did I\u00a0ever say that?\n\n&gt; That dynamic programming languages use test-driven development is totally unrelated to OOP.\n\nWhy do you think I said OOP was such a protean term? Those languages brand themselves as OOP. TDD was merely an example of how *different* that brand of OOP is from whatever came before it.\n\n&gt; That the game industry is moving away from OOP could not be more false. I work in the industry, OOP is stronger than ever.\n\nYou mean, stronger than a decade ago, before ECS was even invented? I know many are still using OOP (I believe Unreal engine is still using a huge inheritance tree). Many others have moved towards data driven approaches such as ECS. Like Unity.\n\n&gt; That GUI and simulations have solutions in the FP space remains to be seen. Personally, I haven't seen anything related.\n\nI haven't looked closely, but LightTable is an adaptation of ECS for a GUI application (an IDE in this case).\n\n&gt; I really don't get the way FP people think. Do you really want to impress us? gives us solutions. Writing articles with that many logical fallacies and false claims does nothing more than reenforce our stereotypes about FP.\n\nThere is a point where the onus is on you to make the effort to learn. I don't care much about you, so I won't try to convince you. But if you dismiss something so many brilliant minds are excited about without taking a *serious* look, you're just being irrational.\n","aSentId": 45172,"answer": "I am actually very interested in FP. Do you think I like having to think about all those objects, setter, getters, event handlers, callbacks, etc? I certainly do not.\n\nHowever, each time I try to use FP for something in my domain (guis, simulations, games), the effort I have to do is much greater than the relevant effort in the OOP space, without any actual great benefits over OOP.\n \nIf you want to convert us, show us the brilliance you are talking about. Write code. Write games. Write guis. Write simulations. Let us see that FP is actually the superior programming paradigm. Trying to make OOP bad just to make FP look good won't work.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45173,"question": "I am actually very interested in FP. Do you think I like having to think about all those objects, setter, getters, event handlers, callbacks, etc? I certainly do not.\n\nHowever, each time I try to use FP for something in my domain (guis, simulations, games), the effort I have to do is much greater than the relevant effort in the OOP space, without any actual great benefits over OOP.\n \nIf you want to convert us, show us the brilliance you are talking about. Write code. Write games. Write guis. Write simulations. Let us see that FP is actually the superior programming paradigm. Trying to make OOP bad just to make FP look good won't work.","aSentId": 45174,"answer": "&gt; However, each time I try to use FP for something in my domain (guis, simulations, games), the effort I have to do is much greater than the relevant effort in the OOP space, without any actual great benefits over OOP.\n\nHow many available libraries and framework are available when you do GUI in OOP? In FP? That's a *huge* incentive. I'm currently working on a Qt project, and I just use OOP, not because of C++, but because of Qt. So much ready-made convenience squash any hope at making an FP solution better. If I used an FP framework instead of Qt, things would be different.\n\n&gt; Write code. Write games. Write guis. Write simulations\n\nWill do. That post was just an itch that needed scratching.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45176,"question": "\u00c0 chacun son go\u00fbt, I guess I personally have a very unrefined definition of object oriented as I always saw the component-entity model as heavily object oriented ","aSentId": 45177,"answer": "Yep. Component-entity models only differ from component-object models by a synonym, its even in the wiki article:\n\n&gt; Entity-component-system (ECS) is a architectural pattern that is mostly used in game development. A ECS follows the Composition over inheritance principle that allows greater flexibility in defining entities whereat every object in a game's scene is an entity (e.g. enemies, bullets, vehicles, etc.).\n\nSo objects in ECS are called entities because...well, let's look at the definition of entity:\n\n&gt; a thing with distinct and independent existence.\n\nECS seems heavily OOP, more so than I see in other frameworks that might use inheritance instead. Each entity has a GUID, an identity, the essence of an object, and then after that it is all about modularizing object state and behavior. \n\nContrast to pure FP programming, where values by definition cannot have GUIDs, which would destroy its equational reasoning aspect. Rich Hickey says it best:\n\n&gt; People accustomed to OO conceive of their programs as mutating the values of objects. They understand the true notion of a value, say, 42, as something that would never change, but usually don't extend that notion of value to their object's state. That is a failure of their programming language. These languages use the same constructs for modeling values as they do for identities, objects, and default to mutability, causing all but the most disciplined programmers to create many more identities than they should, creating identities out of things that should be values etc.\n\nAnd improves on it:\n\n&gt; There is another way, and that is to separate identity and state (once again, indirection saves the day in programming). We need to move away from a notion of state as \"the content of this memory block\" to one of \"the value currently associated with this identity\". Thus an identity can be in different states at different times, but the state itself doesn't change. That is, an identity is not a state, an identity has a state.\n\nSo another way of doing objects...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45178,"question": "Yep. Component-entity models only differ from component-object models by a synonym, its even in the wiki article:\n\n&gt; Entity-component-system (ECS) is a architectural pattern that is mostly used in game development. A ECS follows the Composition over inheritance principle that allows greater flexibility in defining entities whereat every object in a game's scene is an entity (e.g. enemies, bullets, vehicles, etc.).\n\nSo objects in ECS are called entities because...well, let's look at the definition of entity:\n\n&gt; a thing with distinct and independent existence.\n\nECS seems heavily OOP, more so than I see in other frameworks that might use inheritance instead. Each entity has a GUID, an identity, the essence of an object, and then after that it is all about modularizing object state and behavior. \n\nContrast to pure FP programming, where values by definition cannot have GUIDs, which would destroy its equational reasoning aspect. Rich Hickey says it best:\n\n&gt; People accustomed to OO conceive of their programs as mutating the values of objects. They understand the true notion of a value, say, 42, as something that would never change, but usually don't extend that notion of value to their object's state. That is a failure of their programming language. These languages use the same constructs for modeling values as they do for identities, objects, and default to mutability, causing all but the most disciplined programmers to create many more identities than they should, creating identities out of things that should be values etc.\n\nAnd improves on it:\n\n&gt; There is another way, and that is to separate identity and state (once again, indirection saves the day in programming). We need to move away from a notion of state as \"the content of this memory block\" to one of \"the value currently associated with this identity\". Thus an identity can be in different states at different times, but the state itself doesn't change. That is, an identity is not a state, an identity has a state.\n\nSo another way of doing objects...","aSentId": 45179,"answer": "This is exactly what the article is talking about though. Whenever the current flavor of the day of \"object oriented programming\" goes out of style (because people finally realize that it's not a magical solution to everything), the new thing gets incorporated under the \"object oriented programming\" umbrella and it all gets even more vague.\n\nECS is *very* different from the typical flavor of inheritance and/or late binding-based OOP with objects' behavior all encapsulated in one nice little package.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45180,"question": "This is exactly what the article is talking about though. Whenever the current flavor of the day of \"object oriented programming\" goes out of style (because people finally realize that it's not a magical solution to everything), the new thing gets incorporated under the \"object oriented programming\" umbrella and it all gets even more vague.\n\nECS is *very* different from the typical flavor of inheritance and/or late binding-based OOP with objects' behavior all encapsulated in one nice little package.","aSentId": 45181,"answer": "we have been debating what objects are since the 80s. You should read the Treaty of Orlando at OOPSLA '88. There were many flavors of OOP that were studied as OOP, many resembling ECS systems, and then Java came along and OOP suddenly meant just what Java does. \n\nI mean seriously, would anyone ever call CLOS (from the late 80s) not OOP?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45182,"question": "we have been debating what objects are since the 80s. You should read the Treaty of Orlando at OOPSLA '88. There were many flavors of OOP that were studied as OOP, many resembling ECS systems, and then Java came along and OOP suddenly meant just what Java does. \n\nI mean seriously, would anyone ever call CLOS (from the late 80s) not OOP?","aSentId": 45183,"answer": "Again, that is the point of the article.\n\nOOP is a really vague term, so applying it to anything that has any form of \"object\" (itself a really widely applicable term) is extremely counterproductive when trying to talk about programming paradigms. The interesting things are the distinctions, not whether you can jam the term \"object\" in somewhere.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45184,"question": "Again, that is the point of the article.\n\nOOP is a really vague term, so applying it to anything that has any form of \"object\" (itself a really widely applicable term) is extremely counterproductive when trying to talk about programming paradigms. The interesting things are the distinctions, not whether you can jam the term \"object\" in somewhere.","aSentId": 45185,"answer": "That is always true. But then why claim \"the repeated death of OOP\" as if it was some very specific philosophy/paradigm, etc? PG's blub principles is probably relevant. \n\nThis is not about claiming territory for OOP, but avoiding stereotypes that don't add much value (and stereotypes are associated with OOP, but that is beside the point). OOP is quite literally programming with objects; *they even put it in the bloody name.* \n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45186,"question": "That is always true. But then why claim \"the repeated death of OOP\" as if it was some very specific philosophy/paradigm, etc? PG's blub principles is probably relevant. \n\nThis is not about claiming territory for OOP, but avoiding stereotypes that don't add much value (and stereotypes are associated with OOP, but that is beside the point). OOP is quite literally programming with objects; *they even put it in the bloody name.* \n\n","aSentId": 45187,"answer": "I suppose you could say \"OOP is dead, long live OOP.\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45188,"question": "I suppose you could say \"OOP is dead, long live OOP.\"","aSentId": 45189,"answer": "True that. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45178,"question": "Yep. Component-entity models only differ from component-object models by a synonym, its even in the wiki article:\n\n&gt; Entity-component-system (ECS) is a architectural pattern that is mostly used in game development. A ECS follows the Composition over inheritance principle that allows greater flexibility in defining entities whereat every object in a game's scene is an entity (e.g. enemies, bullets, vehicles, etc.).\n\nSo objects in ECS are called entities because...well, let's look at the definition of entity:\n\n&gt; a thing with distinct and independent existence.\n\nECS seems heavily OOP, more so than I see in other frameworks that might use inheritance instead. Each entity has a GUID, an identity, the essence of an object, and then after that it is all about modularizing object state and behavior. \n\nContrast to pure FP programming, where values by definition cannot have GUIDs, which would destroy its equational reasoning aspect. Rich Hickey says it best:\n\n&gt; People accustomed to OO conceive of their programs as mutating the values of objects. They understand the true notion of a value, say, 42, as something that would never change, but usually don't extend that notion of value to their object's state. That is a failure of their programming language. These languages use the same constructs for modeling values as they do for identities, objects, and default to mutability, causing all but the most disciplined programmers to create many more identities than they should, creating identities out of things that should be values etc.\n\nAnd improves on it:\n\n&gt; There is another way, and that is to separate identity and state (once again, indirection saves the day in programming). We need to move away from a notion of state as \"the content of this memory block\" to one of \"the value currently associated with this identity\". Thus an identity can be in different states at different times, but the state itself doesn't change. That is, an identity is not a state, an identity has a state.\n\nSo another way of doing objects...","aSentId": 45191,"answer": "&gt; pure FP programming, where values by definition cannot have GUIDs, which would destroy its equational reasoning aspect.\n\nThat is not true. You are welcome to add a GUID to your records in Haskell (and other FPLs). You may also provide your own Eq typeclass instance if you want to test equality differently than the default. The issue with Java is that it gives every class an extra field called \"magicID\" (not really) and an extra method called == that you can't change. So think of FP as forcing you to use .equals(). If you want the == behavior, you have to add the id explicitly. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45192,"question": "&gt; pure FP programming, where values by definition cannot have GUIDs, which would destroy its equational reasoning aspect.\n\nThat is not true. You are welcome to add a GUID to your records in Haskell (and other FPLs). You may also provide your own Eq typeclass instance if you want to test equality differently than the default. The issue with Java is that it gives every class an extra field called \"magicID\" (not really) and an extra method called == that you can't change. So think of FP as forcing you to use .equals(). If you want the == behavior, you have to add the id explicitly. ","aSentId": 45193,"answer": "A GUID generator in haskell is impure, most FLs are impure in contrast. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45192,"question": "&gt; pure FP programming, where values by definition cannot have GUIDs, which would destroy its equational reasoning aspect.\n\nThat is not true. You are welcome to add a GUID to your records in Haskell (and other FPLs). You may also provide your own Eq typeclass instance if you want to test equality differently than the default. The issue with Java is that it gives every class an extra field called \"magicID\" (not really) and an extra method called == that you can't change. So think of FP as forcing you to use .equals(). If you want the == behavior, you have to add the id explicitly. ","aSentId": 45195,"answer": "== does exactly what it says - it tells you if two values are equal.\n\nThe issue with it is that objects aren't values, references are.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45178,"question": "Yep. Component-entity models only differ from component-object models by a synonym, its even in the wiki article:\n\n&gt; Entity-component-system (ECS) is a architectural pattern that is mostly used in game development. A ECS follows the Composition over inheritance principle that allows greater flexibility in defining entities whereat every object in a game's scene is an entity (e.g. enemies, bullets, vehicles, etc.).\n\nSo objects in ECS are called entities because...well, let's look at the definition of entity:\n\n&gt; a thing with distinct and independent existence.\n\nECS seems heavily OOP, more so than I see in other frameworks that might use inheritance instead. Each entity has a GUID, an identity, the essence of an object, and then after that it is all about modularizing object state and behavior. \n\nContrast to pure FP programming, where values by definition cannot have GUIDs, which would destroy its equational reasoning aspect. Rich Hickey says it best:\n\n&gt; People accustomed to OO conceive of their programs as mutating the values of objects. They understand the true notion of a value, say, 42, as something that would never change, but usually don't extend that notion of value to their object's state. That is a failure of their programming language. These languages use the same constructs for modeling values as they do for identities, objects, and default to mutability, causing all but the most disciplined programmers to create many more identities than they should, creating identities out of things that should be values etc.\n\nAnd improves on it:\n\n&gt; There is another way, and that is to separate identity and state (once again, indirection saves the day in programming). We need to move away from a notion of state as \"the content of this memory block\" to one of \"the value currently associated with this identity\". Thus an identity can be in different states at different times, but the state itself doesn't change. That is, an identity is not a state, an identity has a state.\n\nSo another way of doing objects...","aSentId": 45197,"answer": "A GUID is not an identity, it's just a value (typically an integer). There's nothing inherent in pure FP that prevents you from working with such things.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45198,"question": "A GUID is not an identity, it's just a value (typically an integer). There's nothing inherent in pure FP that prevents you from working with such things.","aSentId": 45199,"answer": "You can't generate and use a GUID while still maintaining equational reasoning, I hhoe that is at least obvious. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45200,"question": "You can't generate and use a GUID while still maintaining equational reasoning, I hhoe that is at least obvious. ","aSentId": 45201,"answer": "Sure you can. Just write a GUID Monad.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45202,"question": "Sure you can. Just write a GUID Monad.","aSentId": 45203,"answer": "Yep. You still lose your equational reasoning though, even if the effect is explicit (as with any use of monads, they string a world object through everything). GUIDs allow stateful values (being stateful is equivalent to having a unique identity, the essence of an object is its unique identity). ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45204,"question": "Yep. You still lose your equational reasoning though, even if the effect is explicit (as with any use of monads, they string a world object through everything). GUIDs allow stateful values (being stateful is equivalent to having a unique identity, the essence of an object is its unique identity). ","aSentId": 45205,"answer": "No, you don't.\n\n    main = do\n        foo &lt;- bar &gt;&gt;= baz\n        foo2 &lt;- bar &gt;&gt;= baz\n        print foo\n        print foo2\n\n\nGives exactly the same behaviour as:\n\n    main = let quux = bar &gt;&gt;= baz in do\n        foo &lt;- quux\n        foo2 &lt;- quux\n        print foo\n        print foo2\n\nThere is no effect here. This is merely the purely functional construction of monadic values, preserving equational reasoning. The effects are handled by the runtime and are outside the scope of our program for all intents and purposes.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45206,"question": "No, you don't.\n\n    main = do\n        foo &lt;- bar &gt;&gt;= baz\n        foo2 &lt;- bar &gt;&gt;= baz\n        print foo\n        print foo2\n\n\nGives exactly the same behaviour as:\n\n    main = let quux = bar &gt;&gt;= baz in do\n        foo &lt;- quux\n        foo2 &lt;- quux\n        print foo\n        print foo2\n\nThere is no effect here. This is merely the purely functional construction of monadic values, preserving equational reasoning. The effects are handled by the runtime and are outside the scope of our program for all intents and purposes.","aSentId": 45207,"answer": "The effects are still there, say you have an object value with a unique identity and a dictionary of unique identities to property values. To understand what that object value \"means\" depends on that property dictionary. That makes reasoning much harder since he object value is effectively stateful (you can even alias it!). ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45208,"question": "The effects are still there, say you have an object value with a unique identity and a dictionary of unique identities to property values. To understand what that object value \"means\" depends on that property dictionary. That makes reasoning much harder since he object value is effectively stateful (you can even alias it!). ","aSentId": 45209,"answer": "But you don't have any of those things. You have pure monadic values standing in for the computations which manipulate those things. It's a subtle but very important distinction.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45210,"question": "But you don't have any of those things. You have pure monadic values standing in for the computations which manipulate those things. It's a subtle but very important distinction.","aSentId": 45211,"answer": "Haskell, even Haskell without unsafe constructs, is Turing complete. You can write a JVM on top of Haskell, but that wouldn't make Java code pure.\n\nIn giving a bunch of values identities then using a immutable world dictionary to maintain mutable properties about them, you cross a line somewhere. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45213,"question": "I don't understand how the criticism of scripted languages and TDD supports your point that OOP is dead. That whole section didn't really make sense to me in the context of the larger argument you were trying to make.","aSentId": 45214,"answer": "I don't necessarily see that section as criticism, just stating facts. But yes, it is a little out of place.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45215,"question": "I don't necessarily see that section as criticism, just stating facts. But yes, it is a little out of place.","aSentId": 45216,"answer": "For the record, I'm not entirely happy with that section. I just didn't have a better example of how different dynamic OOP languages are from the static ones, mostly because I lack experience in them. (I have written a couple thousand lines of Lua, and that's basically it.)\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45213,"question": "I don't understand how the criticism of scripted languages and TDD supports your point that OOP is dead. That whole section didn't really make sense to me in the context of the larger argument you were trying to make.","aSentId": 45218,"answer": "It wasn't a criticism. TDD is *good*. I badly felt the need for it when I started a semi-serious project with Lua. But yeah, dynamic type systems are bust for me. Beyond a couple hundred lines, I lack the brainpower to think for them. I *really* need my static checks.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45220,"question": "In any OOP discussion you'll find no end of language nerds who say that OOP is dead and is a flawed paradigm.  I don't care enough to argue either way.\n\nWhat I do know is that it's not dead, simply because there are a shit ton of legacy C++ OOP codebases to maintain and extend out there. \n\nI don't care if monads and a functional lambda something-something could have been used.  When you're handed a million line C++ OOP codebase with bugs to fix, features to implement and users to support today, you're boss/organizing is sure going to love you wax snobbily  about how it should have all been done in Haskell.","aSentId": 45221,"answer": "&gt; In any OOP discussion you'll find no end of language nerds who say that OOP is dead and is a flawed paradigm. I don't care enough to argue either way.  What I do know is that it's not dead, simply because there are a shit ton of legacy C++ OOP codebases to maintain and extend out there.\n\nDid you read the article?  I quote:\n\n&gt; (Note: the following \"deaths\" are only in rough chronological order, and often describe a slow decline in popularity, not a brutal cessation of activity. Think of COBOL. The language is long dead, yet still maintained to this day.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45220,"question": "In any OOP discussion you'll find no end of language nerds who say that OOP is dead and is a flawed paradigm.  I don't care enough to argue either way.\n\nWhat I do know is that it's not dead, simply because there are a shit ton of legacy C++ OOP codebases to maintain and extend out there. \n\nI don't care if monads and a functional lambda something-something could have been used.  When you're handed a million line C++ OOP codebase with bugs to fix, features to implement and users to support today, you're boss/organizing is sure going to love you wax snobbily  about how it should have all been done in Haskell.","aSentId": 45223,"answer": "I have not seen an OOP C++ code quite for a while. Generic? A lot. Modular? Of course. Functional? A little bit, yes. But OOP is nearly non-existent in the modern C++.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45224,"question": "I have not seen an OOP C++ code quite for a while. Generic? A lot. Modular? Of course. Functional? A little bit, yes. But OOP is nearly non-existent in the modern C++.","aSentId": 45225,"answer": "So you don't see inheritance anywhere? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45226,"question": "So you don't see inheritance anywhere? ","aSentId": 45227,"answer": "Inheritance per se does not make it an OOP. In most of the cases it's there as just a poorly implemented modularity. There is no object model of the problem domain attached to this mere low-level semantics, therefore, it's not that OOP the religious zealots are touting.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45228,"question": "Inheritance per se does not make it an OOP. In most of the cases it's there as just a poorly implemented modularity. There is no object model of the problem domain attached to this mere low-level semantics, therefore, it's not that OOP the religious zealots are touting.","aSentId": 45229,"answer": "So OOP is fine as long as you wrap it in functional programming buzzwords, got it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45230,"question": "So OOP is fine as long as you wrap it in functional programming buzzwords, got it.","aSentId": 45231,"answer": "What? You did not get a thing. Functional programming is totally irrelevant here.\n\nOOP is not fine. It is a broken methodology and a totally broken way of modelling real-world problems. Some of the programming languages semantics elements are somehow associated with OOP (for no particular reason), and some people would call any use of such elements an OOP, which is totally pointless.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45234,"question": "Over time, i have adopted my own definitions. Will probably make you cringe, but here they are\n \nProcedure: A routine which have or rely on a persistent state.  \nFunction: A routine which cannot have or rely on a persistent state, which is referentially transparent (like a mathematics's function).  \nProcedural programming: Reasoning through procedures.  \nFunctional programming: Reasoning through functions.  \nPurely functional programming: Reasoning through and only through functions.  \nAbstract data type: Data is hidden by a separated/external cluster of operations.  \nObject: Data is hidden by a included/internal cluster of operations (a.k.a the object's interface).  \nObject oriented programming: Reasoning through objects.  \nPure OOP: Reasoning through and only through objects.  \nMethod: Procedure bound to an object (eg: when the *this* argument is implicit).  \nProcedural (or stateful) ADT: has procedures in its cluster of ops  \nFunctional (or stateless) ADT: has only functions in its cluster of ops.  \nsame for Functional and Procedural Object.\n\nI see both ADT and Object as data abstraction techniques. It's easier to make sub-objects with Objects than sub-types with ADTs but it's easier to add operations with ADTs than with Objects (the row vs column thing). \n\nNeither Procedural nor Functional programming are in conflict with OOP because you can compose the cluster of operations with functions or procedures or both. It's just that OOP + Functional + Static typing will turn inheritance really painful.\n\nThis definition of object (and oop) remains valid whatever is the concept you rely on to build object (classes, prototypes, high-order programming) or to invoke operations (messages, routine calls). \n\nTo show an example of adt vs obj and proc vs func in pseudo code:\n\n    Type AT;\n    \n    // cluster of ops is seperated of the type\n    add_func (const AT a, const AT b) -&gt; const AT; // a + b\n    add_proc (AT a, const AT b) -&gt; None; // a += b\n    \n    Object O {\n    \t// cluster of ops is included in the object and can only\n    \t// be accessed through this one.\n    \tadd_func (const O this, const O b) -&gt; const AT;\n    \tadd_proc (O this, const O b) -&gt; None;\n        add_method (const O b) -&gt; None; // implicit \"this\" argument\n    }\n\n","aSentId": 45235,"answer": "I operate more or less under the same definitions. I have just one qualm: `a.f(x)` and `f(a, x)` are just a little syntax sugar away. I have heard there's a C++ proposal to make them strictly equivalent, even. This would seriously fuzzy the limit between abstract data types and objects.\n\nAs for the expression problem you talk about, it seems it's not an Abstract Data Type vs Object match, but an *Algebraic* Data Type vs *Inheritance* Hierarchy. If you put one in the ADT bucket, and the other in the object bucket, then the limit becomes sharp again.\n\nHence my *one* qualm about your definitions: you didn't mention inheritance (or delegation) along with object, and you did not mention sum types at all. But that's a detail at that point. If everyone thought as clearly as you do, we wouldn't be in this mess to begin with.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45236,"question": "I operate more or less under the same definitions. I have just one qualm: `a.f(x)` and `f(a, x)` are just a little syntax sugar away. I have heard there's a C++ proposal to make them strictly equivalent, even. This would seriously fuzzy the limit between abstract data types and objects.\n\nAs for the expression problem you talk about, it seems it's not an Abstract Data Type vs Object match, but an *Algebraic* Data Type vs *Inheritance* Hierarchy. If you put one in the ADT bucket, and the other in the object bucket, then the limit becomes sharp again.\n\nHence my *one* qualm about your definitions: you didn't mention inheritance (or delegation) along with object, and you did not mention sum types at all. But that's a detail at that point. If everyone thought as clearly as you do, we wouldn't be in this mess to begin with.","aSentId": 45237,"answer": "&gt; a.f(x) and f(a, x) are just a little syntax sugar away.\n\nD does pretty much exactly this, they call it \"Universal Function Call Syntax\". C# has \"Extension Methods\" which are similar. OTOH in JQuery and Java (builder pattern) the trick is to just write tons of boilerplate. Meanwhile in languages with composition operators you can do pretty much everything you can do with UFCS and without any boilerplate.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45240,"question": "Game programmer here. OOP is not going away. Popular game engines like Unity are built entirely upon OOP, where GameObjects are composed of Components.","aSentId": 45241,"answer": "Someone didn't read the article...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45242,"question": "Someone didn't read the article...","aSentId": 45243,"answer": "I didn't read through the last point, you got me on that. This article is ridiculous though, composition is a form of OOP. This article might as well just claim inheritance is dead, that would be more accurate. But even so, that model is alive and well, just not the large inflexible inheritance trees, and that model was on the way out 7-10 years ago. He then goes on to tout immutability as a cure-all for multicore performance, but in situations the require high performance, large amounts of garbage collection will drag you down.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45240,"question": "Game programmer here. OOP is not going away. Popular game engines like Unity are built entirely upon OOP, where GameObjects are composed of Components.","aSentId": 45245,"answer": "The usage of components over object inheritance hierarchies is a prime example of OOP going away...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45246,"question": "The usage of components over object inheritance hierarchies is a prime example of OOP going away...","aSentId": 45247,"answer": "OOP includes both inheritance and composition (my Car object HAS an Engine). People have gotten smart enough to stop using ridiculous inheritance trees, but that doesn't mean OOP is going away.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45248,"question": "OOP includes both inheritance and composition (my Car object HAS an Engine). People have gotten smart enough to stop using ridiculous inheritance trees, but that doesn't mean OOP is going away.","aSentId": 45249,"answer": "When I think of the way Unity handles components, I don't think of it as composition. Maybe because there's no static way to reference other components and it's free to change its composition at runtime (by adding or removing components). But those things really aren't mentioned in anything that talks about what composition is - so you've changed how I think about this!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45250,"question": "When I think of the way Unity handles components, I don't think of it as composition. Maybe because there's no static way to reference other components and it's free to change its composition at runtime (by adding or removing components). But those things really aren't mentioned in anything that talks about what composition is - so you've changed how I think about this!","aSentId": 45251,"answer": "You could say an Entity is composed of a dynamic set of Components, and those Components may be composed of other components or may inherit from another type of Component.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45248,"question": "OOP includes both inheritance and composition (my Car object HAS an Engine). People have gotten smart enough to stop using ridiculous inheritance trees, but that doesn't mean OOP is going away.","aSentId": 45253,"answer": "That's where I think you misunderstand the OP. He's not arguing that inheritance is dead. Inheritance is one tool in the box, but it's not your defining architecture.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45246,"question": "The usage of components over object inheritance hierarchies is a prime example of OOP going away...","aSentId": 45255,"answer": "It's a prime example of how nobody can agree on the definition of OOP.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45240,"question": "Game programmer here. OOP is not going away. Popular game engines like Unity are built entirely upon OOP, where GameObjects are composed of Components.","aSentId": 45257,"answer": "Well, recall the part where I said new cool stuff is called \"OOP\" just so we can use it (example: parametric polymorphism turned generics).\n\nWant to call ECS a flavour of OOP? Fine. That will just be one more death.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45258,"question": "Well, recall the part where I said new cool stuff is called \"OOP\" just so we can use it (example: parametric polymorphism turned generics).\n\nWant to call ECS a flavour of OOP? Fine. That will just be one more death.","aSentId": 45259,"answer": "Think ECS is going away? I'm open for suggestions as to capable solutions. Remember that game engines affect the editor itself and the way artists and designers interface with the engine, so any alternative needs to be presented to other developers intuitively.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45260,"question": "Think ECS is going away? I'm open for suggestions as to capable solutions. Remember that game engines affect the editor itself and the way artists and designers interface with the engine, so any alternative needs to be presented to other developers intuitively.","aSentId": 45261,"answer": "I don't think ECS is going away. If anything, it will likely replace the horrendous inheritance hierarchy scheme that was used before.\n\nI'm saying, if you encompass ECS into the OOP umbrella, that will change OOP's meaning *yet again*, which in the context of my blog post means another death.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45263,"question": "I may be missing the point, but I don't really grok people who keep insisting on the death of OOP, as if they hate inheritance so much that anything touched by it must die. Sure, excess of it is terrible, but should we not talk about good practices (as we do when we take composition as a better alternative) instead of advocate for very different paradigms on everything else?\n\nThe way I see it, as broken as OOP might seem, it has survived because it's the lesser evil in practice. Would love to know the holes in that argument.\n\nCertain paradigms might be better applied to a set of problems (eg functional) but I'd say it's a limited solution for very specific problems. ","aSentId": 45264,"answer": "Inheritance is a very specific pattern that implies a lot more than it seems to at first glance, especially if you involve dynamic dispatch. It often turns out that there is a better pattern that would be easier to read, more flexible, and more amenable to optimization.\n\nInheritance bothers me because I have a lower threshold for \"excess\"- because it's a language-level default tool people jump to, it gets used even when it shouldn't, and that \"shouldn't\" is apparently very non-obvious until you have seen or used some good alternatives to flush the OOP defaults out of your thought process.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45263,"question": "I may be missing the point, but I don't really grok people who keep insisting on the death of OOP, as if they hate inheritance so much that anything touched by it must die. Sure, excess of it is terrible, but should we not talk about good practices (as we do when we take composition as a better alternative) instead of advocate for very different paradigms on everything else?\n\nThe way I see it, as broken as OOP might seem, it has survived because it's the lesser evil in practice. Would love to know the holes in that argument.\n\nCertain paradigms might be better applied to a set of problems (eg functional) but I'd say it's a limited solution for very specific problems. ","aSentId": 45266,"answer": "&gt; The way I see it, as broken as OOP might seem, it has survived because it's the lesser evil in practice. Would love to know the holes in that argument.\n\nJust curious what is the lesser evil?\n\nOOP is easier to visualize and model where as functional is more mathematical and conceptual.\n\nThe problem with OOP right now is in the era of multicore holding state is bad. Functional paradigm of transforming data instead of holding state is actually better for multicore.\n\nI'm not sure if OOP is going to die but I know for sure Functional paradigm will see more adoption.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45267,"question": "&gt; The way I see it, as broken as OOP might seem, it has survived because it's the lesser evil in practice. Would love to know the holes in that argument.\n\nJust curious what is the lesser evil?\n\nOOP is easier to visualize and model where as functional is more mathematical and conceptual.\n\nThe problem with OOP right now is in the era of multicore holding state is bad. Functional paradigm of transforming data instead of holding state is actually better for multicore.\n\nI'm not sure if OOP is going to die but I know for sure Functional paradigm will see more adoption.","aSentId": 45268,"answer": "OOP is easier to visualise than what, exactly? A low level imperative code flow is easy to visualise, yes, see the flow charts. Dataflow is very easy to visualise, see LabView and alike. But OOP? No way. Spaghetti mess of UML is nowhere near any easy visualisations. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45269,"question": "OOP is easier to visualise than what, exactly? A low level imperative code flow is easy to visualise, yes, see the flow charts. Dataflow is very easy to visualise, see LabView and alike. But OOP? No way. Spaghetti mess of UML is nowhere near any easy visualisations. ","aSentId": 45270,"answer": "Data flow makes it easier to visualize behaviour; OOP makes it easier to visualize state (as an object graph).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45267,"question": "&gt; The way I see it, as broken as OOP might seem, it has survived because it's the lesser evil in practice. Would love to know the holes in that argument.\n\nJust curious what is the lesser evil?\n\nOOP is easier to visualize and model where as functional is more mathematical and conceptual.\n\nThe problem with OOP right now is in the era of multicore holding state is bad. Functional paradigm of transforming data instead of holding state is actually better for multicore.\n\nI'm not sure if OOP is going to die but I know for sure Functional paradigm will see more adoption.","aSentId": 45272,"answer": "&gt; OOP is easier to visualize and model where as functional is more mathematical and conceptual.\n\nI totally agree with this perspective.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45263,"question": "I may be missing the point, but I don't really grok people who keep insisting on the death of OOP, as if they hate inheritance so much that anything touched by it must die. Sure, excess of it is terrible, but should we not talk about good practices (as we do when we take composition as a better alternative) instead of advocate for very different paradigms on everything else?\n\nThe way I see it, as broken as OOP might seem, it has survived because it's the lesser evil in practice. Would love to know the holes in that argument.\n\nCertain paradigms might be better applied to a set of problems (eg functional) but I'd say it's a limited solution for very specific problems. ","aSentId": 45274,"answer": "I know *one* legitimate use case for inheritance: writing formal grammars. You just override a production (like you would a method), and voil\u00e0, you have another syntax. Very handy when combined with full Parsing Expression Grammars.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45275,"question": "I know *one* legitimate use case for inheritance: writing formal grammars. You just override a production (like you would a method), and voil\u00e0, you have another syntax. Very handy when combined with full Parsing Expression Grammars.\n","aSentId": 45276,"answer": "Then there is another similar case for you: inheriting AST structures, for the sequences of slightly different languages (see nanopass framework for example of this approach). But, this sort of inheritance is very different from the typical OOP approach.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45281,"question": "I wish that this very nice article would provide some code / pseudo-code examples for ECS. Say I'm using Java. Where are the functions in the component-entity model? Are they object methods or static functions? \n\nI know the concept of entities in terms of ORMs, a way of thinking of things both as objects, and as sets of persistent data. Besides the tying of properties to DB fields, ORMs allow completely standard OOP, design patters, and what not. ","aSentId": 45282,"answer": "Sorry, I don't know ECS well enough to provide such an example. One of my projects in my backlog is to write a simple ECS framework. Once I do that, I'll be able to write about it.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45284,"question": "The death of OOP will be even simpler. OOP is just a collection of modes of use of records + closures. There is no reason to give those modes of use that correspond to OOP concepts special status within a language such as objects, classes, and inheritance. Once you understand that those modes of use of records are nothing special, you also understand that they are vastly over applied in OOP languages, and that other ways of structuring your data are usually more appropriate (e.g. ECS, relational, algebraic data types). It can be difficult to get out of the OOP mindset though. Once you've been using OOP for a long time you forget how unnatural it actually was when you first started learning it, and when you are trying to model data your mind immediately jumps to an OO design.","aSentId": 45285,"answer": "How come some languages, like Perl, get so much flak for their lack of \"proper\" OOP support? For quick stuff, my own Perl seems to be mostly procedural with a OOP stuff mixed in when using libraries.\n\nOn the other hand, it blew my socks off when I first tried to do **foo++** in Ruby...\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45286,"question": "How come some languages, like Perl, get so much flak for their lack of \"proper\" OOP support? For quick stuff, my own Perl seems to be mostly procedural with a OOP stuff mixed in when using libraries.\n\nOn the other hand, it blew my socks off when I first tried to do **foo++** in Ruby...\n","aSentId": 45287,"answer": "&gt; How come some languages, like Perl, get so much flak for their lack of \"proper\" OOP support?\n\nIf I had to guess, I'd say, because people jump to OOP solution before they even start thinking? Then *any* sufficiently popular language that doesn't do OOP by default would get some flak.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45289,"question": "Wow, what an uninformed article. Knowledgeable people like you support it? Not sure, by this article, you deserve to fit in this category.\n\nInheritance is not about code reuse, it is about subtypes and polymorphism. This is not a blow to OOP, only to a beginner's perspective.\n\nAnd as if generics break down oop! Object oriented languages aren't OO because you write the word Object in your code a bunch! Completely infantile argument.\n\nAll this from the guy who claims to be some kind of language specialist and hasn't heard of Go!\n\nSeriously, who are you, what are your credentials?","aSentId": 45290,"answer": "&gt; Knowledgeable people like you support it? Not sure, by this article, you deserve to fit in this category.\n\nI was wondering how long it would take for someone to call me out on this.  I was being sarcastic. The *real* knowledgeable people are the like of Simon Marlow, Simon Peyton Jones, Xavier Leroy, Don Stewart, Chris Okasaki, Alexander Stepanov\u2026 People who unlike me have *done stuff* \u2014and still shun OOP. Of course, I'm aware that *other* knowledgeable people still support OOP. I think we can safely say that expert opinion is divided.\n\nI considered taking this sentence out, but I couldn't find a better phrasing.\n\n&gt; Inheritance is not about code reuse, it is about subtypes and polymorphism.\n\n1. You think [I don't know that?](http://loup-vaillant.fr/articles/classes-as-syntactic-sugar)\n2. I remember how inheritance was sold, and I remember what I was taught. Back then, code reuse was an important criterion.\n\n&gt; This is not a blow to OOP, only to a beginner's perspective.\n\nOf course not. But committing, then rejecting, that mistake, *did* change the way we programmed.\n\n&gt; And as if generics break down oop! Object oriented languages aren't OO because you write the word Object in your code a bunch! \n\nBut they did change the way we write Java code. Maybe not *much*, but still. Also note that I have not dedicated a death to this one. The *real* change at that time was the realization that design patterns were cool.\n\n&gt; All this from the guy who claims to be some kind of language specialist and hasn't heard of Go!\n\nI'm an *aspiring* language specialist. Maybe I gave you the wrong impression\u2026 Oh, right. About my writing style: I make it short. I usually cut any standard disclaimers about my own ignorance or uncertainty. It often comes out too dogmatic for some people.\n\n&gt; Seriously, who are you, what are your credentials?\n\nI am a random guy on the internet, and you should not take anything I say at face value. _This_, is not sarcasm. You have to judge my work for yourself.\n\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45291,"question": "&gt; Knowledgeable people like you support it? Not sure, by this article, you deserve to fit in this category.\n\nI was wondering how long it would take for someone to call me out on this.  I was being sarcastic. The *real* knowledgeable people are the like of Simon Marlow, Simon Peyton Jones, Xavier Leroy, Don Stewart, Chris Okasaki, Alexander Stepanov\u2026 People who unlike me have *done stuff* \u2014and still shun OOP. Of course, I'm aware that *other* knowledgeable people still support OOP. I think we can safely say that expert opinion is divided.\n\nI considered taking this sentence out, but I couldn't find a better phrasing.\n\n&gt; Inheritance is not about code reuse, it is about subtypes and polymorphism.\n\n1. You think [I don't know that?](http://loup-vaillant.fr/articles/classes-as-syntactic-sugar)\n2. I remember how inheritance was sold, and I remember what I was taught. Back then, code reuse was an important criterion.\n\n&gt; This is not a blow to OOP, only to a beginner's perspective.\n\nOf course not. But committing, then rejecting, that mistake, *did* change the way we programmed.\n\n&gt; And as if generics break down oop! Object oriented languages aren't OO because you write the word Object in your code a bunch! \n\nBut they did change the way we write Java code. Maybe not *much*, but still. Also note that I have not dedicated a death to this one. The *real* change at that time was the realization that design patterns were cool.\n\n&gt; All this from the guy who claims to be some kind of language specialist and hasn't heard of Go!\n\nI'm an *aspiring* language specialist. Maybe I gave you the wrong impression\u2026 Oh, right. About my writing style: I make it short. I usually cut any standard disclaimers about my own ignorance or uncertainty. It often comes out too dogmatic for some people.\n\n&gt; Seriously, who are you, what are your credentials?\n\nI am a random guy on the internet, and you should not take anything I say at face value. _This_, is not sarcasm. You have to judge my work for yourself.\n\n\n","aSentId": 45292,"answer": "Well you've struck a chord with people who already agree with you and there _is_ value in that. However, I fear you push people away from OO without cause. I hope you become one of those knowledgeable people, whether you are for OO or against it, and can put your points in logical convincing fashions. Discussion is good and I'm glad you want to take part.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45294,"question": "Wait...people don't like OOP? That's all I ever use.","aSentId": 45295,"answer": "I think it's better to be pragmatic and say certain part of OOP should be discourage. \n\nOne example is composition over inheritance. And like a redditor have commented on polymorphism and subtyping where you should use inheritance. If you have turtle all the way down you're doing something wrong.\n\nIn general OOP works and very debatable if it's going away. I like a mix like Scala unfortunately I dislike Scala's complexity (that or I'm too dumb).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45294,"question": "Wait...people don't like OOP? That's all I ever use.","aSentId": 45297,"answer": "Some people don't, much like some people don't like logic programming, some people don't like array-based programming, some people don't like functional programming, and so on.\n\nBut I would recommend learning something other than OOP. If nothing else just so at least you know what tradeoffs you are making by only using OOP.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45298,"question": "Some people don't, much like some people don't like logic programming, some people don't like array-based programming, some people don't like functional programming, and so on.\n\nBut I would recommend learning something other than OOP. If nothing else just so at least you know what tradeoffs you are making by only using OOP.","aSentId": 45299,"answer": "Sometimes OOP just helps me organize things better. But if you rely on it 100% in my experience, you fall into an endless sea of object orientation and you end up never finishing what you started. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45300,"question": "Sometimes OOP just helps me organize things better. But if you rely on it 100% in my experience, you fall into an endless sea of object orientation and you end up never finishing what you started. ","aSentId": 45301,"answer": "Well, to keep this simple, one of the big problems here is that there's a long history of OOP advocates taking features or techniques that exist in many different language, and then calling them \"OOP\" with the implications or connotations that:\n\n1. The feature or technique was invented by OOP;\n2. Languages that are not OOP don't have the feature or allow you to use the technique.\n\nSo I don't know what precisely you mean by this:\n\n&gt; Sometimes OOP just helps me organize things better.\n\n...but I just strongly suspect that whatever features or techniques you're thinking of, most if not all of them either (a) are no more \"OOP\" than statements or variables are, or (b) have simple and effective counterparts in non-OOP languages.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45302,"question": "Well, to keep this simple, one of the big problems here is that there's a long history of OOP advocates taking features or techniques that exist in many different language, and then calling them \"OOP\" with the implications or connotations that:\n\n1. The feature or technique was invented by OOP;\n2. Languages that are not OOP don't have the feature or allow you to use the technique.\n\nSo I don't know what precisely you mean by this:\n\n&gt; Sometimes OOP just helps me organize things better.\n\n...but I just strongly suspect that whatever features or techniques you're thinking of, most if not all of them either (a) are no more \"OOP\" than statements or variables are, or (b) have simple and effective counterparts in non-OOP languages.","aSentId": 45303,"answer": "All I mean is if I have a bunch of variables called carColor, carSpeed, and carPrice...I turn it into an object. Just makes way more sense.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45305,"question": "I think golang is another sign of the purported \"OOP death,\" and I'm surprised it's absent from this article.  Maybe because it's not that popular?","aSentId": 45306,"answer": "No, it's because I know nothing about that language. Could you fill in the void? Why is Go yet another sign?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45307,"question": "No, it's because I know nothing about that language. Could you fill in the void? Why is Go yet another sign?","aSentId": 45308,"answer": "Go has a concept of structs whose instances have methods that can be called. It's a very loose sort of OO. There's no inheritance or anything like that. It does have interfaces, but that's about it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45309,"question": "Go has a concept of structs whose instances have methods that can be called. It's a very loose sort of OO. There's no inheritance or anything like that. It does have interfaces, but that's about it.","aSentId": 45310,"answer": "That's just a gimped type system that doesn't have generics.\n\nThey dumb Go down because of the problem domain they're trying to solve and what Rob Pike think is needed and not needed to solve that domain.\n\nWhether this is good or not is debatable. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45311,"question": "That's just a gimped type system that doesn't have generics.\n\nThey dumb Go down because of the problem domain they're trying to solve and what Rob Pike think is needed and not needed to solve that domain.\n\nWhether this is good or not is debatable. ","aSentId": 45312,"answer": "Gee, where do you stand on the subject? ;)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45305,"question": "I think golang is another sign of the purported \"OOP death,\" and I'm surprised it's absent from this article.  Maybe because it's not that popular?","aSentId": 45314,"answer": "As I reached the final paragraph I came to the mixins conclusion. Then I thought about interfaces and ultimately Go Lang. Go seems to be built on concurrency, non-oo, and heavy on interfaces (which should allow a thing to be multiple things: loot is a object, also, moving, also static, etc.). I haven't used Go, but definitely want to. it seems interesting. I'll cut my teeth by contributing to a project soon","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45316,"question": "I didn't understand quite well the last part of the article. I mean, how the mixins can't be implemented using the set of mechanism that OOP bring to us?\n\nSpecifically that part, seems to me like the Relational vs Key-Value databases, I mean, it seems like a too simple argument, and yet, the author thinks is the best part of the article.","aSentId": 45317,"answer": "I didn't say mixins couldn't be implemented\u2026 Just that there are even better ideas for the use case I\u00a0was describing.\n\n&gt; and yet, the author thinks is the best part of the article.\n\nHow did you work that out?  That was the most rushed part!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45320,"question": "Can someone please, please tell me. Is there some company going around paying people to write these cookie cutter articles? I seem to see a couple a week, they never offer anything new. I much prefer the articles demonstrating how awesome the alternatives are instead of banging on about how OOP will die.","aSentId": 45321,"answer": "Probably. Look at /r/seo.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45323,"question": "... still waiting for that \"multicore revolution\" ;-)","aSentId": 45324,"answer": "I think that one passed by a while ago...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45325,"question": "I think that one passed by a while ago...","aSentId": 45326,"answer": "But the current crop of mainstream languages is holding us back from taking full advantage of it. :)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45325,"question": "I think that one passed by a while ago...","aSentId": 45328,"answer": "... did you notice? 'Cause I didn't. Is it going to U-turn?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45329,"question": "... did you notice? 'Cause I didn't. Is it going to U-turn?","aSentId": 45330,"answer": "Our 4 cores aren't going away. When we tire of our computer not getting faster, or less power hungry, we'll have to exploit them properly. And it only takes 2 threads to change everything. Which is probably why so many programs are still stuck in only 1 thread.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45331,"question": "Our 4 cores aren't going away. When we tire of our computer not getting faster, or less power hungry, we'll have to exploit them properly. And it only takes 2 threads to change everything. Which is probably why so many programs are still stuck in only 1 thread.","aSentId": 45332,"answer": "I'm with Linus on this one: battery life tends to be more important than raw throughput. \n\nAnd where raw throughput is required, optimizing the inner loops can often give you much more than that factor of 2 you would seem to be hinting at. \n\nBy the way, I don't have 4 cores. I have 2 physical cores with hyper-threading, just like you do most likely. It just looks like four cores at first glance.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45333,"question": "I'm with Linus on this one: battery life tends to be more important than raw throughput. \n\nAnd where raw throughput is required, optimizing the inner loops can often give you much more than that factor of 2 you would seem to be hinting at. \n\nBy the way, I don't have 4 cores. I have 2 physical cores with hyper-threading, just like you do most likely. It just looks like four cores at first glance.","aSentId": 45334,"answer": "&gt; I'm with Linus on this one: battery life tends to be more important than raw throughput.\n\nOkay, then\u2026 decrease the voltage *and* frequency of your CPU. 4 cores that do as much MIPS as a single, faster core, are much less power hungry (possibly a factor of 4). You can scale that to quite many cores.\n\nSo if you care about battery life *and* still want reasonable performance, being able to handle 128+ cores is a real boon.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45335,"question": "&gt; I'm with Linus on this one: battery life tends to be more important than raw throughput.\n\nOkay, then\u2026 decrease the voltage *and* frequency of your CPU. 4 cores that do as much MIPS as a single, faster core, are much less power hungry (possibly a factor of 4). You can scale that to quite many cores.\n\nSo if you care about battery life *and* still want reasonable performance, being able to handle 128+ cores is a real boon.","aSentId": 45336,"answer": "In his recent rant, he would seem to suggest larger caches instead. I'm not of a hardware guy, but if that trade-off can be made, why bother on the software side? Cache locality is much to reason about...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45333,"question": "I'm with Linus on this one: battery life tends to be more important than raw throughput. \n\nAnd where raw throughput is required, optimizing the inner loops can often give you much more than that factor of 2 you would seem to be hinting at. \n\nBy the way, I don't have 4 cores. I have 2 physical cores with hyper-threading, just like you do most likely. It just looks like four cores at first glance.","aSentId": 45338,"answer": "&gt; .. did you notice? 'Cause I didn't. Is it going to U-turn?\n\nAlmost every device on the market now has multiple cores, and modern language design has shifted to better accommodate methods of writing highly concurrent and parallel code to make use of this fact. \n\n&gt; battery life tends to be more important than raw throughput.\n\nUsing 25% of four cores is far better on battery life than 100% of one core. If you're worried about battery life, then spreading the load is better.\n\n&gt; By the way, I don't have 4 cores. I have 2 physical cores with hyper-threading, just like you do most likely. It just looks like four cores at first glance.\n\nI haven't owned a computer with less than four physical cores since about 2007 - close to a decade ago - and even my phone is now quad core. The only CPUs I can see on the market with less than this are budget models, and even then dual-core seems to be the minimum.\n\nGiven that multi-core CPUs are almost universal, I'm confused as to why I wouldn't want to write code that utilizes them?\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45341,"question": "I'm not familiar with ECS. Are there any good articles or resources you would recommend on the subject?","aSentId": 45342,"answer": "Not really. I didn't find many resources myself\u2026 Search the web for the article talking about Dungeon Siege, that was a good one. Old, but still relevant for the ECS side of things.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45341,"question": "I'm not familiar with ECS. Are there any good articles or resources you would recommend on the subject?","aSentId": 45344,"answer": "The best way to learn is to grab a framework and try it yourself. My poison is artemis-odb, a fork of artemis. Vanilla Artemis is ded but the website has an awesome couple of talks that explain the model behind quite well.\n\nhttp://gamadu.com/artemis/","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45346,"question": "If OOP dies then does OOD die along with it? If so, then what replaces that?","aSentId": 45347,"answer": "OOD is the worst methodology ever created. Almost anything else is better than it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45351,"question": "I come from programming Python, where everything is a value.\n\nIt's nice to bind methods into a value, so that they will be available in value's namespace. This makes sense when the method makes only sense in presence of the value, which often happens.\n\nInheritance I tend to use when there's no need for something to be extended outside of it's module, yet there is different kinds of the same thing. For the situations where it is useful it is so valuable that I advice to avoid using inheritance when there is an alternative way, because the use for wrong reasons in one place inhibits the use in another place for right reasons.\n\nIt is possible there could be better alternatives and that my use of these mechanisms can be outdated. I also do not really call it object oriented programming.\n\nIn other hand, the dogmatic object oriented perspective, where everything is being wrapped into classes and everything must be inherited from something else, may be living strong. I haven't seen java or C#, or that one flavour of C++ dropping in popularity.\n\nOOP overall is quite boring, and I'd rather use it as pejorative term for java worldview. In smalltalk I am much more interested about the live environment and program image -concept, but it seems like something that didn't work out in the way smalltalk implements it. Having programmed within live environments, I think there would be value in the concept and I realize that Smalltalk's failure doesn't mean that the concept is unfeasible to implement.","aSentId": 45352,"answer": "Java and c++ have fairly recently been equipped with all sorts of nice functional inspired tools. C# has had them for years. There are not many pure OO languages /left/. I'd actually say python is closer than most given the (intentionally) poor support for functional doodads. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45353,"question": "Java and c++ have fairly recently been equipped with all sorts of nice functional inspired tools. C# has had them for years. There are not many pure OO languages /left/. I'd actually say python is closer than most given the (intentionally) poor support for functional doodads. ","aSentId": 45354,"answer": "Functional is not an opposite for OOP. Java still requires every file to contain a class.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45355,"question": "Functional is not an opposite for OOP. Java still requires every file to contain a class.","aSentId": 45356,"answer": "OOP or FP is not about languages, but the way you write code. The language can just make doing it this way or that way easier or harder. Everything else are just boring details. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45357,"question": "OOP or FP is not about languages, but the way you write code. The language can just make doing it this way or that way easier or harder. Everything else are just boring details. ","aSentId": 45358,"answer": "&gt; OOP or FP is not about languages, but the way you write code\n\nStill not opposites though. Most of the code I write is functional *and* OOP.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45359,"question": "&gt; OOP or FP is not about languages, but the way you write code\n\nStill not opposites though. Most of the code I write is functional *and* OOP.","aSentId": 45360,"answer": "In some senses they are contrary to each other. In particular, methods compose very badly with functions, and if you don't have methods, I have a hard time calling it OOP. What is possible, I guess, is to employ OOP as a large-scale architectural pattern, and write functional code inside methods and such, but by then you are actually separating them by layering.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45361,"question": "In some senses they are contrary to each other. In particular, methods compose very badly with functions, and if you don't have methods, I have a hard time calling it OOP. What is possible, I guess, is to employ OOP as a large-scale architectural pattern, and write functional code inside methods and such, but by then you are actually separating them by layering.","aSentId": 45362,"answer": "They are really not contrary. A class\u2019 instance can be thought of as a closure over its member variables which is returned from a function (= the constructor). In fact, this is a *natural* way of thinking about OOP which *follows* from functional programming (but it\u2019s of course not the *only* way of thinking about OOP). JavaScript does exactly that.\n\nThe same can be done in R (although OOP is usually solved in R in one of two different ways), and I *think* object-oriented variants of Lisp/Scheme do the same (but I don\u2019t know either).\n\n&gt; methods compose badly with functions\n\nI\u2019m not entirely sure what you mean by that \u2013 in modern C++ for instance you do that routinely. And both JavaScript and R also have no trouble with it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45359,"question": "&gt; OOP or FP is not about languages, but the way you write code\n\nStill not opposites though. Most of the code I write is functional *and* OOP.","aSentId": 45364,"answer": "Me too, they are quite complementary.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45357,"question": "OOP or FP is not about languages, but the way you write code. The language can just make doing it this way or that way easier or harder. Everything else are just boring details. ","aSentId": 45366,"answer": "Boring details? To compress the language discussion to plain paradigms is boring. There are so much details that makes a language good or bad for various purposes.\n\nFor example the [PHP: a fractal of bad design](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) demonstrates how many things you can get wrong. And we're not even getting to the overall paradigm or opinionated things being wrong. Bad design on language level can make primitive things such as comparison nontrivial matter.\n\nNow these bad design choices may not matter because Rasmus meant PHP as a single-purpose language. You weren't supposed to do anything complex such as number or string comparison with PHP.\n\nAnd it is hard to get every little thing right. I value Guido, Python and Python's community for the attempt to do so. Even then there are some things they didn't get right. The result is a very generic language, where really many things are straightforward if not trivial to do.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45351,"question": "I come from programming Python, where everything is a value.\n\nIt's nice to bind methods into a value, so that they will be available in value's namespace. This makes sense when the method makes only sense in presence of the value, which often happens.\n\nInheritance I tend to use when there's no need for something to be extended outside of it's module, yet there is different kinds of the same thing. For the situations where it is useful it is so valuable that I advice to avoid using inheritance when there is an alternative way, because the use for wrong reasons in one place inhibits the use in another place for right reasons.\n\nIt is possible there could be better alternatives and that my use of these mechanisms can be outdated. I also do not really call it object oriented programming.\n\nIn other hand, the dogmatic object oriented perspective, where everything is being wrapped into classes and everything must be inherited from something else, may be living strong. I haven't seen java or C#, or that one flavour of C++ dropping in popularity.\n\nOOP overall is quite boring, and I'd rather use it as pejorative term for java worldview. In smalltalk I am much more interested about the live environment and program image -concept, but it seems like something that didn't work out in the way smalltalk implements it. Having programmed within live environments, I think there would be value in the concept and I realize that Smalltalk's failure doesn't mean that the concept is unfeasible to implement.","aSentId": 45368,"answer": "&gt; I come from programming Python, where everything is a value.\n\nYou're using a very weird definition of \"value\" here because (almost?) everything in Python has an identity, which means it is an object.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45369,"question": "&gt; I come from programming Python, where everything is a value.\n\nYou're using a very weird definition of \"value\" here because (almost?) everything in Python has an identity, which means it is an object.\n\n","aSentId": 45370,"answer": "That put me wonder, does everything have an identity in python? Even things such as numbers?\n\n[Python's 'is' -operator's behavior is undefined with integers](http://stackoverflow.com/questions/306313/pythons-is-operator-behaves-unexpectedly-with-integers). Apparently no, so technically they're all objects, but some could be as well treated as values.\n\n&gt; LISP programmers know the value of everything and the cost of nothing.\n\nI tend to think the 'everything is a value' is the biggest gain about lambda calculus, aside the fact that you have clearly controlled side effects and closures. That is your functions, class definitions, modules, everything are values you can pass into functions. Functions tend to only change global state unless it's the point of the function, and they can bind variables from their lexical scope.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45371,"question": "That put me wonder, does everything have an identity in python? Even things such as numbers?\n\n[Python's 'is' -operator's behavior is undefined with integers](http://stackoverflow.com/questions/306313/pythons-is-operator-behaves-unexpectedly-with-integers). Apparently no, so technically they're all objects, but some could be as well treated as values.\n\n&gt; LISP programmers know the value of everything and the cost of nothing.\n\nI tend to think the 'everything is a value' is the biggest gain about lambda calculus, aside the fact that you have clearly controlled side effects and closures. That is your functions, class definitions, modules, everything are values you can pass into functions. Functions tend to only change global state unless it's the point of the function, and they can bind variables from their lexical scope.","aSentId": 45372,"answer": "There\u2019s is nothing undefined about `is` on integers in Python. The results in a specific implementation may be *unexpected* if you\u2019re not versed in the implementation details, but it\u2019s still a well-defined operation, just not a very meaningful one (because equal numbers may or may not have the same identity).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45374,"question": "Five years later, how is the Oracle-Sun marriage working out?","aSentId": 45375,"answer": "Oracle revealed itself to be incredible incompetent dealing with open-source technology. They are great with private code but a disaster with open-source. Because of this mindset, a lot of great engineers left the company and Oracle lost a ton of intellectual assets. Those great minds continue to innovate and make great things outside Oracle, in fork projects. Almost all the forks are doing better than the Oracle's relative project. They didn't *lose* money in short term but they really did lose the opportunity to *make* money in the long term.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45376,"question": "Oracle revealed itself to be incredible incompetent dealing with open-source technology. They are great with private code but a disaster with open-source. Because of this mindset, a lot of great engineers left the company and Oracle lost a ton of intellectual assets. Those great minds continue to innovate and make great things outside Oracle, in fork projects. Almost all the forks are doing better than the Oracle's relative project. They didn't *lose* money in short term but they really did lose the opportunity to *make* money in the long term.","aSentId": 45377,"answer": "They aren't even competent with closed source software haha. Check out oracle identity manager","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45378,"question": "They aren't even competent with closed source software haha. Check out oracle identity manager","aSentId": 45379,"answer": "Or the state that contracted Oracle for their website. Oregon I think?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45380,"question": "Or the state that contracted Oracle for their website. Oregon I think?","aSentId": 45381,"answer": "I know my home state of Washington used OIM and had tons of problems with it.. not sure about Oregon. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45378,"question": "They aren't even competent with closed source software haha. Check out oracle identity manager","aSentId": 45383,"answer": "[This rant](http://attrition.org/security/rant/oracle01/) sums it up pretty well.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45374,"question": "Five years later, how is the Oracle-Sun marriage working out?","aSentId": 45385,"answer": "I still use Virtualbox but you couldn't get me to touch another Oracle, Sun, or MySQL product again.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45386,"question": "I still use Virtualbox but you couldn't get me to touch another Oracle, Sun, or MySQL product again.","aSentId": 45387,"answer": "Why?  Oracle makes regular MySQL releases with bug fixes and new features.  Not only that, it's possible to see a long term direction as they sand down the legacy MySQL rough edges, like data validation.  ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45388,"question": "Why?  Oracle makes regular MySQL releases with bug fixes and new features.  Not only that, it's possible to see a long term direction as they sand down the legacy MySQL rough edges, like data validation.  ","aSentId": 45389,"answer": "Comparing with the original MySQL developers' fork, the mariadb, Oracle's software is stuck in time.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45390,"question": "Comparing with the original MySQL developers' fork, the mariadb, Oracle's software is stuck in time.","aSentId": 45391,"answer": "Just like Java!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45392,"question": "Just like Java!","aSentId": 45393,"answer": "Actually, they've been rapidly improving Java 8 had some major advances.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45394,"question": "Actually, they've been rapidly improving Java 8 had some major advances.","aSentId": 45395,"answer": "They've improve from non-existent progress to glacial progress.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45388,"question": "Why?  Oracle makes regular MySQL releases with bug fixes and new features.  Not only that, it's possible to see a long term direction as they sand down the legacy MySQL rough edges, like data validation.  ","aSentId": 45397,"answer": "What the fuck is \"data validation\"?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45386,"question": "I still use Virtualbox but you couldn't get me to touch another Oracle, Sun, or MySQL product again.","aSentId": 45399,"answer": "virtualbox is to (vmware/kvm/xen) as mysql is to postgres","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45400,"question": "virtualbox is to (vmware/kvm/xen) as mysql is to postgres","aSentId": 45401,"answer": "But unlike mysql-postgres it doesn't even try to play in the same ballpark as esx\\kvm\\xen, and never really did. I think as a desktop virtualization it's still pretty good, and answers 99% of it's users need. \n\nThe thing is, the progress rate has slowed down so much, that even in the dying market of desktop based virtualization you get the sense that in a couple of years it would be a dead project. Hell. if vmware releases a free workstation version it would probably kill virtualbox now.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45400,"question": "virtualbox is to (vmware/kvm/xen) as mysql is to postgres","aSentId": 45403,"answer": "I'd even say it's as bdb or dbase IV is to Postgres","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45404,"question": "I'd even say it's as bdb or dbase IV is to Postgres","aSentId": 45405,"answer": "VirtualBox has become a lot more stable over the past two years.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45374,"question": "Five years later, how is the Oracle-Sun marriage working out?","aSentId": 45407,"answer": "It's only been five years? Feels like an eternity.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45412,"question": "Pharo by Example","aSentId": 45413,"answer": "I've tried to build some \"e-toys\" in Pharo, and some years previously, in Squeak, which is what Pharo is a fork of.   I never really got to a point where I could say I actually LIKED image-based live programming.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45414,"question": "I've tried to build some \"e-toys\" in Pharo, and some years previously, in Squeak, which is what Pharo is a fork of.   I never really got to a point where I could say I actually LIKED image-based live programming.","aSentId": 45415,"answer": "That's unfortunate, because it is a great (and strange) experience. It is like having a friendly conversation with it as you develop your software. It tells you something can't be done, suggests a way to do it, you ask it what was what at some point in the execution, ask it what the value be if you instead do it the other way, and continue from there onwards. You save and quit, go to sleep, come back to the exact same point.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45416,"question": "That's unfortunate, because it is a great (and strange) experience. It is like having a friendly conversation with it as you develop your software. It tells you something can't be done, suggests a way to do it, you ask it what was what at some point in the execution, ask it what the value be if you instead do it the other way, and continue from there onwards. You save and quit, go to sleep, come back to the exact same point.","aSentId": 45417,"answer": "&gt; You save and quit, go to sleep, come back to the exact same point.\n\nWhat happens if you want to go back to a specific, previous state? What happens if your colleagues have different conversations from the same point, then want to combine them together at a later date? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45419,"question": "Analysis of a Brute-Force Shuffle","aSentId": 45420,"answer": "that sounds kinda painful either way.  how about assigning a random number between 0 and 65535 to each card then sorting (and don't worry about collisions)?\n\nedit: Fisher\u2013Yates looks straight forward enough, no sorting","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45421,"question": "that sounds kinda painful either way.  how about assigning a random number between 0 and 65535 to each card then sorting (and don't worry about collisions)?\n\nedit: Fisher\u2013Yates looks straight forward enough, no sorting","aSentId": 45422,"answer": "Not solving the problem, as you'd still have to \"randomly\" assign those numbers. Fisher-Yates is kinda linear with the number of cards (or whatever you are shuffling). But as mentioned, for small sets the difference is almost negligible, you can see that from the graph too.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45424,"question": "Storing months of historical metrics from Hystrix in Graphite","aSentId": 45425,"answer": "I really hate the user blogger theme. It is really slow, and constantly \"loading...\". It's like RealPlayer all over again.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45427,"question": "The Apprentice Programmer (2013)","aSentId": 45428,"answer": "I like how everyone is focusing on the interview question when the point of the story is that programming, like carpeting, is a trade you learn by doing, not studying. \n\nWhile I agree with that in a practical sense, if I hadn't studied (read books, etc. Not necessarily University, although I did that too), I wouldn't be half the programmer I am today. I believe that these things must supplement each other. I guess that point is in the story but I think it deserves some emphasis. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45429,"question": "I like how everyone is focusing on the interview question when the point of the story is that programming, like carpeting, is a trade you learn by doing, not studying. \n\nWhile I agree with that in a practical sense, if I hadn't studied (read books, etc. Not necessarily University, although I did that too), I wouldn't be half the programmer I am today. I believe that these things must supplement each other. I guess that point is in the story but I think it deserves some emphasis. ","aSentId": 45430,"answer": "I add to what /r/Awesan said, learning by doing is great as long as your toolkit stays the same. The foundations of Computer Science are crucial for staying current. What I learned in college 20 years ago still serves me today. Now, I can see where someone might not find too much value in French Cinema (a fine arts requirements since I was at a liberal arts college) but there is a lot of value in that book learnin. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45431,"question": "I add to what /r/Awesan said, learning by doing is great as long as your toolkit stays the same. The foundations of Computer Science are crucial for staying current. What I learned in college 20 years ago still serves me today. Now, I can see where someone might not find too much value in French Cinema (a fine arts requirements since I was at a liberal arts college) but there is a lot of value in that book learnin. ","aSentId": 45432,"answer": "The apprenticeship program in Germany covered theory during the Fridays they went to vocational school -- they mentioned Big O and algorithms. But overall the balance was PRACTICE^theory rather than **THEORY**^(practice).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45427,"question": "The Apprentice Programmer (2013)","aSentId": 45434,"answer": "That's a pretty big pond","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45435,"question": "That's a pretty big pond","aSentId": 45436,"answer": "Or really tiny lilies!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45427,"question": "The Apprentice Programmer (2013)","aSentId": 45438,"answer": "&gt; The number of lilies in a pond double every day. So, on the first day of the month there is one lily. On the second day, two lilies, the next day four lilies, then eight, sixteen, thirty two, etc. If the pond is full on the 30th day of the month, what day is it half full?\n\nI like this question!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45439,"question": "&gt; The number of lilies in a pond double every day. So, on the first day of the month there is one lily. On the second day, two lilies, the next day four lilies, then eight, sixteen, thirty two, etc. If the pond is full on the 30th day of the month, what day is it half full?\n\nI like this question!","aSentId": 45440,"answer": "Yeah, I'm dumb. I didn't even think about the problem intuitively, I just busted out some arithmetic.\n\nnumLilies(x) = 2^x  \nnumLilles(30) = 2^30 = 1,073,741,824  \nnumLillies(y) = 1/2 * numLillies(x)  \nnumLillies(y) = 2^30 * 1/2 = 536,870,912  \n2^y = 536,870,912   \nln(2^y) = ln(536,870,912)  \nyln(2) = ln(536,870,912)  \n0.693147181y = ln(536,870,912)  \ny = ln(536870912) / 0.693147181 = 29 days.  \n\nCheck answer:  \n2^29 = 536870912  \n536870912 * 2 = 1073741824  \n2^30 = 1073741824\n\nWhich intuitively it makes sense. If day 30 = full, then obviously it was half full the day before, because it doubled from day 29 -&gt; 30 -_-;\n\nAlthough I realize that's actually a smidge off, since the first day was 2^0, so it'd actually be 2^29 = day 30, but alas...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45441,"question": "Yeah, I'm dumb. I didn't even think about the problem intuitively, I just busted out some arithmetic.\n\nnumLilies(x) = 2^x  \nnumLilles(30) = 2^30 = 1,073,741,824  \nnumLillies(y) = 1/2 * numLillies(x)  \nnumLillies(y) = 2^30 * 1/2 = 536,870,912  \n2^y = 536,870,912   \nln(2^y) = ln(536,870,912)  \nyln(2) = ln(536,870,912)  \n0.693147181y = ln(536,870,912)  \ny = ln(536870912) / 0.693147181 = 29 days.  \n\nCheck answer:  \n2^29 = 536870912  \n536870912 * 2 = 1073741824  \n2^30 = 1073741824\n\nWhich intuitively it makes sense. If day 30 = full, then obviously it was half full the day before, because it doubled from day 29 -&gt; 30 -_-;\n\nAlthough I realize that's actually a smidge off, since the first day was 2^0, so it'd actually be 2^29 = day 30, but alas...","aSentId": 45442,"answer": "2^n is 2 times itself n times.\n\nIf you divide by two, it will cancel out one 2 from the multiplication.\n\n2^n /2 = 2^(n-1)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45445,"question": "Haven't done it but would you calculate the number of Lillie's on the 30th day (position) and then divide it by 2 and find out which day(position) it corresponds to. Assuming the number was calculated linearly","aSentId": 45446,"answer": "Nope, it is an exponential growth problem. If the lilies in the pond double every day, and the pond is full on day 30, then it must have been half full the day before (day 29).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45445,"question": "Haven't done it but would you calculate the number of Lillie's on the 30th day (position) and then divide it by 2 and find out which day(position) it corresponds to. Assuming the number was calculated linearly","aSentId": 45448,"answer": "That's the day right before the day it's full. Day 29. You don't even need paper, unless I'm missing something. I think it is a good question because such a simple answer isn't always immediately obvious.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45449,"question": "That's the day right before the day it's full. Day 29. You don't even need paper, unless I'm missing something. I think it is a good question because such a simple answer isn't always immediately obvious.","aSentId": 45450,"answer": "no, you are right. This riddle is old. I first heard it without \"Day 30\", there was just a question \"which day is the pond half full?\" and the answer is \"last but one\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45455,"question": "Build a Reddit bot with Perl","aSentId": 45456,"answer": "Shhhhhhhhh  , don't tell them ! Haha nice post you crazy .","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45457,"question": "Shhhhhhhhh  , don't tell them ! Haha nice post you crazy .","aSentId": 45458,"answer": "The python api makes it ridiculously easy to make a bot.\n\nYou can replace auto moderator and roll your own quite easily.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45459,"question": "The python api makes it ridiculously easy to make a bot.\n\nYou can replace auto moderator and roll your own quite easily.","aSentId": 45460,"answer": "Been meaning to look this up one of these days, but then again all my Reddit needs are provided already and i have no itch there to scratch, so no idea what would i do with it, and the site doesn't need yet another annoying bot.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45461,"question": "Been meaning to look this up one of these days, but then again all my Reddit needs are provided already and i have no itch there to scratch, so no idea what would i do with it, and the site doesn't need yet another annoying bot.","aSentId": 45462,"answer": "It's not about helping yourself, it's about annoying others.\n\n^^^^all ^^^^my ^^^^bots ^^^^don't ^^^^post ^^^^don't ^^^^worry","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45463,"question": "It's not about helping yourself, it's about annoying others.\n\n^^^^all ^^^^my ^^^^bots ^^^^don't ^^^^post ^^^^don't ^^^^worry","aSentId": 45464,"answer": "Was that Python post a bot hehe :p","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45455,"question": "Build a Reddit bot with Perl","aSentId": 45466,"answer": "This is really good stuff. I'm brand new to Perl (and programming, in general). But I can almost make out exactly how this works - despite the fact that you go through it all :) I look forward to seeing more posts in the /r/perl subreddit!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45469,"question": "The Parable of the Two Programmers","aSentId": 45470,"answer": "It occurs to me that this doesn't just apply to programmers... Isn't this kind of thing like every job? Perception of how hard something is to do or how well it is being done is more important than the actual task in terms of success. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45471,"question": "It occurs to me that this doesn't just apply to programmers... Isn't this kind of thing like every job? Perception of how hard something is to do or how well it is being done is more important than the actual task in terms of success. ","aSentId": 45472,"answer": "I recall a locksmith writing about how taking less time to fix locks as he grew more experienced awarded him *less* customer satisfaction.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45473,"question": "I recall a locksmith writing about how taking less time to fix locks as he grew more experienced awarded him *less* customer satisfaction.","aSentId": 45474,"answer": "Heh. As someone who's been a locksmith in various capacities for 20 years, that describes pretty much all of us. When I first started, my boss used to open cars for people, and when he as too fast, they'd complain he was overcharging them because \"it only took you two minutes\". His answer was always something like \"I can lock it back up and call the apprentice in the shop over to do it. It'd easily take him 2 hours\". \n\nAnother common thing is when someone's locked out of their house and you stick the pick in and give the pins a quick rake to loosen them up... and the lock unlocks. Usually you pretend to be still working at it for a couple minutes at least, just to make it seem worth the $50 you charge them. \n\nThere's a fine line between working fast and appearing to be an expert, and working so fast it looks like you're \"cheating\" somehow. It's one of the reasons I got out of private industry and have gone in institutional locksmithing for a government agency. Pays better, and being able to do 8 hours of work in 1 hour just gives you 7 hours to dick around with programming the PLC's that handle access control. \n\nAs relates to the story's postscript, one of the many reasons I've stuck closer to locksmithing than programming is that there are too many boss-people who think they know about programming, but nobody knows a damn thing about how locks and access control work! Complete a job and say \"adjusted v-rod on Von Duprin 99\" in the description and charge 6 hours to it. Someone asks if that's how long that takes, the answer to them is \"as far as *you* know\".\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45475,"question": "Heh. As someone who's been a locksmith in various capacities for 20 years, that describes pretty much all of us. When I first started, my boss used to open cars for people, and when he as too fast, they'd complain he was overcharging them because \"it only took you two minutes\". His answer was always something like \"I can lock it back up and call the apprentice in the shop over to do it. It'd easily take him 2 hours\". \n\nAnother common thing is when someone's locked out of their house and you stick the pick in and give the pins a quick rake to loosen them up... and the lock unlocks. Usually you pretend to be still working at it for a couple minutes at least, just to make it seem worth the $50 you charge them. \n\nThere's a fine line between working fast and appearing to be an expert, and working so fast it looks like you're \"cheating\" somehow. It's one of the reasons I got out of private industry and have gone in institutional locksmithing for a government agency. Pays better, and being able to do 8 hours of work in 1 hour just gives you 7 hours to dick around with programming the PLC's that handle access control. \n\nAs relates to the story's postscript, one of the many reasons I've stuck closer to locksmithing than programming is that there are too many boss-people who think they know about programming, but nobody knows a damn thing about how locks and access control work! Complete a job and say \"adjusted v-rod on Von Duprin 99\" in the description and charge 6 hours to it. Someone asks if that's how long that takes, the answer to them is \"as far as *you* know\".\n","aSentId": 45476,"answer": "$1 to turn the screw, $999 to know which screw to turn.... Also I had to drive out here.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45477,"question": "$1 to turn the screw, $999 to know which screw to turn.... Also I had to drive out here.","aSentId": 45478,"answer": "It took me ten minutes to finish the project, but four years of education to know how to do it in only ten minutes.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45479,"question": "It took me ten minutes to finish the project, but four years of education to know how to do it in only ten minutes.","aSentId": 45480,"answer": "10 minutes to finish, but 8 years to figure out the max I could charge without you refusing to pay.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45475,"question": "Heh. As someone who's been a locksmith in various capacities for 20 years, that describes pretty much all of us. When I first started, my boss used to open cars for people, and when he as too fast, they'd complain he was overcharging them because \"it only took you two minutes\". His answer was always something like \"I can lock it back up and call the apprentice in the shop over to do it. It'd easily take him 2 hours\". \n\nAnother common thing is when someone's locked out of their house and you stick the pick in and give the pins a quick rake to loosen them up... and the lock unlocks. Usually you pretend to be still working at it for a couple minutes at least, just to make it seem worth the $50 you charge them. \n\nThere's a fine line between working fast and appearing to be an expert, and working so fast it looks like you're \"cheating\" somehow. It's one of the reasons I got out of private industry and have gone in institutional locksmithing for a government agency. Pays better, and being able to do 8 hours of work in 1 hour just gives you 7 hours to dick around with programming the PLC's that handle access control. \n\nAs relates to the story's postscript, one of the many reasons I've stuck closer to locksmithing than programming is that there are too many boss-people who think they know about programming, but nobody knows a damn thing about how locks and access control work! Complete a job and say \"adjusted v-rod on Von Duprin 99\" in the description and charge 6 hours to it. Someone asks if that's how long that takes, the answer to them is \"as far as *you* know\".\n","aSentId": 45482,"answer": "That seems sort of silly to me, because I expect a locksmith to be quite skilled and come over and work some sort of voodoo magic learned over years of hard work to do the task in a ridiculously short period of time, and I want in as fast as I can. My evaluation of the value of a service isn't the effort required but how useful it is to me, and I want in my damn car.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45483,"question": "That seems sort of silly to me, because I expect a locksmith to be quite skilled and come over and work some sort of voodoo magic learned over years of hard work to do the task in a ridiculously short period of time, and I want in as fast as I can. My evaluation of the value of a service isn't the effort required but how useful it is to me, and I want in my damn car.","aSentId": 45484,"answer": "That makes you an unusual customer compared to the general public.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45485,"question": "That makes you an unusual customer compared to the general public.","aSentId": 45486,"answer": "The general public doesn't spend their time on programming subreddits.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45487,"question": "The general public doesn't spend their time on programming subreddits.","aSentId": 45488,"answer": "Indeed. They do, however, make up the vast majority of locksmith customers.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45489,"question": "Indeed. They do, however, make up the vast majority of locksmith customers.","aSentId": 45490,"answer": "My first thought was \"Unfortunately...\", and then I realized the chaos of a world we'd have if everyone, or even just the majority of the population, were programmers.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45491,"question": "My first thought was \"Unfortunately...\", and then I realized the chaos of a world we'd have if everyone, or even just the majority of the population, were programmers.","aSentId": 45492,"answer": "There's a different solution to the same problem, but if only programmers were having problems with locks, the world would be a weird place.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45487,"question": "The general public doesn't spend their time on programming subreddits.","aSentId": 45494,"answer": "People who spend time on programming subreddits usually have a gray-matter algorithm they implement to avoid locking themselves out of any of their property.\n\n(Mine is to never remove my keys from my pants, and never leave my house without pants. My currently active pair of pants can be determined by the fact that it has things in its pockets. I call it the \"Immutable Pockets\" algorithm.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45495,"question": "People who spend time on programming subreddits usually have a gray-matter algorithm they implement to avoid locking themselves out of any of their property.\n\n(Mine is to never remove my keys from my pants, and never leave my house without pants. My currently active pair of pants can be determined by the fact that it has things in its pockets. I call it the \"Immutable Pockets\" algorithm.)","aSentId": 45496,"answer": "This sounds good, but what if you get a girlfriend? She may spontaneously decide to do your laundry, and then your pockets become indeterminate. It's more robust to have some external construct in which pants transitions do not disrupt the context of keyful pockets.\n\nClearly, this calls for a pants monad.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45483,"question": "That seems sort of silly to me, because I expect a locksmith to be quite skilled and come over and work some sort of voodoo magic learned over years of hard work to do the task in a ridiculously short period of time, and I want in as fast as I can. My evaluation of the value of a service isn't the effort required but how useful it is to me, and I want in my damn car.","aSentId": 45498,"answer": "\"Fizzbin\" for locksmiths?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45483,"question": "That seems sort of silly to me, because I expect a locksmith to be quite skilled and come over and work some sort of voodoo magic learned over years of hard work to do the task in a ridiculously short period of time, and I want in as fast as I can. My evaluation of the value of a service isn't the effort required but how useful it is to me, and I want in my damn car.","aSentId": 45500,"answer": "Seriously. I once had a HVAC guy come in for my heater in the winter, pilot went out and wouldn't re-light. I don't remember what he determined the issue was, some soot in the valve or something, but it took him 5 minutes to fix. He apologized for having to charge me $85 for it, since it was so quick. \n\nI'm like, people complain about this? I couldn't fix it (and I tried, couldn't figure out the issue), and because he was quick, I didn't have to freeze to death so as far as I was concerned it was money well spent, he earned it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45475,"question": "Heh. As someone who's been a locksmith in various capacities for 20 years, that describes pretty much all of us. When I first started, my boss used to open cars for people, and when he as too fast, they'd complain he was overcharging them because \"it only took you two minutes\". His answer was always something like \"I can lock it back up and call the apprentice in the shop over to do it. It'd easily take him 2 hours\". \n\nAnother common thing is when someone's locked out of their house and you stick the pick in and give the pins a quick rake to loosen them up... and the lock unlocks. Usually you pretend to be still working at it for a couple minutes at least, just to make it seem worth the $50 you charge them. \n\nThere's a fine line between working fast and appearing to be an expert, and working so fast it looks like you're \"cheating\" somehow. It's one of the reasons I got out of private industry and have gone in institutional locksmithing for a government agency. Pays better, and being able to do 8 hours of work in 1 hour just gives you 7 hours to dick around with programming the PLC's that handle access control. \n\nAs relates to the story's postscript, one of the many reasons I've stuck closer to locksmithing than programming is that there are too many boss-people who think they know about programming, but nobody knows a damn thing about how locks and access control work! Complete a job and say \"adjusted v-rod on Von Duprin 99\" in the description and charge 6 hours to it. Someone asks if that's how long that takes, the answer to them is \"as far as *you* know\".\n","aSentId": 45504,"answer": "To wrench this back to programming, I am perpetually underappreciated at my place of work.  Basically what I do is make it easier for my co-workers to do their jobs, by leveraging packaging systems and configuration management. Blah, blah, buzzwords.\n\nThe procedure when I showed up at my current place of work was that for each piece of software which was to be installed, you ran the installer manually, and then configured everything by hand.  I turned the installers into standard distro packages, and then let the configuration files be part of a configuration management bundle.  Everything was easier as a result, and everything was standardized across the entire environment.  When you have a thousand-odd server, standard software and configuration is a huge boon.\n\nI received all kinds of push-back from my co-workers.  I was changing how things work, and introducing extra paperwork into the system, and it was more work and it was horrible.\n\nTurns out that the best way to deal with that was pure attrition.  Everyone who complained about how much extra work I made for them (which actually saved them work by adding accountability and tracking for everything they did) has quit.  They've been replaced by new people who were introduced to the systems I made, and they just accepted it because it was, as far as they were concerned, tradition, and so now there are standard software packages for everything, and a standard configuration repository, and everything goes exceedingly smoothly.  So I've improved things.\n\nBut still, whenever I have an idea to improve things further, I receive push-back, because nobody likes it when things change.  So the only thing I can do is play with the idea for a while, determine whether it's actually an improvement or not, and if it actually is an improvement, simply *pretend that that's how things have always been* and run with that.  If I can pull off the pretense well enough, then the procedure changes.  And that seems to be the secret to changes being implemented: just pretend that they're not actually changes.  Nobody likes changes, but everyone is fine with standard procedures that have been done always, even if they haven't actually been done always.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45505,"question": "To wrench this back to programming, I am perpetually underappreciated at my place of work.  Basically what I do is make it easier for my co-workers to do their jobs, by leveraging packaging systems and configuration management. Blah, blah, buzzwords.\n\nThe procedure when I showed up at my current place of work was that for each piece of software which was to be installed, you ran the installer manually, and then configured everything by hand.  I turned the installers into standard distro packages, and then let the configuration files be part of a configuration management bundle.  Everything was easier as a result, and everything was standardized across the entire environment.  When you have a thousand-odd server, standard software and configuration is a huge boon.\n\nI received all kinds of push-back from my co-workers.  I was changing how things work, and introducing extra paperwork into the system, and it was more work and it was horrible.\n\nTurns out that the best way to deal with that was pure attrition.  Everyone who complained about how much extra work I made for them (which actually saved them work by adding accountability and tracking for everything they did) has quit.  They've been replaced by new people who were introduced to the systems I made, and they just accepted it because it was, as far as they were concerned, tradition, and so now there are standard software packages for everything, and a standard configuration repository, and everything goes exceedingly smoothly.  So I've improved things.\n\nBut still, whenever I have an idea to improve things further, I receive push-back, because nobody likes it when things change.  So the only thing I can do is play with the idea for a while, determine whether it's actually an improvement or not, and if it actually is an improvement, simply *pretend that that's how things have always been* and run with that.  If I can pull off the pretense well enough, then the procedure changes.  And that seems to be the secret to changes being implemented: just pretend that they're not actually changes.  Nobody likes changes, but everyone is fine with standard procedures that have been done always, even if they haven't actually been done always.","aSentId": 45506,"answer": "I had the same experience. Then I turned freelance and charged lots more for the same sort of thing, and was considered a bargain. Go figure. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45505,"question": "To wrench this back to programming, I am perpetually underappreciated at my place of work.  Basically what I do is make it easier for my co-workers to do their jobs, by leveraging packaging systems and configuration management. Blah, blah, buzzwords.\n\nThe procedure when I showed up at my current place of work was that for each piece of software which was to be installed, you ran the installer manually, and then configured everything by hand.  I turned the installers into standard distro packages, and then let the configuration files be part of a configuration management bundle.  Everything was easier as a result, and everything was standardized across the entire environment.  When you have a thousand-odd server, standard software and configuration is a huge boon.\n\nI received all kinds of push-back from my co-workers.  I was changing how things work, and introducing extra paperwork into the system, and it was more work and it was horrible.\n\nTurns out that the best way to deal with that was pure attrition.  Everyone who complained about how much extra work I made for them (which actually saved them work by adding accountability and tracking for everything they did) has quit.  They've been replaced by new people who were introduced to the systems I made, and they just accepted it because it was, as far as they were concerned, tradition, and so now there are standard software packages for everything, and a standard configuration repository, and everything goes exceedingly smoothly.  So I've improved things.\n\nBut still, whenever I have an idea to improve things further, I receive push-back, because nobody likes it when things change.  So the only thing I can do is play with the idea for a while, determine whether it's actually an improvement or not, and if it actually is an improvement, simply *pretend that that's how things have always been* and run with that.  If I can pull off the pretense well enough, then the procedure changes.  And that seems to be the secret to changes being implemented: just pretend that they're not actually changes.  Nobody likes changes, but everyone is fine with standard procedures that have been done always, even if they haven't actually been done always.","aSentId": 45508,"answer": "If you're having to wage war with all of your 'improvements'.  They might not actually be improvements.  Not many things in life can be qualified simply in terms of time spent vs product gained.  If people are unhappy, that's not a boon.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45509,"question": "If you're having to wage war with all of your 'improvements'.  They might not actually be improvements.  Not many things in life can be qualified simply in terms of time spent vs product gained.  If people are unhappy, that's not a boon.","aSentId": 45510,"answer": "Neither tells the full story, though.  There could be business reasons why change is unwelcome (eg. the work load and stress load are high enough that change is unwelcome), or personal preference, or sensitivity over removal of the current system because they implemented it, or because it reduced their ability to BS work.\n\nI make it a point to take my ideas and attribute them to others so that I have an ally on my side.  Teams seem more willing to acquiesce to change if it has a group behind it, and more people lets you spread the cost of evangelism around a bit.  People also love being praised, and that makes them love you.  Plus people are more likely to come to you when they have a question, instead of do the first thing that comes to their mind, which further reinforces the objective: creating better developers who in turn create better code.\n\nAs developers, we're trained to ask questions and argue.  If there is pushback to a change, it doesn't necessarily invalidate the benefits of the change.  I'd argue no pushback would be more worrisome.  Developers are also people though, and vulnerable to the weaknesses of anyone else.  \n\nSometimes, making people do it the hard way is the best way.  Sometimes the \"extra work\" they're complaining about is the work they should've been doing anyway.  I get those complaints all the time doing code reviews, but our team remains more productive with fewer upstream and downstream complaints about the quality of the code-base (and most importantly no complaints from security compliance).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45509,"question": "If you're having to wage war with all of your 'improvements'.  They might not actually be improvements.  Not many things in life can be qualified simply in terms of time spent vs product gained.  If people are unhappy, that's not a boon.","aSentId": 45512,"answer": "If you can tell me how manually editing configuration files across hundreds of servers, and installing software with \"make install\" in the source code directory (hope you remembered what configuration options you used last time!) is better than using configuration management and packages to ensure consistency, I'll concede your point that I'm not making any improvements.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45513,"question": "If you can tell me how manually editing configuration files across hundreds of servers, and installing software with \"make install\" in the source code directory (hope you remembered what configuration options you used last time!) is better than using configuration management and packages to ensure consistency, I'll concede your point that I'm not making any improvements.","aSentId": 45514,"answer": "&gt; Not many things in life can be qualified simply in terms of time spent vs product gained.\n\nYou've saved time no doubt, but if you're creating an environment of 'my way or the highway', I'd bet a months pay that those people you are 'helping' are now working more slowly around you simply by virtue of not liking being around you.  People are more productive when they are happy.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45515,"question": "&gt; Not many things in life can be qualified simply in terms of time spent vs product gained.\n\nYou've saved time no doubt, but if you're creating an environment of 'my way or the highway', I'd bet a months pay that those people you are 'helping' are now working more slowly around you simply by virtue of not liking being around you.  People are more productive when they are happy.","aSentId": 45516,"answer": "But businesses are more profitable when its workers are productive.\n\nAt one gig in the past, the codebase was this mass of hand-compiled stuff.  Over a million lines of code, and not even such a thing as a Makefile in sight.  The \"proper\" installation method was to do a bespoke installation of all of the relevant code onto a variety of servers, copying executables and shared libraries over by hand.  A standard installation of this took a solid month of a professional services engineer's time.\n\nBy the time I was done with it, three years later, a full installation of the product took an hour, and there was a build server which did a regular automated build of the whole thing every day to catch programmers checking in bad code.  I had pushback the whole time because people hate change, but damn if I didn't leave things one hell of a sight better than I found them.\n\nIt's a fact of development that no developer likes making software packages or installers or build systems, because those aren't exciting or particularly innovative.  That's why I do those things, though, and my co-workers end up using them, and their life is easier as a result, and so is the life of the customers and management.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45509,"question": "If you're having to wage war with all of your 'improvements'.  They might not actually be improvements.  Not many things in life can be qualified simply in terms of time spent vs product gained.  If people are unhappy, that's not a boon.","aSentId": 45518,"answer": "Just because the status quo exists, there will be people well invested in it.  \n\nEvery improvement in an environment with thousands of systems is going to be a battle of attrition.  There's just no way around that.  There's always going to be someone adversely affected by a change.  No matter how optimal or trivial -- if it hits that many systems/environments, someone is going to object strenuously and raise it up the flag of management.  \n\nThe absolute worst thing you can do is let that stop you from actually implementing the change.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45519,"question": "Just because the status quo exists, there will be people well invested in it.  \n\nEvery improvement in an environment with thousands of systems is going to be a battle of attrition.  There's just no way around that.  There's always going to be someone adversely affected by a change.  No matter how optimal or trivial -- if it hits that many systems/environments, someone is going to object strenuously and raise it up the flag of management.  \n\nThe absolute worst thing you can do is let that stop you from actually implementing the change.","aSentId": 45520,"answer": "Th unfortunate reality is that if the company is big enough for all changes to be met with negativity, then the company is big enough that politics are more important than optimization.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45521,"question": "Th unfortunate reality is that if the company is big enough for all changes to be met with negativity, then the company is big enough that politics are more important than optimization.","aSentId": 45522,"answer": "That's simply not true.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45505,"question": "To wrench this back to programming, I am perpetually underappreciated at my place of work.  Basically what I do is make it easier for my co-workers to do their jobs, by leveraging packaging systems and configuration management. Blah, blah, buzzwords.\n\nThe procedure when I showed up at my current place of work was that for each piece of software which was to be installed, you ran the installer manually, and then configured everything by hand.  I turned the installers into standard distro packages, and then let the configuration files be part of a configuration management bundle.  Everything was easier as a result, and everything was standardized across the entire environment.  When you have a thousand-odd server, standard software and configuration is a huge boon.\n\nI received all kinds of push-back from my co-workers.  I was changing how things work, and introducing extra paperwork into the system, and it was more work and it was horrible.\n\nTurns out that the best way to deal with that was pure attrition.  Everyone who complained about how much extra work I made for them (which actually saved them work by adding accountability and tracking for everything they did) has quit.  They've been replaced by new people who were introduced to the systems I made, and they just accepted it because it was, as far as they were concerned, tradition, and so now there are standard software packages for everything, and a standard configuration repository, and everything goes exceedingly smoothly.  So I've improved things.\n\nBut still, whenever I have an idea to improve things further, I receive push-back, because nobody likes it when things change.  So the only thing I can do is play with the idea for a while, determine whether it's actually an improvement or not, and if it actually is an improvement, simply *pretend that that's how things have always been* and run with that.  If I can pull off the pretense well enough, then the procedure changes.  And that seems to be the secret to changes being implemented: just pretend that they're not actually changes.  Nobody likes changes, but everyone is fine with standard procedures that have been done always, even if they haven't actually been done always.","aSentId": 45524,"answer": "This is genius. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45526,"question": "Interesting stuff! What sort of access control programming are you doing? I've done a bit of work with RFID card readers in the past. I've been messing around with controlling an electric door strike with a raspberry pi recently.","aSentId": 45527,"answer": "The stuff I've been looking at lately is a weird hand-built system for a detention facility. I'm not allowed to modify it, but knowing how it works makes it easier to troubleshoot when it craps out. Most systems I've worked with aren't very programmable like that. Typically when you have a system installed it consists of a controller with a bunch of keypad/card reader inputs, a bunch of output relays, and assn Ethernet jack to access the internal web based programming interface. I've looked into getting into the industry on the manufacturing side as a programmer, but the pay is awful and there's no job security whatsoever. It's a shame, because the programming of these systems is done by guys who are primarily embedded programmers, but know nothing at all about locks and security, and it shows. Most of these systems have glaring deficiencies in usability and configurability. \n\nI've actually been tempted to build an access control system for myself on something like a raspberry pi, but I have too many side projects in the queue already. Someday, maybe after I retire.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45528,"question": "The stuff I've been looking at lately is a weird hand-built system for a detention facility. I'm not allowed to modify it, but knowing how it works makes it easier to troubleshoot when it craps out. Most systems I've worked with aren't very programmable like that. Typically when you have a system installed it consists of a controller with a bunch of keypad/card reader inputs, a bunch of output relays, and assn Ethernet jack to access the internal web based programming interface. I've looked into getting into the industry on the manufacturing side as a programmer, but the pay is awful and there's no job security whatsoever. It's a shame, because the programming of these systems is done by guys who are primarily embedded programmers, but know nothing at all about locks and security, and it shows. Most of these systems have glaring deficiencies in usability and configurability. \n\nI've actually been tempted to build an access control system for myself on something like a raspberry pi, but I have too many side projects in the queue already. Someday, maybe after I retire.","aSentId": 45529,"answer": "Thanks for the insights - this sort of area is obviously fraught with both physical (hardware) and virtual (software) potential security problems ... a field for specialists if ever there was one.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45473,"question": "I recall a locksmith writing about how taking less time to fix locks as he grew more experienced awarded him *less* customer satisfaction.","aSentId": 45532,"answer": "Dentist, after taking tooth out, say:\n- it will be 200$.\nPatient:\n- what, 200 for 1 minute of work? That's way too much!\n- If you wish, I can pull your tooth for an hour.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45533,"question": "Dentist, after taking tooth out, say:\n- it will be 200$.\nPatient:\n- what, 200 for 1 minute of work? That's way too much!\n- If you wish, I can pull your tooth for an hour.","aSentId": 45534,"answer": "But that is not how things work in most salaried positions, so I can understand the reasoning. As a senior soft dev, if I finish a task earlier then expected because I'm experienced, I still have to work for the rest of the day because I'm not paid per task, I'm paid hourly. They won't tell me to go home and still pay me the full amount, they'll just give me more work to do.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45535,"question": "But that is not how things work in most salaried positions, so I can understand the reasoning. As a senior soft dev, if I finish a task earlier then expected because I'm experienced, I still have to work for the rest of the day because I'm not paid per task, I'm paid hourly. They won't tell me to go home and still pay me the full amount, they'll just give me more work to do.","aSentId": 45536,"answer": "You're doing it wrong.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45535,"question": "But that is not how things work in most salaried positions, so I can understand the reasoning. As a senior soft dev, if I finish a task earlier then expected because I'm experienced, I still have to work for the rest of the day because I'm not paid per task, I'm paid hourly. They won't tell me to go home and still pay me the full amount, they'll just give me more work to do.","aSentId": 45538,"answer": "If you're salaried you aren't paid hourly, you're paid to fulfill your job description as you see fit as a professional. You may also have an ass-in-office hourly expectation, but those usually don't spell out how you spend your time. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45535,"question": "But that is not how things work in most salaried positions, so I can understand the reasoning. As a senior soft dev, if I finish a task earlier then expected because I'm experienced, I still have to work for the rest of the day because I'm not paid per task, I'm paid hourly. They won't tell me to go home and still pay me the full amount, they'll just give me more work to do.","aSentId": 45540,"answer": "A lot of dentists aren't salaried though, they take a proportion of the payment...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45473,"question": "I recall a locksmith writing about how taking less time to fix locks as he grew more experienced awarded him *less* customer satisfaction.","aSentId": 45542,"answer": "It feels like you're being ripped off if he charges the same but does the work in half the time.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45543,"question": "It feels like you're being ripped off if he charges the same but does the work in half the time.","aSentId": 45544,"answer": "The classic \"it took me ten years to learn how to do this in ten minutes\" billing story.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45545,"question": "The classic \"it took me ten years to learn how to do this in ten minutes\" billing story.","aSentId": 45546,"answer": "If you didn't think the price was fair you would've learned how to pick locks by now.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45545,"question": "The classic \"it took me ten years to learn how to do this in ten minutes\" billing story.","aSentId": 45548,"answer": "Calling it a story implies it's not true. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45543,"question": "It feels like you're being ripped off if he charges the same but does the work in half the time.","aSentId": 45550,"answer": "which is the customer's irrationality showing up - they are paying to get a job done, not paying for time spent. And yet, the average joe doesn't get this, and just irrationally feels ripped off. How would one fix this problem in general?!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45551,"question": "which is the customer's irrationality showing up - they are paying to get a job done, not paying for time spent. And yet, the average joe doesn't get this, and just irrationally feels ripped off. How would one fix this problem in general?!","aSentId": 45552,"answer": "Ask them to try to do it for an hour before you start, or explain how to do it to them.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45551,"question": "which is the customer's irrationality showing up - they are paying to get a job done, not paying for time spent. And yet, the average joe doesn't get this, and just irrationally feels ripped off. How would one fix this problem in general?!","aSentId": 45554,"answer": "By stop using timesheets or other such crap? I do not know.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45471,"question": "It occurs to me that this doesn't just apply to programmers... Isn't this kind of thing like every job? Perception of how hard something is to do or how well it is being done is more important than the actual task in terms of success. ","aSentId": 45556,"answer": "Mangers can't see or document \"thinking.\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45557,"question": "Mangers can't see or document \"thinking.\"","aSentId": 45558,"answer": "Maybe we should install a surveillance system at the manger. This would help document behaviors related to thinking while keeping track of the animals at the same time. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45559,"question": "Maybe we should install a surveillance system at the manger. This would help document behaviors related to thinking while keeping track of the animals at the same time. ","aSentId": 45560,"answer": "... and hopefully get video evidence of random saviors.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45557,"question": "Mangers can't see or document \"thinking.\"","aSentId": 45562,"answer": "This happened to me in year 12 when we had a relatively large programming assignment. We were tasked to make an ordering system in pascal (so basically everything was done on a command line environment with text inputs, ugh), and there were marks assigned to specifications and bonus marks for adding the tougher specs if we wanted to. Most of my class spent hours of time at the desk in class swearing at their screens and trying to help each other. Because they collaborated almost to the point of copying they made life 10 times harder for themselves and wasted time and lines of code fixing errors. I however, spent the next weeks worth of showers thinking about the program then writing code a module or two in class and finished the program with full marks in with half the amount of lines as the other students and in most cases more features in less lines. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45471,"question": "It occurs to me that this doesn't just apply to programmers... Isn't this kind of thing like every job? Perception of how hard something is to do or how well it is being done is more important than the actual task in terms of success. ","aSentId": 45564,"answer": "As a programmer of many years, it occurs to me that this doesn't apply to fucking *anyone*.\n\nThis is a story filled with strawmen.\n\nIt's not even wrong.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45565,"question": "As a programmer of many years, it occurs to me that this doesn't apply to fucking *anyone*.\n\nThis is a story filled with strawmen.\n\nIt's not even wrong.","aSentId": 45566,"answer": "This story is not about inefficient managers or inefficient programmers. It's about an inefficient system where programmers are paid for their TIME, not for their CONTRIBUTED VALUE. It's no strawmen, it's that literary term for \"exaggerated personalities to create a point about what ideal they are supposed to represent\". The managers in this case are actually not symbolic of people. They are just a general response of the \"business system\" to different types of programmers.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45565,"question": "As a programmer of many years, it occurs to me that this doesn't apply to fucking *anyone*.\n\nThis is a story filled with strawmen.\n\nIt's not even wrong.","aSentId": 45568,"answer": "It sounds like you've been lucky enough to have managers who are technical enough to more or less understand what you do for a living.  The rest of us know the author's pain.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45469,"question": "The Parable of the Two Programmers","aSentId": 45572,"answer": "The moral of the story is:\nPick a time waster that does not involve rhythmic key strokes. Maybe hanging out on redit commenting on apocryphal allegories.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45573,"question": "The moral of the story is:\nPick a time waster that does not involve rhythmic key strokes. Maybe hanging out on redit commenting on apocryphal allegories.","aSentId": 45574,"answer": "someone ought to create a \"sublime text\" css for reddit ... ;)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45575,"question": "someone ought to create a \"sublime text\" css for reddit ... ;)","aSentId": 45576,"answer": "I would think there could just be an actual Sublime plugin for browsing reddit.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45573,"question": "The moral of the story is:\nPick a time waster that does not involve rhythmic key strokes. Maybe hanging out on redit commenting on apocryphal allegories.","aSentId": 45578,"answer": "At my internship last year, i found out that the program i was supposed to build was very easy but i had to spend two months at the company. http://codereddit.com/ came to rescue, 1 hour of work then 3 hours of reddit and then one hour of work, still finished 3 weeks early.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45579,"question": "At my internship last year, i found out that the program i was supposed to build was very easy but i had to spend two months at the company. http://codereddit.com/ came to rescue, 1 hour of work then 3 hours of reddit and then one hour of work, still finished 3 weeks early.","aSentId": 45580,"answer": "I knew an intern once. His name was \"Bob.\" Bob seemed like a pretty bright fellow. He occasionally asked silly questions, like \"how do you do a reverse backspace?\" but on the whole he was a fun guy to work with.\n\nOne day Bob was looking for work. I told him that we had a task that the senior engineers thought would be really difficult, but that I hadn't looked into. Perhaps he could bang his head on that for a while?\n\nAn hour later, he had finished the project. Everyone was rather impressed with Bob's work. We tried to find a flaw (mostly out of disbelief), but his work was solid. He had made the problem seem so blindingly obvious that we all felt like fools.\n\nBob was not a collage grad. He had only completed a single semester. All the same, he was offered a job (on par with a position requiring 3 to 4 years experience) on the spot, with a deal to help him finish collage if that was what he wanted.\n\nWe were all sad when he didn't take it. I miss Bob.\n\nP.S. Though this person's name has been changed, all other details are free from exaggeration. If you find yourself in the same position in the future: finish your task early, then seek out other tasks in the department/company. Good bosses will realize that you are not undermining them, but instead making the company better with your presence. Bad bosses aren't worth working for.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45581,"question": "I knew an intern once. His name was \"Bob.\" Bob seemed like a pretty bright fellow. He occasionally asked silly questions, like \"how do you do a reverse backspace?\" but on the whole he was a fun guy to work with.\n\nOne day Bob was looking for work. I told him that we had a task that the senior engineers thought would be really difficult, but that I hadn't looked into. Perhaps he could bang his head on that for a while?\n\nAn hour later, he had finished the project. Everyone was rather impressed with Bob's work. We tried to find a flaw (mostly out of disbelief), but his work was solid. He had made the problem seem so blindingly obvious that we all felt like fools.\n\nBob was not a collage grad. He had only completed a single semester. All the same, he was offered a job (on par with a position requiring 3 to 4 years experience) on the spot, with a deal to help him finish collage if that was what he wanted.\n\nWe were all sad when he didn't take it. I miss Bob.\n\nP.S. Though this person's name has been changed, all other details are free from exaggeration. If you find yourself in the same position in the future: finish your task early, then seek out other tasks in the department/company. Good bosses will realize that you are not undermining them, but instead making the company better with your presence. Bad bosses aren't worth working for.","aSentId": 45582,"answer": "Well I did work on many projects other than the one I was assigned, if you takeaway the back pace incident I could be bob","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45581,"question": "I knew an intern once. His name was \"Bob.\" Bob seemed like a pretty bright fellow. He occasionally asked silly questions, like \"how do you do a reverse backspace?\" but on the whole he was a fun guy to work with.\n\nOne day Bob was looking for work. I told him that we had a task that the senior engineers thought would be really difficult, but that I hadn't looked into. Perhaps he could bang his head on that for a while?\n\nAn hour later, he had finished the project. Everyone was rather impressed with Bob's work. We tried to find a flaw (mostly out of disbelief), but his work was solid. He had made the problem seem so blindingly obvious that we all felt like fools.\n\nBob was not a collage grad. He had only completed a single semester. All the same, he was offered a job (on par with a position requiring 3 to 4 years experience) on the spot, with a deal to help him finish collage if that was what he wanted.\n\nWe were all sad when he didn't take it. I miss Bob.\n\nP.S. Though this person's name has been changed, all other details are free from exaggeration. If you find yourself in the same position in the future: finish your task early, then seek out other tasks in the department/company. Good bosses will realize that you are not undermining them, but instead making the company better with your presence. Bad bosses aren't worth working for.","aSentId": 45584,"answer": "Don't know how to spell \"college\"?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45585,"question": "Don't know how to spell \"college\"?","aSentId": 45586,"answer": "I have minor dyslexia. I freely admit to relying on browser spell-checkers to keep my spelling honest. \"collage\" is a word (though not the one I intended) and slipped through the cracks.\n\nIf I have offended you, I apologize. I will be more careful in the future.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45587,"question": "I have minor dyslexia. I freely admit to relying on browser spell-checkers to keep my spelling honest. \"collage\" is a word (though not the one I intended) and slipped through the cracks.\n\nIf I have offended you, I apologize. I will be more careful in the future.","aSentId": 45588,"answer": "Ah mah gah, I'm not offended! Just pointing out an error that I'm constitutionally unable to pass by. Sorry to come down on you. Didn't mean to be mean or anything.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45579,"question": "At my internship last year, i found out that the program i was supposed to build was very easy but i had to spend two months at the company. http://codereddit.com/ came to rescue, 1 hour of work then 3 hours of reddit and then one hour of work, still finished 3 weeks early.","aSentId": 45590,"answer": "I would be embarrassed to tell this story, if I were you.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45573,"question": "The moral of the story is:\nPick a time waster that does not involve rhythmic key strokes. Maybe hanging out on redit commenting on apocryphal allegories.","aSentId": 45592,"answer": "You devil you, reading my mind... (I probably shouldn't be reading this at work)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45469,"question": "The Parable of the Two Programmers","aSentId": 45594,"answer": "What's the moral of the story? Who should we strive to emulate? Charles, or Alan? Who is better off in the end?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45595,"question": "What's the moral of the story? Who should we strive to emulate? Charles, or Alan? Who is better off in the end?","aSentId": 45596,"answer": "The moral is for managers. Appreciate Charles.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45597,"question": "The moral is for managers. Appreciate Charles.","aSentId": 45598,"answer": "And don't fucking read code","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45599,"question": "And don't fucking read code","aSentId": 45600,"answer": "Yeah, code review is so overrated.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45601,"question": "Yeah, code review is so overrated.","aSentId": 45602,"answer": "code review should be done by peers, not by managers. A non-programmer reading code is useless.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45597,"question": "The moral is for managers. Appreciate Charles.","aSentId": 45604,"answer": "The moral is for programmers, emulate Alan. Uh oh.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45595,"question": "What's the moral of the story? Who should we strive to emulate? Charles, or Alan? Who is better off in the end?","aSentId": 45606,"answer": "I think the moral here is that unless the manager himself understands the complexity of the task, he cannot make sound decisions.\n\nThat is, you need to be a programmer to manager programmers.\n\nYou can't solve it by hiring an expert, as an expert might overcharge you by exaggerating the complexity to get higher compensation.\n\nYou actually need someone who has relevant skills and is fully loyal to the company.\n\nOtherwise it is a matter of luck. Of course, it is possible that an expert you hire will do things in a cost-effective way, And it is also possible that an entry level programmer will produce nothing of value.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45595,"question": "What's the moral of the story? Who should we strive to emulate? Charles, or Alan? Who is better off in the end?","aSentId": 45608,"answer": "Both approaches have serious flaws, but Charles' might be considered the \"best\" overall in terms of product quality. Charles' mistake was to goof off for 2 months before beginning work and to not communicate with his superior or the product owner about the complexity of the task. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45609,"question": "Both approaches have serious flaws, but Charles' might be considered the \"best\" overall in terms of product quality. Charles' mistake was to goof off for 2 months before beginning work and to not communicate with his superior or the product owner about the complexity of the task. ","aSentId": 45610,"answer": "You misunderstood, he wasn't goofing off, he was thinking about the problem. \n The reason his boss was able to understand the program is that Charles really understood the problem and expressed his solution clearly.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45611,"question": "You misunderstood, he wasn't goofing off, he was thinking about the problem. \n The reason his boss was able to understand the program is that Charles really understood the problem and expressed his solution clearly.","aSentId": 45612,"answer": "In that case, it serves as a reminder that those who are managing/ leading/ etc, programmers should be aware of the thinking aspect of the field. I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight.  ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45613,"question": "In that case, it serves as a reminder that those who are managing/ leading/ etc, programmers should be aware of the thinking aspect of the field. I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight.  ","aSentId": 45614,"answer": "&gt;I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight. \n\nOne thing that I think is important is to turn your thinking into something tangible, like diagrams, pros-and-cons charts, or even just free-form writing in a text file about the problem you're working on.  A lot of the BS flow charts that you see paraded around by managers are actually good ideas if they come about organically rather than being forced.  Managers appreciate that you have at least *something* to show for your day and it will probably help you to clarify your thinking.\n\nAlso, sometimes it's good to start writing code with the promise to yourself that you're going to throw it away, just so you get a sense of what problems might come up with various design patterns.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45615,"question": "&gt;I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight. \n\nOne thing that I think is important is to turn your thinking into something tangible, like diagrams, pros-and-cons charts, or even just free-form writing in a text file about the problem you're working on.  A lot of the BS flow charts that you see paraded around by managers are actually good ideas if they come about organically rather than being forced.  Managers appreciate that you have at least *something* to show for your day and it will probably help you to clarify your thinking.\n\nAlso, sometimes it's good to start writing code with the promise to yourself that you're going to throw it away, just so you get a sense of what problems might come up with various design patterns.","aSentId": 45616,"answer": "Free-form drawing on a pad of paper - it's like typing, but you can have random arrows and diagrams wherever you feel like!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45615,"question": "&gt;I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight. \n\nOne thing that I think is important is to turn your thinking into something tangible, like diagrams, pros-and-cons charts, or even just free-form writing in a text file about the problem you're working on.  A lot of the BS flow charts that you see paraded around by managers are actually good ideas if they come about organically rather than being forced.  Managers appreciate that you have at least *something* to show for your day and it will probably help you to clarify your thinking.\n\nAlso, sometimes it's good to start writing code with the promise to yourself that you're going to throw it away, just so you get a sense of what problems might come up with various design patterns.","aSentId": 45618,"answer": "I always find it helpful to draw on a white board. It is totally freeform and can be erased super easily so I can be as sloppy as I want without 'feeling bad' about wasting paper or being constrained to typing lines on a computer.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45615,"question": "&gt;I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight. \n\nOne thing that I think is important is to turn your thinking into something tangible, like diagrams, pros-and-cons charts, or even just free-form writing in a text file about the problem you're working on.  A lot of the BS flow charts that you see paraded around by managers are actually good ideas if they come about organically rather than being forced.  Managers appreciate that you have at least *something* to show for your day and it will probably help you to clarify your thinking.\n\nAlso, sometimes it's good to start writing code with the promise to yourself that you're going to throw it away, just so you get a sense of what problems might come up with various design patterns.","aSentId": 45620,"answer": "That's true at higher levels, and it's preferred if we break large planning tasks down into delivering actual plans before coding, but at lower levels, like implementing a single feature, if I'm just thinking about the best way to integrate my new code, then test it, I'm going to find more value in just implementing the ideas.\n\nAlso, I've always preferred text files for planning, then encoding them into higher level diagrams once all of the ideas are written down.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45613,"question": "In that case, it serves as a reminder that those who are managing/ leading/ etc, programmers should be aware of the thinking aspect of the field. I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight.  ","aSentId": 45622,"answer": "&gt; I was contracted\n\nI think this might have been more of the issue.  When I was contracting, there were a lot of places with funny ideas about contractors and what they should be doing.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45623,"question": "&gt; I was contracted\n\nI think this might have been more of the issue.  When I was contracting, there were a lot of places with funny ideas about contractors and what they should be doing.","aSentId": 45624,"answer": "I'm still contracting now, and it's a great setup if you get good clients. That client was my first on site contract, as well as my first ever \"office job\" so I wasn't aware of any red flags. Being 19 I was also not ready to challenge people who had been working for as long as I'd been living.\n\nIn the end, the CEO didn't understand programmers because the only other programmer he'd ever hired had filled his head with nonsense about how programming happened, and was a complete yes man. Want a massive rewrite in 3 months? Yes! Even if it's really over a year of work? 3 months! \n\nI was only hired for 3 months because of him, and the company probably didn't find much value from because of it. Oh well, that taught me a lot and paid for me to fly abroad several times.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45613,"question": "In that case, it serves as a reminder that those who are managing/ leading/ etc, programmers should be aware of the thinking aspect of the field. I'm more of a Charles in this case, and it has worked against me when the CEO of a small company I was contracted at didn't like the fact I wasn't typing 8 hours straight.  ","aSentId": 45626,"answer": "That's why I like remote work. If I can do 8 hours of work in 2 hours I don't want to spend my time pretending like I'm working for 6 hours.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45611,"question": "You misunderstood, he wasn't goofing off, he was thinking about the problem. \n The reason his boss was able to understand the program is that Charles really understood the problem and expressed his solution clearly.","aSentId": 45628,"answer": "Exactly, he wasn't goofing off, but the manager THOUGHT he was goofing off. The lesson here is to always manage the perception of reality of others.\n\nThe George method, always look annoyed.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45611,"question": "You misunderstood, he wasn't goofing off, he was thinking about the problem. \n The reason his boss was able to understand the program is that Charles really understood the problem and expressed his solution clearly.","aSentId": 45630,"answer": "According to the story, he was goofing off playing space invaders, during which time he was devoting at most 10-20% of his thought to the problem. And he was not communicating to his superior *that* he needed to think about the problem, nor at least producing some form of notes as to how he thought about the problem. Nor was he attempting proofs of concept, designing, etc. \n\nHe was goofing off, plain and simple.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45631,"question": "According to the story, he was goofing off playing space invaders, during which time he was devoting at most 10-20% of his thought to the problem. And he was not communicating to his superior *that* he needed to think about the problem, nor at least producing some form of notes as to how he thought about the problem. Nor was he attempting proofs of concept, designing, etc. \n\nHe was goofing off, plain and simple.","aSentId": 45632,"answer": "Really? You've never stepped away from a problem briefly and found the answer somewhat obvious afterwards?\n\nAt some point, he was producing notes - just not well structured ones - although I don't think that's particularly important.\n\nI'm not sure why you think producing something is a must in order to not be \"goofing off.\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45631,"question": "According to the story, he was goofing off playing space invaders, during which time he was devoting at most 10-20% of his thought to the problem. And he was not communicating to his superior *that* he needed to think about the problem, nor at least producing some form of notes as to how he thought about the problem. Nor was he attempting proofs of concept, designing, etc. \n\nHe was goofing off, plain and simple.","aSentId": 45634,"answer": "The problem is that nobody thinks 100% about a problem for a any length of time. There is a lot of research on this. The extreme upper limit is under an hour and in most cases people can only concentrate on a problem for around 10-20 minutes. Serious contemplation generally requires large bouts where you aren't thinking about the problem. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45635,"question": "The problem is that nobody thinks 100% about a problem for a any length of time. There is a lot of research on this. The extreme upper limit is under an hour and in most cases people can only concentrate on a problem for around 10-20 minutes. Serious contemplation generally requires large bouts where you aren't thinking about the problem. ","aSentId": 45636,"answer": "Yeah, when I had my first USRA for math, my supervisor told me I was supposed to work 7 hours a day, but he only ever did 3-4 hours of research a day and didn't expect me to do any more.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45631,"question": "According to the story, he was goofing off playing space invaders, during which time he was devoting at most 10-20% of his thought to the problem. And he was not communicating to his superior *that* he needed to think about the problem, nor at least producing some form of notes as to how he thought about the problem. Nor was he attempting proofs of concept, designing, etc. \n\nHe was goofing off, plain and simple.","aSentId": 45638,"answer": "Either you misunderstood the story or you are not a programmer. The story NEVER said that he goofs off playing space invaders. You can read it AGAIN on 5th paragraph. The parable NEVER say that Charles is playing space invaders. Actually he is thinking!! Thinking about the problem while drinking coffee, thinking while scribbling the problem! The parable NEVER say that he actually goofs off for 2 months. Please re-read again. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45639,"question": "Either you misunderstood the story or you are not a programmer. The story NEVER said that he goofs off playing space invaders. You can read it AGAIN on 5th paragraph. The parable NEVER say that Charles is playing space invaders. Actually he is thinking!! Thinking about the problem while drinking coffee, thinking while scribbling the problem! The parable NEVER say that he actually goofs off for 2 months. Please re-read again. ","aSentId": 45640,"answer": "One of the points of the story is that everyone thought he was goofing off. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45642,"question": "That may be true, but the difference I read from this was more than just thinking about and understanding the problem, it was understanding the subject area in which the problem will be operating.\n  \nAlan built a robust solution which has the ability to scale. The interfaces were well designed and valuable technical artifacts were produced during the process. \n  \nCharles put together a simple application to do exactly what it needed to do, and a little bit extra.\n  \n  Great, simple is better, right? Well these are accounting firms. These applications will stick around for many years to come. They will be maintained and improved by many other developers.\n  \n  So this leaves is with: \nAlan\u2019s application, which has solid documentation on why design decisions were made, interfaces for modules, and a design which supports scale. Future developers will be able to gain an understanding on what was done and why, and build on it.\n  \n  Charles\u2019 application is simple, it is to the point and gets the job done. When future development is done, it will either be: a) hacked in by someone else who doesn\u2019t understand the problem as well as Charles (They didn\u2019t have two months to think about it, they had 2 days) or b) re-factored to hell.\n   \nThis is the reality of working as an in-house developer in the corporate world. Creating something which is simple, to the point and does one specific task extremely well is not necessarily the best answer. Charles solution may be the best for a small business, a start-up, or creating a temporary tool. In the environment in which they were operating, the monolithic solution is what was really required.\n","aSentId": 45643,"answer": "Except that the story does not really validate your reading.\n\nAbout Alan you says:\n\n&gt; So this leaves is with: Alan\u2019s application, which has solid documentation on why design decisions were made, interfaces for modules, and a design which supports scale. Future developers will be able to gain an understanding on what was done and why, and build on it.\n\nBut the story says:\n\n&gt;  Alan was complimented for completing his project on schedule.\nHis  supervisor  looked over the program. With a few minutes of thumbing through\nhe saw that the  company  standards  about  structured  programming  were  being\nobserved.  **He  quickly gave up attempting to read the program however; it seemed\nquite incomprehensible.**\n\nAbout Charles you says:\n \n&gt; Charles\u2019 application is simple, it is to the point and gets the job done. When future development is done, it will either be: a) hacked in by someone else who doesn\u2019t understand the problem as well as Charles (They didn\u2019t have two months to think about it, they had 2 days) or b) re-factored to hell.\n\nBut the story says:\n\n&gt; At first Charles's supervisor was impressed. But as  he  read  through  the\nsource  code,  **he  realized that the project was really much simpler** than he had\noriginally though.\n\nKeep in mind that the problem is the same. But it is Charles solution that makes its solution obvious to his manager, while Alan solution, through working mostly correctly most of the time, it is still a black box to anybody else.\n\nNow, it is a given that this story is so full of strawman that you could feed an herd of cows for months.\n\nBut, if you go with it, it is Charles solution that is written in a way that makes the reader, and so a future maintainer, better understand the problem and the solution.\n\nIn my opinion, this is because this story really it is not only about programming, but about understanding complexity. One solution is able to reduce it, the other just barely work around it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45644,"question": "Except that the story does not really validate your reading.\n\nAbout Alan you says:\n\n&gt; So this leaves is with: Alan\u2019s application, which has solid documentation on why design decisions were made, interfaces for modules, and a design which supports scale. Future developers will be able to gain an understanding on what was done and why, and build on it.\n\nBut the story says:\n\n&gt;  Alan was complimented for completing his project on schedule.\nHis  supervisor  looked over the program. With a few minutes of thumbing through\nhe saw that the  company  standards  about  structured  programming  were  being\nobserved.  **He  quickly gave up attempting to read the program however; it seemed\nquite incomprehensible.**\n\nAbout Charles you says:\n \n&gt; Charles\u2019 application is simple, it is to the point and gets the job done. When future development is done, it will either be: a) hacked in by someone else who doesn\u2019t understand the problem as well as Charles (They didn\u2019t have two months to think about it, they had 2 days) or b) re-factored to hell.\n\nBut the story says:\n\n&gt; At first Charles's supervisor was impressed. But as  he  read  through  the\nsource  code,  **he  realized that the project was really much simpler** than he had\noriginally though.\n\nKeep in mind that the problem is the same. But it is Charles solution that makes its solution obvious to his manager, while Alan solution, through working mostly correctly most of the time, it is still a black box to anybody else.\n\nNow, it is a given that this story is so full of strawman that you could feed an herd of cows for months.\n\nBut, if you go with it, it is Charles solution that is written in a way that makes the reader, and so a future maintainer, better understand the problem and the solution.\n\nIn my opinion, this is because this story really it is not only about programming, but about understanding complexity. One solution is able to reduce it, the other just barely work around it.","aSentId": 45645,"answer": "Alan\u2019s manager quickly gave up because he is not an experienced developer. Technical artifacts and documentation are in no way the same as systems level documentation.\n    \n  Charles' manager was lead to believe that the project was much simpler than he thought because Charles' code was simple, and he spent lots of time \u2018wasting time\u2019. These two points lead the manager to think that the project was simple. In situations like this, no one usually knows the true requirements or complexity. A simple solution will make the problem appear simple, while a complex solution will make it appear complicated. Even though Charles\u2019 solution was simple, and worked, it was not right for the company.\n  \n  &gt; But, if you go with it, it is Charles solution that is written in a way that makes the reader, and so a future maintainer, better understand the problem and the solution.\nIn my opinion, this is because this story really it is not only about programming, but about understanding complexity. One solution is able to reduce it, the other just barely work around it.\n  \n  I do agree with this point, I am a big believer of spending more time writing code to reduce the time required to read it. \n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45642,"question": "That may be true, but the difference I read from this was more than just thinking about and understanding the problem, it was understanding the subject area in which the problem will be operating.\n  \nAlan built a robust solution which has the ability to scale. The interfaces were well designed and valuable technical artifacts were produced during the process. \n  \nCharles put together a simple application to do exactly what it needed to do, and a little bit extra.\n  \n  Great, simple is better, right? Well these are accounting firms. These applications will stick around for many years to come. They will be maintained and improved by many other developers.\n  \n  So this leaves is with: \nAlan\u2019s application, which has solid documentation on why design decisions were made, interfaces for modules, and a design which supports scale. Future developers will be able to gain an understanding on what was done and why, and build on it.\n  \n  Charles\u2019 application is simple, it is to the point and gets the job done. When future development is done, it will either be: a) hacked in by someone else who doesn\u2019t understand the problem as well as Charles (They didn\u2019t have two months to think about it, they had 2 days) or b) re-factored to hell.\n   \nThis is the reality of working as an in-house developer in the corporate world. Creating something which is simple, to the point and does one specific task extremely well is not necessarily the best answer. Charles solution may be the best for a small business, a start-up, or creating a temporary tool. In the environment in which they were operating, the monolithic solution is what was really required.\n","aSentId": 45647,"answer": "You are making assumptions. While its true that companies tend to use stuff that is around since many years where they do it is something no one can predict.   \rIve seen shitty shell scripts hanging around for many years.   \rAnd Ive seen major projects that took years to accomplish get thrown out to the garbage because:  New high level manager decided we should use some other tech for this domain; people didn't like the design, department A who uses it realized that they need something else; department A was disbanded altogether; department B rewrites the same program and forces on everyone bc their manager wants to gain power,...\r\rMaking something complex just because that complexity might be useful in the future is not a good idea in my experience ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45642,"question": "That may be true, but the difference I read from this was more than just thinking about and understanding the problem, it was understanding the subject area in which the problem will be operating.\n  \nAlan built a robust solution which has the ability to scale. The interfaces were well designed and valuable technical artifacts were produced during the process. \n  \nCharles put together a simple application to do exactly what it needed to do, and a little bit extra.\n  \n  Great, simple is better, right? Well these are accounting firms. These applications will stick around for many years to come. They will be maintained and improved by many other developers.\n  \n  So this leaves is with: \nAlan\u2019s application, which has solid documentation on why design decisions were made, interfaces for modules, and a design which supports scale. Future developers will be able to gain an understanding on what was done and why, and build on it.\n  \n  Charles\u2019 application is simple, it is to the point and gets the job done. When future development is done, it will either be: a) hacked in by someone else who doesn\u2019t understand the problem as well as Charles (They didn\u2019t have two months to think about it, they had 2 days) or b) re-factored to hell.\n   \nThis is the reality of working as an in-house developer in the corporate world. Creating something which is simple, to the point and does one specific task extremely well is not necessarily the best answer. Charles solution may be the best for a small business, a start-up, or creating a temporary tool. In the environment in which they were operating, the monolithic solution is what was really required.\n","aSentId": 45649,"answer": "It's too late for this one guys...they already got to 'im.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45650,"question": "It's too late for this one guys...they already got to 'im.","aSentId": 45651,"answer": "All very well to have a laugh, but enterprise development is a bit different to uni. \n  \n  If you end up working in an enterprise in-house team, and start maintaining these cleaver little programmes which were built by a single person who spent months thinking about it and wrote it to do exactly what they wanted it to, and no more, you will understand. You will start to realise that a good developer isn't one who can write the coolest code and use the newest technologies. The best developers you meet are ones who follow process, develop with the purpose in mind, and who think carefully about who will end up maintaining the solution.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45654,"question": "Neither is correct, both are different methods to the same goal.","aSentId": 45655,"answer": "I'd say they're different methods towards different goals. Alan produced money for himself, Charles produced quality for his company.\n\nI think the best approach is to realize how much of \"the game\" you're willing to play and do so enthusiastically for the sake of money in your pocket. At the same time, produce as much quality as is feasible for the sake of the light in your soul.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45656,"question": "I'd say they're different methods towards different goals. Alan produced money for himself, Charles produced quality for his company.\n\nI think the best approach is to realize how much of \"the game\" you're willing to play and do so enthusiastically for the sake of money in your pocket. At the same time, produce as much quality as is feasible for the sake of the light in your soul.","aSentId": 45657,"answer": "So then the moral is \"emulate Alan\"? :)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45658,"question": "So then the moral is \"emulate Alan\"? :)","aSentId": 45659,"answer": "Emulate some of Alan for money, some of Charles for morality.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45660,"question": "Emulate some of Alan for money, some of Charles for morality.","aSentId": 45661,"answer": "I don't get paid for morality. My boss is a sociopath. How is Chuck helping me?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45662,"question": "I don't get paid for morality. My boss is a sociopath. How is Chuck helping me?","aSentId": 45663,"answer": "In such a situation, there can only be a use for Alan :)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45662,"question": "I don't get paid for morality. My boss is a sociopath. How is Chuck helping me?","aSentId": 45665,"answer": "Well, if more people emulate Chuck, then it'll mean it's easier to extend the software when needed.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45666,"question": "Well, if more people emulate Chuck, then it'll mean it's easier to extend the software when needed.","aSentId": 45667,"answer": "Well, sure, but Chuck himself doesn't benefit because he either quits or gets shitcanned. :)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45660,"question": "Emulate some of Alan for money, some of Charles for morality.","aSentId": 45669,"answer": "I've been a Charles for a year. Got rewarded with 6 month of part-time because company money shortage (my colleagues got only 3 month).\n\nNow we all are back to full-time. But this time I'm gonna be an Alan.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45656,"question": "I'd say they're different methods towards different goals. Alan produced money for himself, Charles produced quality for his company.\n\nI think the best approach is to realize how much of \"the game\" you're willing to play and do so enthusiastically for the sake of money in your pocket. At the same time, produce as much quality as is feasible for the sake of the light in your soul.","aSentId": 45671,"answer": "Didn't Charles produce a mediocre result? ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45673,"question": "So I'm getting the impression reading this subreddit that management has a real difficult time figuring out what is and isn't good code. As a terrible coder, things are looking good for me.","aSentId": 45674,"answer": "Until you get a job where your managers are coders... Sure. But then you'll be buffered by the really bad coders. They have to get rid of them before they get rid of you. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45675,"question": "Until you get a job where your managers are coders... Sure. But then you'll be buffered by the really bad coders. They have to get rid of them before they get rid of you. ","aSentId": 45676,"answer": "Or you could end up like me where your managers are the rally bad coders. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45677,"question": "Or you could end up like me where your managers are the rally bad coders. ","aSentId": 45678,"answer": "This is actually a common scenario. The company can't get rid of the bad coders for various legal reasons and they are instead famously promoted to their level of incompetence. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45679,"question": "This is actually a common scenario. The company can't get rid of the bad coders for various legal reasons and they are instead famously promoted to their level of incompetence. ","aSentId": 45680,"answer": "&gt; famously promoted to their level of incompetence.\n\nYou're referring to the Peter Principle, which states that people are promoted based on performance in their current role, not their future role.  In this case, you would see excellent programmers being promoted into management positions, where they would fail.\n\nIn the situation where bad programmers are promoted...that might actually work out better for everyone, if they have other skills.\n\nSource: was bad programmer, am better manager.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45681,"question": "&gt; famously promoted to their level of incompetence.\n\nYou're referring to the Peter Principle, which states that people are promoted based on performance in their current role, not their future role.  In this case, you would see excellent programmers being promoted into management positions, where they would fail.\n\nIn the situation where bad programmers are promoted...that might actually work out better for everyone, if they have other skills.\n\nSource: was bad programmer, am better manager.","aSentId": 45682,"answer": "The Dilbert principle:\n\n&gt;companies tend to systematically promote their least-competent employees to management, in order to limit the amount of damage they are capable of doing.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45675,"question": "Until you get a job where your managers are coders... Sure. But then you'll be buffered by the really bad coders. They have to get rid of them before they get rid of you. ","aSentId": 45684,"answer": "That's not a problem -- he can just go somewhere else.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45673,"question": "So I'm getting the impression reading this subreddit that management has a real difficult time figuring out what is and isn't good code. As a terrible coder, things are looking good for me.","aSentId": 45686,"answer": "Or make your code better, that also helps.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45687,"question": "Or make your code better, that also helps.","aSentId": 45688,"answer": "Possibly, if the people reading the code are also the ones who provide the feedback for your advancement, and those events happen in that order. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45690,"question": "With The Story of Mel surfacing again, figured I'd dig this one up too. Probably my favorite of the old usenet tales, and it hasn't seen light on /r/programming in 5 years!","aSentId": 45691,"answer": "This sounds a lot like one of the stories from 'Soul of a New Machine'. Maybe the one about Epstein and the microcode sequencer?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45690,"question": "With The Story of Mel surfacing again, figured I'd dig this one up too. Probably my favorite of the old usenet tales, and it hasn't seen light on /r/programming in 5 years!","aSentId": 45693,"answer": "Why does this feel like the opening of /r/arrow?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45694,"question": "Why does this feel like the opening of /r/arrow?","aSentId": 45695,"answer": "...what?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45697,"question": "The trick is to work on problems someone prestigious has *already failed at*.  Then no one can call them \"easy\".","aSentId": 45698,"answer": "Actually this is key in business. You want to always promote your successes *particularly* when others have tried and failed.\n\nAlso a good trick is to be told by others that something isn't possible - then do it.\n\nI was working with a proprietary multitasking operating system written for 16-bit DOS back in the day, and though why not port it to 32-bit for Windows. The task-switching logic, however, was written in Assembler. One of my team members adamantly believed it was not possible to write Assembler for Windows - he was convinced it was impossible. So I stayed up late a few nights one week, got it running under Windows porting the Assembler as well as C, and the whole thing performed immensely (10x, maybe 100x) faster than the 16-bit DOS version under Windows.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45699,"question": "Actually this is key in business. You want to always promote your successes *particularly* when others have tried and failed.\n\nAlso a good trick is to be told by others that something isn't possible - then do it.\n\nI was working with a proprietary multitasking operating system written for 16-bit DOS back in the day, and though why not port it to 32-bit for Windows. The task-switching logic, however, was written in Assembler. One of my team members adamantly believed it was not possible to write Assembler for Windows - he was convinced it was impossible. So I stayed up late a few nights one week, got it running under Windows porting the Assembler as well as C, and the whole thing performed immensely (10x, maybe 100x) faster than the 16-bit DOS version under Windows.","aSentId": 45700,"answer": "But it isn't possible to write \"assembler.\" \"Assembly language\" is what you write.\n\nThe assembler is the compiler that takes your code mnemonic and replaces it with 1's and 0's for the chip set.\n\n^^Pet ^^peeve ^^of ^^mine.\n\nGood job on the project though, I don't mean to diminish it. I'd be proud of that one too.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45703,"question": "Although a nice story does this actually resonate with anyone? Is this a typical scenario?","aSentId": 45704,"answer": "I remember this sort of thing when I first started in the 80s. Larger programming teams often have the problem that they can't do small projects. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45705,"question": "I remember this sort of thing when I first started in the 80s. Larger programming teams often have the problem that they can't do small projects. ","aSentId": 45706,"answer": "Makes sense if you think about the psychology.  If you assign 10 people to do a task that only needs 2 people, 8 of the people aren't likely to just come out and say \"I'm not necessary!\", but rather the project will grow extra 'work' until all 10 people can feel necessary.\n\nMaybe the lesson is to make sure to allocate the right number of people.  Oh and also have the people who evaluate performance know enough about the job of the person they are evaluating.  ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45707,"question": "Makes sense if you think about the psychology.  If you assign 10 people to do a task that only needs 2 people, 8 of the people aren't likely to just come out and say \"I'm not necessary!\", but rather the project will grow extra 'work' until all 10 people can feel necessary.\n\nMaybe the lesson is to make sure to allocate the right number of people.  Oh and also have the people who evaluate performance know enough about the job of the person they are evaluating.  ","aSentId": 45708,"answer": "Parkinson's law.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45703,"question": "Although a nice story does this actually resonate with anyone? Is this a typical scenario?","aSentId": 45710,"answer": "IMHO this just happened to me. I recently has a meeting with my managers and told them I felt I wasn't being compensated for the value I brought to the company.   \n\nI was told I wasn't the \"go to guy on anything.\" From my mangers point of view, when something broke, and production was down, I wasn't the guy he asked to fix it. \n\nFrom my point of view I write code that didn't break, or if it does break it breaks gracefully and with plenty of warning to avoid production down.   \n\n\"Fred\"on the other hand is the \"go to guy\" if the JSS goes down, preventing one server from taking to another, risking missing 100+ SLAs. Never mind it went down because somebody left a field blank instead of entering a zero.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45711,"question": "IMHO this just happened to me. I recently has a meeting with my managers and told them I felt I wasn't being compensated for the value I brought to the company.   \n\nI was told I wasn't the \"go to guy on anything.\" From my mangers point of view, when something broke, and production was down, I wasn't the guy he asked to fix it. \n\nFrom my point of view I write code that didn't break, or if it does break it breaks gracefully and with plenty of warning to avoid production down.   \n\n\"Fred\"on the other hand is the \"go to guy\" if the JSS goes down, preventing one server from taking to another, risking missing 100+ SLAs. Never mind it went down because somebody left a field blank instead of entering a zero.","aSentId": 45712,"answer": "Basically that's the trap that many companies find themselves in. There's no value placed on the actual planning and execution of the job.\n\nDeliver 50% quality in 50% of the time, and you're a hero. Sure it'll never be a \"AAA\" product, and the effort to take that 50% product to 100% of the ask is 1x to 3x of what it would have taken to build it correctly in the first place, but your program managers can claim success early and that's what they value rather than long term investment/maintenance cost/customer satisfaction.\n\nSo the guys (and teams) that get code in early (or just deliver to an unreasonable schedule) and spend their days \"firefighting\" are the heroes, while the programmers delivering real solutions on a predictable cadence are overlooked.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45713,"question": "Basically that's the trap that many companies find themselves in. There's no value placed on the actual planning and execution of the job.\n\nDeliver 50% quality in 50% of the time, and you're a hero. Sure it'll never be a \"AAA\" product, and the effort to take that 50% product to 100% of the ask is 1x to 3x of what it would have taken to build it correctly in the first place, but your program managers can claim success early and that's what they value rather than long term investment/maintenance cost/customer satisfaction.\n\nSo the guys (and teams) that get code in early (or just deliver to an unreasonable schedule) and spend their days \"firefighting\" are the heroes, while the programmers delivering real solutions on a predictable cadence are overlooked.","aSentId": 45714,"answer": "Yup. I've never been praised as much as I was for the solution I delivered in September. It contained about 10% of the necesarry features, and covered about 20% of the intended domain. It's pure crap from both a usability and effectivity viewpoint. But I delivered that shit in 3 weeks and I had warned it would take 6 months. Which it would if I had actually been allowed to make the entire thing instead of delivering early:S","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45711,"question": "IMHO this just happened to me. I recently has a meeting with my managers and told them I felt I wasn't being compensated for the value I brought to the company.   \n\nI was told I wasn't the \"go to guy on anything.\" From my mangers point of view, when something broke, and production was down, I wasn't the guy he asked to fix it. \n\nFrom my point of view I write code that didn't break, or if it does break it breaks gracefully and with plenty of warning to avoid production down.   \n\n\"Fred\"on the other hand is the \"go to guy\" if the JSS goes down, preventing one server from taking to another, risking missing 100+ SLAs. Never mind it went down because somebody left a field blank instead of entering a zero.","aSentId": 45716,"answer": "The story ends that you didn't counter with that because of the entirely rational fear of losing your job for \"talking back\" to your managers, right?\n\n(That could sound sarcastic, or mocking, it's not. More like mocking the insecure management types who can't stand any implication that they're wrong.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45717,"question": "The story ends that you didn't counter with that because of the entirely rational fear of losing your job for \"talking back\" to your managers, right?\n\n(That could sound sarcastic, or mocking, it's not. More like mocking the insecure management types who can't stand any implication that they're wrong.)","aSentId": 45718,"answer": "&gt; The story ends that you didn't counter with that because of the entirely rational fear of losing your job for \"talking back\" to your managers, right?\n\nI'd rather speak my mind and be fired. Haven't been fired yet.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45719,"question": "&gt; The story ends that you didn't counter with that because of the entirely rational fear of losing your job for \"talking back\" to your managers, right?\n\nI'd rather speak my mind and be fired. Haven't been fired yet.","aSentId": 45720,"answer": "&gt; I'd rather speak my mind and be fired.\n\nWe're on the same page. Some people can't chance it. Others (myself) have had bad experiences, even when the feedback was tactfully presented.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45711,"question": "IMHO this just happened to me. I recently has a meeting with my managers and told them I felt I wasn't being compensated for the value I brought to the company.   \n\nI was told I wasn't the \"go to guy on anything.\" From my mangers point of view, when something broke, and production was down, I wasn't the guy he asked to fix it. \n\nFrom my point of view I write code that didn't break, or if it does break it breaks gracefully and with plenty of warning to avoid production down.   \n\n\"Fred\"on the other hand is the \"go to guy\" if the JSS goes down, preventing one server from taking to another, risking missing 100+ SLAs. Never mind it went down because somebody left a field blank instead of entering a zero.","aSentId": 45722,"answer": "At my the first ever full-time job the dude I was told to help (so he was like *senior* while I was *junior*) was always trying to make things in such way that they break as soon as possible -- this made him a *very important person* in company because everyday he makes an *improvement* that causes new bug tomorrow. The longer he works there, the more bug reports come to him and he heroically solves them -- of course it is not hard for him because he already knew yesterday how exactly it would fail today and what to *fix* now to make it fail tomorrow...  \nI left that job and tried not to join any same shitty organized company for months, being without money, while everyone was telling me that it was stupid to become unemployed... until several months later I was accepted to the largest and the most technological IT company in country, that millions of people dream to work at or at least visit the office, etc. This proved, that when you see that some company works in wrong way -- just fuck it and find the one that doesn't.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45723,"question": "At my the first ever full-time job the dude I was told to help (so he was like *senior* while I was *junior*) was always trying to make things in such way that they break as soon as possible -- this made him a *very important person* in company because everyday he makes an *improvement* that causes new bug tomorrow. The longer he works there, the more bug reports come to him and he heroically solves them -- of course it is not hard for him because he already knew yesterday how exactly it would fail today and what to *fix* now to make it fail tomorrow...  \nI left that job and tried not to join any same shitty organized company for months, being without money, while everyone was telling me that it was stupid to become unemployed... until several months later I was accepted to the largest and the most technological IT company in country, that millions of people dream to work at or at least visit the office, etc. This proved, that when you see that some company works in wrong way -- just fuck it and find the one that doesn't.","aSentId": 45724,"answer": "&gt; this made him a very important person in company because everyday he makes an improvement that causes new bug tomorrow. &gt; The longer he works there, the more bug reports come to him and he heroically solves them -- of course it is not hard for him because he already knew yesterday how exactly it would fail today and what to fix now to make it fail tomorrow\n\nThis is essentially the business model of 99% of consultancies.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45725,"question": "&gt; this made him a very important person in company because everyday he makes an improvement that causes new bug tomorrow. &gt; The longer he works there, the more bug reports come to him and he heroically solves them -- of course it is not hard for him because he already knew yesterday how exactly it would fail today and what to fix now to make it fail tomorrow\n\nThis is essentially the business model of 99% of consultancies.","aSentId": 45726,"answer": "That's the truth. I worked as a consultant and saw guys trying to sabotage and milk corps. many times. Me and a couple guys I worked with, however, would usually go in and kick their asses until they saw the train get back on the tracks and then you saw them all trying to jump on before it left them at the station.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45728,"question": "\"So you'll pay me more if if my code stops working every 12 hours?\"","aSentId": 45729,"answer": "Here's what I would do in that situation:\n\n* If I can demonstrate that my code doesn't *need* fixing, therefore saving you maintenance costs, would you agree that adds value?\n* Let's work out a way to review my code/projects to hold me accountable to that value.\n* Then let's discuss compensation.\n\nThis is, of course, completely dependent on you actually having a way to do this. But I recommend being proactive about it.\n\nAnd it is hard. I was in a similar situation at a previous job because the review cycles moved faster than the product ship cycles. By the time my code was vetted in production, I was already given a performance rating for it.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45732,"question": "The tragic thing is that your boss is right.  If you've written code that is solid and doesn't break, it doesn't add to your value.  The *code* adds the value.  But the company owns that code, not you.  If it doesn't break, they don't need you.  Economics.","aSentId": 45733,"answer": "But it does add value. Not having problems is valuable, and having people on payroll with the ability to create mostly flawless things is, imo,  extremely valuable. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45734,"question": "But it does add value. Not having problems is valuable, and having people on payroll with the ability to create mostly flawless things is, imo,  extremely valuable. ","aSentId": 45735,"answer": "Obviously, writing code adds value.  What I'm saying is that *having written* the code does not add value, *unless* you have \"locked in\" the employer (or customer!) with a dependency on future fixes.\n\nI mean, sure, the guy who writes bullet-proof zero-maintenance code is super-valuable.  But if you're *comparing* that guy to to the other guy, whose code isn't so flawless, but who is literally the one person in the company who can navigate the constantly-breaking spaghetti mess of code (that he wrote!) that performs a critical task, he's not *as* valuable.  The spaghetti mess guy has got the employer locked in.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45736,"question": "Obviously, writing code adds value.  What I'm saying is that *having written* the code does not add value, *unless* you have \"locked in\" the employer (or customer!) with a dependency on future fixes.\n\nI mean, sure, the guy who writes bullet-proof zero-maintenance code is super-valuable.  But if you're *comparing* that guy to to the other guy, whose code isn't so flawless, but who is literally the one person in the company who can navigate the constantly-breaking spaghetti mess of code (that he wrote!) that performs a critical task, he's not *as* valuable.  The spaghetti mess guy has got the employer locked in.","aSentId": 45737,"answer": "In other words, a programmer is only valuable for his future code.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45738,"question": "In other words, a programmer is only valuable for his future code.","aSentId": 45739,"answer": "In other words don't do a good job. Write obfuscated shit and ensure your job security for years to come.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45740,"question": "In other words don't do a good job. Write obfuscated shit and ensure your job security for years to come.\n\n","aSentId": 45741,"answer": "Well, that means your future code is barely valuable, but still more valuable than someone who won't write any.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45740,"question": "In other words don't do a good job. Write obfuscated shit and ensure your job security for years to come.\n\n","aSentId": 45743,"answer": "I wrote some very high quality code for my family engineering company and because of the trust there I've been able to work for the company while living in a bunch of interesting places like Nicragua, Thailand, Shanghai, Ukraine and around Eastern Europe.  It doesn't pay a huge amount currently because I'm building up a product while owning a piece of it.  Anyways, I think that family businesses are pretty cool because there is a lot of built-in incentive for family members to remember high quality work.  Last year I was the rich guy in Ukraine but now I'm the barely making it guy in Shanghai.  I'm not rich here - but at least I'm here.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45744,"question": "I wrote some very high quality code for my family engineering company and because of the trust there I've been able to work for the company while living in a bunch of interesting places like Nicragua, Thailand, Shanghai, Ukraine and around Eastern Europe.  It doesn't pay a huge amount currently because I'm building up a product while owning a piece of it.  Anyways, I think that family businesses are pretty cool because there is a lot of built-in incentive for family members to remember high quality work.  Last year I was the rich guy in Ukraine but now I'm the barely making it guy in Shanghai.  I'm not rich here - but at least I'm here.","aSentId": 45745,"answer": "That's... uhm... interesting? \n\nSarcasm doesn't travel well via text I suppose.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45746,"question": "That's... uhm... interesting? \n\nSarcasm doesn't travel well via text I suppose.","aSentId": 45747,"answer": "It's legitimately on-point in terms of analyzing perverse incentive structures.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45748,"question": "It's legitimately on-point in terms of analyzing perverse incentive structures.","aSentId": 45749,"answer": "I suppose that's true. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45748,"question": "It's legitimately on-point in terms of analyzing perverse incentive structures.","aSentId": 45751,"answer": "I'm not sure what you mean and if that is a kind of subtle shot at me.  I made sold software a long time ago that just chugs along without hicup and now I'm building a new technology.  The other day I read an article about someone choosing to startup in Changhai, Thailand for the lifestyle and cost.  Depending on where I am I can receive between a hell of a lot of envy and also deep criticism for not making much or not settling down, etc.  I like that I can live in the big world while developing my career and giving very large amounts of time in the pursuit of perfection.  I've met a lot of people who are only class programmers and never get to see the big picture of it.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45746,"question": "That's... uhm... interesting? \n\nSarcasm doesn't travel well via text I suppose.","aSentId": 45753,"answer": "My first post was lost because I'm in China and the Internet to the outside world often sucks here.  In short that old code that I wrote is done and finished and the code that I am writing now is unrelated.  I'm pretty proud of writing that code that doesn't have any bugs at all and just keeps on working.  I was given a hell of a lot of time to do it though and mostly that is because my family member didn't force me to stop until I said that it was finished.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45754,"question": "My first post was lost because I'm in China and the Internet to the outside world often sucks here.  In short that old code that I wrote is done and finished and the code that I am writing now is unrelated.  I'm pretty proud of writing that code that doesn't have any bugs at all and just keeps on working.  I was given a hell of a lot of time to do it though and mostly that is because my family member didn't force me to stop until I said that it was finished.","aSentId": 45755,"answer": "But reddit isn't blocked in China.\n\nCongrats on the Badass code though.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45756,"question": "But reddit isn't blocked in China.\n\nCongrats on the Badass code though.","aSentId": 45757,"answer": "Its strange that reddit is not blocked, probably something to do with it not being encrypted.  China seems real cozy with Amazon so maybe that has something to do with it.\n\nI had LOTS of energy back then and I could work for 15 hours straight.  Now, not so much.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45740,"question": "In other words don't do a good job. Write obfuscated shit and ensure your job security for years to come.\n\n","aSentId": 45759,"answer": "It depends on the company/project. Both my current employer and my previous employer would boot you out if you were terrible at your job (i.e. wrote bad code).\n\nThe only way you can get away with that plan is if the majority of other engineers on your team are doing the same thing *or* you inherited a bunch of legacy code.\n\nThe two worst things my managers see:\n\n1. Someone who takes forever trying to do it the \"right way\"\n2. Someone who keeps breaking everyone else's stuff\n\n(1) isn't worth the cost and everyone worth their salt calls out (2) as soon as they can.\n\n----\n\nWhich comes to the unfortunate point: If you want to do good work you need a good job. There are teams with 95%+ good engineers on them. Teams like that tend to stick together since they provide crazy amounts of value (and are paid accordingly.)\n\nCase in point: My current job has something like 80%+ people I've worked with at a different employer because we all know each other and know that we know what we are doing.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45736,"question": "Obviously, writing code adds value.  What I'm saying is that *having written* the code does not add value, *unless* you have \"locked in\" the employer (or customer!) with a dependency on future fixes.\n\nI mean, sure, the guy who writes bullet-proof zero-maintenance code is super-valuable.  But if you're *comparing* that guy to to the other guy, whose code isn't so flawless, but who is literally the one person in the company who can navigate the constantly-breaking spaghetti mess of code (that he wrote!) that performs a critical task, he's not *as* valuable.  The spaghetti mess guy has got the employer locked in.","aSentId": 45761,"answer": "That's exactly the kind of logic that leads to rotting organizations with spectacular failures. The developer you're talking about is actually adding a negative value and the only solution is to get rid of them as soon as possible.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45762,"question": "That's exactly the kind of logic that leads to rotting organizations with spectacular failures. The developer you're talking about is actually adding a negative value and the only solution is to get rid of them as soon as possible.","aSentId": 45763,"answer": "yes, but unless your manager is an ex-engineer you're safe!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45736,"question": "Obviously, writing code adds value.  What I'm saying is that *having written* the code does not add value, *unless* you have \"locked in\" the employer (or customer!) with a dependency on future fixes.\n\nI mean, sure, the guy who writes bullet-proof zero-maintenance code is super-valuable.  But if you're *comparing* that guy to to the other guy, whose code isn't so flawless, but who is literally the one person in the company who can navigate the constantly-breaking spaghetti mess of code (that he wrote!) that performs a critical task, he's not *as* valuable.  The spaghetti mess guy has got the employer locked in.","aSentId": 45765,"answer": "Those (that become a single point of organizational failure due to poor work) are the type of people that fit the definition of incompetent, and you should fire them, if you can spot them.\n\nIf it is your job to spot them, and you can't, you're the incompetent manager.\n\nUnfortunately, in this way, incompetence breeds incompetence, so guard your standards.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45732,"question": "The tragic thing is that your boss is right.  If you've written code that is solid and doesn't break, it doesn't add to your value.  The *code* adds the value.  But the company owns that code, not you.  If it doesn't break, they don't need you.  Economics.","aSentId": 45768,"answer": "The code is the accrued value, writing the code is where the value is added.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45732,"question": "The tragic thing is that your boss is right.  If you've written code that is solid and doesn't break, it doesn't add to your value.  The *code* adds the value.  But the company owns that code, not you.  If it doesn't break, they don't need you.  Economics.","aSentId": 45770,"answer": "And this is how Bill Gates became \"the richest man in the world.\"\n\n^^which ^^is ^^actually ^^the ^^banksters, ^^but ^^I ^^won't ^^get ^^into ^^that","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45703,"question": "Although a nice story does this actually resonate with anyone? Is this a typical scenario?","aSentId": 45776,"answer": "Often, yes. If you're hired into a non-tech company, if you're able to simplify a problem, the bosses/clients tend to think you're just slacking off or aren't working hard enough. If you make a mountain out of a molehill and then lead a team to resolve this newly found huge task as if you're battling an invading army, you're seen as a hard worker and great expert.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45777,"question": "Often, yes. If you're hired into a non-tech company, if you're able to simplify a problem, the bosses/clients tend to think you're just slacking off or aren't working hard enough. If you make a mountain out of a molehill and then lead a team to resolve this newly found huge task as if you're battling an invading army, you're seen as a hard worker and great expert.","aSentId": 45778,"answer": "It doesn't really have to do with tech or any field specifically. How do people outside your field know whether the task was easy or you are just really good? If you have managers who don't understand your tasks then they'll fall back to easy to measure things like hours spent to try to determine how hard you are working. It's in your managers own best interest to show that they are leading a productive team to THEIR managers. Having more man hours spent on the same task but appearing to be working harder makes them look better even if in the end the company is spending more money. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45777,"question": "Often, yes. If you're hired into a non-tech company, if you're able to simplify a problem, the bosses/clients tend to think you're just slacking off or aren't working hard enough. If you make a mountain out of a molehill and then lead a team to resolve this newly found huge task as if you're battling an invading army, you're seen as a hard worker and great expert.","aSentId": 45780,"answer": "My first real full-time job was in vaguely similar situation, where I was the single programmer in a non-software business. But in my case I was hired specifically to avoid the giant, expensive team because my group knew it would cost them 10x more money and 10x more time to get the same results. Fortunately I got enough consistent output that my screwing around was tolerated just fine.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45777,"question": "Often, yes. If you're hired into a non-tech company, if you're able to simplify a problem, the bosses/clients tend to think you're just slacking off or aren't working hard enough. If you make a mountain out of a molehill and then lead a team to resolve this newly found huge task as if you're battling an invading army, you're seen as a hard worker and great expert.","aSentId": 45782,"answer": "While true I'm going to be the honest one here. I haven't seen this happen in my career. Maybe on small modules of an applications but not anything near what was told in this story. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45784,"question": "I used to work somewhere where time spent in the office was more important than amount/quality of code produced. ","aSentId": 45785,"answer": "My company has \"leadership charts\", which is just a bar graph of how many \"productive hours\" entered into billing in the last month/3 months. But what is considered a \"productive hour\" seems totally arbitrary to me. For example travel time spent on client visit is a \"productive hour\". What?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45786,"question": "My company has \"leadership charts\", which is just a bar graph of how many \"productive hours\" entered into billing in the last month/3 months. But what is considered a \"productive hour\" seems totally arbitrary to me. For example travel time spent on client visit is a \"productive hour\". What?","aSentId": 45787,"answer": "Are you paid by your clients on an hourly basis?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45788,"question": "Are you paid by your clients on an hourly basis?","aSentId": 45789,"answer": "Nope, clients purchase per user licenses and additional modules. Most support is covered and the only time we bill hourly is if the client has done something incredibly stupid and we need to do data repair, which is thankfully very rare.\n\nI should have been clearer in my original post. Since almost everything is considered productive the charts essentially just become a representation of who worked the most hours in the last month which is what zanbato was talking about.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45786,"question": "My company has \"leadership charts\", which is just a bar graph of how many \"productive hours\" entered into billing in the last month/3 months. But what is considered a \"productive hour\" seems totally arbitrary to me. For example travel time spent on client visit is a \"productive hour\". What?","aSentId": 45791,"answer": "Productive == Billable in a services shop. Used to get hit up for too many General Admin hours when I was working for an engineering consultancy, they wanted me to \"find ways to reduce my GA hours\" aka pad my billable hours :-/","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45792,"question": "Productive == Billable in a services shop. Used to get hit up for too many General Admin hours when I was working for an engineering consultancy, they wanted me to \"find ways to reduce my GA hours\" aka pad my billable hours :-/","aSentId": 45793,"answer": "Ah I see with that definition travel being counted as productive makes sense but in our company almost anything is considered \"productive\" included working on internal stuff; research; meetings; and support tickets, which are almost always covered.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45784,"question": "I used to work somewhere where time spent in the office was more important than amount/quality of code produced. ","aSentId": 45795,"answer": "I just started at one of those places recently. I fucking hate it. \n\nWe're salaried workers that have to punch a clock -- and they take punching that clock *seriously*. Late? You have to fill out a form with HR like your a tardy middle schooler. \n\nBeing treated like an untrustworthy cog in the machine sure inspires me to work hard! \n\n\n\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45796,"question": "I just started at one of those places recently. I fucking hate it. \n\nWe're salaried workers that have to punch a clock -- and they take punching that clock *seriously*. Late? You have to fill out a form with HR like your a tardy middle schooler. \n\nBeing treated like an untrustworthy cog in the machine sure inspires me to work hard! \n\n\n\n\n","aSentId": 45797,"answer": "I took my youngest kid to a doctor's appointment last week. Her doctor asked me if I needed a note for work. I didn't even know that was a thing. The more I read the more lucky I feel that my company treats me like an adult and puts more emphasis on results than looking busy.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45796,"question": "I just started at one of those places recently. I fucking hate it. \n\nWe're salaried workers that have to punch a clock -- and they take punching that clock *seriously*. Late? You have to fill out a form with HR like your a tardy middle schooler. \n\nBeing treated like an untrustworthy cog in the machine sure inspires me to work hard! \n\n\n\n\n","aSentId": 45799,"answer": "Why are you working there?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45796,"question": "I just started at one of those places recently. I fucking hate it. \n\nWe're salaried workers that have to punch a clock -- and they take punching that clock *seriously*. Late? You have to fill out a form with HR like your a tardy middle schooler. \n\nBeing treated like an untrustworthy cog in the machine sure inspires me to work hard! \n\n\n\n\n","aSentId": 45801,"answer": "A lot of places that contact for the government do that too. Its nice where I work because they stick pretty close to the 40 hour workweek. There are very few 60 hour weeks.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45803,"question": "It happened once to me long ago. A colleague got a raise and I didn't, and when I asked why it was because the other fellow worked long hours and I didn't. I replied that I didn't need to because my project worked, and he needed to because his was full of bugs.\n\nI wouldn't say that experience was typical, it only happened once.","aSentId": 45804,"answer": "What happened next? How did your manager react to that?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45805,"question": "What happened next? How did your manager react to that?","aSentId": 45806,"answer": "we need an answer OP!","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45810,"question": "It's been years since I was in a \"the lone coder off alone on the range\" type situation. Increasingly you work with other programmers, alongside the pm's, etc. People know -exactly- what you are working on, because you tell them each day. You keep people informed and your processes transparent.\n\nThe danger here is in assuming either Charles or Alan were the 'right' way. Neither is.. and neither aren't. They are different approaches for different environments.","aSentId": 45811,"answer": "Charles had the right approach, aside from slacking off for two months.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45812,"question": "Charles had the right approach, aside from slacking off for two months.","aSentId": 45813,"answer": "This tends to be necessary sometimes to work out the most elegant approach to keeping the code simple and concise. The mistake Charles made was the failure to make a show out of this downtime. Fill it with fluff to inflate the perception of complexity.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45814,"question": "This tends to be necessary sometimes to work out the most elegant approach to keeping the code simple and concise. The mistake Charles made was the failure to make a show out of this downtime. Fill it with fluff to inflate the perception of complexity.\n\n","aSentId": 45815,"answer": "Gotta pad that status report to fit your boss's preconceived notions. Learning how to play that game took me a while. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45816,"question": "Gotta pad that status report to fit your boss's preconceived notions. Learning how to play that game took me a while. ","aSentId": 45817,"answer": "Yep. Learn to be Charlie looking like Alan.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45816,"question": "Gotta pad that status report to fit your boss's preconceived notions. Learning how to play that game took me a while. ","aSentId": 45819,"answer": "Yeah, I joke that the metaphorical database that my status reports go in must only at least be \"eventually consistent\".","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45814,"question": "This tends to be necessary sometimes to work out the most elegant approach to keeping the code simple and concise. The mistake Charles made was the failure to make a show out of this downtime. Fill it with fluff to inflate the perception of complexity.\n\n","aSentId": 45821,"answer": "You say things like this... and then wonder why managers can't understand programmers...","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45822,"question": "You say things like this... and then wonder why managers can't understand programmers...","aSentId": 45823,"answer": "I wouldn't exactly call myself a programmer. Though I have written a fair assortment of programs, including some shell scripting in Linux, I have never had a manager. For me it's a lot easier to learn something from source code than manuals. Those manuals just make no sense.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45824,"question": "I wouldn't exactly call myself a programmer. Though I have written a fair assortment of programs, including some shell scripting in Linux, I have never had a manager. For me it's a lot easier to learn something from source code than manuals. Those manuals just make no sense.","aSentId": 45825,"answer": "As a programmer, when things don't work, I go to the source code as often as I can. Docs tend to get overlooked, and you really know how it should work after you read the source.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45814,"question": "This tends to be necessary sometimes to work out the most elegant approach to keeping the code simple and concise. The mistake Charles made was the failure to make a show out of this downtime. Fill it with fluff to inflate the perception of complexity.\n\n","aSentId": 45827,"answer": "Making a report about which problem you was thinking about from 13:25 to 16:20 while playing a ball, would take another 3 hours.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45828,"question": "Making a report about which problem you was thinking about from 13:25 to 16:20 while playing a ball, would take another 3 hours.","aSentId": 45829,"answer": "Technics for productivity theater may vary.\n\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45812,"question": "Charles had the right approach, aside from slacking off for two months.","aSentId": 45831,"answer": "I think the part about Charles \"slacking\" was written from the managers perspective.  I presumed that was thinking time.\n\nHow can anyone, especially a non-programmer, tell from the outside if that employee staring out of the window is just wasting time until 5p.m. or is about to have a brainwave that'll save/make millions?  You can't.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45812,"question": "Charles had the right approach, aside from slacking off for two months.","aSentId": 45833,"answer": "I'd rather have an underling slack off than add hundreds of lines of mickey-mouse source that someone more capable must clean up.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45838,"question": "I work hard on keeping the applications as simple as possible (both in feature set and actual code) for the projects I'm on, and my supervisor (Java/enterprise culture-y, loves super-thin abstraction layers) does not appreciate it at all.","aSentId": 45839,"answer": "'Super-thin abstraction layers' = waste of typing","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45840,"question": "'Super-thin abstraction layers' = waste of typing","aSentId": 45841,"answer": "It's not that much more typing - typically a few lines of setup and imports. My issue is that not all the code is in one goddamn place so that I can easily bring up all the logic and view it in one place.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45838,"question": "I work hard on keeping the applications as simple as possible (both in feature set and actual code) for the projects I'm on, and my supervisor (Java/enterprise culture-y, loves super-thin abstraction layers) does not appreciate it at all.","aSentId": 45843,"answer": "I am like Charlie except that I don't play games (if that is what Charlie was in fact doing between thinking) and I have 30 years experience.    I often notice that people make software code way more complicated than it needs to be or should be.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45852,"question": "Both strike me as bad methodology. The text itself is obviously written from the perspective of the disadvantaged programmer. However spending months at work goofing off is unprofessional regardless of if you end up solving the problem.","aSentId": 45853,"answer": "You completely missed the entire point of the parable.\n\nHe wasn't \"goofing\" off. The whole point is that it *looks* like he was goofing off. But re-read that part again.\n\n&gt; **Back at Consolidated, Charles spent some time thinking about  the  problem.**\nHis  fellow  employees noticed that Charles often sat with his feet on the desk,\ndrinking coffee. He was occasionally seen at his computer  terminal,  but  his\noffice mate  could  tell from the rhythmic striking of keys that he was actually\nplaying Space Invaders.\n\nThe point is, in the end, that \"goofing off\" time actually saved the company time and money because it gave the programmer time to think. And the result was simple code for a program which worked well. Up front thinking about a problem from many angles allowed Charles to write simple code. Unfortunately, the simple code also gave his manager the mistaken assumption that the reason Charles succeeded was that the problem was far simpler than originally imagined. In reality, Charles proved himself to be *\"as good as he pretended,\"* but his manager didn't see that because they incorrectly thought he was simply goofing off (much as you did).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45855,"question": "&gt; Is this a typical scenario?\n\nThe two extremes are obviously exaggerated to emphasize the point.","aSentId": 45856,"answer": "Not really an exaggeration at all. Extremely common IMHO, and it happens just like that in corporations all over the U.S. every single day.\n\nSource: Sr. contract programmer 26 years.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45859,"question": "I will submit my work (which I have slept-on, drank coffee and pondered about, played games while running the problem through my mind in the background) only to be told how simple it turned out to be in the end - once they have seen the code of course. Then some guy comes along with his 1000 lines of Rube Goldberg unreadable spaghetti crap and everyone is all- wow- that problem was so hard. Does not help that I am female.","aSentId": 45860,"answer": "It's weird.  Some of the worst code that I've seen is from men that are always super confident in their own skills, all the while doing a terrible job but being somehow proud because their spaghetti code sort of works.\n\nMeanwhile, I don't see any of that overconfidence in women that I work with, even if their work is much better.\n\nI don't know if it's stereotype threat or what.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45861,"question": "It's weird.  Some of the worst code that I've seen is from men that are always super confident in their own skills, all the while doing a terrible job but being somehow proud because their spaghetti code sort of works.\n\nMeanwhile, I don't see any of that overconfidence in women that I work with, even if their work is much better.\n\nI don't know if it's stereotype threat or what.","aSentId": 45862,"answer": "I have had at least one experience with a programmer who was super confident and produced code that I hated.\n\nHe was arrogant and not a very good programmer.  Per his own description, he had converted from a previous career as a small-time local news personality.  You could totally tell that from the way he coded.\n\nSometimes people try to compensate for incompetence with overconfidence.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45861,"question": "It's weird.  Some of the worst code that I've seen is from men that are always super confident in their own skills, all the while doing a terrible job but being somehow proud because their spaghetti code sort of works.\n\nMeanwhile, I don't see any of that overconfidence in women that I work with, even if their work is much better.\n\nI don't know if it's stereotype threat or what.","aSentId": 45864,"answer": "What does \"spaghetti code\" mean?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45865,"question": "What does \"spaghetti code\" mean?","aSentId": 45866,"answer": "Messy code. I think it refers mostly to how the control-flow looks in your code. Make a double for-loop with two goto's and you've quite likely already got spaghetti code - unreadable.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45867,"question": "Messy code. I think it refers mostly to how the control-flow looks in your code. Make a double for-loop with two goto's and you've quite likely already got spaghetti code - unreadable.","aSentId": 45868,"answer": "What languages in use these days still have goto's?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45869,"question": "What languages in use these days still have goto's?","aSentId": 45870,"answer": "C++","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45869,"question": "What languages in use these days still have goto's?","aSentId": 45872,"answer": "It's nice for error handling in c, if all your error cases have similar cleanup.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45869,"question": "What languages in use these days still have goto's?","aSentId": 45874,"answer": "C# has goto.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45867,"question": "Messy code. I think it refers mostly to how the control-flow looks in your code. Make a double for-loop with two goto's and you've quite likely already got spaghetti code - unreadable.","aSentId": 45876,"answer": "If you could have any one food for the rest of your life, what would it be and why is it spaghetti?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45861,"question": "It's weird.  Some of the worst code that I've seen is from men that are always super confident in their own skills, all the while doing a terrible job but being somehow proud because their spaghetti code sort of works.\n\nMeanwhile, I don't see any of that overconfidence in women that I work with, even if their work is much better.\n\nI don't know if it's stereotype threat or what.","aSentId": 45878,"answer": "There is definitely a ton of gender stereotyping in computer science. I work from home (for the same company for over a decade) and I am certain if my name was Charles the new hires would give me far more respect.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45879,"question": "There is definitely a ton of gender stereotyping in computer science. I work from home (for the same company for over a decade) and I am certain if my name was Charles the new hires would give me far more respect.","aSentId": 45880,"answer": "I definitely agree that the problem is there, but I have no idea how to help fix it.  It would help if there were more women in computer science and programming, but I don't see how it would be appealing as a career when so many colleagues would immediately write you off for no rational reason.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45881,"question": "I definitely agree that the problem is there, but I have no idea how to help fix it.  It would help if there were more women in computer science and programming, but I don't see how it would be appealing as a career when so many colleagues would immediately write you off for no rational reason.","aSentId": 45882,"answer": "It would help if people were less sexist regardless of how many female programmers there are.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45885,"question": "Story of my life sadly, quite literally.  I made great programs for my work with plans to consolidate a lot of their older code into simpler modules so we could upgrade everything.  I get fired for \"slacking off\" and under performing on new tasks and busying myself with customer emails.\n\nMeanwhile my programs are still solid a year after I'm gone, they're floundering to upgrade now that support for their ancient system is gone, and the majority of their workers are now overseas producing 5 times the code I was but with almost no efficiency and constant turn around.\n\nMy job was *system administrator*, but I was relegated to grunt work patching after a week of joining rather than being allowed to push forward on upgrades and streamlining systems.","aSentId": 45886,"answer": "I'd be tempted to just email your exact thoughts to the company that sacked you, just to rub it in that they basically fucked up.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45887,"question": "I'd be tempted to just email your exact thoughts to the company that sacked you, just to rub it in that they basically fucked up.","aSentId": 45888,"answer": "No need.  The friend who got me into the company, and the senior programmer who liked me but left to pursue a better job but stayed on as a contract worker, have both mentioned as such.  &gt;)\n\nI wouldn't work for them again if they asked though, even if I got to do the thing I was hired to do, and in spite of the job being a telecommute position.  They're a small company with no tech manager (who quit the week after I joined, which should really have been a red flag, and was the primary reason I was taken off sysadmin duties).  The only person in charge is a bottom-line business man, and his bottom-line business man superior.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45885,"question": "Story of my life sadly, quite literally.  I made great programs for my work with plans to consolidate a lot of their older code into simpler modules so we could upgrade everything.  I get fired for \"slacking off\" and under performing on new tasks and busying myself with customer emails.\n\nMeanwhile my programs are still solid a year after I'm gone, they're floundering to upgrade now that support for their ancient system is gone, and the majority of their workers are now overseas producing 5 times the code I was but with almost no efficiency and constant turn around.\n\nMy job was *system administrator*, but I was relegated to grunt work patching after a week of joining rather than being allowed to push forward on upgrades and streamlining systems.","aSentId": 45890,"answer": "About ten years ago I spent a few Summers and school weekends making a VB .NET 1.0 application that manages Timesheets for an engineering company.  It does a lot stuff and even generates paper reports with the normalized data arranged in all sorts of nice ways.  They've tried several times to improve upon that experience by integrating in with Quickbooks extensions but nothing delivers that tailored experience.  Its still running the business solid after ten years and the only issue that popped up is people trying to run the application over the network instead of copying to their machine.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45885,"question": "Story of my life sadly, quite literally.  I made great programs for my work with plans to consolidate a lot of their older code into simpler modules so we could upgrade everything.  I get fired for \"slacking off\" and under performing on new tasks and busying myself with customer emails.\n\nMeanwhile my programs are still solid a year after I'm gone, they're floundering to upgrade now that support for their ancient system is gone, and the majority of their workers are now overseas producing 5 times the code I was but with almost no efficiency and constant turn around.\n\nMy job was *system administrator*, but I was relegated to grunt work patching after a week of joining rather than being allowed to push forward on upgrades and streamlining systems.","aSentId": 45892,"answer": "did you make a business case for the consolidation? did you just take it upon yourself and not perform other assigned tasks?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45893,"question": "did you make a business case for the consolidation? did you just take it upon yourself and not perform other assigned tasks?","aSentId": 45894,"answer": "I was going over the upgrade with said senior programmer, and he was recommending that I take the project.  After he left though, I was re-reassigned to doing grunt work again because the system was working just fine (in spite of needing to be restarted nightly to prevent overflowing and crashing).  I did the assigned work, but in the end I was assigned the work of three individuals, had to do customer relations, and try to fit system upgrades in somewhere.  I'm convinced the boss was trying to get rid of me because I was one of the highest paid people on the team, and he was trying to keep costs down by forwarding work overseas (where it wasn't done well or on time).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45896,"question": "If you work at a company where Alan's approach is the one being encouraged and praised, please quit. This type of CYA wouldn't stand a chance at my job; the \"supervisors\" are all too skilled as programmers to let a process like this live for very long.","aSentId": 45897,"answer": "&gt; at my job; the \"supervisors\" are all too skilled as programmers to let a process like this live for very long.\n\nProgrammer-heavy environments can be just as bad for this, depending on how much of a grip on reality the programmers in question have.  But it's usually scoring points based on how many flavour-of-the-month libraries can be worked into a project regardless of need or complexity, rather than following design methodologies.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45898,"question": "&gt; at my job; the \"supervisors\" are all too skilled as programmers to let a process like this live for very long.\n\nProgrammer-heavy environments can be just as bad for this, depending on how much of a grip on reality the programmers in question have.  But it's usually scoring points based on how many flavour-of-the-month libraries can be worked into a project regardless of need or complexity, rather than following design methodologies.\n","aSentId": 45899,"answer": "The \"X factor\" here is company culture. The company where I work has a very strong \"homebrew\" preference, but we're also ruthless pragmatists. We are all very open to the idea of using new libraries or tools, but one of our core cultural tenets is using data to justify decisions, so if you can put together an objective bake-off of your new thing versus what we already have or other potential solutions, and yours wins, yes we'll use it.\n\nWe did a pretty intense bake-off between SQL Server Service Broker, Riak Enterprise, Aerospike, and a homebrew solution using RabbitMQ and Redis for the purpose of master-master replication of data (that primarily lives in SQL Server). All of us almost instantly fell in love with Riak Enterprise, but at the end of the day, it was less complex and less expensive to solve the problem with Service Broker. We had to live with that reality. I think that what we achieved is pretty cool, even though it isn't the kind of thing being talked about at hipster conferences right now.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45900,"question": "The \"X factor\" here is company culture. The company where I work has a very strong \"homebrew\" preference, but we're also ruthless pragmatists. We are all very open to the idea of using new libraries or tools, but one of our core cultural tenets is using data to justify decisions, so if you can put together an objective bake-off of your new thing versus what we already have or other potential solutions, and yours wins, yes we'll use it.\n\nWe did a pretty intense bake-off between SQL Server Service Broker, Riak Enterprise, Aerospike, and a homebrew solution using RabbitMQ and Redis for the purpose of master-master replication of data (that primarily lives in SQL Server). All of us almost instantly fell in love with Riak Enterprise, but at the end of the day, it was less complex and less expensive to solve the problem with Service Broker. We had to live with that reality. I think that what we achieved is pretty cool, even though it isn't the kind of thing being talked about at hipster conferences right now.","aSentId": 45901,"answer": "IMO, that is the best balance. Be open to new solutions, but be pragmatic about what problems those new solutions actually solve, what new problems they may create, and how that fits into the overall project and development process.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45900,"question": "The \"X factor\" here is company culture. The company where I work has a very strong \"homebrew\" preference, but we're also ruthless pragmatists. We are all very open to the idea of using new libraries or tools, but one of our core cultural tenets is using data to justify decisions, so if you can put together an objective bake-off of your new thing versus what we already have or other potential solutions, and yours wins, yes we'll use it.\n\nWe did a pretty intense bake-off between SQL Server Service Broker, Riak Enterprise, Aerospike, and a homebrew solution using RabbitMQ and Redis for the purpose of master-master replication of data (that primarily lives in SQL Server). All of us almost instantly fell in love with Riak Enterprise, but at the end of the day, it was less complex and less expensive to solve the problem with Service Broker. We had to live with that reality. I think that what we achieved is pretty cool, even though it isn't the kind of thing being talked about at hipster conferences right now.","aSentId": 45903,"answer": "Out of curiosity, how much person-time does your company spend evaluating technologies like this, compared to the time spent developing proof-of-concepts etc. used to conduct the measurements?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45904,"question": "Out of curiosity, how much person-time does your company spend evaluating technologies like this, compared to the time spent developing proof-of-concepts etc. used to conduct the measurements?","aSentId": 45905,"answer": "Tough to quantify universally. The project I cited here was related to core business operations, so we really wanted to make the right decision. In other cases we might have one person install a couple of contenders and do actual tests, sharing their methodology and results with everyone. \n\nI guess the short answer is: it depends. But we never choose any new technology without some measurable justification. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45898,"question": "&gt; at my job; the \"supervisors\" are all too skilled as programmers to let a process like this live for very long.\n\nProgrammer-heavy environments can be just as bad for this, depending on how much of a grip on reality the programmers in question have.  But it's usually scoring points based on how many flavour-of-the-month libraries can be worked into a project regardless of need or complexity, rather than following design methodologies.\n","aSentId": 45907,"answer": "At my previous position we were programmer heavy with the inverse problem; people were stricken with the \"it wasn't developed here\" syndrome, not trusting code written by anyone other than themselves. They would write everything from scratch, even so far as duplicating functionality built by other teams.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45898,"question": "&gt; at my job; the \"supervisors\" are all too skilled as programmers to let a process like this live for very long.\n\nProgrammer-heavy environments can be just as bad for this, depending on how much of a grip on reality the programmers in question have.  But it's usually scoring points based on how many flavour-of-the-month libraries can be worked into a project regardless of need or complexity, rather than following design methodologies.\n","aSentId": 45909,"answer": "I've seen way too many people over complicate things just to keep them interesting and then be praised for doing so by the devs over them.  I always cringe when I meet a dev who's too smart for their own good.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45896,"question": "If you work at a company where Alan's approach is the one being encouraged and praised, please quit. This type of CYA wouldn't stand a chance at my job; the \"supervisors\" are all too skilled as programmers to let a process like this live for very long.","aSentId": 45911,"answer": "Hell man, this is everywhere.  It isn't usually phrased this way, though.  Its usually \"Programmer X wants to build Y program using framework A and packages B, C, and D,\" where A, B, C, D are unnecessary bolt-ons chosen because X thinks they're neat and wants to try them out.  Programmers are really great at turning simple problems into complicated ones, especially when they're bored.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45912,"question": "Hell man, this is everywhere.  It isn't usually phrased this way, though.  Its usually \"Programmer X wants to build Y program using framework A and packages B, C, and D,\" where A, B, C, D are unnecessary bolt-ons chosen because X thinks they're neat and wants to try them out.  Programmers are really great at turning simple problems into complicated ones, especially when they're bored.","aSentId": 45913,"answer": "Counterpoint: Programmer X \"trying this new framework out because it's cool\" is the reason your company isn't still using ASP.NET web forms with Visual Basic.\n\nYou could counter with \"well he should have learned this new framework on his own time\" but you know what?  I'm getting really sick of this attitude that says programmers aren't entitled to do anything with their nights and weekends except programming.  Programmer X likes to spend time with his wife/girlfriend once in a while too, you know.  No one expects the project manager to go home and do project management, or accountants to go home and do accounting.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45914,"question": "Counterpoint: Programmer X \"trying this new framework out because it's cool\" is the reason your company isn't still using ASP.NET web forms with Visual Basic.\n\nYou could counter with \"well he should have learned this new framework on his own time\" but you know what?  I'm getting really sick of this attitude that says programmers aren't entitled to do anything with their nights and weekends except programming.  Programmer X likes to spend time with his wife/girlfriend once in a while too, you know.  No one expects the project manager to go home and do project management, or accountants to go home and do accounting.","aSentId": 45915,"answer": "Just a counterpoint, there are other knowledge workers who are expected to do \"homework.\" e.g. medicine--even as a practicing doctor, you're expected to stay up-to-date on the literature (on your own time.)\n\nEdit: reminded by /u/mjec that lawyers can just bill their clients for their time (including research). Were that doctors could do the same! (Fat chance)\n\nAlso reworded original submission.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45916,"question": "Just a counterpoint, there are other knowledge workers who are expected to do \"homework.\" e.g. medicine--even as a practicing doctor, you're expected to stay up-to-date on the literature (on your own time.)\n\nEdit: reminded by /u/mjec that lawyers can just bill their clients for their time (including research). Were that doctors could do the same! (Fat chance)\n\nAlso reworded original submission.","aSentId": 45917,"answer": "&gt; But law is similar, as are many other knowledge fields.\n\nPracticing lawyer here. We do have to stay up-to-date -- and we do it on company time. This includes both formal and informal training. Plus if a particular project requires us to do research, we do it and charge the client.\n\nThe problem is that programming is seen (by some) as a technical task: if you're not writing code you're not working. That's not how it works. As in the rest of the world, you probably need to spend 20% - 50% of your time doing work that doesn't produce SLOC.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45918,"question": "&gt; But law is similar, as are many other knowledge fields.\n\nPracticing lawyer here. We do have to stay up-to-date -- and we do it on company time. This includes both formal and informal training. Plus if a particular project requires us to do research, we do it and charge the client.\n\nThe problem is that programming is seen (by some) as a technical task: if you're not writing code you're not working. That's not how it works. As in the rest of the world, you probably need to spend 20% - 50% of your time doing work that doesn't produce SLOC.","aSentId": 45919,"answer": "&gt;Plus if a particular project requires us to do research, we do it and charge the client.\n\nThanks for the insight. After I posted that I was thinking that programmers and lawyers can usually afford to do their research at work. Practicing doctors are supposed to know the stuff already (unless it's something really rare/unusual, in which case you still have to know the name of the thing you're looking up.)","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45918,"question": "&gt; But law is similar, as are many other knowledge fields.\n\nPracticing lawyer here. We do have to stay up-to-date -- and we do it on company time. This includes both formal and informal training. Plus if a particular project requires us to do research, we do it and charge the client.\n\nThe problem is that programming is seen (by some) as a technical task: if you're not writing code you're not working. That's not how it works. As in the rest of the world, you probably need to spend 20% - 50% of your time doing work that doesn't produce SLOC.","aSentId": 45921,"answer": "&gt; (...) programming is seen (by some) as a technical task (...)\n\nBeats having it seen as a clerical task, though decidedly sub-ideal.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45916,"question": "Just a counterpoint, there are other knowledge workers who are expected to do \"homework.\" e.g. medicine--even as a practicing doctor, you're expected to stay up-to-date on the literature (on your own time.)\n\nEdit: reminded by /u/mjec that lawyers can just bill their clients for their time (including research). Were that doctors could do the same! (Fat chance)\n\nAlso reworded original submission.","aSentId": 45923,"answer": "I like the structure of doctor and lawyer firms.  The business manager answers to the talent, not the other way around.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45924,"question": "I like the structure of doctor and lawyer firms.  The business manager answers to the talent, not the other way around.","aSentId": 45925,"answer": "That's changing with the \"corporatization\" of medicine, largely driven by ACO's. (regulatory burden and explicit incentives for monopolization are causing practices to be bought up / work for large hospitals) If you spend enough time on /r/medicine, you'll come across the animosity for boneheaded medical administrators.\n\nI think lawyers are still in charge. Just the new ones can't get jobs.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45916,"question": "Just a counterpoint, there are other knowledge workers who are expected to do \"homework.\" e.g. medicine--even as a practicing doctor, you're expected to stay up-to-date on the literature (on your own time.)\n\nEdit: reminded by /u/mjec that lawyers can just bill their clients for their time (including research). Were that doctors could do the same! (Fat chance)\n\nAlso reworded original submission.","aSentId": 45927,"answer": "&gt;Just a counterpoint, there are plenty of jobs where you're expected to do \"homework.\" e.g. medicine--even as a practicing doctor, you're expected to stay up-to-date on the literature.\n\nDoctors make *so* much more money on average, though.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45928,"question": "&gt;Just a counterpoint, there are plenty of jobs where you're expected to do \"homework.\" e.g. medicine--even as a practicing doctor, you're expected to stay up-to-date on the literature.\n\nDoctors make *so* much more money on average, though.","aSentId": 45929,"answer": "Than programmers?\n\nI don't know what the average programmer/developer makes these days, I looked it up recently and was seeing numbers that were pretty high (70k for newbie mobile developers and 120++ for experienced.) Do programmers tend to actually work &gt;40 hr/wk on average? Most doctors work around 60 (average), not including \"homework.\"","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45930,"question": "Than programmers?\n\nI don't know what the average programmer/developer makes these days, I looked it up recently and was seeing numbers that were pretty high (70k for newbie mobile developers and 120++ for experienced.) Do programmers tend to actually work &gt;40 hr/wk on average? Most doctors work around 60 (average), not including \"homework.\"","aSentId": 45931,"answer": "AFAIK, Doctors make about $160k *without* specializing and much more if they do specialize.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45932,"question": "AFAIK, Doctors make about $160k *without* specializing and much more if they do specialize.","aSentId": 45933,"answer": "All I was saying is that other similar professions (knowledge workers) who want to stay relevant have uncompensated time outside of work.\n\nI've run the numbers before with a slightly lower earning profession than developers. The average doc catches up in terms of earnings at around age 45-50. That doesn't account for the non-monetary burdens of 8 years of med school + residency, the emotional burden, or the continuing 60+ hour work week after training. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45914,"question": "Counterpoint: Programmer X \"trying this new framework out because it's cool\" is the reason your company isn't still using ASP.NET web forms with Visual Basic.\n\nYou could counter with \"well he should have learned this new framework on his own time\" but you know what?  I'm getting really sick of this attitude that says programmers aren't entitled to do anything with their nights and weekends except programming.  Programmer X likes to spend time with his wife/girlfriend once in a while too, you know.  No one expects the project manager to go home and do project management, or accountants to go home and do accounting.","aSentId": 45935,"answer": "While we're on the topic of things programmers aren't entitled to:  using company time and resources to satisfy their curiosities, often to the detriment of the product.\n\nYou speak of ASP.NET and Visual Basic as if they're bad.  And sure, maybe they are.  But know what's worse?  An unending patchwork of a system where every component uses different tools, languages, paradigms, and logic.  The former you can maintain.  The latter can only be pitched.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45936,"question": "While we're on the topic of things programmers aren't entitled to:  using company time and resources to satisfy their curiosities, often to the detriment of the product.\n\nYou speak of ASP.NET and Visual Basic as if they're bad.  And sure, maybe they are.  But know what's worse?  An unending patchwork of a system where every component uses different tools, languages, paradigms, and logic.  The former you can maintain.  The latter can only be pitched.","aSentId": 45937,"answer": "&gt;While we're on the topic of things programmers aren't entitled to: using company time and resources to satisfy their curiosities, often to the detriment of the product.\n\nSure, programmers aren't entitled to this, but smart companies recognize it's in their best interest to allow programmers to spend time learning new things.  An hour of careful study (directed at learning technologies to solve the problem at hand) has often saved me days of work.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45896,"question": "If you work at a company where Alan's approach is the one being encouraged and praised, please quit. This type of CYA wouldn't stand a chance at my job; the \"supervisors\" are all too skilled as programmers to let a process like this live for very long.","aSentId": 45939,"answer": "There is problem with Charles not covering his butt (as much as i dislike it). The problem is this, if the manager asks Charles to build X, and Charles delivers X just like he did in the story, then afterwards it turns out the investors or CEO or whoever wanted Y and *not* X. Now those folks are pissed they wasted so much time and money to get X instead of Y and want to know why. At that point it is trivial for the manager to save himself by throwing Charles under the proverbial bus. \"Oh, he was junior and slacked off all the time so i am not surprised. I told him what you wanted Y, but clearly he cant deliver.\" On the flip side, Alan has a mountain of documentation describing what was built and why. That leaves no way for the manager to shift the blame off to the team who did exactly what they were told. (i have seen this very scenario happen so many times too :( )\n\nAnother scenario, what if said software ended up malfunctioning and causing injury at some point later? The company as a whole will be a lot better off with Alan's approach because they will have clear documentation of their development process and QA testing, and at what level they did their testing. That in turn makes it much harder to sue the company for negligence.\n","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45940,"question": "There is problem with Charles not covering his butt (as much as i dislike it). The problem is this, if the manager asks Charles to build X, and Charles delivers X just like he did in the story, then afterwards it turns out the investors or CEO or whoever wanted Y and *not* X. Now those folks are pissed they wasted so much time and money to get X instead of Y and want to know why. At that point it is trivial for the manager to save himself by throwing Charles under the proverbial bus. \"Oh, he was junior and slacked off all the time so i am not surprised. I told him what you wanted Y, but clearly he cant deliver.\" On the flip side, Alan has a mountain of documentation describing what was built and why. That leaves no way for the manager to shift the blame off to the team who did exactly what they were told. (i have seen this very scenario happen so many times too :( )\n\nAnother scenario, what if said software ended up malfunctioning and causing injury at some point later? The company as a whole will be a lot better off with Alan's approach because they will have clear documentation of their development process and QA testing, and at what level they did their testing. That in turn makes it much harder to sue the company for negligence.\n","aSentId": 45941,"answer": "The documentation aspect is true when you are forced to use a waterfall methodology or when the people you're building the software for do not trust you, or are unscrupulous people. By iterating on a design quickly and showing working, ongoing progress, we try to escape from the paperwork without eschewing the accountability. Granted, most government contracts don't go this way.\n\nThe second scenario is less likely to happen when the product you are building is driven by internal stakeholders (as is the case at my current job). When you are delivering work for external clients, even with an agile approach, clear documentation is nearly always a necessity, for both liability and simple contractual reasons. I've never worked freelance without a fairly clear spec (even though I prefer agile, myself).","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45942,"question": "The documentation aspect is true when you are forced to use a waterfall methodology or when the people you're building the software for do not trust you, or are unscrupulous people. By iterating on a design quickly and showing working, ongoing progress, we try to escape from the paperwork without eschewing the accountability. Granted, most government contracts don't go this way.\n\nThe second scenario is less likely to happen when the product you are building is driven by internal stakeholders (as is the case at my current job). When you are delivering work for external clients, even with an agile approach, clear documentation is nearly always a necessity, for both liability and simple contractual reasons. I've never worked freelance without a fairly clear spec (even though I prefer agile, myself).","aSentId": 45943,"answer": "IMO, iteration is great and does not preclude documentation. \n\nI agree the second scenario is really rare which is a great thing :D","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45947,"question": "Minor detail in the story, while I know LOC is an inherently flawed metric, but 500 LOC in 3 months seems like a really low number, especially for a new project. ","aSentId": 45948,"answer": "You wanted that number to ten times higher?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45950,"question": "Can someone tell me the proper way the managers should have handled either situation? How could they have responded properly when information is being withheld from them (the difficulty of the task)? As much as Charles did do what he was supposed to, is it really surprising that he did not receive the best review when he gave off the appearance that he was accomplishing little work on an easy task?","aSentId": 45951,"answer": "I think the moral of the story is managers don't really know how to judge a valuable programmer, so they use proxies like how many people are under them or how long they take or how incomprehensible their code looks.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45952,"question": "I think the moral of the story is managers don't really know how to judge a valuable programmer, so they use proxies like how many people are under them or how long they take or how incomprehensible their code looks.","aSentId": 45953,"answer": "&gt; I think the moral of the story is managers don't really know how to judge\n\nNot just some managers. Politicians. CEOs. Captains of industry.\n\nHow many billion-choose-your-currency projects have you seen reported failed in the last 5 years for IT systems for the police, for immigration services, for nationwide health? These are projects that were started by big-name firms, ran for years, then spectacularly failed with all that money spent and gone forever.\n\nAnd how many of those failed projects have the money reclaimed by the taxpayer?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45952,"question": "I think the moral of the story is managers don't really know how to judge a valuable programmer, so they use proxies like how many people are under them or how long they take or how incomprehensible their code looks.","aSentId": 45955,"answer": "I get that that is what the story says, but my question is what is the solution? What *should* the manager do to more accurately measure performance in a situation like the one in the story?","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45956,"question": "I get that that is what the story says, but my question is what is the solution? What *should* the manager do to more accurately measure performance in a situation like the one in the story?","aSentId": 45957,"answer": "There is no easy way to do it. But if I were pressed, I'd judge cost vs benefits.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45950,"question": "Can someone tell me the proper way the managers should have handled either situation? How could they have responded properly when information is being withheld from them (the difficulty of the task)? As much as Charles did do what he was supposed to, is it really surprising that he did not receive the best review when he gave off the appearance that he was accomplishing little work on an easy task?","aSentId": 45959,"answer": "Have some more appreciation for programmers who write code that tends to just work right and not have a lot of bugs.  These are the people who understand things better and know what they are doing.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45964,"question": "What the fuck is this obsession of printing programming blogs in shitty unreadable fonts?","aSentId": 45965,"answer": "Well ... /u/mobileDevKing ... what makes you think this is a blog? It's from 1985 and was most likely passed around as a text file without fancy fonts and any other kind of formatting. It was then probably copy/pasted onto this website and uses a monospace font to simply achieve a proper alignment of the text paragraphs.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45966,"question": "Well ... /u/mobileDevKing ... what makes you think this is a blog? It's from 1985 and was most likely passed around as a text file without fancy fonts and any other kind of formatting. It was then probably copy/pasted onto this website and uses a monospace font to simply achieve a proper alignment of the text paragraphs.","aSentId": 45967,"answer": "&gt;uses a monospace font to simply achieve a proper alignment of the text paragraphs.\n\nSomeone could easily re-enter using what is considered a more readable style.  It is a vain nostalgia that keeps poor design aesthetics alive.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45968,"question": "&gt;uses a monospace font to simply achieve a proper alignment of the text paragraphs.\n\nSomeone could easily re-enter using what is considered a more readable style.  It is a vain nostalgia that keeps poor design aesthetics alive.","aSentId": 45969,"answer": "But I think that's what this page and text is about. Nostalgia. So why bother. I also don't think it's any less readable. It looks clear and concise to me.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45970,"question": "But I think that's what this page and text is about. Nostalgia. So why bother. I also don't think it's any less readable. It looks clear and concise to me.","aSentId": 45971,"answer": "It is a story. I get it, it's old, hard core.   That doesn't mean it needs to look like shit.  Whats with all the double spaces between words?  This is begging for a screenplay or another more modern format. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45972,"question": "It is a story. I get it, it's old, hard core.   That doesn't mean it needs to look like shit.  Whats with all the double spaces between words?  This is begging for a screenplay or another more modern format. ","aSentId": 45973,"answer": "Agreed it would look better on medium but who cares if the page is ugly, it's part of the experience man\n\nNice name though","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45980,"question": "I feel like this story was written by someone who thinks you don't need all that overhead of \"planning\" or \"design\" -- just code! Yet that attitude can lead to some major unmaintainable bug-filled messes. Of course in the fairytale land of the story, Charles' program ends up being the higher quality one. It just doesn't ring very true to me.","aSentId": 45981,"answer": "Charles doesn't just write the code. The whole point is that he thought about the program for a while before he started coding at all. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45987,"question": "As a software developer, from my point of view, this is bullshit. It's just a story invented by somebody, and in that story, you could write anything. I could even write a story where I am an awesome man with great chicks around, who kills bad guys before lunch.\nBut the reality is, that you need teams to do your work. And now, work gets too complex to be solved by a single men who just thinks for 2 weeks. If you think of something for 2 weeks and do it in a week, there's no WAY a team will do it 3 times worse and 3 times slower. At least, not the teams I've been into.\n\nThis is just an invented story, probably by some frustrated lasy-ass developer, just like the stories of powerful women which are flooding my Facebook feed.","aSentId": 45988,"answer": "Sure the story is made up, but it makes a good point. And I can say from personal experience that 3 times worse and 3 times slower is absolutely possible. I once implemented something according to spec in about 4 hours and handed it over to another team of 4. They spent 5 weeks making minor changes and discussing things and in the end the majority of my code was still there, unchanged. ","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45987,"question": "As a software developer, from my point of view, this is bullshit. It's just a story invented by somebody, and in that story, you could write anything. I could even write a story where I am an awesome man with great chicks around, who kills bad guys before lunch.\nBut the reality is, that you need teams to do your work. And now, work gets too complex to be solved by a single men who just thinks for 2 weeks. If you think of something for 2 weeks and do it in a week, there's no WAY a team will do it 3 times worse and 3 times slower. At least, not the teams I've been into.\n\nThis is just an invented story, probably by some frustrated lasy-ass developer, just like the stories of powerful women which are flooding my Facebook feed.","aSentId": 45990,"answer": "&gt; But the reality is, that you need teams to do your work. And now, work gets too complex to be solved by a single men who just thinks for 2 weeks. If you think of something for 2 weeks and do it in a week, there's no WAY a team will do it 3 times worse and 3 times slower.\n\nYou couldn't be more wrong. Yes, there is a time and place for teams. But there's also times when a single person can write code faster and better than a team. It all depends on what problem you're solving. You can't just keep adding people to a project and speed up the timeline. Eventually you add too many people - and sometimes the optimum number of people is one.\n\n[edit]**I had originally written a huge wall of text, so here's the tldr:** In two weeks, I rewrote in Java (using an algorithm I came up with on my own) the core of a Prolog module that was originally written by a math PHD over a couple of years. The module was essentially a constraint satisfaction algorithm which solved a fairly complex problem. My algorithm (which I later realized was akin to arc consistency) resulted in drastically faster performance (some large benchmarks dropped from 60s to sub-100ms), easier implementation of new features, and has resulted in almost zero bugs after several years of use.\n\nThe point is, problems like that do exist. Maybe not as entire systems, but as sub-components in systems that you might be working on. You just have to look for them. Think about what components are slow and think why are they slow. And then figure out if you can come up with a way to solve them that wouldn't be as slow.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45995,"question": "Its always a balance. \n\nWrite a quick overly simple script and it may work well. But then it gets a new feature request, and another, and another, and the original design started getting in the road.\n\nAlternatively you can take possible feature requests into consideration at the start. Over engineer your solution, and nothing ever changes and no feature gets added. \n\nPersonally I go for the second option, as it may take some time up front, overall this approach will keep you more sane and maintainable long term. Prototypes almost always end up in production. ","aSentId": 45996,"answer": "Never option 2. Taking all possible features into account is an illusion. Users decide what those are and you can never dream up a complete list. So go minimum viable application and just make it updateable (good unit tests etc.). The overengineering won't just waste time, it will also make a much poorer product.","corpus": "reddit"},{"docID": "t5_2fwo","qSentId": 45999,"question": "Is this a true story?","aSentId": 46000,"answer": "&gt;Parable\n\n...\n\n&gt;True story","corpus": "reddit"}]