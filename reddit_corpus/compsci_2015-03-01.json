[{"docID": "t5_2qhmr", "qSentId": 32860, "question": "Freshman interested in distributed systems where should I start", "aSentId": 32861, "answer": "I'd suggest learning a little more about computer science before arbitrarily choosing a topic to become an expert in.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32862, "question": "I'd suggest learning a little more about computer science before arbitrarily choosing a topic to become an expert in.", "aSentId": 32863, "answer": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32864, "question": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "aSentId": 32865, "answer": "You don't have to be a dick about it though...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32864, "question": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "aSentId": 32867, "answer": "You said yourself that you're a freshman and don't even know the fundamentals of distributed computing. That's plenty enough information for me to advise that studying the fundamentals of computer science will be infinitely more helpful for you now than trying to become an expert in a random field that you don't know anything about.\n\nAs much as you don't want to hear it, this is advice coming from a current \"expert\" in distributed computing.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32868, "question": "You said yourself that you're a freshman and don't even know the fundamentals of distributed computing. That's plenty enough information for me to advise that studying the fundamentals of computer science will be infinitely more helpful for you now than trying to become an expert in a random field that you don't know anything about.\n\nAs much as you don't want to hear it, this is advice coming from a current \"expert\" in distributed computing.", "aSentId": 32869, "answer": "You are right, I over-reacted sorry about that. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32864, "question": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "aSentId": 32871, "answer": "If you had enough exposure, you would know where to start. You decided to advertise your class status, which is an indicator of inexperience in the CS field. Coming off as a fedora wearing autist is a bad idea when asking strangers for help.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32872, "question": "If you had enough exposure, you would know where to start. You decided to advertise your class status, which is an indicator of inexperience in the CS field. Coming off as a fedora wearing autist is a bad idea when asking strangers for help.", "aSentId": 32873, "answer": "There is knowing \"where to start\" and getting input for good resources on the subject. Sorry if I came out as an ass, it was not my intention.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32860, "question": "Freshman interested in distributed systems where should I start", "aSentId": 32875, "answer": "The question of \"How do I distributed systems?!\" is fairly tied to what it you want to distribute. If it's something easily parallelisable, then functional languages (e.g. Scala) seem to be all the rage these days.\n\nIf you need a bit more control, something like Ada is well worth looking into (if only to understand how it handles concurrency and distribution, as it has probably the best in-language mechanisms I've ever seen).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32860, "question": "Freshman interested in distributed systems where should I start", "aSentId": 32877, "answer": "I would study C and get a good understanding of operating systems. Then I would study computer networks and algorithms analysis (parallel algorithms as well). With all that knowledge I think you would definitely be able to tackle it. But unfortunately this is one of those times where knowing the things leading up to it is going to helpful. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32880, "question": "The simulated annealing algorithm (with an emphasis on the schedule function)", "aSentId": 32881, "answer": "This is a very cool augmentation of the local search paradigm.  Thanks for sharing.\n\nIs it possible to provide any expectation of alpha based on the exponential decay function chosen? \n\nThe reason I ask is because I'm currently taking a seminar on approximation algorithms. If the analysis is interesting, perhaps I can bring it up with my classmates/professor for discussion.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32882, "question": "This is a very cool augmentation of the local search paradigm.  Thanks for sharing.\n\nIs it possible to provide any expectation of alpha based on the exponential decay function chosen? \n\nThe reason I ask is because I'm currently taking a seminar on approximation algorithms. If the analysis is interesting, perhaps I can bring it up with my classmates/professor for discussion.", "aSentId": 32883, "answer": "Hey thanks for your feedback! Good question! Let me see if I can add something. The transition probability to an immediately worse state is given by P(x &lt; e^(E/T(n) ), right? If T(n) is high (n=0), the exponential (i.e., the Boltzmann factor) goes to 1, so the transition is likely to occur. As time goes by (n=100), T(n) decreases and the exponential goes to 0, so the transition becomes unlikely. The expected value (average) of the decay is given by the sum of a geometric progression, so 1/(1-alpha). For simplicity, let's state that since alpha is negative (decay), the formula gets 1/(1+|alpha|). Thus, the smaller the magnitude of alpha, the greater the expectation that the search process will accept the \"bad\" transition as the temperature will stay large more time.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32885, "question": "Hypothetical : What restrictions will I need to add to Java so that I can remove its GC?", "aSentId": 32886, "answer": "Here's how I'd think about how to GC works in Java. It's super trivial.\n\nConsider what it would be like taking something written in Java and porting it to C++ with very minimal changes-- you're not allowed to add anything to avoid memory leaks, all you're allowed to do is change the syntax to match. How do you do that?\n\nIt's very simple; any time you deal with \"objects\", they become \"object pointers\" instead. So your `Class* c = new Class();` still works, and instead of having `Object getObject();` you have `Object* getObject();`\n\nSo now you have an equivalent C++ program that leaks for every object created but otherwise acts identical to Java.\n\nWhat you could then do in C++ is create a \"GabageCollector\" singleton class. Add a method called `::trackPointer(Object* obj);` and implement it so it adds to a vector owned by the class, any pointer added to it. Then you can (for example purposes here) find every \"new\" statement in your program, and have it call \"trackPointer.\"\n\nNot quite garbage collection yet, but now you're tracking pointers for every object created by new. You're still \"leaking\", but you know where all the leaks are at this point.\n\nTo make the garbage collector class complete, you'll need to add reference counting. Reference counting is not something I do regularly myself but there's plenty of material on it online with regards to C++. Basically though, you would add two methods to your garbage collector class: `::addReference(Object*);` and `::removeReference(Object*);`.\n\nYour internal list is now a \"pointer\" and a \"reference count\"; and any time your reference count is zero you should be safe to delete the pointer (from within `::removeReference`.)\n\nThat's how you could emulate garbage collection for an app written in Java but ported to C++.\n\nSo what do you need to remove garbage collection?\n\nPersonally I'd say it's as simple as adding a delete operator to the language and removing the garbage component.\n\nTwo consequences here though:\n\n * You have to possibly recompile everything with your new language spec to ensure delete is supported\n * You will have memory leaks with anything that doesn't use delete or legacy Java code that expected delete to begin with\n\nYou can make this issue easier for yourself though, by including the first version of the garbage collection class we talked about above (the pointer list.) when your app ends, any pointer left is a \"leak\", and if you include a file and line where the \"new\" occurred, you can determine locations where leaks happen and write updates to include deleted and such.\n\nHope that helps.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32887, "question": "Here's how I'd think about how to GC works in Java. It's super trivial.\n\nConsider what it would be like taking something written in Java and porting it to C++ with very minimal changes-- you're not allowed to add anything to avoid memory leaks, all you're allowed to do is change the syntax to match. How do you do that?\n\nIt's very simple; any time you deal with \"objects\", they become \"object pointers\" instead. So your `Class* c = new Class();` still works, and instead of having `Object getObject();` you have `Object* getObject();`\n\nSo now you have an equivalent C++ program that leaks for every object created but otherwise acts identical to Java.\n\nWhat you could then do in C++ is create a \"GabageCollector\" singleton class. Add a method called `::trackPointer(Object* obj);` and implement it so it adds to a vector owned by the class, any pointer added to it. Then you can (for example purposes here) find every \"new\" statement in your program, and have it call \"trackPointer.\"\n\nNot quite garbage collection yet, but now you're tracking pointers for every object created by new. You're still \"leaking\", but you know where all the leaks are at this point.\n\nTo make the garbage collector class complete, you'll need to add reference counting. Reference counting is not something I do regularly myself but there's plenty of material on it online with regards to C++. Basically though, you would add two methods to your garbage collector class: `::addReference(Object*);` and `::removeReference(Object*);`.\n\nYour internal list is now a \"pointer\" and a \"reference count\"; and any time your reference count is zero you should be safe to delete the pointer (from within `::removeReference`.)\n\nThat's how you could emulate garbage collection for an app written in Java but ported to C++.\n\nSo what do you need to remove garbage collection?\n\nPersonally I'd say it's as simple as adding a delete operator to the language and removing the garbage component.\n\nTwo consequences here though:\n\n * You have to possibly recompile everything with your new language spec to ensure delete is supported\n * You will have memory leaks with anything that doesn't use delete or legacy Java code that expected delete to begin with\n\nYou can make this issue easier for yourself though, by including the first version of the garbage collection class we talked about above (the pointer list.) when your app ends, any pointer left is a \"leak\", and if you include a file and line where the \"new\" occurred, you can determine locations where leaks happen and write updates to include deleted and such.\n\nHope that helps.", "aSentId": 32888, "answer": "Java GC also cyclical references, which is something simple reference counting doesn't do.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32887, "question": "Here's how I'd think about how to GC works in Java. It's super trivial.\n\nConsider what it would be like taking something written in Java and porting it to C++ with very minimal changes-- you're not allowed to add anything to avoid memory leaks, all you're allowed to do is change the syntax to match. How do you do that?\n\nIt's very simple; any time you deal with \"objects\", they become \"object pointers\" instead. So your `Class* c = new Class();` still works, and instead of having `Object getObject();` you have `Object* getObject();`\n\nSo now you have an equivalent C++ program that leaks for every object created but otherwise acts identical to Java.\n\nWhat you could then do in C++ is create a \"GabageCollector\" singleton class. Add a method called `::trackPointer(Object* obj);` and implement it so it adds to a vector owned by the class, any pointer added to it. Then you can (for example purposes here) find every \"new\" statement in your program, and have it call \"trackPointer.\"\n\nNot quite garbage collection yet, but now you're tracking pointers for every object created by new. You're still \"leaking\", but you know where all the leaks are at this point.\n\nTo make the garbage collector class complete, you'll need to add reference counting. Reference counting is not something I do regularly myself but there's plenty of material on it online with regards to C++. Basically though, you would add two methods to your garbage collector class: `::addReference(Object*);` and `::removeReference(Object*);`.\n\nYour internal list is now a \"pointer\" and a \"reference count\"; and any time your reference count is zero you should be safe to delete the pointer (from within `::removeReference`.)\n\nThat's how you could emulate garbage collection for an app written in Java but ported to C++.\n\nSo what do you need to remove garbage collection?\n\nPersonally I'd say it's as simple as adding a delete operator to the language and removing the garbage component.\n\nTwo consequences here though:\n\n * You have to possibly recompile everything with your new language spec to ensure delete is supported\n * You will have memory leaks with anything that doesn't use delete or legacy Java code that expected delete to begin with\n\nYou can make this issue easier for yourself though, by including the first version of the garbage collection class we talked about above (the pointer list.) when your app ends, any pointer left is a \"leak\", and if you include a file and line where the \"new\" occurred, you can determine locations where leaks happen and write updates to include deleted and such.\n\nHope that helps.", "aSentId": 32890, "answer": "Yes, this is the naive implementation I will likely focus on, but the cyclical references and perf are a concern, but well let's see. Thanks for the detailed writeup!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32885, "question": "Hypothetical : What restrictions will I need to add to Java so that I can remove its GC?", "aSentId": 32892, "answer": "Eliminate all uses of new, and you should be fine.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32893, "question": "Eliminate all uses of new, and you should be fine.", "aSentId": 32894, "answer": "Resolving memory management by allocating everything static? Nope, that can't be fine.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32895, "question": "Resolving memory management by allocating everything static? Nope, that can't be fine.", "aSentId": 32896, "answer": "That's basically what NASA does with their python-generated C code that powers the latest mars river. They're actually allowed to make dynamic allocations at start time, but not once they begin doing anything useful.\n\nThere are plenty of languages that don't have a heap at all. If you teach someone Scheme, and then ask them to write Java without giving them any stylistic guidance, there's a pretty good chance you'll end up without any uses of new. There's also a chance you'll get functions calling themselves recursively to implement loops (I once saw this with main() in C++), but it will work, at least until you overflow the stack.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32897, "question": "That's basically what NASA does with their python-generated C code that powers the latest mars river. They're actually allowed to make dynamic allocations at start time, but not once they begin doing anything useful.\n\nThere are plenty of languages that don't have a heap at all. If you teach someone Scheme, and then ask them to write Java without giving them any stylistic guidance, there's a pretty good chance you'll end up without any uses of new. There's also a chance you'll get functions calling themselves recursively to implement loops (I once saw this with main() in C++), but it will work, at least until you overflow the stack.", "aSentId": 32898, "answer": "You're right, but that wasn't my point.  \nI wasn't implying that dynamic allocation is essential, I was just saying that your previous comment is wrong. You can't port a Java code in which everything is dynamically allocated to C++ by changing the allocations to static and expect it to work.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32893, "question": "Eliminate all uses of new, and you should be fine.", "aSentId": 32900, "answer": "Could also not cause an allocation to get GC'd.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32885, "question": "Hypothetical : What restrictions will I need to add to Java so that I can remove its GC?", "aSentId": 32902, "answer": "Check out [Virgil](http://lambda-the-ultimate.org/node/4716). It's not exactly Java, but it's an Java-like embedded programming language whose whole runtime, including the GC, is writting in Virgil.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32903, "question": "Check out [Virgil](http://lambda-the-ultimate.org/node/4716). It's not exactly Java, but it's an Java-like embedded programming language whose whole runtime, including the GC, is writting in Virgil.", "aSentId": 32904, "answer": "thanks for this ... it's around the same ballpark of vision, but I want to take different route.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32905, "question": "thanks for this ... it's around the same ballpark of vision, but I want to take different route.\n", "aSentId": 32906, "answer": "You should also look into the [MMTk](http://jikesrvm.org/MMTk). The research papers on Java GCs of the past 10 years have mostly been written in a Java subset for the Jikes RVM.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32910, "question": "What's faster, logarithmic time or linear time?", "aSentId": 32911, "answer": "Depends on what you mean by \"faster.\" Do you mean asymptotically faster, or faster in practice? For the former, log n definitely is faster. For the latter, it depends on the constants involved in your particular algorithm, but most likely log n will be faster. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32910, "question": "What's faster, logarithmic time or linear time?", "aSentId": 32913, "answer": "log n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32910, "question": "What's faster, logarithmic time or linear time?", "aSentId": 32915, "answer": "In practice, it depends on the size and coefficients for each (i.e. if you have an n of 500 and it's between an O((log2 n) * 8) and an O(n/8) algorithm (probably parallel or some other method of processing multiple elements at once), you probably want the O(n/8) algorithm), but generally the O(log n) will be faster for most uses.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32917, "question": "Great papers/texts every Comp Sci should have read at least once.", "aSentId": 32918, "answer": "Some good ones here too:\n\nhttps://github.com/papers-we-love/papers-we-love/", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32917, "question": "Great papers/texts every Comp Sci should have read at least once.", "aSentId": 32920, "answer": "Wilkes, Wheeler, and Gill (1951) *Report on the Preparation of Programmes for the EDSAC and the Use of the Library of Subroutines.*\n\nAlso known as the first programming book, and it has been read by all the (European) pioneers of the computer science field in the 1950s", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32917, "question": "Great papers/texts every Comp Sci should have read at least once.", "aSentId": 32922, "answer": "The Little Schemer by Dan Friedman and Matthias Felleisen, and all the other \"Little\" books. \n\nAnd, of course, Structure and Interpretation of Computer Programs.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32924, "question": "&gt; I observe a cultural tradition, which in all probability has its roots in the Renaissance [...] to regard the human mind as the supreme and autonomous master of its artefacts. But if I start to analyse the thinking habits of myself and of my fellow human beings, I come, whether I like it or not, to a completely different conclusion, viz. that the tools we are trying to use and the language or notation we are using to express or record our thoughts, are the major factors determining what we can think or express at all!\n\nThis is gold, thanks for sharing.", "aSentId": 32925, "answer": "That's the computational equivalent of the Sapir-Whorf hypothesis.\n\nIt was long discredited in linguistics, but has recently enjoyed a bit of a resurgence under the likes of Lera Boroditsky. \n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32926, "question": "That's the computational equivalent of the Sapir-Whorf hypothesis.\n\nIt was long discredited in linguistics, but has recently enjoyed a bit of a resurgence under the likes of Lera Boroditsky. \n\n", "aSentId": 32927, "answer": "I would have framed it by saying that a language constitutes a prior distribution over thoughts: thoughts which require fewer words to be written down are easier to think.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32928, "question": "I would have framed it by saying that a language constitutes a prior distribution over thoughts: thoughts which require fewer words to be written down are easier to think.", "aSentId": 32929, "answer": "Agree.\n\nIverson was also influenced by this Whorfian hypothesis when he created the computer language APL. Expressive and minimal.\n\nPersonally, I think it's obviously true that better notations (particularly in regard to abstractions and ability to easily group \"like\" concepts) are crucial in letting us express and comprehend grander concepts and bigger complexity in both mathematics and computer programming.\n\nI think the issue in linguistics was that the claims were initially overstated. And also extrapolating too far from that was politically and/or ethically unpalatable -- implying that one spoken language might be \"superior\" to another, which is fundamental anathema in linguistics (for good reason). But now milder forms of the claim (now known as linguistic relativism (or \"mild\" linguistic relativism)) are accepted once again (at least by many if not all).\n\nIn the techie world, I think it's pretty clear that Hindu-Arabic numerals are superior to Roman numerals, expressing a matrix as \"A\" instead of 200 equations, and so forth greatly extends our conceptual reach.\n\nSo better notations and tools clearly allow us to \"accurately express better thoughts\" even if we are forced later to \"down-translate\" them into C or assembly code or some such for actual use.\n\nAnd people frequently mention that learning another language or approach (say something functional like Haskell) improves their programming mindset and approach, even when returning to something like Perl or JavaScript. I believe it. Your mileage may vary.\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32936, "question": "How to extract product page URL's from a specific category on Walmart's website.", "aSentId": 32937, "answer": "Check out [Scrapy](http://scrapy.org/)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32936, "question": "How to extract product page URL's from a specific category on Walmart's website.", "aSentId": 32939, "answer": "This isn't on topic for this subreddit.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32940, "question": "This isn't on topic for this subreddit.", "aSentId": 32941, "answer": "Dear Reddit police,\nWhere would you advice this post to go?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32942, "question": "Dear Reddit police,\nWhere would you advice this post to go?", "aSentId": 32943, "answer": "He is right, don't be an asshole.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32946, "question": "Understand the Germans Enigma machine from WW2 in 30 lines of Ruby. Featuring in the Oscar winning film \"The Imitation Game\"", "aSentId": 32947, "answer": "Featuring in a movie is hardly the enigma codes biggest claim to fame. I mean, it is probably the most talked about pre-computer code of all time.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32949, "question": "ifferences between books in the principles of computer programming, and in programming languages", "aSentId": 32950, "answer": "I think what you're really asking is about the difference between programming languages and software engineering.  \n\nProgramming languages is primarily concerned with the design and implementation of the actual languages that people use to write software.  It can be very theoretical in nature (ex. formal verification of language features), or more applied (ex. new language features to make a task easier).  Data structures would probably fit here or in computer theory/algorithms.\n\nSoftware engineering is more concerned with how to leverage programming languages to design and implement systems.  This seems to be what you're calling principles of computer programming.  Design patterns would fall into the software engineering category.\n\nThe boundary between the two is somewhat fuzzy and a lot of PL research has an SE component and vice versa.  The two are often combined into one group at universities.\n\nEDIT: A book about programming languages in general might cover the different choices one can make when implementing a language, and what the implications of that are (ex. static vs dynamic typing, functional vs oop, call by value vs call by name).  It will also likely discuss things like turing completeness and what features a programming language typically has.  A book about a specific language will be more focused on teaching that language and will likely be much less theoretical.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32949, "question": "ifferences between books in the principles of computer programming, and in programming languages", "aSentId": 32952, "answer": "The **principles of programming** typically refer to the mathematical foundations of programming.  When languages are concerned, we typical use various forms of mathematical logic to describe the behavior or semantics of programs (and their type systems, when applicable).\n\nSCIP and HtDP are books that provide an introduction to computer programming in the context of functional programming.  In contrast, EoPL and other books such as Types and Programming Languages (TAPL) deal directly with these mathematical principles.\n\n**Design Patterns** are programming idioms designed to handle a common task.  Typically, design patterns are discussed in the context of software engineering where we discuss how to put together or architect substantial software artifacts.  But there is nothing essential about design patterns such that we don't discuss them in the domain of programming languages, for example, in functional programs or proof assistants.\n\n**Data Structures** concerns the arrangement of complex data and the associated algorithms for manipulating those structures.  Data structures are usually discussed in the context of theoretical computer science.  However, like design patterns, there again is nothing essential about design patterns such that we don't discuss them within programming languages, for example, immutable, functional data structures.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32953, "question": "The **principles of programming** typically refer to the mathematical foundations of programming.  When languages are concerned, we typical use various forms of mathematical logic to describe the behavior or semantics of programs (and their type systems, when applicable).\n\nSCIP and HtDP are books that provide an introduction to computer programming in the context of functional programming.  In contrast, EoPL and other books such as Types and Programming Languages (TAPL) deal directly with these mathematical principles.\n\n**Design Patterns** are programming idioms designed to handle a common task.  Typically, design patterns are discussed in the context of software engineering where we discuss how to put together or architect substantial software artifacts.  But there is nothing essential about design patterns such that we don't discuss them in the domain of programming languages, for example, in functional programs or proof assistants.\n\n**Data Structures** concerns the arrangement of complex data and the associated algorithms for manipulating those structures.  Data structures are usually discussed in the context of theoretical computer science.  However, like design patterns, there again is nothing essential about design patterns such that we don't discuss them within programming languages, for example, immutable, functional data structures.", "aSentId": 32954, "answer": "Thanks. \n\nWhat do you mean by \"mathematical foundations of programming\"?\n\nAre they not the \"mathematical principles\" of  programming languages?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32955, "question": "Thanks. \n\nWhat do you mean by \"mathematical foundations of programming\"?\n\nAre they not the \"mathematical principles\" of  programming languages?", "aSentId": 32956, "answer": "My coarse-grained description of the *mathematical foundations of programming* is using math (in particular, mathematical logic) to reason about programs.  Studying the foundations of programming languages provides one perspective on this broad field where the language in question is amendable to extension and re-design.  Another perspective holds the language as a constant, yet still uses mathematics and logic to analyze programs.\n\nTypically we label the first perspective as *programming languages* and the second as *formal verification*.  But these labels are highly variable depending on who you talk to, what institution you are a part of, what academic circles you run in, etc.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32959, "question": "How is data in a database stored in terms of data structures?", "aSentId": 32960, "answer": "You might want to start with some basic understanding of B and B+ trees. That is probably not even close to a satisfying and comprehensive answer to your question, but I think it will likely start moving you in the direction you want to go.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32961, "question": "You might want to start with some basic understanding of B and B+ trees. That is probably not even close to a satisfying and comprehensive answer to your question, but I think it will likely start moving you in the direction you want to go.", "aSentId": 32962, "answer": "I think this is a great starter path. First try implementing trees in memory, then in disk.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32963, "question": "I think this is a great starter path. First try implementing trees in memory, then in disk.", "aSentId": 32964, "answer": "How would you begin to implement disk-based structures? Here I'm assuming implementing structures in memory is just how you would do it with, say, a linked list with nodes malloc()'d from the heap?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32965, "question": "How would you begin to implement disk-based structures? Here I'm assuming implementing structures in memory is just how you would do it with, say, a linked list with nodes malloc()'d from the heap?", "aSentId": 32966, "answer": "B-Trees have pages, each page containing n records. Your storage is a binary file open for read/write where you write the page structs. In disk, instead of pointers to memory structures you have pointers to the number of the in-disk page.\n\nYou will have to write your own allocation and release functions that reserve and free disk pages, like an in-disk version of malloc().", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32967, "question": "B-Trees have pages, each page containing n records. Your storage is a binary file open for read/write where you write the page structs. In disk, instead of pointers to memory structures you have pointers to the number of the in-disk page.\n\nYou will have to write your own allocation and release functions that reserve and free disk pages, like an in-disk version of malloc().", "aSentId": 32968, "answer": "Interesting, thanks.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32969, "question": "Interesting, thanks.", "aSentId": 32970, "answer": "Its always fun to come at long standing problems with new eyes.  Itd be fun to play around with some ideas and just see where they lead.  \n\nIve been considering append only databases.  I think theres a need there that isnt yet being filled.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32965, "question": "How would you begin to implement disk-based structures? Here I'm assuming implementing structures in memory is just how you would do it with, say, a linked list with nodes malloc()'d from the heap?", "aSentId": 32972, "answer": "Check out mmap()", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32959, "question": "How is data in a database stored in terms of data structures?", "aSentId": 32974, "answer": "In my opinion, column store databases are easier to handle algorithmically. Maybe you want to start with such a database. Column stores are used in search engines, on-line analytical software and in-memory databases. But you could just start with implementing a class for a column store with variable number of fields and records in it. Then work your way up. Google should bring up more infos on column stores for you.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32959, "question": "How is data in a database stored in terms of data structures?", "aSentId": 32976, "answer": "Try a google search for \"sql server internals\" to see how that database does things. An example article from [Simple Talk](https://www.simple-talk.com/sql/database-administration/sql-server-storage-internals-101/). \"oracle internals\" would give a look at Oracle. This give you two relational databases to examine.\n \nIf you wanted to expand your study to non-relational models, you might try looking into \"nosql internals\".", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32977, "question": "Try a google search for \"sql server internals\" to see how that database does things. An example article from [Simple Talk](https://www.simple-talk.com/sql/database-administration/sql-server-storage-internals-101/). \"oracle internals\" would give a look at Oracle. This give you two relational databases to examine.\n \nIf you wanted to expand your study to non-relational models, you might try looking into \"nosql internals\".", "aSentId": 32978, "answer": "Looks good, thanks for those", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32979, "question": "Looks good, thanks for those", "aSentId": 32980, "answer": "I am not really qualified to provide guidance here, but you should also look at the source code of Sqlite. It is fairly compact and comes conveniently packaged into a single file to inspect. The documentation is also very good.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32984, "question": "Extension of Hindley-Milner for infinite types?", "aSentId": 32985, "answer": "So, according to some people on the Haskell mailing list, just removing the occurs check (by, e.g. replacing Robinson's unification algorithm with Jaffar's unification algorithm) is sufficient.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32986, "question": "So, according to some people on the Haskell mailing list, just removing the occurs check (by, e.g. replacing Robinson's unification algorithm with Jaffar's unification algorithm) is sufficient.", "aSentId": 32987, "answer": "By \"infinite\" types you meant recursive types?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32988, "question": "By \"infinite\" types you meant recursive types?", "aSentId": 32989, "answer": "Yes, that's right.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32990, "question": "Yes, that's right.", "aSentId": 32991, "answer": "Isorecursive or equirecursive?  But whatever.  You don't actually have to take out the occurs-check, you just have to use it only for variables not bound by the `\\mu` operator.  *Inferring* an isorecursive type without any `\\mu` annotation is a little trickier, and not actually done in most Hindley-Milner unification implementations, as I do believe it requires actually locating an equation of the general form `\\alpha = Constructor1 \\beta \\alpha` to *build* a `\\mu` representation of the iso-recursive type.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32992, "question": "Isorecursive or equirecursive?  But whatever.  You don't actually have to take out the occurs-check, you just have to use it only for variables not bound by the `\\mu` operator.  *Inferring* an isorecursive type without any `\\mu` annotation is a little trickier, and not actually done in most Hindley-Milner unification implementations, as I do believe it requires actually locating an equation of the general form `\\alpha = Constructor1 \\beta \\alpha` to *build* a `\\mu` representation of the iso-recursive type.", "aSentId": 32993, "answer": "Equirecursive. Ah, OK.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32995, "question": "Meet the Man Behind 'Solarized,' the Most Important Color Scheme in Computer History", "aSentId": 32996, "answer": "This site redirects to crapware on Android devices. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 32998, "question": "The story behind PETSc, the open-source software library that helps break the barriers between science &amp; HPC. Crossposted to /r/HPC.", "aSentId": 32999, "answer": "Any case studies / anecdotes from our colleagues in this sub on this library?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33001, "question": "Why can a finite automate represent only those languages where one can count up to M mod K where K is number of states in the machine?", "aSentId": 33002, "answer": "Do you mean \"why can the FSA not represent other languages in the Chomsky hierarchy\" or \"why can an FSA not represent different sorts of counting\" or something else? ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33003, "question": "Do you mean \"why can the FSA not represent other languages in the Chomsky hierarchy\" or \"why can an FSA not represent different sorts of counting\" or something else? ", "aSentId": 33004, "answer": "I believe this is the question: why can an FSA not represent different sorts of counting? But more to the point exactly the phrase Professor uses.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33001, "question": "Why can a finite automate represent only those languages where one can count up to M mod K where K is number of states in the machine?", "aSentId": 33006, "answer": "Think of it this way- You have a finite state system of K different states. However, your input can theoretically be much longer, up to M different states where M&gt;&gt;&gt;&gt;K. Each new character in your input may or may not bring you to a different state, but no matter what you will \"land\" on one of your K states. You can't be clever and \"derive\" extra states from this because you have no context for your state (e.g. I went to state 1 from state 4). You're either in the state or not. The end result is that an input of the range (0-M) gets mapped to a range of (0-K). This is exactly what M%K happens to do. \n\nAnd since you asked about the pumping lemma- This is not quite related. The pumping lemma is more a proof against certain expressions (such as the \"(^i )^i \" used in the video) to prove that no matter how many states you give your FSA, you won't be able to make it large enough to parse the expression. I think the \"counting limit\" may be a core part of the pumping lemma so they are related, but you need to understand this BEFORE you can understand the lemma, not the other way around. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33008, "question": "The Escalang Programming Language (current Master's project). Soliciting feedback.", "aSentId": 33009, "answer": "Just a brief glance, but I found something that confused me... it seems like list concat is infix (++) but arithmetic is lisp-like prefix?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33008, "question": "The Escalang Programming Language (current Master's project). Soliciting feedback.", "aSentId": 33011, "answer": "If you are aiming for new programmers, you may want to look at some of what the Quorum people have done if you have not already.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33008, "question": "The Escalang Programming Language (current Master's project). Soliciting feedback.", "aSentId": 33013, "answer": "Much better explanation of the example programs' semantics than most of the \"what do you think of my new language\" things I've been handed. Seeing as the language itself seems to be the research project, it would be nice to see more about the reasoning behind the design though.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33016, "question": "Trouble with analyzing recursive algorithms", "aSentId": 33017, "answer": "Recursion is essential, because if you don't understand Recursion then there's no way you can do dynamic programming, which is essential for real world speed. \n\nAlso, most practical fast data structures, like balanced trees, use recursive algorithms. Likewise, pretty much everything in programming languages and compilers is recursive (traversing a syntax tree), so if you ever want to get into that, you'll need recursion. \n\nFinding the actual big O complexity won't come up tons in practice, but you should be able to look at a recursive function and tell if it's going to explode exponentially. \n\nThe thing is, a function calling itself is NOT the essence of recursion. It's the concept of solving a problem by breaking it into smaller problems, assuming we can solve them, and reincorporating them into our solution. This is basically a parallel to induction. \n\nDon't worry about learning combinatorics, other than basic permutations, factorial, etc. The main thing I would learn is induction. Learn induction over natural numbers, but also trees and such. That's when the number of nodes in a binary tree and stuff like that becomes obvious. \n\nAlso note that Python can do recursion just fine, and there are some data structures I would never do without recursion. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33018, "question": "Recursion is essential, because if you don't understand Recursion then there's no way you can do dynamic programming, which is essential for real world speed. \n\nAlso, most practical fast data structures, like balanced trees, use recursive algorithms. Likewise, pretty much everything in programming languages and compilers is recursive (traversing a syntax tree), so if you ever want to get into that, you'll need recursion. \n\nFinding the actual big O complexity won't come up tons in practice, but you should be able to look at a recursive function and tell if it's going to explode exponentially. \n\nThe thing is, a function calling itself is NOT the essence of recursion. It's the concept of solving a problem by breaking it into smaller problems, assuming we can solve them, and reincorporating them into our solution. This is basically a parallel to induction. \n\nDon't worry about learning combinatorics, other than basic permutations, factorial, etc. The main thing I would learn is induction. Learn induction over natural numbers, but also trees and such. That's when the number of nodes in a binary tree and stuff like that becomes obvious. \n\nAlso note that Python can do recursion just fine, and there are some data structures I would never do without recursion. ", "aSentId": 33019, "answer": "It's not so much that I think Python can't handle recursion, it's that I hear Python's support for recursion pales to other languages (even getting outside languages like Haskell that depend on it). The native recursion limit is something like 1000. However, given my exposure to other languages (outside of PHP and Python) is \"I've heard of that, I can probably identify it by syntax.\"\n\nI can't say I'm interested much in syntax trees *right now* but two years ago I wasn't interested in Markov Chains either.\n\nAny good sources for studying induction? My understanding of it is starting with a base case, proving that and then moving to more general solutions. Basically, T(1) then T(2), T(3), ... until T(n) can be proven.\n\nI think I'm going to back up from algorithms and brush up on algebra for now as that seems to be the actual sticking point for me. I don't think it's so much I don't get trees as I don't get the math (which I guess is the same thing).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33020, "question": "It's not so much that I think Python can't handle recursion, it's that I hear Python's support for recursion pales to other languages (even getting outside languages like Haskell that depend on it). The native recursion limit is something like 1000. However, given my exposure to other languages (outside of PHP and Python) is \"I've heard of that, I can probably identify it by syntax.\"\n\nI can't say I'm interested much in syntax trees *right now* but two years ago I wasn't interested in Markov Chains either.\n\nAny good sources for studying induction? My understanding of it is starting with a base case, proving that and then moving to more general solutions. Basically, T(1) then T(2), T(3), ... until T(n) can be proven.\n\nI think I'm going to back up from algorithms and brush up on algebra for now as that seems to be the actual sticking point for me. I don't think it's so much I don't get trees as I don't get the math (which I guess is the same thing).", "aSentId": 33021, "answer": "Take a Discrete Math course (MIT Opencourseware offers a good one, but it's quite challenging. It has two lectures on induction and a couple on recurrences.) Great tool for algorithmic analysis. Focus on the  proofs - people often skim that part because \"why do I need to prove something that already works, just tell me how it works\". It's very important to know how to prove things, that's like the backbone of theory.   \n \n\nIt also wouldn't hurt to take a quick refresher on algebra, linear algebra and calculus as well (polynomials, logarithms, derivatives, that sort of stuff). Just intro level for now would be enough. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33020, "question": "It's not so much that I think Python can't handle recursion, it's that I hear Python's support for recursion pales to other languages (even getting outside languages like Haskell that depend on it). The native recursion limit is something like 1000. However, given my exposure to other languages (outside of PHP and Python) is \"I've heard of that, I can probably identify it by syntax.\"\n\nI can't say I'm interested much in syntax trees *right now* but two years ago I wasn't interested in Markov Chains either.\n\nAny good sources for studying induction? My understanding of it is starting with a base case, proving that and then moving to more general solutions. Basically, T(1) then T(2), T(3), ... until T(n) can be proven.\n\nI think I'm going to back up from algorithms and brush up on algebra for now as that seems to be the actual sticking point for me. I don't think it's so much I don't get trees as I don't get the math (which I guess is the same thing).", "aSentId": 33023, "answer": "I would recommend Scheinerman's Discrete Mathematics. It's very readable, although it doesn't talk about programming at all, but you may recognize some of the graphs from data structures. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33016, "question": "Trouble with analyzing recursive algorithms", "aSentId": 33025, "answer": "Edited for formatting.\n\nGoing to your intermediate points:\n\n* b is the reduction in data size.  Don't worry about the \"near constant\" issue so much.  (Why \"near constant?\"  Think about merge-sort.  For n odd, you generally break into two parts, one n/2 rounded up, the other rounded down.  Neither is perfectly n/2, but both are about n * 1/2.)\n\n* f(n) is, as you describe, the amount of work minus the recursion.  Again, in mergesort, this would be the time needed to make (but not run) the recursive calls, and more importantly, the time to merge the two (recursively sorted) halves of the problem.  For that problem, merging dominates the non-recursive parts.  For one individual call, it depends on n, not on the number of recursions.\n\n* a is the number of children in the recursion tree, 2 for mergesort, but you can break a problem into a different number of recursive parts, even just 1 part (like in binary search).\n\n* Clearly, ignoring recursion, the top level of the recurrence tree takes f(n) work.  The next level down has a children, each with n/b size, and so it will take af(n/b) work.  Depending on a, b, and f(), this can be more, less, or equal in work to the top level of the tree.\nat depth i of the tree, there are a^i nodes.  After we divide the problem size by b for log_b n times, the problem size will just be size 1, so the problem size is 1, and recursion bottoms out.  There are a power log_b n nodes at that point.\n\n* The total nodes are n power log_b a = a power log_b n.  This is a property of logs, and can be proved easily by taking the log_b of both sides of the equation, and then applying the rule that log_b a^c = c log_b a.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33027, "question": "/r/math are hosting a discussion about everything regarding the P vs. NP problem. Check it out!", "aSentId": 33028, "answer": "Why is P vs. NP considered relevant to computer science? What *practical* effect would an answer have?\n\nEdit: I wasn't trying to say that it wasn't relevant or that it had no practical effect. I just wanted to start a discussion!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33029, "question": "Why is P vs. NP considered relevant to computer science? What *practical* effect would an answer have?\n\nEdit: I wasn't trying to say that it wasn't relevant or that it had no practical effect. I just wanted to start a discussion!", "aSentId": 33030, "answer": "By asking this question you are clearly ignoring the **science** part of computer science.  Sure, a resolution of P vs NP may, or may not have any (direct) practical effect - but Computer Science is more than just [what I like to call] \"Computing\".  CS includes exploring the limitations of what computers can do and this is where P vs NP is very relevant.  On a related note, is it practical to know that there are problems that aren't solvable by computer?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33031, "question": "By asking this question you are clearly ignoring the **science** part of computer science.  Sure, a resolution of P vs NP may, or may not have any (direct) practical effect - but Computer Science is more than just [what I like to call] \"Computing\".  CS includes exploring the limitations of what computers can do and this is where P vs NP is very relevant.  On a related note, is it practical to know that there are problems that aren't solvable by computer?", "aSentId": 33032, "answer": "&gt; ignoring the **science** part of computer science\n\nAm I? Isn't science inherently practical, rooted in the real world?\n\n&gt; exploring the limitations of what computers can do and this is where P vs NP is very relevant\n\nIs it? What kind of thing that we think computers can't do, would be know that computers can do, if P=NP?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33033, "question": "&gt; ignoring the **science** part of computer science\n\nAm I? Isn't science inherently practical, rooted in the real world?\n\n&gt; exploring the limitations of what computers can do and this is where P vs NP is very relevant\n\nIs it? What kind of thing that we think computers can't do, would be know that computers can do, if P=NP?", "aSentId": 33034, "answer": "Not necessarily,  \"science\" has theoretical implications too - in CS the theoretical is (largely) mathematical rather than observational.\n\nAs to what computers can do if P=NP, it would show that deterministic polynomial time bounded Turing machines have the same computing power as non-deterministic polynomial time bounded machines.  Now you might argue that \"computers\" are quite far removed from Turing machines, but TMs are a (quite reasonable) *model* of computation - and models are essential if you want to do any form of reasoning.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33035, "question": "Not necessarily,  \"science\" has theoretical implications too - in CS the theoretical is (largely) mathematical rather than observational.\n\nAs to what computers can do if P=NP, it would show that deterministic polynomial time bounded Turing machines have the same computing power as non-deterministic polynomial time bounded machines.  Now you might argue that \"computers\" are quite far removed from Turing machines, but TMs are a (quite reasonable) *model* of computation - and models are essential if you want to do any form of reasoning.", "aSentId": 33036, "answer": "What would be an example of a non-deterministic time-bounded machine?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33037, "question": "What would be an example of a non-deterministic time-bounded machine?", "aSentId": 33038, "answer": "Non-deterministic machines are (at the moment) theoretical, but in general very useful to have around because they have very good mathematical properties.  \n\nA non-deterministic time-bounded (Turing) machine is a non-deterministic TM that halts after a polynomial number of steps. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33039, "question": "Non-deterministic machines are (at the moment) theoretical, but in general very useful to have around because they have very good mathematical properties.  \n\nA non-deterministic time-bounded (Turing) machine is a non-deterministic TM that halts after a polynomial number of steps. ", "aSentId": 33040, "answer": "Oh, theoretical! Interesting. I'll have to ask around for more info about it, seems like a fun thing.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33033, "question": "&gt; ignoring the **science** part of computer science\n\nAm I? Isn't science inherently practical, rooted in the real world?\n\n&gt; exploring the limitations of what computers can do and this is where P vs NP is very relevant\n\nIs it? What kind of thing that we think computers can't do, would be know that computers can do, if P=NP?", "aSentId": 33042, "answer": "&gt;Am I? Isn't science inherently practical, rooted in the real world?\n\nAs a none native speaker of English I find the word 'science' a bit annoying. It seems to have taken on the meaning of \"natural science\" in modern English, leaving no word for the traditional meaning of science.\n\nAnyways, no matter if computer science is a science or not and no matter what the word \"science\" actually means, it is clear that the field of computer science both has a theoretical and a practical side to it. The fact that something might not have huge practical effect (not saying that P vs. NP does not, I am really not the right person to ask about that) does not mean that it can't be hugely important and relevant to computer science.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33043, "question": "&gt;Am I? Isn't science inherently practical, rooted in the real world?\n\nAs a none native speaker of English I find the word 'science' a bit annoying. It seems to have taken on the meaning of \"natural science\" in modern English, leaving no word for the traditional meaning of science.\n\nAnyways, no matter if computer science is a science or not and no matter what the word \"science\" actually means, it is clear that the field of computer science both has a theoretical and a practical side to it. The fact that something might not have huge practical effect (not saying that P vs. NP does not, I am really not the right person to ask about that) does not mean that it can't be hugely important and relevant to computer science.", "aSentId": 33044, "answer": "&gt; The fact that something might not have huge practical effect\n\nThat's fine. Perhaps that's the answer to my original question. What's wrong with saying so?\n\nPerhaps it's only relevant (and perhaps very relevant) to the theoretical side of computer science. What's wrong with saying so?\n\nI never tried to argue that it wasn't practical, except when someone said that P=NP would be the death of public key crypto, which I know not to be true.\n\nI asked what the practical significance was, because I was genuinely curious!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33033, "question": "&gt; ignoring the **science** part of computer science\n\nAm I? Isn't science inherently practical, rooted in the real world?\n\n&gt; exploring the limitations of what computers can do and this is where P vs NP is very relevant\n\nIs it? What kind of thing that we think computers can't do, would be know that computers can do, if P=NP?", "aSentId": 33046, "answer": "Often but not always. Things which are applicable in real life are what most people work on and hear about but that is not everything. Just because something does not seem connected to any application, doesn't mean it never will.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33029, "question": "Why is P vs. NP considered relevant to computer science? What *practical* effect would an answer have?\n\nEdit: I wasn't trying to say that it wasn't relevant or that it had no practical effect. I just wanted to start a discussion!", "aSentId": 33048, "answer": "Whether or not an answer would have any practical effect, P vs. NP is an important (probably *the* most important, and certainly the most famous) problem it computational complexity theory, and computational complexity theory is considered an area of computer science (although it's at the intersection of mathematics and computer science).  In fact, much of theoretical computer science can just be considered a branch of mathematics (usually combinatorics) even though it's not often categorized like that.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33049, "question": "Whether or not an answer would have any practical effect, P vs. NP is an important (probably *the* most important, and certainly the most famous) problem it computational complexity theory, and computational complexity theory is considered an area of computer science (although it's at the intersection of mathematics and computer science).  In fact, much of theoretical computer science can just be considered a branch of mathematics (usually combinatorics) even though it's not often categorized like that.", "aSentId": 33050, "answer": "Theoretical Computer Science isn't really a branch of combinatorics.\n\nThere's a bunch of TCS that doesn't rely on anything combinatorial, instead using (say), group theory, or logic, or fields or other branches of mathematics. For instance crypto depends largely on algebra, many advances in modern complexity theory are being made using algebraic geometry, etc.\n\nThe foundations of the field itself lie in logic.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33051, "question": "Theoretical Computer Science isn't really a branch of combinatorics.\n\nThere's a bunch of TCS that doesn't rely on anything combinatorial, instead using (say), group theory, or logic, or fields or other branches of mathematics. For instance crypto depends largely on algebra, many advances in modern complexity theory are being made using algebraic geometry, etc.\n\nThe foundations of the field itself lie in logic.", "aSentId": 33052, "answer": "Thanks, I agree, I was going to put usually combinatorics and logic, but stuck with combinatorics.  I was probably thinking about graph algorithms or something like that.\n\nBut you're absolutely right, algebra is a big part of it (I didn't know about algebraic geometry specifically, that's interesting to here, but I have basically no knowledge of algebraic geometry personally), and I know that category theory can be relevant also.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33049, "question": "Whether or not an answer would have any practical effect, P vs. NP is an important (probably *the* most important, and certainly the most famous) problem it computational complexity theory, and computational complexity theory is considered an area of computer science (although it's at the intersection of mathematics and computer science).  In fact, much of theoretical computer science can just be considered a branch of mathematics (usually combinatorics) even though it's not often categorized like that.", "aSentId": 33054, "answer": "I think computer science extends discrete mathematics, which combinatorics is a part of. What computer science has more is that it doesn't limit the discussion to describing discrete objects, and finding proofs. But also, how problems are solved in a machinery context (using computers). ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33029, "question": "Why is P vs. NP considered relevant to computer science? What *practical* effect would an answer have?\n\nEdit: I wasn't trying to say that it wasn't relevant or that it had no practical effect. I just wanted to start a discussion!", "aSentId": 33056, "answer": "You literally just asked if the largest open problem in computer science is relevant to computer science. What makes you think computer science is supposed to be practical?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33057, "question": "You literally just asked if the largest open problem in computer science is relevant to computer science. What makes you think computer science is supposed to be practical?", "aSentId": 33058, "answer": "&gt; You literally just asked if the largest open problem in computer science is relevant to computer science.\n\nNo, I didn't.\n\nI asked *why*, not *if*. I never considered that it might not be relevant, I was interested in starting a discussing about what makes it significant.\n\n&gt; What makes you think computer science is supposed to be practical?\n\nNothing, and I didn't say it should be. I didn't ask about the theoretical significance of P=NP because it's well established and well understood. I asked about the practical effect (with emphasis on *practical*) because I thought we could have an interesting conversation about that aspect of it.\n\n----\n\nYeah, I get that you can't just say what you mean on the Internet, and expect to be understood. This thread is a great reminder of that.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33059, "question": "&gt; You literally just asked if the largest open problem in computer science is relevant to computer science.\n\nNo, I didn't.\n\nI asked *why*, not *if*. I never considered that it might not be relevant, I was interested in starting a discussing about what makes it significant.\n\n&gt; What makes you think computer science is supposed to be practical?\n\nNothing, and I didn't say it should be. I didn't ask about the theoretical significance of P=NP because it's well established and well understood. I asked about the practical effect (with emphasis on *practical*) because I thought we could have an interesting conversation about that aspect of it.\n\n----\n\nYeah, I get that you can't just say what you mean on the Internet, and expect to be understood. This thread is a great reminder of that.", "aSentId": 33060, "answer": "I might have misunderstood what you meant, but if so, I do wonder why you phrased it in such a perverse way.\n\nSuppose we were discussing special relativity. It's easy to imagine that someone might be interested in what practical applications it has. But if they asked, \"why is relativity considered relevant to physics\", you can understand why physicists would be baffled by such a question.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33061, "question": "I might have misunderstood what you meant, but if so, I do wonder why you phrased it in such a perverse way.\n\nSuppose we were discussing special relativity. It's easy to imagine that someone might be interested in what practical applications it has. But if they asked, \"why is relativity considered relevant to physics\", you can understand why physicists would be baffled by such a question.", "aSentId": 33062, "answer": "&gt; Suppose we were discussing special relativity. It's easy to imagine that someone might be interested in what practical applications it has. But if they asked, \"why is relativity considered relevant to physics\", you can understand why physicists would be baffled by such a question.\n\nI think this is a bad example, because special relativity isn't an open question in physics, it's a known result, and because it has obvious effects on the world we live in.\n\nI think a physics equivalent would be if I had posted the following in /r/physics:\n\n&gt; Why is the Riemann hypothesis considered relevant to physics? What *practical* effect would an answer have?\n\nI guess I'm saying that theoretical physics is applied mathematics, and theoretical computer science is also applied mathematics.\n\nDid you think the Riemann hypothesis example was silly? It is a bit, but why? I think it's because we know that the Riemann hypothesis has no relevance to physics, because it has no practical effect on the real world.\n\nSimilarly, it seems to me that it's very interesting to as if P=NP has any practical effect on computing in the real world.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33063, "question": "&gt; Suppose we were discussing special relativity. It's easy to imagine that someone might be interested in what practical applications it has. But if they asked, \"why is relativity considered relevant to physics\", you can understand why physicists would be baffled by such a question.\n\nI think this is a bad example, because special relativity isn't an open question in physics, it's a known result, and because it has obvious effects on the world we live in.\n\nI think a physics equivalent would be if I had posted the following in /r/physics:\n\n&gt; Why is the Riemann hypothesis considered relevant to physics? What *practical* effect would an answer have?\n\nI guess I'm saying that theoretical physics is applied mathematics, and theoretical computer science is also applied mathematics.\n\nDid you think the Riemann hypothesis example was silly? It is a bit, but why? I think it's because we know that the Riemann hypothesis has no relevance to physics, because it has no practical effect on the real world.\n\nSimilarly, it seems to me that it's very interesting to as if P=NP has any practical effect on computing in the real world.", "aSentId": 33064, "answer": "No. I chose that example on purpose. That's exactly my point. P vs NP *is* a problem in computer science, specifically in computational complexity theory.\n\nThat's why it was such an odd question to ask. If you'd asked how the Riemann hypothesis was relevant to computer science, that would have been reasonable. But P vs NP is already a problem in computer science, so its relevance to computer science is a tautology.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33066, "question": "If P == NP, finding a solution to a decision problem will have the same time complexity as checking if a given solution for the problem is correct.\n\nBasically, all of modern computing is based on the premise that P != NP.\n\nedit: decision problem* ", "aSentId": 33067, "answer": "&gt;Basically, all of modern computing is based on the premise that P != NP.\n\nThat's a wee bit of a stretch. Many programs would not be affected by the realization that P = NP at all. Security is the most common wide-reaching aspect that P = NP would affect, and can't be downplayed, but it's ahrdly \"all of modern computing\".\n\nAlso, there's the possibility that the algorithm that solves an NP problem in polynomial time on a deterministic Turing machine would simply be so inefficient that nothing changes. For example, suppose I have two algorithms whose timings can be described with something like like T(n) = 5n^2 and T(n) = 10000000n^(2). These are both O(n^(2)), but obviously the first is going to be far, far faster until n is extremely large (at which point the difference becomes negligible).\n\nSo suppose that our algorithm has a large constant like that. Then it does have a polynomial time solution (ie, it's in P), but it's not really efficient by any means and many real world applications wouldn't be changed by having a P = NP algorithm that is so inefficient (where the real world is concerned, we only care about the actual time to run the algorithm on real world data).\n\nNot to say that P = NP won't change the world, but just a reminder that it doesn't necessarily mean a groundbreaking change.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33066, "question": "If P == NP, finding a solution to a decision problem will have the same time complexity as checking if a given solution for the problem is correct.\n\nBasically, all of modern computing is based on the premise that P != NP.\n\nedit: decision problem* ", "aSentId": 33069, "answer": "But would P = NP imply that any currently intractable problem becomes tractable?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33070, "question": "But would P = NP imply that any currently intractable problem becomes tractable?", "aSentId": 33071, "answer": "No and yes.  First it is worth noting that \"tractable\" is not the same as \"feasible\" - in this context it is usually taken to mean \"solvable in polynomial time\".  Second, mileage varies on \"intractable\" - logically it should be \"not tractable\" and there are definitely problems that can never be solved in polynomial time; but often it refers to the \"seemingly attackable\" problems that make up NP (e.g. travelling salesman, Hamiltonian circuit, etc).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33072, "question": "No and yes.  First it is worth noting that \"tractable\" is not the same as \"feasible\" - in this context it is usually taken to mean \"solvable in polynomial time\".  Second, mileage varies on \"intractable\" - logically it should be \"not tractable\" and there are definitely problems that can never be solved in polynomial time; but often it refers to the \"seemingly attackable\" problems that make up NP (e.g. travelling salesman, Hamiltonian circuit, etc).", "aSentId": 33073, "answer": "&gt; \"tractable\"\n\nI was using the natural English definition. Google says: \"*(of a situation or problem) easy to deal with.*\"", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33074, "question": "&gt; \"tractable\"\n\nI was using the natural English definition. Google says: \"*(of a situation or problem) easy to deal with.*\"", "aSentId": 33075, "answer": "Yes, but it also has a technical meaning.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33076, "question": "Yes, but it also has a technical meaning.", "aSentId": 33077, "answer": "If the technical definition is \"the decision problem can be solved in polynomial time\", then I think we have to put that definition aside for the purposes of discussing the significance of P=NP.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33070, "question": "But would P = NP imply that any currently intractable problem becomes tractable?", "aSentId": 33079, "answer": "Yes, the whole NP and NP-complete class would collapse and become P. For example, modern encryption would be useless, because it depends on it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33080, "question": "Yes, the whole NP and NP-complete class would collapse and become P. For example, modern encryption would be useless, because it depends on it.", "aSentId": 33081, "answer": "No!\n\nP=NP does not imply any particular question becomes *practically* solvable.\n\nEdit: for example, maybe we prove P=NP and (assuming it's a constructive proof) we find that public-key cryptography can now be broken in O( n^1,000,000 ) time for any given key of size n. Do people turn away from public-key cryptography?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33084, "question": "All of modern cryptography is based on the assumption that P != NP", "aSentId": 33085, "answer": "I am not a fan of people saying that P=NP implies crypto is \"broken\".  A problem being in P is an indication of how it **scales**, *not*, as commonly assumed, how it **performs**.  There are polynomial time algorithms that, with sufficiently large inputs, will still take \"too long\" to be useful in practice.  Conversely, some exponential algorithms (like state-of-the-art SAT solvers) can handle inputs that are orders of magnitude greater than most (current) practical applications.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33086, "question": "I am not a fan of people saying that P=NP implies crypto is \"broken\".  A problem being in P is an indication of how it **scales**, *not*, as commonly assumed, how it **performs**.  There are polynomial time algorithms that, with sufficiently large inputs, will still take \"too long\" to be useful in practice.  Conversely, some exponential algorithms (like state-of-the-art SAT solvers) can handle inputs that are orders of magnitude greater than most (current) practical applications.", "aSentId": 33087, "answer": "The trick is:\n\nFormally proof that breaking the cipher is in NP and then make sure the constants are big enough so that the key size doesn't have to be too big.\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33089, "question": "All of modern cryptography is based on that. ", "aSentId": 33090, "answer": "Actually, very little of modern crypto is based on the separation of P and NP.  Sure, if P=NP then many crypto techniques would be solvable in polynomial time (this does not necessarily mean quickly solvable), but it is still possible for many crypto techniques to be solvable in polynomial time even if P!=NP.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33093, "question": "Advice on Switching Post Secondary Education Pathway", "aSentId": 33094, "answer": "\"do you think I will do fine in first year?\"\nSure, as there are no prereqs for the computer science or computer engineering pathways, you will be fine.\n\nFor future posts, put the question(s) at the end so we know what the concern is.  Best of luck!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33095, "question": "\"do you think I will do fine in first year?\"\nSure, as there are no prereqs for the computer science or computer engineering pathways, you will be fine.\n\nFor future posts, put the question(s) at the end so we know what the concern is.  Best of luck!", "aSentId": 33096, "answer": "Thanks for the answer, do you think it will be a struggle to learn coding without prior knowledge, since it is university? I formatted my post to reflect your advice.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33093, "question": "Advice on Switching Post Secondary Education Pathway", "aSentId": 33098, "answer": "Honestly, it's hard to say. You won't be the only one going in with zero coding experience, that's for sure. It certainly won't be a handicap. But we can't guarantee you won't struggle anyway, not everyone takes to it. \n\nIn my experience, knowing how to learn and adapt is much more important than prior knowledge. That applies to school and job-hunting. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33093, "question": "Advice on Switching Post Secondary Education Pathway", "aSentId": 33100, "answer": "Coming out of a Canadian High school and taking those computer programming courses in hs and now being in first year studying compsci at a Canadian university it helps but you can do fine without them as well. For compsci at my university they assume you have no prior programming experience so they teach you all the basics again. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33102, "question": "Computer Science vs Information Technology?", "aSentId": 33103, "answer": "Computer science is a science and information technology is a trade.\n\nThe analogy of mechanical engineer and car mechanic works well, or electrical engineer and electrician.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33102, "question": "Computer Science vs Information Technology?", "aSentId": 33105, "answer": "At the risk of sounding insensitive IT is CS with all the hard parts taken out", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33106, "question": "At the risk of sounding insensitive IT is CS with all the hard parts taken out", "aSentId": 33107, "answer": "I work as a senior software developer in the CS (computer services) department where many of the ICS (information computer services) masters students take computer science courses in addition to ics. I have my masters in CS. \n\nThe real truth is that it's really hard to apply closed system concepts (from cs) to open systems (things with more variance than 'everyone is using the same IDE').\n\nMaking improvements using my cs degree is low hanging fruit. Actually fundamentally closing the gap between theory and data is a lot harder, even if only in theory to start. \n\nThat's what real information science is about. It's about the chaotic side of systems that are hard to express mechanically or mathematically.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33108, "question": "I work as a senior software developer in the CS (computer services) department where many of the ICS (information computer services) masters students take computer science courses in addition to ics. I have my masters in CS. \n\nThe real truth is that it's really hard to apply closed system concepts (from cs) to open systems (things with more variance than 'everyone is using the same IDE').\n\nMaking improvements using my cs degree is low hanging fruit. Actually fundamentally closing the gap between theory and data is a lot harder, even if only in theory to start. \n\nThat's what real information science is about. It's about the chaotic side of systems that are hard to express mechanically or mathematically.", "aSentId": 33109, "answer": "I do agree that information science and information technology is an important distinction, at least as far as I can tell (my undergrad is CS and I'm starting a Computer and Information Sciences masters at the University of Michigan in the fall).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33106, "question": "At the risk of sounding insensitive IT is CS with all the hard parts taken out", "aSentId": 33111, "answer": "I don't know. I know a few BCompSci graduates that would fail miserably in an IT career.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33102, "question": "Computer Science vs Information Technology?", "aSentId": 33113, "answer": "Kind of like car  designer vs car mechanic . A bit harsh but generally true \u263a", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33114, "question": "Kind of like car  designer vs car mechanic . A bit harsh but generally true \u263a", "aSentId": 33115, "answer": "Although it sounds harsh, it is true, but not necessarily in a bad way.  Just a few things:\n- finding good (i.e. competent) IT staff is not as easy as it sounds, just because you can install Microsoft Office on a PC, does not mean you are an IT professional;\n- you can probably make better money in IT than CS if you are competent at what you do (just my opinion);\n- @PvtPoopyPants mentioned the electrical engineer vs electrician analogy - again, finding a competent electrician is not that easy and their rates are not cheap.\n- I see more job vacancies for IT specifically than CS.  It all comes down to economics at the end of the day.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33116, "question": "Although it sounds harsh, it is true, but not necessarily in a bad way.  Just a few things:\n- finding good (i.e. competent) IT staff is not as easy as it sounds, just because you can install Microsoft Office on a PC, does not mean you are an IT professional;\n- you can probably make better money in IT than CS if you are competent at what you do (just my opinion);\n- @PvtPoopyPants mentioned the electrical engineer vs electrician analogy - again, finding a competent electrician is not that easy and their rates are not cheap.\n- I see more job vacancies for IT specifically than CS.  It all comes down to economics at the end of the day.", "aSentId": 33117, "answer": "More money in IT than in CS? If you are good at what you are doing you will probably make a lot more money as a CSist than as an IT technician. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33121, "question": "Choosing between various Universities", "aSentId": 33122, "answer": "Your top four look good.  I have no data on Notre Dame as a CS school though.\n\nDon't worry too much about weather.  Your body will tune to just about anywhere after the first winter.\n\nRegarding a social life: It is always possible to have a social life.  However, balance is required in all things. I found that alternating heavy and light years (not semesters) was something that worked well for me. Joining a student organization (HKN, IEEE, ACM) is a good way to get a social network that is attuned to the challenges in your department.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33121, "question": "Choosing between various Universities", "aSentId": 33124, "answer": "Relating to whether you have to give up on your social life, that just depends on how smart you are and how hard your classes are going to be. You'll find out after your first year in college.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 33121, "question": "Choosing between various Universities", "aSentId": 33126, "answer": "I'm gonna jump on to op's original and ask about Texas A&amp;M San Antonio and UTSA. I'm looking to go to one of those two because it's significantly cheaper than UT Austin.", "corpus": "reddit"}]