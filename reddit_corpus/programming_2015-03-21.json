[{"docID": "t5_2fwo", "qSentId": 35025, "question": "A curated list of awesome C/C++ frameworks, libraries, resources, and shiny things.", "aSentId": 35026, "answer": "You could put POCO under frameworks. It is still regarded as network centric, but it serves well as a general purpose framework. I use it for database support, XML/JSON parsing, threading, logging, filesystem, and more. I love POCO. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35027, "question": "You could put POCO under frameworks. It is still regarded as network centric, but it serves well as a general purpose framework. I use it for database support, XML/JSON parsing, threading, logging, filesystem, and more. I love POCO. ", "aSentId": 35028, "answer": "POCO is one of the nicest libraries I've seen", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35027, "question": "You could put POCO under frameworks. It is still regarded as network centric, but it serves well as a general purpose framework. I use it for database support, XML/JSON parsing, threading, logging, filesystem, and more. I love POCO. ", "aSentId": 35030, "answer": "POCO is definitely good stuff. Lots of surface area and we'll written/designed", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35025, "question": "A curated list of awesome C/C++ frameworks, libraries, resources, and shiny things.", "aSentId": 35032, "answer": "What does the \":zap:\" next to a dozen-or-so links mean? They all seem to work fine.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35033, "question": "What does the \":zap:\" next to a dozen-or-so links mean? They all seem to work fine.", "aSentId": 35034, "answer": "I think it's to mark the popular/well known ones. I see it by big names like Boost, Qt, and SDL. As for *why* it's there, Github has some text patterns it can replace with emoticons, and I'd guess it was one of those, except that they don't render on Github either. See the main repository page: https://github.com/fffaraz/awesome-cpp/", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35025, "question": "A curated list of awesome C/C++ frameworks, libraries, resources, and shiny things.", "aSentId": 35036, "answer": "Clang isn't \"Developed by Apple.\", and libc++ should probably be on there (and perhaps LLVM itself). You're also missing the LLVM coding style. Cap'n Proto probably fits better under Serialization, although it does IPC too, so maybe both? And no PostgreSQL?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35039, "question": "Name inspired on https://notabug.org/koz.ross/awesome-c ?", "aSentId": 35040, "answer": "Sort of, not really.\n\nThey share a common ancestor in that people have started calling these collections \"awesome-X\" lists. See e.g. [the meta awesome-awesomeness](https://github.com/bayandin/awesome-awesomeness) or [awesome - a curalted list of awesome lists](https://github.com/sindresorhus/awesome).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35039, "question": "Name inspired on https://notabug.org/koz.ross/awesome-c ?", "aSentId": 35042, "answer": "I thought it came from [awesome Rust](https://github.com/kud1ing/awesome-rust), but that's also clearly a latecomer..", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35044, "question": "I was happy to see that ROOT is not on this list.\n\nedit: damnit, its right there under frameworks.", "aSentId": 35045, "answer": "Not familiar with ROOT - why were you happy?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35047, "question": "I only see a blank page. You might want to simply your website design so it works for everyone.", "aSentId": 35048, "answer": "Yeah I got a blank page with NoScript... looks like the entire page is rendered from JS for some reason.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35049, "question": "Yeah I got a blank page with NoScript... looks like the entire page is rendered from JS for some reason.", "aSentId": 35050, "answer": "It's not rendered with Javascript, but it pulls in data from Github and seems to pass it through a Markdown parser.\n\nhttps://github.com/fffaraz/awesome-cpp/blob/master/README.md\n\nNot sure why he doesn't just link to Github as the resource, but maybe he plans to do more with the site.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35051, "question": "It's not rendered with Javascript, but it pulls in data from Github and seems to pass it through a Markdown parser.\n\nhttps://github.com/fffaraz/awesome-cpp/blob/master/README.md\n\nNot sure why he doesn't just link to Github as the resource, but maybe he plans to do more with the site.", "aSentId": 35052, "answer": "&gt;seems to pass it through a Markdown parser\n\ni.e. rendered with JS\n\nYeah it seems pretty pointless, maybe he just doesn't want to link straight to a github page.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35053, "question": "&gt;seems to pass it through a Markdown parser\n\ni.e. rendered with JS\n\nYeah it seems pretty pointless, maybe he just doesn't want to link straight to a github page.", "aSentId": 35054, "answer": "Well he could have just use Jekyll, or some other kind of offline rendering.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35058, "question": "Brilliant presentation on the Ackermann function", "aSentId": 35059, "answer": "That's a fun video.  \n\nA few comments:\n\n* Wow, K&amp;R-style C. I haven't seen that in a good while. \"Well-nigh on a quarter century, I'd reckon.\"\n\n* Hmmm, non-indented code. Unfortunately, I *have* seen that recently.\n\n* There will not be a \"Big Crunch.\" Quite the opposite, in fact. They handed out a Nobel Prize a few years ago to the astronomers who showed just how massively \"not a big crunch\" the universe is.  \n(as a matter of fact: \"You're tearing me apart, Lisa!\" &lt;-- mandatory reddit karma pandering quip.)\n\n* As others pointed out, the \"recursion\" can be done with for-loops and the appropriate data structures.\n\n* If he knows he'll be dealing with recursion of depth 2^65000 then he obviously needs to worry about overflow in his stack pointer, too, and not just in the result register.\n\n* I think (trying to remember what he said) he got his #particles in the observable universe and #seconds since the Big Bang wrong. it's about 4 x 10^17 seconds since t=0. I.e., about 2^60 or so.\n\nDespite my nitpicks, I love these Computerphile/Numberphile videos. Good enthusiasm. Good presentation. Excellent topics to spread to a popular audience. (Yes, I got very tired of explaining why -1/12 does **not** equal infinity a few months ago, but hey! it got people talking about Zeta functions, so it's a small price to pay!)\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35060, "question": "That's a fun video.  \n\nA few comments:\n\n* Wow, K&amp;R-style C. I haven't seen that in a good while. \"Well-nigh on a quarter century, I'd reckon.\"\n\n* Hmmm, non-indented code. Unfortunately, I *have* seen that recently.\n\n* There will not be a \"Big Crunch.\" Quite the opposite, in fact. They handed out a Nobel Prize a few years ago to the astronomers who showed just how massively \"not a big crunch\" the universe is.  \n(as a matter of fact: \"You're tearing me apart, Lisa!\" &lt;-- mandatory reddit karma pandering quip.)\n\n* As others pointed out, the \"recursion\" can be done with for-loops and the appropriate data structures.\n\n* If he knows he'll be dealing with recursion of depth 2^65000 then he obviously needs to worry about overflow in his stack pointer, too, and not just in the result register.\n\n* I think (trying to remember what he said) he got his #particles in the observable universe and #seconds since the Big Bang wrong. it's about 4 x 10^17 seconds since t=0. I.e., about 2^60 or so.\n\nDespite my nitpicks, I love these Computerphile/Numberphile videos. Good enthusiasm. Good presentation. Excellent topics to spread to a popular audience. (Yes, I got very tired of explaining why -1/12 does **not** equal infinity a few months ago, but hey! it got people talking about Zeta functions, so it's a small price to pay!)\n\n", "aSentId": 35061, "answer": "Paging /u/JeffDujon, as I'm sure he'll be happy to read this feedback.  Or I guess I could tweet it at Grey and point out that I'm not about to board an airplane...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35058, "question": "Brilliant presentation on the Ackermann function", "aSentId": 35063, "answer": "In 160 different programming languages on [Rosetta Code](http://rosettacode.org/wiki/Ackermann_function)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35064, "question": "In 160 different programming languages on [Rosetta Code](http://rosettacode.org/wiki/Ackermann_function)", "aSentId": 35065, "answer": "Ah, but they don't have the truly masterful K&amp;R-style C.\n\nYou'd be completely screwed if you found yourself on a computer with only a C compiler from 1988 and relied on Rosetta.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35058, "question": "Brilliant presentation on the Ackermann function", "aSentId": 35067, "answer": "I just coded this up, and Ack(4, 1), which took the presenter's sytem 3 minutes to calculate, took less than six seconds on my 5-year-old Mac. Funny how computers progress. :)\n\n    Ack( 0, 0 ) = 1 (2e-07 seconds)\n    Ack( 0, 1 ) = 2 (3.9e-08 seconds)\n    Ack( 0, 2 ) = 3 (2.7e-08 seconds)\n    Ack( 0, 3 ) = 4 (2.8e-08 seconds)\n    Ack( 0, 4 ) = 5 (2.6e-08 seconds)\n    Ack( 0, 5 ) = 6 (2.4e-08 seconds)\n    Ack( 1, 0 ) = 2 (5.1e-08 seconds)\n    Ack( 1, 1 ) = 3 (4e-08 seconds)\n    Ack( 1, 2 ) = 4 (5e-08 seconds)\n    Ack( 1, 3 ) = 5 (4.8e-08 seconds)\n    Ack( 1, 4 ) = 6 (4.9e-08 seconds)\n    Ack( 1, 5 ) = 7 (6.1e-08 seconds)\n    Ack( 2, 0 ) = 3 (5.3e-08 seconds)\n    Ack( 2, 1 ) = 5 (9.1e-08 seconds)\n    Ack( 2, 2 ) = 7 (1.42e-07 seconds)\n    Ack( 2, 3 ) = 9 (1.58e-07 seconds)\n    Ack( 2, 4 ) = 11 (2.26e-07 seconds)\n    Ack( 2, 5 ) = 13 (2.78e-07 seconds)\n    Ack( 3, 0 ) = 5 (7.1e-08 seconds)\n    Ack( 3, 1 ) = 13 (3.61e-07 seconds)\n    Ack( 3, 2 ) = 29 (1.292e-06 seconds)\n    Ack( 3, 3 ) = 61 (4.555e-06 seconds)\n    Ack( 3, 4 ) = 125 (1.657e-05 seconds)\n    Ack( 3, 5 ) = 253 (6.2876e-05 seconds)\n    Ack( 4, 0 ) = 13 (2.78e-07 seconds)\n    Ack( 4, 1 ) = 65533 (5.27731 seconds)\n\nC++11 code:\n\n    //\n    //  main.cpp\n    //  Ackermann\n    //\n\n    #include &lt;iostream&gt;\n    #include &lt;cstdint&gt;\n    #include &lt;chrono&gt;\n\n    uint64_t Ack( uint64_t m, uint64_t n )\n    {\n        return (m == 0)\n                   ? n + 1\n                   : (n == 0)\n                         ? Ack( m - 1, 1 )\n                         : Ack( m - 1, Ack( m, n - 1 ) );\n    }\n\n    int main(int argc, const char * argv[])\n    {\n        using hires_clock_t = std::chrono::high_resolution_clock;\n        using timepoint_t   = std::chrono::time_point&lt; hires_clock_t &gt;;\n        using duration_t    = std::chrono::duration&lt; double &gt;;\n        \n        for( uint64_t m = 0; m &lt; 6; m++ )\n            for( uint64_t n = 0; n &lt; 6; n++ )\n            {\n                // Get Ack(m, n) along with timing info\n                const timepoint_t start  = hires_clock_t::now();\n                const uint64_t    answer = Ack(m, n);\n                const timepoint_t end    = hires_clock_t::now();\n                \n                \n                // Display output\n                const duration_t duration = end - start;\n                \n                std::cout &lt;&lt; \"Ack( \" &lt;&lt; m &lt;&lt; \", \" &lt;&lt; n &lt;&lt; \" ) = \" &lt;&lt; answer &lt;&lt; \" (\" &lt;&lt; duration.count() &lt;&lt; \" seconds)\\n\";\n            }\n        \n        return 0;\n    }\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35068, "question": "I just coded this up, and Ack(4, 1), which took the presenter's sytem 3 minutes to calculate, took less than six seconds on my 5-year-old Mac. Funny how computers progress. :)\n\n    Ack( 0, 0 ) = 1 (2e-07 seconds)\n    Ack( 0, 1 ) = 2 (3.9e-08 seconds)\n    Ack( 0, 2 ) = 3 (2.7e-08 seconds)\n    Ack( 0, 3 ) = 4 (2.8e-08 seconds)\n    Ack( 0, 4 ) = 5 (2.6e-08 seconds)\n    Ack( 0, 5 ) = 6 (2.4e-08 seconds)\n    Ack( 1, 0 ) = 2 (5.1e-08 seconds)\n    Ack( 1, 1 ) = 3 (4e-08 seconds)\n    Ack( 1, 2 ) = 4 (5e-08 seconds)\n    Ack( 1, 3 ) = 5 (4.8e-08 seconds)\n    Ack( 1, 4 ) = 6 (4.9e-08 seconds)\n    Ack( 1, 5 ) = 7 (6.1e-08 seconds)\n    Ack( 2, 0 ) = 3 (5.3e-08 seconds)\n    Ack( 2, 1 ) = 5 (9.1e-08 seconds)\n    Ack( 2, 2 ) = 7 (1.42e-07 seconds)\n    Ack( 2, 3 ) = 9 (1.58e-07 seconds)\n    Ack( 2, 4 ) = 11 (2.26e-07 seconds)\n    Ack( 2, 5 ) = 13 (2.78e-07 seconds)\n    Ack( 3, 0 ) = 5 (7.1e-08 seconds)\n    Ack( 3, 1 ) = 13 (3.61e-07 seconds)\n    Ack( 3, 2 ) = 29 (1.292e-06 seconds)\n    Ack( 3, 3 ) = 61 (4.555e-06 seconds)\n    Ack( 3, 4 ) = 125 (1.657e-05 seconds)\n    Ack( 3, 5 ) = 253 (6.2876e-05 seconds)\n    Ack( 4, 0 ) = 13 (2.78e-07 seconds)\n    Ack( 4, 1 ) = 65533 (5.27731 seconds)\n\nC++11 code:\n\n    //\n    //  main.cpp\n    //  Ackermann\n    //\n\n    #include &lt;iostream&gt;\n    #include &lt;cstdint&gt;\n    #include &lt;chrono&gt;\n\n    uint64_t Ack( uint64_t m, uint64_t n )\n    {\n        return (m == 0)\n                   ? n + 1\n                   : (n == 0)\n                         ? Ack( m - 1, 1 )\n                         : Ack( m - 1, Ack( m, n - 1 ) );\n    }\n\n    int main(int argc, const char * argv[])\n    {\n        using hires_clock_t = std::chrono::high_resolution_clock;\n        using timepoint_t   = std::chrono::time_point&lt; hires_clock_t &gt;;\n        using duration_t    = std::chrono::duration&lt; double &gt;;\n        \n        for( uint64_t m = 0; m &lt; 6; m++ )\n            for( uint64_t n = 0; n &lt; 6; n++ )\n            {\n                // Get Ack(m, n) along with timing info\n                const timepoint_t start  = hires_clock_t::now();\n                const uint64_t    answer = Ack(m, n);\n                const timepoint_t end    = hires_clock_t::now();\n                \n                \n                // Display output\n                const duration_t duration = end - start;\n                \n                std::cout &lt;&lt; \"Ack( \" &lt;&lt; m &lt;&lt; \", \" &lt;&lt; n &lt;&lt; \" ) = \" &lt;&lt; answer &lt;&lt; \" (\" &lt;&lt; duration.count() &lt;&lt; \" seconds)\\n\";\n            }\n        \n        return 0;\n    }\n", "aSentId": 35069, "answer": "In J,\n\n        Ack=. 3 -~ [ ({&amp;(2 4$'&gt;:  2x&amp;+') ::(,&amp;'&amp;1'&amp;'2x&amp;*'@:(-&amp;2))\"0@:[ 128!:2 ]) 3 + ]\n\ntiming both 4 Ack 1 and 4 Ack 2 (1.63 seconds to do both) without \n\n      timespacex '4 Ack 1 2'\n1.63042 211712\n\n       timespacex '4 Ack 1'\n2.784e_5 7296\n\n4 Ack 1 timing can be cut in nearly 1/3 if using simple precision numbers, as 4 Ack 2 is 19729 digits", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35070, "question": "In J,\n\n        Ack=. 3 -~ [ ({&amp;(2 4$'&gt;:  2x&amp;+') ::(,&amp;'&amp;1'&amp;'2x&amp;*'@:(-&amp;2))\"0@:[ 128!:2 ]) 3 + ]\n\ntiming both 4 Ack 1 and 4 Ack 2 (1.63 seconds to do both) without \n\n      timespacex '4 Ack 1 2'\n1.63042 211712\n\n       timespacex '4 Ack 1'\n2.784e_5 7296\n\n4 Ack 1 timing can be cut in nearly 1/3 if using simple precision numbers, as 4 Ack 2 is 19729 digits", "aSentId": 35071, "answer": "Oh sure, use a *math* language to do math. Pff. :P", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35072, "question": "Oh sure, use a *math* language to do math. Pff. :P", "aSentId": 35073, "answer": "Okay, I downloaded SPSS, now what do I do?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35074, "question": "Okay, I downloaded SPSS, now what do I do?", "aSentId": 35075, "answer": "I dunno, learn statistical analysis? That's what *I'd* do if I was actually smart instead of having to fake it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35076, "question": "I dunno, learn statistical analysis? That's what *I'd* do if I was actually smart instead of having to fake it.", "aSentId": 35077, "answer": "Okay, I copy and pasted your code into SPSS and ran a regression on it. Everything broke. wat do?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35078, "question": "Okay, I copy and pasted your code into SPSS and ran a regression on it. Everything broke. wat do?", "aSentId": 35079, "answer": "Call NASA. Tell 'em it's an emergency.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35080, "question": "Call NASA. Tell 'em it's an emergency.", "aSentId": 35081, "answer": "Hell no, I'm like 95% sure I just broke math, those guys love math, they'd be really rude.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35068, "question": "I just coded this up, and Ack(4, 1), which took the presenter's sytem 3 minutes to calculate, took less than six seconds on my 5-year-old Mac. Funny how computers progress. :)\n\n    Ack( 0, 0 ) = 1 (2e-07 seconds)\n    Ack( 0, 1 ) = 2 (3.9e-08 seconds)\n    Ack( 0, 2 ) = 3 (2.7e-08 seconds)\n    Ack( 0, 3 ) = 4 (2.8e-08 seconds)\n    Ack( 0, 4 ) = 5 (2.6e-08 seconds)\n    Ack( 0, 5 ) = 6 (2.4e-08 seconds)\n    Ack( 1, 0 ) = 2 (5.1e-08 seconds)\n    Ack( 1, 1 ) = 3 (4e-08 seconds)\n    Ack( 1, 2 ) = 4 (5e-08 seconds)\n    Ack( 1, 3 ) = 5 (4.8e-08 seconds)\n    Ack( 1, 4 ) = 6 (4.9e-08 seconds)\n    Ack( 1, 5 ) = 7 (6.1e-08 seconds)\n    Ack( 2, 0 ) = 3 (5.3e-08 seconds)\n    Ack( 2, 1 ) = 5 (9.1e-08 seconds)\n    Ack( 2, 2 ) = 7 (1.42e-07 seconds)\n    Ack( 2, 3 ) = 9 (1.58e-07 seconds)\n    Ack( 2, 4 ) = 11 (2.26e-07 seconds)\n    Ack( 2, 5 ) = 13 (2.78e-07 seconds)\n    Ack( 3, 0 ) = 5 (7.1e-08 seconds)\n    Ack( 3, 1 ) = 13 (3.61e-07 seconds)\n    Ack( 3, 2 ) = 29 (1.292e-06 seconds)\n    Ack( 3, 3 ) = 61 (4.555e-06 seconds)\n    Ack( 3, 4 ) = 125 (1.657e-05 seconds)\n    Ack( 3, 5 ) = 253 (6.2876e-05 seconds)\n    Ack( 4, 0 ) = 13 (2.78e-07 seconds)\n    Ack( 4, 1 ) = 65533 (5.27731 seconds)\n\nC++11 code:\n\n    //\n    //  main.cpp\n    //  Ackermann\n    //\n\n    #include &lt;iostream&gt;\n    #include &lt;cstdint&gt;\n    #include &lt;chrono&gt;\n\n    uint64_t Ack( uint64_t m, uint64_t n )\n    {\n        return (m == 0)\n                   ? n + 1\n                   : (n == 0)\n                         ? Ack( m - 1, 1 )\n                         : Ack( m - 1, Ack( m, n - 1 ) );\n    }\n\n    int main(int argc, const char * argv[])\n    {\n        using hires_clock_t = std::chrono::high_resolution_clock;\n        using timepoint_t   = std::chrono::time_point&lt; hires_clock_t &gt;;\n        using duration_t    = std::chrono::duration&lt; double &gt;;\n        \n        for( uint64_t m = 0; m &lt; 6; m++ )\n            for( uint64_t n = 0; n &lt; 6; n++ )\n            {\n                // Get Ack(m, n) along with timing info\n                const timepoint_t start  = hires_clock_t::now();\n                const uint64_t    answer = Ack(m, n);\n                const timepoint_t end    = hires_clock_t::now();\n                \n                \n                // Display output\n                const duration_t duration = end - start;\n                \n                std::cout &lt;&lt; \"Ack( \" &lt;&lt; m &lt;&lt; \", \" &lt;&lt; n &lt;&lt; \" ) = \" &lt;&lt; answer &lt;&lt; \" (\" &lt;&lt; duration.count() &lt;&lt; \" seconds)\\n\";\n            }\n        \n        return 0;\n    }\n", "aSentId": 35083, "answer": "I get stack overflow when I run that code :\\", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35084, "question": "I get stack overflow when I run that code :\\", "aSentId": 35085, "answer": "That'll happen after Ack(4, 1) due to the mind-bogglingly huge recursion that happens on Ack(4, 2).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35086, "question": "That'll happen after Ack(4, 1) due to the mind-bogglingly huge recursion that happens on Ack(4, 2).", "aSentId": 35087, "answer": "I don't get to Ack(4,1) thou. I get stack overflow after Ack (4,0).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35088, "question": "I don't get to Ack(4,1) thou. I get stack overflow after Ack (4,0).", "aSentId": 35089, "answer": "Odd. What OS and compiler are you using? Which processor? 32/64 bit?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35090, "question": "Odd. What OS and compiler are you using? Which processor? 32/64 bit?", "aSentId": 35091, "answer": "I'm using Visual studio 2013 on Windows 8.1 with an i5-2320 and I tried both 32 and 64 bit.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35092, "question": "I'm using Visual studio 2013 on Windows 8.1 with an i5-2320 and I tried both 32 and 64 bit.", "aSentId": 35093, "answer": "Windows must set up the stack differently than OS X. Not really a huge deal since you'd never use this insane level of recursion normally. :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35094, "question": "Windows must set up the stack differently than OS X. Not really a huge deal since you'd never use this insane level of recursion normally. :)", "aSentId": 35095, "answer": "Yeah I think it has to do with the compiler", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35068, "question": "I just coded this up, and Ack(4, 1), which took the presenter's sytem 3 minutes to calculate, took less than six seconds on my 5-year-old Mac. Funny how computers progress. :)\n\n    Ack( 0, 0 ) = 1 (2e-07 seconds)\n    Ack( 0, 1 ) = 2 (3.9e-08 seconds)\n    Ack( 0, 2 ) = 3 (2.7e-08 seconds)\n    Ack( 0, 3 ) = 4 (2.8e-08 seconds)\n    Ack( 0, 4 ) = 5 (2.6e-08 seconds)\n    Ack( 0, 5 ) = 6 (2.4e-08 seconds)\n    Ack( 1, 0 ) = 2 (5.1e-08 seconds)\n    Ack( 1, 1 ) = 3 (4e-08 seconds)\n    Ack( 1, 2 ) = 4 (5e-08 seconds)\n    Ack( 1, 3 ) = 5 (4.8e-08 seconds)\n    Ack( 1, 4 ) = 6 (4.9e-08 seconds)\n    Ack( 1, 5 ) = 7 (6.1e-08 seconds)\n    Ack( 2, 0 ) = 3 (5.3e-08 seconds)\n    Ack( 2, 1 ) = 5 (9.1e-08 seconds)\n    Ack( 2, 2 ) = 7 (1.42e-07 seconds)\n    Ack( 2, 3 ) = 9 (1.58e-07 seconds)\n    Ack( 2, 4 ) = 11 (2.26e-07 seconds)\n    Ack( 2, 5 ) = 13 (2.78e-07 seconds)\n    Ack( 3, 0 ) = 5 (7.1e-08 seconds)\n    Ack( 3, 1 ) = 13 (3.61e-07 seconds)\n    Ack( 3, 2 ) = 29 (1.292e-06 seconds)\n    Ack( 3, 3 ) = 61 (4.555e-06 seconds)\n    Ack( 3, 4 ) = 125 (1.657e-05 seconds)\n    Ack( 3, 5 ) = 253 (6.2876e-05 seconds)\n    Ack( 4, 0 ) = 13 (2.78e-07 seconds)\n    Ack( 4, 1 ) = 65533 (5.27731 seconds)\n\nC++11 code:\n\n    //\n    //  main.cpp\n    //  Ackermann\n    //\n\n    #include &lt;iostream&gt;\n    #include &lt;cstdint&gt;\n    #include &lt;chrono&gt;\n\n    uint64_t Ack( uint64_t m, uint64_t n )\n    {\n        return (m == 0)\n                   ? n + 1\n                   : (n == 0)\n                         ? Ack( m - 1, 1 )\n                         : Ack( m - 1, Ack( m, n - 1 ) );\n    }\n\n    int main(int argc, const char * argv[])\n    {\n        using hires_clock_t = std::chrono::high_resolution_clock;\n        using timepoint_t   = std::chrono::time_point&lt; hires_clock_t &gt;;\n        using duration_t    = std::chrono::duration&lt; double &gt;;\n        \n        for( uint64_t m = 0; m &lt; 6; m++ )\n            for( uint64_t n = 0; n &lt; 6; n++ )\n            {\n                // Get Ack(m, n) along with timing info\n                const timepoint_t start  = hires_clock_t::now();\n                const uint64_t    answer = Ack(m, n);\n                const timepoint_t end    = hires_clock_t::now();\n                \n                \n                // Display output\n                const duration_t duration = end - start;\n                \n                std::cout &lt;&lt; \"Ack( \" &lt;&lt; m &lt;&lt; \", \" &lt;&lt; n &lt;&lt; \" ) = \" &lt;&lt; answer &lt;&lt; \" (\" &lt;&lt; duration.count() &lt;&lt; \" seconds)\\n\";\n            }\n        \n        return 0;\n    }\n", "aSentId": 35097, "answer": "Disappointed to not see a single auto in what claims to be C++11 code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35098, "question": "Disappointed to not see a single auto in what claims to be C++11 code.", "aSentId": 35099, "answer": "Just because one *can* do a thing does not mean one *should*.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35098, "question": "Disappointed to not see a single auto in what claims to be C++11 code.", "aSentId": 35101, "answer": "It uses K&amp;R function signatures, not exactly C++11 level...\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35103, "question": "The video is inaccurate.  Anything that can be implemented with recursion, can also be implemented with for loops and an explicitly maintained stack data structure for the function 'stack frames'.\nIf you replace his statement with 'not computable with for-loops and a fixed amount of space' (e.g. so you can't use a growable stack data structure) then it makes more sense", "aSentId": 35104, "answer": "There are a few problems with his terminology, but what he means by \"for loops\" is really \"bounded for loops\".\n\nThe primitive recursive functions are exactly those which can be computed using for loops of the form:\n\nfor(int i = 0; i &lt; N; i++) {\n\nWhere N is based on the input.\n\nThe Ackermann function can be implemented iteratively, but at least one of the loops will have to check some condition in memory, rather than just counting up to some predetermined number. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35105, "question": "There are a few problems with his terminology, but what he means by \"for loops\" is really \"bounded for loops\".\n\nThe primitive recursive functions are exactly those which can be computed using for loops of the form:\n\nfor(int i = 0; i &lt; N; i++) {\n\nWhere N is based on the input.\n\nThe Ackermann function can be implemented iteratively, but at least one of the loops will have to check some condition in memory, rather than just counting up to some predetermined number. ", "aSentId": 35106, "answer": "That makes sense :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35105, "question": "There are a few problems with his terminology, but what he means by \"for loops\" is really \"bounded for loops\".\n\nThe primitive recursive functions are exactly those which can be computed using for loops of the form:\n\nfor(int i = 0; i &lt; N; i++) {\n\nWhere N is based on the input.\n\nThe Ackermann function can be implemented iteratively, but at least one of the loops will have to check some condition in memory, rather than just counting up to some predetermined number. ", "aSentId": 35108, "answer": "&gt; but at least one of the loops will have to check some condition in memory\n\nI'm going to call that \"isomorphically-recursive\" and be on my way...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35103, "question": "The video is inaccurate.  Anything that can be implemented with recursion, can also be implemented with for loops and an explicitly maintained stack data structure for the function 'stack frames'.\nIf you replace his statement with 'not computable with for-loops and a fixed amount of space' (e.g. so you can't use a growable stack data structure) then it makes more sense", "aSentId": 35110, "answer": "That is still recursion though, just not taking advantage of the built-in stack doesn't change that.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35111, "question": "That is still recursion though, just not taking advantage of the built-in stack doesn't change that.", "aSentId": 35112, "answer": "Well, regardless if you consider that recursion or not (and I wouldn't), it can still be done with for loops.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35111, "question": "That is still recursion though, just not taking advantage of the built-in stack doesn't change that.", "aSentId": 35114, "answer": "I wouldn't call it recursive if the function isn't recursive.\n\nIts just a loop with some data storage really.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35117, "question": "Too bad he didn't mention memoization and its benefits, which are particularly evident with the Ackerman function.\n\n", "aSentId": 35118, "answer": "It wouldn't matter, ack(4,2) is just very large. Computing anything above that might be too much trouble to bother with.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35120, "question": "Are pointers and arrays equivalent in C? (2009)", "aSentId": 35121, "answer": "One caveat: the assemble code generation is compiler dependent and NOT a characteristic of C. A better compiler would generate the identical code for array[8] and pointer[8]", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35122, "question": "One caveat: the assemble code generation is compiler dependent and NOT a characteristic of C. A better compiler would generate the identical code for array[8] and pointer[8]", "aSentId": 35123, "answer": "Yeah... this is a pretty stupid article overall. He essentially just talks about the distinction between pointers and const pointers (and a good compiler will full-program optimization could've been able to infer the constness anyway).\n\nThere *is* actually one very practical difference between arrays and pointers that he doesn't touch on at all: sizeof(pointer_var) is always equal to sizeof(void \\*), whereas sizeof(array_var) is actually equal to the size of the whole array *iff* it is statically known at that point.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35124, "question": "Yeah... this is a pretty stupid article overall. He essentially just talks about the distinction between pointers and const pointers (and a good compiler will full-program optimization could've been able to infer the constness anyway).\n\nThere *is* actually one very practical difference between arrays and pointers that he doesn't touch on at all: sizeof(pointer_var) is always equal to sizeof(void \\*), whereas sizeof(array_var) is actually equal to the size of the whole array *iff* it is statically known at that point.", "aSentId": 35125, "answer": "&gt; and a good compiler will full-program optimization could've been able to infer the constness anyway\n\nAre you sure that isn't *impossible* due to aliasing? In C const barely means anything from the compiler's perspective, since const variables can be aliased. It's mostly used to make sure you don't accidentally explicitly assign a value to the wrong variable, and that happens before any compilation begins.\n\nPlus there's that whole thing with free() invalidating the contents pointed to by a const pointer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35126, "question": "&gt; and a good compiler will full-program optimization could've been able to infer the constness anyway\n\nAre you sure that isn't *impossible* due to aliasing? In C const barely means anything from the compiler's perspective, since const variables can be aliased. It's mostly used to make sure you don't accidentally explicitly assign a value to the wrong variable, and that happens before any compilation begins.\n\nPlus there's that whole thing with free() invalidating the contents pointed to by a const pointer.", "aSentId": 35127, "answer": "This is about the constness of the pointer variable itself, not the memory it points to. Aliasing doesn't play a role in this case.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35128, "question": "This is about the constness of the pointer variable itself, not the memory it points to. Aliasing doesn't play a role in this case.", "aSentId": 35129, "answer": "It does when you take a reference of it. It's legal to reference any section of memory that isn't declared const, including pointers declared on the stack. There are probably some simple cases where compilers can be reasonably certain there's no aliasing, but a full solution would be impossible.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35126, "question": "&gt; and a good compiler will full-program optimization could've been able to infer the constness anyway\n\nAre you sure that isn't *impossible* due to aliasing? In C const barely means anything from the compiler's perspective, since const variables can be aliased. It's mostly used to make sure you don't accidentally explicitly assign a value to the wrong variable, and that happens before any compilation begins.\n\nPlus there's that whole thing with free() invalidating the contents pointed to by a const pointer.", "aSentId": 35131, "answer": "What about the strict aliasing model?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35132, "question": "What about the strict aliasing model?", "aSentId": 35133, "answer": "Different types of aliasing.  Objects may not alias by type, but they can alias by value.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35132, "question": "What about the strict aliasing model?", "aSentId": 35135, "answer": "Doesn't that only apply to casting an existing pointer to a different type? It doesn't prevent you from taking a reference of an arbitrary variable.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35136, "question": "Doesn't that only apply to casting an existing pointer to a different type? It doesn't prevent you from taking a reference of an arbitrary variable.", "aSentId": 35137, "answer": "The compiler knows if a variable had a reference taken or not (it only needs to look for the `&amp;` operator). Any other access to the variable that the compiler doesn't know about is UB, unless the variable is `volatile`.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35124, "question": "Yeah... this is a pretty stupid article overall. He essentially just talks about the distinction between pointers and const pointers (and a good compiler will full-program optimization could've been able to infer the constness anyway).\n\nThere *is* actually one very practical difference between arrays and pointers that he doesn't touch on at all: sizeof(pointer_var) is always equal to sizeof(void \\*), whereas sizeof(array_var) is actually equal to the size of the whole array *iff* it is statically known at that point.", "aSentId": 35139, "answer": "There is no requirement that sizeof(T\\*) is the same size as sizeof(void\\*) and in many cases it isn't the same size, for example member function pointers, segmented memory models, or Harvard architectures.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35140, "question": "There is no requirement that sizeof(T\\*) is the same size as sizeof(void\\*) and in many cases it isn't the same size, for example member function pointers, segmented memory models, or Harvard architectures.", "aSentId": 35141, "answer": "True for different memory models, but C doesn't have member pointer functions.\n\nAlso, an implementation in which machine addresses point to words rather than bytes might make `void*` bigger than `int*`; an `int*` could point to a word, but a `void*` or `char*` would need additional information to specify the offset within the word.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35124, "question": "Yeah... this is a pretty stupid article overall. He essentially just talks about the distinction between pointers and const pointers (and a good compiler will full-program optimization could've been able to infer the constness anyway).\n\nThere *is* actually one very practical difference between arrays and pointers that he doesn't touch on at all: sizeof(pointer_var) is always equal to sizeof(void \\*), whereas sizeof(array_var) is actually equal to the size of the whole array *iff* it is statically known at that point.", "aSentId": 35143, "answer": "Actually, sizeof(void*) may be bigger than the size of other pointer types. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35122, "question": "One caveat: the assemble code generation is compiler dependent and NOT a characteristic of C. A better compiler would generate the identical code for array[8] and pointer[8]", "aSentId": 35146, "answer": "If the array and pointer are declared within the function (or if the pointer is declared as a const pointer to char) than the compiler might be able to generate the same assembly for that access but because they are at global scope the code generated for the pointer access has to pessimistically assume that it could have been changed to point elsewhere.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35147, "question": "If the array and pointer are declared within the function (or if the pointer is declared as a const pointer to char) than the compiler might be able to generate the same assembly for that access but because they are at global scope the code generated for the pointer access has to pessimistically assume that it could have been changed to point elsewhere.", "aSentId": 35148, "answer": "&gt; the code generated for the pointer access has to pessimistically assume that it could have been changed to point elsewhere.\n\nIt only has to assume that if it's exposed externally or has an address taken that's then used in a way it can understand. It will trivially identify it as a constant in most cases. It will figure this out even if it *is* non-static as long as you're using link-time optimization (and in a library, `-fvisibility=hidden` with explicit exports as everyone should already be doing - if it's exported then of course it can't do it).\n\nOf course, you could can make the pointer itself constant which is a meaningful guarantee, i.e. `const char *const`. It will really almost always figure this out itself as long as your project has release builds set up well.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35147, "question": "If the array and pointer are declared within the function (or if the pointer is declared as a const pointer to char) than the compiler might be able to generate the same assembly for that access but because they are at global scope the code generated for the pointer access has to pessimistically assume that it could have been changed to point elsewhere.", "aSentId": 35150, "answer": "There is a lot of assumptions about whether the compiler can refer to the start of the array as a constant, rather than load a reference to it in a register. If its the latter then loading the current pointer value for offset instruction and access to array are basically the same. Also instruction set matters a lot, Intel is not the only world for C out there. Depends on whether we are talking CISC or RISC, if instruction set has constant offset address instruction or not, etc, etc...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35147, "question": "If the array and pointer are declared within the function (or if the pointer is declared as a const pointer to char) than the compiler might be able to generate the same assembly for that access but because they are at global scope the code generated for the pointer access has to pessimistically assume that it could have been changed to point elsewhere.", "aSentId": 35152, "answer": "&gt; declared within the function (or if the pointer is declared as a const pointer to char) \n\nThird option: global, but with a `static` keyword. The compiler then at least has the opportunity to infer that it is effectively const if you never change its value.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35122, "question": "One caveat: the assemble code generation is compiler dependent and NOT a characteristic of C. A better compiler would generate the identical code for array[8] and pointer[8]", "aSentId": 35154, "answer": "Especially if the pointer is declared `const`, which it isn't in the example.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35157, "question": "Not true. You can take advantages of efficiencies using a hardcoded array. A really good compiler that decides to inline a function\n\n    char array[] = \"array\";\n\n    _inline void terminate_string(char *a)\n    {\n       a[0] = 0;\n    }\n\n    char *p = array;\n    terminate_string(p); \n\nA good compiler will use array like instructions on the invocation of terminate_string, to get less instructions and more speed.  \n\n\"A foolish consistency is the hobgoblin of little minds\" - Ralph Waldo Emerson.\n", "aSentId": 35158, "answer": "I am missing something? Array vs pointer has little do with the inlining ability of compilers. Why do you believe the compiler would not inline same code with a \"hard coded pointer?\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35159, "question": "I am missing something? Array vs pointer has little do with the inlining ability of compilers. Why do you believe the compiler would not inline same code with a \"hard coded pointer?\"", "aSentId": 35160, "answer": "If the compiler doesn't know what is in the pointer it can't be optimized.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35161, "question": "If the compiler doesn't know what is in the pointer it can't be optimized.\n", "aSentId": 35162, "answer": "As long as the pointer is not void but has a type it is pointing to the compiler knows exactly what the pointer is \"pointing to.\"", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35163, "question": "As long as the pointer is not void but has a type it is pointing to the compiler knows exactly what the pointer is \"pointing to.\"", "aSentId": 35164, "answer": "No, for example\n\n    char *s = (char*) malloc(8); \n\nIn this case the compiler has no idea what *s is pointing to, since the address of s will be determined by the operating system at runtime. Similarly with new.\n\n    char *s = \"george\";\n\nIn this case the compiler knows what *s is pointing to. \n\n    char *s = \"george\";\n\n    DosomethingTo(&amp;s);\n\nat this point the compiler (unless DosomethingTo is inline) has no idea what is in s. S is a variable, not a constant.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35165, "question": "No, for example\n\n    char *s = (char*) malloc(8); \n\nIn this case the compiler has no idea what *s is pointing to, since the address of s will be determined by the operating system at runtime. Similarly with new.\n\n    char *s = \"george\";\n\nIn this case the compiler knows what *s is pointing to. \n\n    char *s = \"george\";\n\n    DosomethingTo(&amp;s);\n\nat this point the compiler (unless DosomethingTo is inline) has no idea what is in s. S is a variable, not a constant.\n", "aSentId": 35166, "answer": "You mean `char*`, not `char`, in the first example.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35167, "question": "You mean `char*`, not `char`, in the first example.\n", "aSentId": 35168, "answer": "The * became formatting for italic. Corrected.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35165, "question": "No, for example\n\n    char *s = (char*) malloc(8); \n\nIn this case the compiler has no idea what *s is pointing to, since the address of s will be determined by the operating system at runtime. Similarly with new.\n\n    char *s = \"george\";\n\nIn this case the compiler knows what *s is pointing to. \n\n    char *s = \"george\";\n\n    DosomethingTo(&amp;s);\n\nat this point the compiler (unless DosomethingTo is inline) has no idea what is in s. S is a variable, not a constant.\n", "aSentId": 35170, "answer": "I think what you say is true IF we are talking about a static array or variable. In that case yes compiler can optimize. But generally speaking if an array or variable is a constant we don't write code that ALTERS the content (we can't and shouldn't). So although this is true it is also trivial, it shouldn't happen.\n\nIf the compiler can not assume array content is constant then a pointer is as good as an array.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35120, "question": "Are pointers and arrays equivalent in C? (2009)", "aSentId": 35172, "answer": "What about when an unsized array is used as a function parameter? `void foo(char arr[])` Is that equivalent to a pointer?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35173, "question": "What about when an unsized array is used as a function parameter? `void foo(char arr[])` Is that equivalent to a pointer?", "aSentId": 35174, "answer": "It is important to realize that *C does not allow arrays as function arguments*. You cannot define a function that takes an array as an argument.\n\nYour example means \n    void foo(char *arr). \n\nIf you have \n\n    void foo(char arr[10]) \n\nthat means \n\n    void foo(char *arr)\n\nThe size of the array is not used by the compiler and the semantics of char arr[10] when used a declaration as a function parameter means that arr is a pointer.\n\nYou can check this using sizeof.\n\nFurthermore\n\n    void foo(char arr[2][3])\n\nmeans\n\n    void foo(char (*arr)[2]))\n\narr is here a pointer to char array[2]. And yes, the 2 is actually a part of the type. Again this can be checked using sizeof.\n\n    Edit: fixed *(arr)[2] to (*arr)[2].", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35175, "question": "It is important to realize that *C does not allow arrays as function arguments*. You cannot define a function that takes an array as an argument.\n\nYour example means \n    void foo(char *arr). \n\nIf you have \n\n    void foo(char arr[10]) \n\nthat means \n\n    void foo(char *arr)\n\nThe size of the array is not used by the compiler and the semantics of char arr[10] when used a declaration as a function parameter means that arr is a pointer.\n\nYou can check this using sizeof.\n\nFurthermore\n\n    void foo(char arr[2][3])\n\nmeans\n\n    void foo(char (*arr)[2]))\n\narr is here a pointer to char array[2]. And yes, the 2 is actually a part of the type. Again this can be checked using sizeof.\n\n    Edit: fixed *(arr)[2] to (*arr)[2].", "aSentId": 35176, "answer": "In C the dimension with the largest stride is the one furthest left. That means `f(char a[w][x][y][z])` is equivalent to `f(char a[][x][y][x])` or `f(char (*a)[x][y][z])` not the other way around (or else indexing would be impossible.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35175, "question": "It is important to realize that *C does not allow arrays as function arguments*. You cannot define a function that takes an array as an argument.\n\nYour example means \n    void foo(char *arr). \n\nIf you have \n\n    void foo(char arr[10]) \n\nthat means \n\n    void foo(char *arr)\n\nThe size of the array is not used by the compiler and the semantics of char arr[10] when used a declaration as a function parameter means that arr is a pointer.\n\nYou can check this using sizeof.\n\nFurthermore\n\n    void foo(char arr[2][3])\n\nmeans\n\n    void foo(char (*arr)[2]))\n\narr is here a pointer to char array[2]. And yes, the 2 is actually a part of the type. Again this can be checked using sizeof.\n\n    Edit: fixed *(arr)[2] to (*arr)[2].", "aSentId": 35178, "answer": "Shouldn't that be\n\n    void foo(char (*arr)[2])\n\n?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35179, "question": "Shouldn't that be\n\n    void foo(char (*arr)[2])\n\n?", "aSentId": 35180, "answer": "Yes, it should :)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35181, "question": "Yes, it should :)", "aSentId": 35182, "answer": "In your edit line the \\*'s were interpreted as formatting. Use \\\\* for a literal \\*.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35183, "question": "In your edit line the \\*'s were interpreted as formatting. Use \\\\* for a literal \\*.", "aSentId": 35184, "answer": "Thanks again!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35173, "question": "What about when an unsized array is used as a function parameter? `void foo(char arr[])` Is that equivalent to a pointer?", "aSentId": 35186, "answer": "When using an array as an argument, the array is said to \"decay\" to a pointer. Code within the function body will see *arr* as a pointer to its first element, so yes, the signature is functionally equivalent to\n\n    void foo(char *arr)\n\nand you can iterate through *arr* using pointer arithmetic. But it's worth using the version you presented when the function expects to operate on an array if only because the code will have better semantics that way.\n\nThe other thing worth pointing out is that your function has no way of knowing how many elements are in *arr* so you would need another parameter to indicate as much. I'm not a C expert, but I've seen the following use case often enough:\n\n    void foo(char arr[], int n)*\n\nand for calls to be in the form\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(char));\n\nor sometimes\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(some_arr[0]));\n\nIf you intend to work through an entire array. The latter is a little uglier but somewhat more maintainable in that the type is easier to change during development. Substitute char in the example for some arbitrary type to generalize.\n\nEdit: \n\n*/u/solinent pointed out below I had used Java array syntax (for some reason; I haven't written Java since college). Fixed now.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35187, "question": "When using an array as an argument, the array is said to \"decay\" to a pointer. Code within the function body will see *arr* as a pointer to its first element, so yes, the signature is functionally equivalent to\n\n    void foo(char *arr)\n\nand you can iterate through *arr* using pointer arithmetic. But it's worth using the version you presented when the function expects to operate on an array if only because the code will have better semantics that way.\n\nThe other thing worth pointing out is that your function has no way of knowing how many elements are in *arr* so you would need another parameter to indicate as much. I'm not a C expert, but I've seen the following use case often enough:\n\n    void foo(char arr[], int n)*\n\nand for calls to be in the form\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(char));\n\nor sometimes\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(some_arr[0]));\n\nIf you intend to work through an entire array. The latter is a little uglier but somewhat more maintainable in that the type is easier to change during development. Substitute char in the example for some arbitrary type to generalize.\n\nEdit: \n\n*/u/solinent pointed out below I had used Java array syntax (for some reason; I haven't written Java since college). Fixed now.", "aSentId": 35188, "answer": "Only occurred to me now, but *char** specifically is maybe the worst type to use to illustrate this concept because of the way C interprets strings. It can be assumed a vanilla C char* string is terminated by 0 (or *char* equivalent '\\0') so functions that operate on strings just work through them until 0 is encountered. That's why there are all those C string functions that don't ask how long your string is. They don't care.\n\nThis can be confusing because there are a number of ways of constructing strings in C, and sometimes the compiler will automatically null-terminate for you, as is the case with the most common way of creating a string variable: instantiating a var of type *char** with a string literal. So\n\n    char *my_var = \"Hello, world!\";\n\nwould give you the following array:\n\n    {'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\0'}", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35189, "question": "Only occurred to me now, but *char** specifically is maybe the worst type to use to illustrate this concept because of the way C interprets strings. It can be assumed a vanilla C char* string is terminated by 0 (or *char* equivalent '\\0') so functions that operate on strings just work through them until 0 is encountered. That's why there are all those C string functions that don't ask how long your string is. They don't care.\n\nThis can be confusing because there are a number of ways of constructing strings in C, and sometimes the compiler will automatically null-terminate for you, as is the case with the most common way of creating a string variable: instantiating a var of type *char** with a string literal. So\n\n    char *my_var = \"Hello, world!\";\n\nwould give you the following array:\n\n    {'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\0'}", "aSentId": 35190, "answer": "The compiler will *always* null-terminate string literals, and most of the standard library's string functions null-terminate their strings as well.\n\nIt's worth noting that there's technically a difference between\n\n    char *my_var = \"Hello, world!\";\n\nand\n\n    char my_var[] = \"Hello, world!\";\n\nThe former allocates not only the char array, but also allocates a pointer for `my_var` which points to that array.  The latter does not allocate the extra pointer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35191, "question": "The compiler will *always* null-terminate string literals, and most of the standard library's string functions null-terminate their strings as well.\n\nIt's worth noting that there's technically a difference between\n\n    char *my_var = \"Hello, world!\";\n\nand\n\n    char my_var[] = \"Hello, world!\";\n\nThe former allocates not only the char array, but also allocates a pointer for `my_var` which points to that array.  The latter does not allocate the extra pointer.", "aSentId": 35192, "answer": "The first declaration allocates a pointer, the second declaration allocates a complete array, copying the contents of the string literal. That makes the array version more costly, but it has the benefit that you can modify the array.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35193, "question": "The first declaration allocates a pointer, the second declaration allocates a complete array, copying the contents of the string literal. That makes the array version more costly, but it has the benefit that you can modify the array.", "aSentId": 35194, "answer": "No, you're wrong here.  The second version does allocate the array, but the array itself refers to the array in memory where the literal is stored.  Since arrays degrade into pointers when passed to function, the pointer is generated (by the compiler, at compile-time) when you write something like `foo(my_var);`.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35195, "question": "No, you're wrong here.  The second version does allocate the array, but the array itself refers to the array in memory where the literal is stored.  Since arrays degrade into pointers when passed to function, the pointer is generated (by the compiler, at compile-time) when you write something like `foo(my_var);`.", "aSentId": 35196, "answer": "No, you're wrong.\n\n`gcc -O0 foo.c -g ; objdump -Mintel -d ./a.out -S`\n\n    00000000004004f6 &lt;main&gt;:\n    int main(int argc, char **argv) {\n      4004f6:       55                      push   rbp\n      4004f7:       48 89 e5                mov    rbp,rsp\n      4004fa:       89 7d ec                mov    DWORD PTR [rbp-0x14],edi\n      4004fd:       48 89 75 e0             mov    QWORD PTR [rbp-0x20],rsi\n        char *x1 = \"Hello\";\n      400501:       48 c7 45 f8 b0 05 40    mov    QWORD PTR [rbp-0x8],0x4005b0\n      400508:       00 \n        char x2[] = \"Hello\";\n      400509:       c7 45 f0 48 65 6c 6c    mov    DWORD PTR [rbp-0x10],0x6c6c6548\n      400510:       66 c7 45 f4 6f 00       mov    WORD PTR [rbp-0xc],0x6f\n    }\n      400516:       5d                      pop    rbp\n      400517:       c3                      ret    \n      400518:       0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]\n      40051f:       00 \n\n\nx1 is a pointer at rbp-0x8 pointing into the .rodata segment (i.e. the string literal). x2 is completely on the stack at rbp-0x10 to rbp-0xd, the contents of the string literal are copied there at runtime (0x6c6c6548 is \"Hell\", 0x6f is \"o\\0\").", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35187, "question": "When using an array as an argument, the array is said to \"decay\" to a pointer. Code within the function body will see *arr* as a pointer to its first element, so yes, the signature is functionally equivalent to\n\n    void foo(char *arr)\n\nand you can iterate through *arr* using pointer arithmetic. But it's worth using the version you presented when the function expects to operate on an array if only because the code will have better semantics that way.\n\nThe other thing worth pointing out is that your function has no way of knowing how many elements are in *arr* so you would need another parameter to indicate as much. I'm not a C expert, but I've seen the following use case often enough:\n\n    void foo(char arr[], int n)*\n\nand for calls to be in the form\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(char));\n\nor sometimes\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(some_arr[0]));\n\nIf you intend to work through an entire array. The latter is a little uglier but somewhat more maintainable in that the type is easier to change during development. Substitute char in the example for some arbitrary type to generalize.\n\nEdit: \n\n*/u/solinent pointed out below I had used Java array syntax (for some reason; I haven't written Java since college). Fixed now.", "aSentId": 35198, "answer": "I wonder sizeof(some_arr) is actually a variable or a function in the declared scope. Because in order to use \"delete\", size must be found, and adding a delimiter is worse.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35199, "question": "I wonder sizeof(some_arr) is actually a variable or a function in the declared scope. Because in order to use \"delete\", size must be found, and adding a delimiter is worse.", "aSentId": 35200, "answer": "Well, sizeof is a built-in operator that resolves to an int (or size_t, or some other integer type; I'm not sure), the value of which can always be resolved at compile time in the same way a macro can, because any operand of sizeof will either be: a primitive type like *int* or *float* etc., with sizes on the target machine that are known by the compiler and never change; a typedef of some primitive type; or otherwise those types composed of built-in types in some well-defined way, like arrays, structs and unions, and the typedefs of said types.\n\nI don't know if this addresses what you're saying at all (sorry), but anyway if some_arr is an array allocated on the heap in C++ with *new* then you're supposed to use *delete[]* instead of *delete* to free the allocated memory. I guess the compiler must know how much memory to free by keeping track of what was allocated in the first place, but I don't know, really.\n\nI wonder why in C, free() only needs a pointer previously given to malloc() and realloc(), but in C++ we have two different operators for freeing memory depending on whether the operand of *new* was an array or not. Allocation in C is lower level (\"set aside this many bytes. OK, I don't need them anymore\") but this seems like something the compiler would be able to figure out on its own if it can in C, instead of making us remember which version of *delete* to use. I dunno.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35201, "question": "Well, sizeof is a built-in operator that resolves to an int (or size_t, or some other integer type; I'm not sure), the value of which can always be resolved at compile time in the same way a macro can, because any operand of sizeof will either be: a primitive type like *int* or *float* etc., with sizes on the target machine that are known by the compiler and never change; a typedef of some primitive type; or otherwise those types composed of built-in types in some well-defined way, like arrays, structs and unions, and the typedefs of said types.\n\nI don't know if this addresses what you're saying at all (sorry), but anyway if some_arr is an array allocated on the heap in C++ with *new* then you're supposed to use *delete[]* instead of *delete* to free the allocated memory. I guess the compiler must know how much memory to free by keeping track of what was allocated in the first place, but I don't know, really.\n\nI wonder why in C, free() only needs a pointer previously given to malloc() and realloc(), but in C++ we have two different operators for freeing memory depending on whether the operand of *new* was an array or not. Allocation in C is lower level (\"set aside this many bytes. OK, I don't need them anymore\") but this seems like something the compiler would be able to figure out on its own if it can in C, instead of making us remember which version of *delete* to use. I dunno.", "aSentId": 35202, "answer": "&gt; I wonder why in C, free() only needs a pointer previously given to malloc() and realloc(), but in C++ we have two different operators for freeing memory depending on whether the operand of new was an array or not.\n\nBecause `delete[]` must call destructors for all elements in the array, and only ever `delete` calls one destructor. `delete` can thus be minimally more efficient, and that\u2019s why you need the distinction. C has no destructors, hence one `free` is enough.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35203, "question": "&gt; I wonder why in C, free() only needs a pointer previously given to malloc() and realloc(), but in C++ we have two different operators for freeing memory depending on whether the operand of new was an array or not.\n\nBecause `delete[]` must call destructors for all elements in the array, and only ever `delete` calls one destructor. `delete` can thus be minimally more efficient, and that\u2019s why you need the distinction. C has no destructors, hence one `free` is enough.", "aSentId": 35204, "answer": "Wow, that seems so obvious now. Thanks.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35203, "question": "&gt; I wonder why in C, free() only needs a pointer previously given to malloc() and realloc(), but in C++ we have two different operators for freeing memory depending on whether the operand of new was an array or not.\n\nBecause `delete[]` must call destructors for all elements in the array, and only ever `delete` calls one destructor. `delete` can thus be minimally more efficient, and that\u2019s why you need the distinction. C has no destructors, hence one `free` is enough.", "aSentId": 35206, "answer": "What I meant was how the compiler know how much memory is used. So unless pointer data type knows also how much data is stored, arrays and pointers `free`must be different as `delete[]`and `delete` is", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35207, "question": "What I meant was how the compiler know how much memory is used. So unless pointer data type knows also how much data is stored, arrays and pointers `free`must be different as `delete[]`and `delete` is", "aSentId": 35208, "answer": "&gt; So unless pointer data type knows also how much data is stored\n\nNo, the array pointer type doesn\u2019t know this. The pointer is *really* just the address, and `sizeof(pointer)` is the size of that address in memory. But `malloc` and `free` obviously do book keeping behind the scenes for the amount of money.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35207, "question": "What I meant was how the compiler know how much memory is used. So unless pointer data type knows also how much data is stored, arrays and pointers `free`must be different as `delete[]`and `delete` is", "aSentId": 35210, "answer": "&gt; What I meant was how the compiler know how much memory is used.\n\nIt's implementation dependent, but typically the amount of memory to delete is stored just before the data.  So if you allocation 10 bytes worth of data, then the value 10 will be stored just before the pointer to the first byte.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35187, "question": "When using an array as an argument, the array is said to \"decay\" to a pointer. Code within the function body will see *arr* as a pointer to its first element, so yes, the signature is functionally equivalent to\n\n    void foo(char *arr)\n\nand you can iterate through *arr* using pointer arithmetic. But it's worth using the version you presented when the function expects to operate on an array if only because the code will have better semantics that way.\n\nThe other thing worth pointing out is that your function has no way of knowing how many elements are in *arr* so you would need another parameter to indicate as much. I'm not a C expert, but I've seen the following use case often enough:\n\n    void foo(char arr[], int n)*\n\nand for calls to be in the form\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(char));\n\nor sometimes\n\n    ... foo(some_arr, sizeof(some_arr)/sizeof(some_arr[0]));\n\nIf you intend to work through an entire array. The latter is a little uglier but somewhat more maintainable in that the type is easier to change during development. Substitute char in the example for some arbitrary type to generalize.\n\nEdit: \n\n*/u/solinent pointed out below I had used Java array syntax (for some reason; I haven't written Java since college). Fixed now.", "aSentId": 35212, "answer": "It's \n\n    char arr[]\n\nbtw. Too much Java for you!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35213, "question": "It's \n\n    char arr[]\n\nbtw. Too much Java for you!", "aSentId": 35214, "answer": "That's so weird. I don't write much C or C++, but I write even less Java so I don't know how to explain that one. I'll have to bear the shame and leave it unfixed though so your comment keeps making sense. Edit: or I did for about five seconds before I couldn't take it anymore =D", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35215, "question": "That's so weird. I don't write much C or C++, but I write even less Java so I don't know how to explain that one. I'll have to bear the shame and leave it unfixed though so your comment keeps making sense. Edit: or I did for about five seconds before I couldn't take it anymore =D", "aSentId": 35216, "answer": "The Java way makes much more sense (type, then variable name), so I don't blame you at all.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35120, "question": "Are pointers and arrays equivalent in C? (2009)", "aSentId": 35218, "answer": "&gt; Are pointers and arrays equivalent in C?\n\nShort answer: No.\n\nLong answer: **Noooooooo!**\n\nIt's misleading to say that array indexing applies to both arrays and pointers. In fact, the `[]` indexing operator takes two operands; one of them must be a pointer, and the other must be an integer. If the prefix is the name of an array object (the simplest case), that name is implicitly converted to a pointer value.\n\nThe article suggests that array indexing and function calls are special cases. They're not. The actual rule is that an expression of array type is implicitly converted to a pointer to the array's initial element *unless* it is:\n\n- The operand of `sizeof`;\n- The operand of unary `&amp;` (the address operator); or\n- A string literal used to initialize an array object.\n\n(A separate rule says that if you define a function parameter with an array type, it's adjusted at compile time to a pointer; `void func(int array[])` really means `void func(int *array)`.)\n\nSee section 6 of the [comp.lang.c FAQ](http://www.c-faq.com/).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35219, "question": "&gt; Are pointers and arrays equivalent in C?\n\nShort answer: No.\n\nLong answer: **Noooooooo!**\n\nIt's misleading to say that array indexing applies to both arrays and pointers. In fact, the `[]` indexing operator takes two operands; one of them must be a pointer, and the other must be an integer. If the prefix is the name of an array object (the simplest case), that name is implicitly converted to a pointer value.\n\nThe article suggests that array indexing and function calls are special cases. They're not. The actual rule is that an expression of array type is implicitly converted to a pointer to the array's initial element *unless* it is:\n\n- The operand of `sizeof`;\n- The operand of unary `&amp;` (the address operator); or\n- A string literal used to initialize an array object.\n\n(A separate rule says that if you define a function parameter with an array type, it's adjusted at compile time to a pointer; `void func(int array[])` really means `void func(int *array)`.)\n\nSee section 6 of the [comp.lang.c FAQ](http://www.c-faq.com/).", "aSentId": 35220, "answer": "does anyone here know why people usually write `int *var` instead of `int* pointer`?\n\nBecause from my perspective it should be  \n- `var` is of type pointer to `int`  \nand not   \n- pointer to `var`, which is of type `int`", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35221, "question": "does anyone here know why people usually write `int *var` instead of `int* pointer`?\n\nBecause from my perspective it should be  \n- `var` is of type pointer to `int`  \nand not   \n- pointer to `var`, which is of type `int`", "aSentId": 35222, "answer": "int* a, b;\n\nRiddle me this: what type is b?\n\nIf you answered int*, congratulations! You're wrong! It's int. As mentioned below, the syntax for pointer declarations is consistent with the syntax for pointer dereference. Thus, keeping the asterisk tied to the identifier rather than the type is more explicit.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35221, "question": "does anyone here know why people usually write `int *var` instead of `int* pointer`?\n\nBecause from my perspective it should be  \n- `var` is of type pointer to `int`  \nand not   \n- pointer to `var`, which is of type `int`", "aSentId": 35224, "answer": "Because C is old and has weird baggage.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35221, "question": "does anyone here know why people usually write `int *var` instead of `int* pointer`?\n\nBecause from my perspective it should be  \n- `var` is of type pointer to `int`  \nand not   \n- pointer to `var`, which is of type `int`", "aSentId": 35226, "answer": "Once you get into [function pointers](https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work), the advantage of `int *var` becomes apparent.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35219, "question": "&gt; Are pointers and arrays equivalent in C?\n\nShort answer: No.\n\nLong answer: **Noooooooo!**\n\nIt's misleading to say that array indexing applies to both arrays and pointers. In fact, the `[]` indexing operator takes two operands; one of them must be a pointer, and the other must be an integer. If the prefix is the name of an array object (the simplest case), that name is implicitly converted to a pointer value.\n\nThe article suggests that array indexing and function calls are special cases. They're not. The actual rule is that an expression of array type is implicitly converted to a pointer to the array's initial element *unless* it is:\n\n- The operand of `sizeof`;\n- The operand of unary `&amp;` (the address operator); or\n- A string literal used to initialize an array object.\n\n(A separate rule says that if you define a function parameter with an array type, it's adjusted at compile time to a pointer; `void func(int array[])` really means `void func(int *array)`.)\n\nSee section 6 of the [comp.lang.c FAQ](http://www.c-faq.com/).", "aSentId": 35228, "answer": "Link broken. Should be http://www.c-faq.com/", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35229, "question": "Link broken. Should be http://www.c-faq.com/", "aSentId": 35230, "answer": "Thank you! I've fixed it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35219, "question": "&gt; Are pointers and arrays equivalent in C?\n\nShort answer: No.\n\nLong answer: **Noooooooo!**\n\nIt's misleading to say that array indexing applies to both arrays and pointers. In fact, the `[]` indexing operator takes two operands; one of them must be a pointer, and the other must be an integer. If the prefix is the name of an array object (the simplest case), that name is implicitly converted to a pointer value.\n\nThe article suggests that array indexing and function calls are special cases. They're not. The actual rule is that an expression of array type is implicitly converted to a pointer to the array's initial element *unless* it is:\n\n- The operand of `sizeof`;\n- The operand of unary `&amp;` (the address operator); or\n- A string literal used to initialize an array object.\n\n(A separate rule says that if you define a function parameter with an array type, it's adjusted at compile time to a pointer; `void func(int array[])` really means `void func(int *array)`.)\n\nSee section 6 of the [comp.lang.c FAQ](http://www.c-faq.com/).", "aSentId": 35232, "answer": "&gt; Short answer: No.\n\n&gt; Long answer: Noooooooo!\n\nActual answer: basically, except when declaring the variables.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35233, "question": "&gt; Short answer: No.\n\n&gt; Long answer: Noooooooo!\n\nActual answer: basically, except when declaring the variables.", "aSentId": 35234, "answer": "Actual answer: No, pointers are not arrays, and arrays are not pointers. The idea that they're equivalent is one of the most common misconceptions about C.\n\nPlease read section 6 of the [comp.lang.c FAQ](http://www.c-faq.com/).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35237, "question": "The real difference:\n\n&amp;array and array are actually the same location, whereas\n&amp;pointer and pointer are not.\n\nie.\n\n    int array[] = {1,2,3};\n    int *pointer = array;\n    assert(&amp;array == array)\n    assert(&amp;pointer != pointer)\n\nboth are true. (this code may not work because the types of &amp;x and x are different. If you print them with cout you'll get the same values though.)\n\nAlso, this holds true for array arguments too, I believe. (edit: no, it does not.)", "aSentId": 35238, "answer": "Yes, for arrays their R-value equals their L-value. Expressions like `a[b]` can thus be translated along pointer arithmetic `(a + b)`. As a consequence, `a[b] == b[a]` (yes, the latter is also valid). Go ahead and see before downvoting ;-)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35240, "question": "&gt; Suppose one file contains a global array:\n\n&gt; char my_arr[256];\n\n&gt; And soothed by the seeming equivalence between arrays and pointers, the programmer that wants to use it in another file mistakingly declares as:\n\n&gt; extern char* my_arr;\n\n&gt; When he tries to access some element of the array using this pointer, he will most likely get a segmentation fault or a fatal exception (the nomenclature depends on the OS). \n\nCan anybody explain why this happens please?", "aSentId": 35241, "answer": "&gt; The semantics of arrays in C dictate that the array name is the address of the first element of the array.\n\nSo say you have initialized `my_arr` to all `0x00` bytes, if you treat it as a pointer and dereference/index it, you dereference the pointer-sized chunk of bytes at start of the array, which is to say a NULL pointer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35240, "question": "&gt; Suppose one file contains a global array:\n\n&gt; char my_arr[256];\n\n&gt; And soothed by the seeming equivalence between arrays and pointers, the programmer that wants to use it in another file mistakingly declares as:\n\n&gt; extern char* my_arr;\n\n&gt; When he tries to access some element of the array using this pointer, he will most likely get a segmentation fault or a fatal exception (the nomenclature depends on the OS). \n\nCan anybody explain why this happens please?", "aSentId": 35243, "answer": "Although I'm not completely sure.  \nchar* my_arr says that you have a variable which points to a character.  \nmy_arr[256] says that you have an array of 256 characters.  \nIf my_arr is used as a variable (eg char* b = a), a evaluates to a pointer pointing towards the first element of the array.  \nWith \"extern char* my_arr;\" the compiler expects that my_arr is a pointer to a character.  \nSo if you use \"my_arr[5]\", the compiler tries to acces the 5th element of my_arr.  \nHowever the contents of my_arr isn't the adress of the first element of the array, but is the first element itself.  \nTo make this easier to understand, lets says we have the following declarations:  \n&gt; short a  \n\nand  \n&gt; extern int a  \n\nWith the extern, the compiler expects a to be an integer.  \nLets say a contains the number 5.  \nWhen you access a, you won't find 5. You'll get garbage. This is because the compiler takes the address of a (stack variable) and uses that.  \nIt doesnt say: the_extern_a = original_a  \nThe same happens when you use \"char[]\" and \"char*\"  \nIt just says that a is a pointer with contents, the address created from the first x (depending on architecture, sizeof(void*)) bytes. Which in case of the array is the bit representation of the first x chars.  \n  \nSo an array isn't quite the same as a pointer. It behaves as a const ptr*.  But it isn't quite a label either. A compiler will when you say a = b and b is an array, use b as if it where an const char*. This is intentional so that users of C can use arrays and pointers alike\". A pointers is an actual variable on the stack, which contains the address it points to. An array will simulate this behaviour through the compiler. An array (eg. char a[6]) is represented on the stack as 6 bytes, there is no separate variable containing the address of the first element of the array.  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35240, "question": "&gt; Suppose one file contains a global array:\n\n&gt; char my_arr[256];\n\n&gt; And soothed by the seeming equivalence between arrays and pointers, the programmer that wants to use it in another file mistakingly declares as:\n\n&gt; extern char* my_arr;\n\n&gt; When he tries to access some element of the array using this pointer, he will most likely get a segmentation fault or a fatal exception (the nomenclature depends on the OS). \n\nCan anybody explain why this happens please?", "aSentId": 35245, "answer": "Take a look at the \"A graphical explanation\" section about how the two data structures are generated differently.\n\nThen look at the assembly that's generated from character assignment.\n\nLet's say someone is using an `extern char* my_arr;` declaration and \"my_arr\" is actually declared as `char my_arr[256];`. Code such as `char b = my_arr[7];` using the extern declaration is going to get this assembly generated (adapted slightly from the example in article):\n\n    00411386  mov  eax,dword ptr [_my_arr (417064h)]\n\nTried to dereference a pointer from my_arr but instead of reading an address from that memory there was actually string data there. The \"pointer\" is using the first four bytes of string data incorrectly as an address in memory.\n\n    0041138B  mov  cl,byte ptr [eax+7]\n\nNow we tried to offset (+7) and read from that faulty address that is stuffed into eax. This \"address\" is almost certainly out of program memory bounds. Operating system will catch this and force stop (aka segfault).\n\nEdit: words.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35248, "question": "Another interesting thing is what happens when you try to do the following (only applies to strings):\n\n    int main(int argc, char** argv)\n    {\n        char array[6] = \"Hello\";\n        char* pointer = \"Hello\";\n        array[0]='h';\n        pointer[0]='h'; // Seg fault, writing to read-only memory\n    }", "aSentId": 35249, "answer": "In C language, that definitely would happen. Some implementations put strings into constant blocks that can't be written to, though.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35248, "question": "Another interesting thing is what happens when you try to do the following (only applies to strings):\n\n    int main(int argc, char** argv)\n    {\n        char array[6] = \"Hello\";\n        char* pointer = \"Hello\";\n        array[0]='h';\n        pointer[0]='h'; // Seg fault, writing to read-only memory\n    }", "aSentId": 35251, "answer": "That's due to the compiler using string pooling.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35253, "question": "How does an array compare to *const?\n\nSo like\n\n    char arr[] = \"test\";\n    char* const ptr = \"test\";\n\nSince it seems the article sums up to \"the array's 'pointer' is constant, a normal pointer is not\".  It didn't seem to address that an array is always stored on the stack while a pointer can point to anything, either.", "aSentId": 35254, "answer": "Arrays aren't always on the stack. They can live in all the normal places for objects: statically allocated global memory; the heap; even entirely in registers in the right circumstances.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35253, "question": "How does an array compare to *const?\n\nSo like\n\n    char arr[] = \"test\";\n    char* const ptr = \"test\";\n\nSince it seems the article sums up to \"the array's 'pointer' is constant, a normal pointer is not\".  It didn't seem to address that an array is always stored on the stack while a pointer can point to anything, either.", "aSentId": 35256, "answer": "For one thing:\n\n    sizeof(arr) != sizeof(ptr)\n\nI've seen that cause bugs when someone swaps an array for a pointer and somewhere later a malloc ends up allocating a buffer to copy into that's the size of a pointer instead of the size of the array.\n\nAlso, arrays aren't always on the stack. The example in the article actually uses an array in the data segment since it's declared at global scope.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35253, "question": "How does an array compare to *const?\n\nSo like\n\n    char arr[] = \"test\";\n    char* const ptr = \"test\";\n\nSince it seems the article sums up to \"the array's 'pointer' is constant, a normal pointer is not\".  It didn't seem to address that an array is always stored on the stack while a pointer can point to anything, either.", "aSentId": 35258, "answer": "Exactly my thought!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35260, "question": "Stuff like this makes me happy that C++11 onwards seems to be shifting away from direct pointer manipulation.", "aSentId": 35261, "answer": "Why exactly? Pointer manipulation is one of most powerful aspects of using C over any other \"managed\" language. There are times where direct pointer access and manipulation results in much better and efficient code. Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35262, "question": "Why exactly? Pointer manipulation is one of most powerful aspects of using C over any other \"managed\" language. There are times where direct pointer access and manipulation results in much better and efficient code. Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.", "aSentId": 35263, "answer": "I think it's more about protecting the next programmer", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35262, "question": "Why exactly? Pointer manipulation is one of most powerful aspects of using C over any other \"managed\" language. There are times where direct pointer access and manipulation results in much better and efficient code. Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.", "aSentId": 35265, "answer": "Because pointers themselves are too vague, furthermore direct pointer access makes code **less** efficient, not more.  C++ reduces the use of direct pointer manipulation in favor of specific, orthogonal use cases.  Not only does this eliminate entire classes of bugs, but it also allows better optimization as the compiler can make stronger assumptions about how a language feature will be used.  The more general a language feature is, the less the compiler can infer about how that feature will be used and hence must generate code to accommodate all of its potential use cases.\n\nThis is why C++ outperforms C in almost all cases.\n\n&gt;Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.\n\nThat statement is a tautology, anything done that isn't beneficial is by definition not a good thing.  The point is that a language providing a strong type system that restricts the use of language features to only those which are provably valid are beneficial.\n\nThat's the direction that C++ and modern statically typed languages like Rust are headed towards.  In Rust, you can't even misuse a pointer period, every operation you perform on memory must be provably correct.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35266, "question": "Because pointers themselves are too vague, furthermore direct pointer access makes code **less** efficient, not more.  C++ reduces the use of direct pointer manipulation in favor of specific, orthogonal use cases.  Not only does this eliminate entire classes of bugs, but it also allows better optimization as the compiler can make stronger assumptions about how a language feature will be used.  The more general a language feature is, the less the compiler can infer about how that feature will be used and hence must generate code to accommodate all of its potential use cases.\n\nThis is why C++ outperforms C in almost all cases.\n\n&gt;Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.\n\nThat statement is a tautology, anything done that isn't beneficial is by definition not a good thing.  The point is that a language providing a strong type system that restricts the use of language features to only those which are provably valid are beneficial.\n\nThat's the direction that C++ and modern statically typed languages like Rust are headed towards.  In Rust, you can't even misuse a pointer period, every operation you perform on memory must be provably correct.", "aSentId": 35267, "answer": "Game programmer here. Let's say I want to store a vector of all of the different components on a game object. How would I do that without pointers?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35268, "question": "Game programmer here. Let's say I want to store a vector of all of the different components on a game object. How would I do that without pointers?", "aSentId": 35269, "answer": "To be clear, my issue with pointers is that they are too broad, and what I'm advocating for is breaking the concept of a pointer down into multiple independent pieces and being able to use those pieces individually.\n\nA vector of game objects is likely as simple as:\n\n    std::vector&lt;std::unique_ptr&lt;Component&gt;&gt;\n\nThis isn't just some wild or raw pointer, this restricts the use of a pointer to uniquely own a single object.\n\nIn other words, when you see this:\n\n    Component* c;\n\nYou don't know whether c is a single object, an array of objects, whether c owns the object, or even whether c is initialized, you know very little about c and that means an increase in bugs as well as a decrease in ways to optimize c.  Even if you give c a descriptive name and document it, fine that's better but the compiler can't help ensure that the documentation and its pretty name matches the actual use case.\n\nWhen you see this:\n\n    std::unique_ptr&lt;Component&gt; c;\n\nYou know almost all that needs to be known about c, except whether it's initialized or whether it's null.  In an even stronger type system like Rust's, pointers are never null and hence everything you ever need to know about the pointer itself is well defined, there is no room for error or ambiguity.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35270, "question": "To be clear, my issue with pointers is that they are too broad, and what I'm advocating for is breaking the concept of a pointer down into multiple independent pieces and being able to use those pieces individually.\n\nA vector of game objects is likely as simple as:\n\n    std::vector&lt;std::unique_ptr&lt;Component&gt;&gt;\n\nThis isn't just some wild or raw pointer, this restricts the use of a pointer to uniquely own a single object.\n\nIn other words, when you see this:\n\n    Component* c;\n\nYou don't know whether c is a single object, an array of objects, whether c owns the object, or even whether c is initialized, you know very little about c and that means an increase in bugs as well as a decrease in ways to optimize c.  Even if you give c a descriptive name and document it, fine that's better but the compiler can't help ensure that the documentation and its pretty name matches the actual use case.\n\nWhen you see this:\n\n    std::unique_ptr&lt;Component&gt; c;\n\nYou know almost all that needs to be known about c, except whether it's initialized or whether it's null.  In an even stronger type system like Rust's, pointers are never null and hence everything you ever need to know about the pointer itself is well defined, there is no room for error or ambiguity.", "aSentId": 35271, "answer": "What you are saying makes sense. I don't have any experience with C++, but I agree with you criticisms of C which I do have experience with.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35266, "question": "Because pointers themselves are too vague, furthermore direct pointer access makes code **less** efficient, not more.  C++ reduces the use of direct pointer manipulation in favor of specific, orthogonal use cases.  Not only does this eliminate entire classes of bugs, but it also allows better optimization as the compiler can make stronger assumptions about how a language feature will be used.  The more general a language feature is, the less the compiler can infer about how that feature will be used and hence must generate code to accommodate all of its potential use cases.\n\nThis is why C++ outperforms C in almost all cases.\n\n&gt;Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.\n\nThat statement is a tautology, anything done that isn't beneficial is by definition not a good thing.  The point is that a language providing a strong type system that restricts the use of language features to only those which are provably valid are beneficial.\n\nThat's the direction that C++ and modern statically typed languages like Rust are headed towards.  In Rust, you can't even misuse a pointer period, every operation you perform on memory must be provably correct.", "aSentId": 35273, "answer": "I disagree with you assertion that \"direct pointer access makes code less efficient, not more.\" I write a great deal of signal processing, time critical code that runs under maximum processor load. I have a great deal of experience. I use language for their strengths and have no interested in doing something myself that a language design/compiler can do just as well just because. Having said that when needed direct pointer access is a MUST for what I do.\n\nMy personal opinion is that  lot of the direction of C++ is not very useful, as we do not need another highly \"protected\" language. There are already many out there that are quite good for a great number of applications.\n\nIf I am missing your point I apologize, please clarify.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35274, "question": "I disagree with you assertion that \"direct pointer access makes code less efficient, not more.\" I write a great deal of signal processing, time critical code that runs under maximum processor load. I have a great deal of experience. I use language for their strengths and have no interested in doing something myself that a language design/compiler can do just as well just because. Having said that when needed direct pointer access is a MUST for what I do.\n\nMy personal opinion is that  lot of the direction of C++ is not very useful, as we do not need another highly \"protected\" language. There are already many out there that are quite good for a great number of applications.\n\nIf I am missing your point I apologize, please clarify.", "aSentId": 35275, "answer": "Raw C++ pointers are just as much a part of C++ as they ever were. What C++11/14 discourages is the use of raw C++ pointers for managing lifetime, that's what std::unique_ptr, std::shared_ptr and std::weak_ptr are for. \n\nIn fact C++11/14 has introduced some new free functions (std::begin, end etc.) to make it even easier to use raw pointers just like any of the other iterators. Also you now have direct access to the underlying array in a std::vector.\n\nThe recent changes to C++ have only made it faster and safer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35274, "question": "I disagree with you assertion that \"direct pointer access makes code less efficient, not more.\" I write a great deal of signal processing, time critical code that runs under maximum processor load. I have a great deal of experience. I use language for their strengths and have no interested in doing something myself that a language design/compiler can do just as well just because. Having said that when needed direct pointer access is a MUST for what I do.\n\nMy personal opinion is that  lot of the direction of C++ is not very useful, as we do not need another highly \"protected\" language. There are already many out there that are quite good for a great number of applications.\n\nIf I am missing your point I apologize, please clarify.", "aSentId": 35277, "answer": "There are definitely times where direct pointer access is necessary, but it's far more common for C's unnecessarily loose semantics to preclude the compiler from making optimizations due to things like an inability to prove that there won't be aliasing. The fact that `restrict` wasn't available until C99 and isn't the default is the only reason why FORTRAN is still taken seriously as a language for writing HPC code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35274, "question": "I disagree with you assertion that \"direct pointer access makes code less efficient, not more.\" I write a great deal of signal processing, time critical code that runs under maximum processor load. I have a great deal of experience. I use language for their strengths and have no interested in doing something myself that a language design/compiler can do just as well just because. Having said that when needed direct pointer access is a MUST for what I do.\n\nMy personal opinion is that  lot of the direction of C++ is not very useful, as we do not need another highly \"protected\" language. There are already many out there that are quite good for a great number of applications.\n\nIf I am missing your point I apologize, please clarify.", "aSentId": 35279, "answer": "If you need direct memory access, then raw pointers are what you need. However, the majority of other cases can be solved with references, which are never slower (and many times faster) than pointers, because compilers assume references are always seated and in many cases optimize them out entirely (i.e. references don't require any storage at all, pointers always do, because they're values like everything else.)\n\nI think this is what the parent was driving at.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35280, "question": "If you need direct memory access, then raw pointers are what you need. However, the majority of other cases can be solved with references, which are never slower (and many times faster) than pointers, because compilers assume references are always seated and in many cases optimize them out entirely (i.e. references don't require any storage at all, pointers always do, because they're values like everything else.)\n\nI think this is what the parent was driving at.", "aSentId": 35281, "answer": "&gt; pointers always do, because they're values like everything else\n\nAFAIK all variables can be optimized out unless their address is taken, that also applies to pointers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35282, "question": "&gt; pointers always do, because they're values like everything else\n\nAFAIK all variables can be optimized out unless their address is taken, that also applies to pointers.", "aSentId": 35283, "answer": "You're correct. But since references don't even have addresses to take, the potential to optimize is much higher. Hence why I said they're never slower.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35280, "question": "If you need direct memory access, then raw pointers are what you need. However, the majority of other cases can be solved with references, which are never slower (and many times faster) than pointers, because compilers assume references are always seated and in many cases optimize them out entirely (i.e. references don't require any storage at all, pointers always do, because they're values like everything else.)\n\nI think this is what the parent was driving at.", "aSentId": 35285, "answer": "What's this nonsense? References aren't 'faster'. They're essentially restricted pointers, and the restrictions aren't such that they help optimization (except in some very marginal cases). If you put some in a struct, you will definitely observe them taking up space.\n\nCompilers can and do use the same techniques of forwarding, promotion and fusion with pointers that they can with references. Why would they not? The aliasing information problem is the same, too.\n\nBy all means use references if you want to do that, but you won't see any performance advantage.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35286, "question": "What's this nonsense? References aren't 'faster'. They're essentially restricted pointers, and the restrictions aren't such that they help optimization (except in some very marginal cases). If you put some in a struct, you will definitely observe them taking up space.\n\nCompilers can and do use the same techniques of forwarding, promotion and fusion with pointers that they can with references. Why would they not? The aliasing information problem is the same, too.\n\nBy all means use references if you want to do that, but you won't see any performance advantage.", "aSentId": 35287, "answer": "I said they're never slower than pointers, and in some cases they can be faster. Perhaps I should have worded that more clearly. Since references don't have addresses to take, compilers have a lot more freedom regarding what optimizations they can apply to them. In a lot of cases you'll see no difference, but using a pointer for something when a reference will do just dandy is what I like to call \"premature pessimization\". And no, they're not essentially restricted pointers. They have different semantics, and different use cases.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35288, "question": "I said they're never slower than pointers, and in some cases they can be faster. Perhaps I should have worded that more clearly. Since references don't have addresses to take, compilers have a lot more freedom regarding what optimizations they can apply to them. In a lot of cases you'll see no difference, but using a pointer for something when a reference will do just dandy is what I like to call \"premature pessimization\". And no, they're not essentially restricted pointers. They have different semantics, and different use cases.", "aSentId": 35289, "answer": "Doesn't really matter, since pointers get the benefit of all the same promotion and alias-analysis machinery that makes your other scalar types perform well even though they can also have their addresses taken. \n\nIf I'm wrong, you'll be able to easily show me a program that, for the same operations, generates noticeably worse assembly for pointers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35280, "question": "If you need direct memory access, then raw pointers are what you need. However, the majority of other cases can be solved with references, which are never slower (and many times faster) than pointers, because compilers assume references are always seated and in many cases optimize them out entirely (i.e. references don't require any storage at all, pointers always do, because they're values like everything else.)\n\nI think this is what the parent was driving at.", "aSentId": 35291, "answer": "Thanks, but I guess maybe this is where I am a little confused. If one is always using fixed indexes for arrays I completely agree, but compilers can not \"optimize away\" any variable index based access to arrays. In fact depending on the code and compiler they may have a much harder time with something like this: if I am sequentially accessing an array but not in a very code clear manner the compiler may need to constantly generate code to recompute offset for array access. But if I use a post incrementing pointer to access and increment the compiler/code generation can use a incrementing access instruction, resulting in one less recompute of address. So how would the compiler be able to do better? At best it could match my code, and some times it generates less optimal code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35292, "question": "Thanks, but I guess maybe this is where I am a little confused. If one is always using fixed indexes for arrays I completely agree, but compilers can not \"optimize away\" any variable index based access to arrays. In fact depending on the code and compiler they may have a much harder time with something like this: if I am sequentially accessing an array but not in a very code clear manner the compiler may need to constantly generate code to recompute offset for array access. But if I use a post incrementing pointer to access and increment the compiler/code generation can use a incrementing access instruction, resulting in one less recompute of address. So how would the compiler be able to do better? At best it could match my code, and some times it generates less optimal code.", "aSentId": 35293, "answer": "I think you missed my point. In your case, you need raw pointers, so use raw pointers.\n\nHowever a lot of programmers use pointers for things where references would do just as fine. In those cases, using references instead of pointers can result in a speed improvement. Because C++ gives us so many tools to work with (references, ref-counted pointers, single ownership pointers, raw pointers, etc) it's up to us to pick the right tool for the right job.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35292, "question": "Thanks, but I guess maybe this is where I am a little confused. If one is always using fixed indexes for arrays I completely agree, but compilers can not \"optimize away\" any variable index based access to arrays. In fact depending on the code and compiler they may have a much harder time with something like this: if I am sequentially accessing an array but not in a very code clear manner the compiler may need to constantly generate code to recompute offset for array access. But if I use a post incrementing pointer to access and increment the compiler/code generation can use a incrementing access instruction, resulting in one less recompute of address. So how would the compiler be able to do better? At best it could match my code, and some times it generates less optimal code.", "aSentId": 35295, "answer": "Basically you are correct, I don't think /u/bstamour is talking about array iteration at all, I'm not sure how references could work there.\n\nMind you, in C++ you'll generally use iterators, which in the case of `std::vector` (and similar) will compile to the same, optimal, pointer manipulation code.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35297, "question": "Under the hood, references ARE pointers, unless you are taking references to sub structs and the compiler can just use the base pointer.\n\n ", "aSentId": 35298, "answer": "Compilers are free to implement references as pointers, so your statement is very dependent on which compiler you're using. If you read the ISO standard (or the free draft standard) nowhere does it mention that references need be implemented in terms of pointers. It does, however, explicitly state that it is unspecified whether or not references require storage at all.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35300, "question": "They're only adding optional features for people that aren't dealing with time critical code, though.  Are there any new features you'd want for time critical code?", "aSentId": 35301, "answer": "Nothing off the top of my head that doesn't tie to the underlying OS. One of the reasons I personally like C/C++ for time critical and performance applications is that it has a lot of good constructs for this application. The \"higher up\" the layer of C++ abstraction we go the less clear the implications are at code generation level. As you pointed out the beauty with the language is that it allows for both high and low level code to co-exist, even in one file. I guess I am a bit concerned how much of C++ is evolving towards high level code, and that people really may be losing sight of the elements that are dangerous to use carelessly or could result in bad code, but in the right hands are very useful. We really don't need another C# or Java.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35300, "question": "They're only adding optional features for people that aren't dealing with time critical code, though.  Are there any new features you'd want for time critical code?", "aSentId": 35303, "answer": "Move semantics?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35266, "question": "Because pointers themselves are too vague, furthermore direct pointer access makes code **less** efficient, not more.  C++ reduces the use of direct pointer manipulation in favor of specific, orthogonal use cases.  Not only does this eliminate entire classes of bugs, but it also allows better optimization as the compiler can make stronger assumptions about how a language feature will be used.  The more general a language feature is, the less the compiler can infer about how that feature will be used and hence must generate code to accommodate all of its potential use cases.\n\nThis is why C++ outperforms C in almost all cases.\n\n&gt;Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.\n\nThat statement is a tautology, anything done that isn't beneficial is by definition not a good thing.  The point is that a language providing a strong type system that restricts the use of language features to only those which are provably valid are beneficial.\n\nThat's the direction that C++ and modern statically typed languages like Rust are headed towards.  In Rust, you can't even misuse a pointer period, every operation you perform on memory must be provably correct.", "aSentId": 35305, "answer": "&gt; Because pointers themselves are too vague, furthermore direct pointer access makes code less efficient, not more. \n\nIn the context of array element access and iterating over arrays, care to share an example where pointer manipulation is slower than the C++ alternative? \n\nAnd remember, iterators basically **are** pointer manipulation in this case, so they're not an alternative approach.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35262, "question": "Why exactly? Pointer manipulation is one of most powerful aspects of using C over any other \"managed\" language. There are times where direct pointer access and manipulation results in much better and efficient code. Constantly \"protecting\" the programmer when it is not beneficial is NOT a good thing.", "aSentId": 35307, "answer": "&gt; Pointer manipulation is one of most powerful aspects of using C over any other \"managed\" language.\n\nI think you've misunderstood me slightly (which is fair enough). I'm not saying that pointers are a bad thing, just that *directly manipulating* them is a can of worms if you're not careful. What I'm saying is that with C++ 11 onwards, you need never do another new or delete again. What's more, references can improve performance without the risks you get with directly manupulating pointers.\n\nOne of the great things about C++ is that its applicable to nearly everybody's use case and no doubt there will be instances where raw pointer manipulation is what's best, but that isn't the case for a good 99% of code out there. It's nice that we now have more, better options.\n\n[This](http://www.lb-stuff.com/pointers) is a good little read, albeit slightly outdated by now.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35260, "question": "Stuff like this makes me happy that C++11 onwards seems to be shifting away from direct pointer manipulation.", "aSentId": 35310, "answer": "Pointers ftw.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35311, "question": "Pointers ftw.", "aSentId": 35312, "answer": "When they're absolutely necessary. std::unique_ptr is typically as fast as raw pointers (possibly faster in some cases due to move semantics?), but you never have to worry about forgetting to free/`delete` it (nor can you do so twice).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35313, "question": "When they're absolutely necessary. std::unique_ptr is typically as fast as raw pointers (possibly faster in some cases due to move semantics?), but you never have to worry about forgetting to free/`delete` it (nor can you do so twice).", "aSentId": 35314, "answer": "What about when I want to write to 0xf000abcd because a memory mapped register is at that location.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35315, "question": "What about when I want to write to 0xf000abcd because a memory mapped register is at that location.", "aSentId": 35316, "answer": "Then you're doing low level work, and you use raw pointers. They still work, you know. :)  \n\nHigh-level abstractions are useful for high-level work. I use them for application development, but when doing kernel hacking, I use C. (A large subset of C++ would work just as well, of course.)\n\nEdit: Heck, I did write to use raw pointers \"When they're absolutely necessary\" in my first comment. Clearly, they are \"absolutely necessary\" when you're not even dealing with allocated memory, since unique_ptr's *only function* is to manage allocated memory.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35313, "question": "When they're absolutely necessary. std::unique_ptr is typically as fast as raw pointers (possibly faster in some cases due to move semantics?), but you never have to worry about forgetting to free/`delete` it (nor can you do so twice).", "aSentId": 35318, "answer": "I don't think move semantics should make `unique_ptr` any faster than raw pointers.\n\nIn a general sense move semantics let you call the move assignment operator or move constructor; but the insides of those functions still just move data around like normal-- just with more leeway about what state they can leave the parameter in.\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35313, "question": "When they're absolutely necessary. std::unique_ptr is typically as fast as raw pointers (possibly faster in some cases due to move semantics?), but you never have to worry about forgetting to free/`delete` it (nor can you do so twice).", "aSentId": 35320, "answer": "&gt; std::unique_ptr is typically as fast as raw pointers (possibly faster in some cases due to move semantics?)\n\nWhen I hear people talking about C++ it's like I'm actually in /r/VXJunkies ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35324, "question": "Hi /r/programming, I've halted development on an open-source side-project for image and video frame filtering on Android. Would anybody use this? (If there's interest, I'll continue development and release it.)", "aSentId": 35325, "answer": "Maybe consider asking /r/androiddev", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35326, "question": "Maybe consider asking /r/androiddev", "aSentId": 35327, "answer": "And perhaps /r/computervision ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35326, "question": "Maybe consider asking /r/androiddev", "aSentId": 35329, "answer": "If he is looking to release it for use probably /r/android as well.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35326, "question": "Maybe consider asking /r/androiddev", "aSentId": 35331, "answer": "But there's only like 5 people there", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35332, "question": "But there's only like 5 people there", "aSentId": 35333, "answer": "Really? It says there are 100+ ppl viewing the subreddit and 36k subs... ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35334, "question": "Really? It says there are 100+ ppl viewing the subreddit and 36k subs... ", "aSentId": 35335, "answer": "Eh I was exaggerating. But only 1 of the current 10 posts up have over 10 comments. That's pretty low", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35324, "question": "Hi /r/programming, I've halted development on an open-source side-project for image and video frame filtering on Android. Would anybody use this? (If there's interest, I'll continue development and release it.)", "aSentId": 35337, "answer": "It seems interesting and useful to me, sorry that you're feeling discouraged about it.\n\nThe project I personally would look at using it for is queued behind my current project, so I can't say \"yes I would use this ASAP!\" -- but I bet such people are out there.\n\nAlso note that, although lots of people currently are saying \"google glass is dead\", they are misquoting and misunderstanding what Google said, which is that they are regrouping and that it will return once they get it together.\n\nAnd aside from Glass, there's a bunch of high powered augmented reality projects going on currently, the best-funded of which is clearly Magic Leap at half a billion dollars, but Microsoft and others are into it too.\n\nSo projects like this are on the bleeding edge prior to massive product releases and creation of a new industry; you should expect only early-adopter-developers to see uses for it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35324, "question": "Hi /r/programming, I've halted development on an open-source side-project for image and video frame filtering on Android. Would anybody use this? (If there's interest, I'll continue development and release it.)", "aSentId": 35339, "answer": "Why did you halt development? ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35340, "question": "Why did you halt development? ", "aSentId": 35341, "answer": "A larger project I used it in (currently not open source)\nonly needs the small set of features that I've implemented.\nMy focus has since shifted onto another project,\nso finishing the library doesn't have any clear\nbenefits to me unless other people are\ninterested in using it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35346, "question": "Can you explain what someone can do with it? ", "aSentId": 35347, "answer": "Yes - please do explain.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35349, "question": "I wish I was interested in this because it seems you've put a ton of work into it judging by the readme. If you happened to be working on the speech recognition I would be all over it. For some reason only people at Carnegie Mellon are interested in speech recognition. What a funny name for a school Carnegie Mellon.", "aSentId": 35350, "answer": "What would you call the merger of the Carnegie Institute of Technology and the Mellon Institute of Industrial Research?\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35351, "question": "What would you call the merger of the Carnegie Institute of Technology and the Mellon Institute of Industrial Research?\n\n", "aSentId": 35352, "answer": "Carnellon", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35351, "question": "What would you call the merger of the Carnegie Institute of Technology and the Mellon Institute of Industrial Research?\n\n", "aSentId": 35354, "answer": "Carmel.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35356, "question": "Throw it up on Github!", "aSentId": 35357, "answer": "Am I missing something?  OP's link is to github", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35358, "question": "Am I missing something?  OP's link is to github", "aSentId": 35359, "answer": "I missed that completely, my apologies.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35362, "question": "Finding the fastest Turing Machine that computes a given function is uncomputable. (And the consequences for superoptimisation)", "aSentId": 35363, "answer": "Wikipedia tells me that superoptimization is posed as applicable to loop-free code, so the halting problem isn't relevant.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35364, "question": "Wikipedia tells me that superoptimization is posed as applicable to loop-free code, so the halting problem isn't relevant.", "aSentId": 35365, "answer": "Super-optimization has come a long way since 1987; go check out stuff by Bansal &amp; Aiken, or more recent stuff from Regehr. For a completely different mechanism for defining 'fast', there's also the work by Tate, Stepp, Tatlock, and Lerner (Equality Saturation).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35364, "question": "Wikipedia tells me that superoptimization is posed as applicable to loop-free code, so the halting problem isn't relevant.", "aSentId": 35367, "answer": "It's true that existing superoptimisers seem to focus only on loop-free code.  However I don't see why superoptimisation can't be applied to some programs with loops, for example loops with bounded number of iterations.\n\nI think it's interesting to establish theoretical bounds on these things - what is and isn't possible in theory.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35368, "question": "It's true that existing superoptimisers seem to focus only on loop-free code.  However I don't see why superoptimisation can't be applied to some programs with loops, for example loops with bounded number of iterations.\n\nI think it's interesting to establish theoretical bounds on these things - what is and isn't possible in theory.", "aSentId": 35369, "answer": "If the iteration number is bounded, is it really a loop?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35370, "question": "If the iteration number is bounded, is it really a loop?", "aSentId": 35371, "answer": "No; iterated loops are a special case of code redundancy reduction.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35362, "question": "Finding the fastest Turing Machine that computes a given function is uncomputable. (And the consequences for superoptimisation)", "aSentId": 35373, "answer": "I think that rather than proving that optimizing a function is uncomputable, it is proving that optimizing a program that doesn't halt is impossible.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35362, "question": "Finding the fastest Turing Machine that computes a given function is uncomputable. (And the consequences for superoptimisation)", "aSentId": 35375, "answer": "I don't see that this has any significant consequences... even if was computable the time constraints would never allow it to be used for long programs. Given we are limiting the length of the input somehow, then it becomes computable because there are just a finite number of programs, and you can try each one of them.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35377, "question": "Got a spam email with an attached HTML file. Seems to have a javascript program, but I can't figure out what it does.", "aSentId": 35378, "answer": "Above answers are great. The takeaway is never, for the love of all that you hold dear, open something that runs Javascript like this. That particular combination of encoded folderol is rarely legit.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35380, "question": "Source code for JPS+ with Goal Bounding. 100x faster than A*! (x-post /r/gamedev)", "aSentId": 35381, "answer": "&gt; This project implements 2D grid pathfinding using JPS+ with Goal Bounding.[...] The compromise with using Goal Bounding is that the Goal Bounding data must be preprocessed offline taking O(n^2) time, thus making it not feasible to support dynamic runtime modifications of the search space (adding or removing edges/walls).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35383, "question": "Interview questions and real software engineering", "aSentId": 35384, "answer": "I think one of the primary angles one should try to gather from a SE job interview is a candidates motivation for a technical decision.  In other words, I don't want to know just how you would solve a given problem;  I want you to explain to me why you solved the problem that way.  \n\nIt's a fine art of critical thinking, business domain intelligence, and technical application.   \n\nFor me, knowing how to ask, and apply the question of 'why?' is the quintessential defining point for what makes a software engineer, and to a superset extension - a technical architect.  In other words, can I take a business need, ask a set of questions to dilute the problem down to it's core, and apply a set of technical decisions and principles that can be verified empirically.  \n\nHaving a candidate open-stream-of-consciousness go through some critical thinking of some sort is satisfying to me.  \n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35383, "question": "Interview questions and real software engineering", "aSentId": 35386, "answer": "I don't think hard interview questions are really a problem. The problem is how the answers are interpreted by the interviewers.\n\nYou can learn a lot about someone's programming ability, problem-solving ability, past experience, software architecture preferences, etc. from the answers to hard coding questions. That insight is a lot more important that requiring that the interviewee produces a perfect solution to the problem.\n\nThe situation is similar to the controversy in education regarding \"teaching to the test.\" Teaching to the test is probably bad, but that doesn't mean that tests are bad. Hard coding questions in interviews aren't bad either, as long as we know what to do with the answers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35387, "question": "I don't think hard interview questions are really a problem. The problem is how the answers are interpreted by the interviewers.\n\nYou can learn a lot about someone's programming ability, problem-solving ability, past experience, software architecture preferences, etc. from the answers to hard coding questions. That insight is a lot more important that requiring that the interviewee produces a perfect solution to the problem.\n\nThe situation is similar to the controversy in education regarding \"teaching to the test.\" Teaching to the test is probably bad, but that doesn't mean that tests are bad. Hard coding questions in interviews aren't bad either, as long as we know what to do with the answers.", "aSentId": 35388, "answer": "I think you maybe missed the point of the article. I believe it was, at least in part, attempting to assert that the \"hard interview questions\" asked during many technical interviews don't actually test a candidate's software engineering skills very well. Rather, that they test a subset of software engineering skills, and not even the most important subset. The author admits that he's unsure how to design interview questions that better reflect a candidate's ability to tackle the (in his opinion) more difficult aspects of software engineering.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35389, "question": "I think you maybe missed the point of the article. I believe it was, at least in part, attempting to assert that the \"hard interview questions\" asked during many technical interviews don't actually test a candidate's software engineering skills very well. Rather, that they test a subset of software engineering skills, and not even the most important subset. The author admits that he's unsure how to design interview questions that better reflect a candidate's ability to tackle the (in his opinion) more difficult aspects of software engineering.", "aSentId": 35390, "answer": "Separate writing competent code from the engineering solutions that go into making it. Ask them as separate questions (or as completely different tasks honestly).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35389, "question": "I think you maybe missed the point of the article. I believe it was, at least in part, attempting to assert that the \"hard interview questions\" asked during many technical interviews don't actually test a candidate's software engineering skills very well. Rather, that they test a subset of software engineering skills, and not even the most important subset. The author admits that he's unsure how to design interview questions that better reflect a candidate's ability to tackle the (in his opinion) more difficult aspects of software engineering.", "aSentId": 35392, "answer": "It really depends on who you're hiring and why - a \"stage 4\" question is about all I'd expect a college hire to be able to handle, but if you've got three or four years of experience you'd better be able to do a \"stage 3\" discussion.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35383, "question": "Interview questions and real software engineering", "aSentId": 35394, "answer": "&gt; step 4 covers a problem space within constraints that make it finite and explorable. An interview concentrating on this will cover how quickly you can navigate a finite space. I believe this step can be solved completely by better programming languages.\n\nThere are actually people who believes in stuff like this?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35397, "question": "Announcing neural2d, a neural net optimized for image processing written in c++", "aSentId": 35398, "answer": "If I understood the wiki correctly, what the author is calling convolution layers doesn't correspond to convolutional neural networks as the term is used in the field of machine learning. In a convolutional network, the kernels themselves are learned by the training algorithm, whereas this program requires them to be manually specified. Also, you can have full connections between layers of M and N convolutional kernels of sizes X and Y, which requires a 4-tensor of weight parameters.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35397, "question": "Announcing neural2d, a neural net optimized for image processing written in c++", "aSentId": 35400, "answer": "Cool stuff, thanks!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35402, "question": "Using Immutable Objects for Persistence in Java", "aSentId": 35403, "answer": "Put the id field in an entity base class with all the other metadata, make the id setter private, minimize the scope of any transients, and avoid all this mess. \n\n&gt; But all the fields aren't final and immutable!\n\nSo? \n\nAre you changing the id field from multiple threads? \n\nTrying to use it in a key to a set / map or equals and hashcode implementation? \n\n( If you are doing one of those two things, stop it. )\n\nIsn't being able to check the id field for null a much simpler and more convenient way to reason about the persistence state of the object than creating a *Draft for every entity in your domain. \n\nIs this really buying you anything or is it just design pattern OCD? \n\nI'm not saying it's the latter, but reading so much of *ruin* and *dirty* and *pollute* makes me highly suspect it. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35404, "question": "Put the id field in an entity base class with all the other metadata, make the id setter private, minimize the scope of any transients, and avoid all this mess. \n\n&gt; But all the fields aren't final and immutable!\n\nSo? \n\nAre you changing the id field from multiple threads? \n\nTrying to use it in a key to a set / map or equals and hashcode implementation? \n\n( If you are doing one of those two things, stop it. )\n\nIsn't being able to check the id field for null a much simpler and more convenient way to reason about the persistence state of the object than creating a *Draft for every entity in your domain. \n\nIs this really buying you anything or is it just design pattern OCD? \n\nI'm not saying it's the latter, but reading so much of *ruin* and *dirty* and *pollute* makes me highly suspect it. ", "aSentId": 35405, "answer": "Valid points. I might be missing something but I believe the approach you mentioned still does not address the case where you update the field of an entity. That is, its `id` is not null, but you modified its `name` and it still looks like a valid `Employee`, which actually is not the case. Adding a `this.id = null` line to every setter? Yep, it can also work. But I would not prefer that way. My actual point was that the moment you change `Employee`, it is not an `Employee` anymore. And I personally like to work with immutable objects *wherever* possible, not because of a certain thread safety or whatever need, but to avoid potential future problems. And I believe it also provides a comfort that you are assured that it will never ever be changed.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35406, "question": "Valid points. I might be missing something but I believe the approach you mentioned still does not address the case where you update the field of an entity. That is, its `id` is not null, but you modified its `name` and it still looks like a valid `Employee`, which actually is not the case. Adding a `this.id = null` line to every setter? Yep, it can also work. But I would not prefer that way. My actual point was that the moment you change `Employee`, it is not an `Employee` anymore. And I personally like to work with immutable objects *wherever* possible, not because of a certain thread safety or whatever need, but to avoid potential future problems. And I believe it also provides a comfort that you are assured that it will never ever be changed.", "aSentId": 35407, "answer": "That's because entities exist to represent mutable state across an object-relational impedance, i.e. a record in a database that can not only be read but also written to concurrently. \n\nYou will always find that trying to turn a thing which is fundamentally *A* into fundamentally *Not A* painful. \n\nPainful doesn't mean impossible, but you're going to write an order of magnitude or more code that is really hard to reason with and maintain, and that's to do really simple things.\n\nFor an example of that, check out Command Query Responsibility Separation with Event Sourcing. \n\n&gt; not because of a certain thread safety or whatever need, but to avoid potential future problems.\n\nWhat future problems? Are you being unspecific because you didn't think the details were important or because you currently can't anticipate a problem but think there might be one if you aren't immutable everywhere? \n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35406, "question": "Valid points. I might be missing something but I believe the approach you mentioned still does not address the case where you update the field of an entity. That is, its `id` is not null, but you modified its `name` and it still looks like a valid `Employee`, which actually is not the case. Adding a `this.id = null` line to every setter? Yep, it can also work. But I would not prefer that way. My actual point was that the moment you change `Employee`, it is not an `Employee` anymore. And I personally like to work with immutable objects *wherever* possible, not because of a certain thread safety or whatever need, but to avoid potential future problems. And I believe it also provides a comfort that you are assured that it will never ever be changed.", "aSentId": 35409, "answer": "&gt;And I personally like to work with immutable objects wherever possible\n\nHave you ever worked with Scala? Scala attempts to enforce as much immutibility as possible. Plus, Scala case classes come with a .copy method which allows you to update fields like:\n\n    val instanceWithUpdatedFields = myInstance.copy(someField = newValue) \n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35402, "question": "Using Immutable Objects for Persistence in Java", "aSentId": 35411, "answer": "I did something similar at my last job, in Scala though. But I defined the Draft as simply:\n\n    type EmployeeDraft = ID -&gt; Employee\n\nFor those that don't know Scala/Haskell syntax, this means that EmployeeDraft is just a function from ID to Employee. So when you are making a draft, you define everything by the ID, like so:\n\n    mkDraft :: String -&gt; Int -&gt; String -&gt; EmployeeDraft\n    mkDraft name age occupation = \\id -&gt; Employee id name age occupation\n\nSo you take the stuff you know (name, age, occupation) and return a function that will take the id. At DB-saving time:\n\n    saveEmployee :: EmployeeDraft -&gt; Employee\n    saveEmployee draft = save(draft(null))\n\n(ofc, Employee would be in IO, but ignore that). ID can be anything, even null maybe, at DB inserting time since it will be overwritten (ignored).\n\nOfc, this didn't really matter at the end of the day. We moved away from this pattern and just started using Optional Id (they are immutable and allow for the \"not there yet\" state). Sadly, however, Optional Ids don't type-safe your state, so for you to know that someone has an ID (ie: is in the DB), you need to ask the object if ID is defined. The `EmployeeDraft` type, on the other hand, gives you a different type so you can't accidentally add Draft when a complete employee is expected. \n\nBut it was a fun little experiment though, I might come back to it. Main reason we didn't stick with it was the DB framework we were using worked best with Optional Ids. \n\nEDIT: Multiple typos and some clarification. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35402, "question": "Using Immutable Objects for Persistence in Java", "aSentId": 35413, "answer": "If anybody had ever met with a similar technique, know the name of the used design pattern, etc. please do add a comment to the post about this.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35414, "question": "If anybody had ever met with a similar technique, know the name of the used design pattern, etc. please do add a comment to the post about this.", "aSentId": 35415, "answer": "For the immutable objects, it's called builder pattern. The author calls everything \"entity\" for some reason. He needed a few months for it but successfully invented the DTO pattern (Data Transfer Object).\n\n\nI also don't get why he wants to pass around entities outside the persistence layer. He is not well educated.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35416, "question": "For the immutable objects, it's called builder pattern. The author calls everything \"entity\" for some reason. He needed a few months for it but successfully invented the DTO pattern (Data Transfer Object).\n\n\nI also don't get why he wants to pass around entities outside the persistence layer. He is not well educated.", "aSentId": 35417, "answer": "Hey @Soultrane9! I am the author of the post. Hence, first thanks for the comments.\n\n* I used *model* and *entity* interchangeably throughout the post in order to be aligned with the same terminology used in persistence APIs, such as, JPA, Spring Data.\n* DTO pattern was a good catch. This can be thought as an application of the pattern. That being said, in Wikipedia it is stated that *The motivation for its use has to do with the fact that communication between processes is usually done resorting to remote interfaces (e.g. web services), where each call is an expensive operation.* In my case, I am not motivated by the communication overhead, in fact using immutable objects significantly increases this cost. Rather, I want to make it possible to work with immutable objects.\n* Everybody passes data around, to JSPs, to remote services, to a library function, etc. Assuming that the remote interface requires almost all available fields of the entity, why not passing it the immutable entity as is, instead of wrapping it with yet another transfer object?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35418, "question": "Hey @Soultrane9! I am the author of the post. Hence, first thanks for the comments.\n\n* I used *model* and *entity* interchangeably throughout the post in order to be aligned with the same terminology used in persistence APIs, such as, JPA, Spring Data.\n* DTO pattern was a good catch. This can be thought as an application of the pattern. That being said, in Wikipedia it is stated that *The motivation for its use has to do with the fact that communication between processes is usually done resorting to remote interfaces (e.g. web services), where each call is an expensive operation.* In my case, I am not motivated by the communication overhead, in fact using immutable objects significantly increases this cost. Rather, I want to make it possible to work with immutable objects.\n* Everybody passes data around, to JSPs, to remote services, to a library function, etc. Assuming that the remote interface requires almost all available fields of the entity, why not passing it the immutable entity as is, instead of wrapping it with yet another transfer object?", "aSentId": 35419, "answer": "&gt; Everybody passes data around, to JSPs, to remote services, to a library function, etc. Assuming that the remote interface requires almost all available fields of the entity, why not passing it the immutable entity as is, instead of wrapping it with yet another transfer object?\n\nIn most systems I've worked on, the service defines separate classes for requests and responses even if they represent the same type of data. There may be fields that are derived only by the service (e.g. id) that might not needed in a request. Similarly, different types of requests might need different arguments. If you use the same class for all requests and responses you will end up bloating the class and confusing future programmers with unnecessary fields.\n\nOne of the main advantages of immutable objects is readability. If you use one object for everything and it becomes bloated, then you've ruined one of the benefits of immutable classes. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35418, "question": "Hey @Soultrane9! I am the author of the post. Hence, first thanks for the comments.\n\n* I used *model* and *entity* interchangeably throughout the post in order to be aligned with the same terminology used in persistence APIs, such as, JPA, Spring Data.\n* DTO pattern was a good catch. This can be thought as an application of the pattern. That being said, in Wikipedia it is stated that *The motivation for its use has to do with the fact that communication between processes is usually done resorting to remote interfaces (e.g. web services), where each call is an expensive operation.* In my case, I am not motivated by the communication overhead, in fact using immutable objects significantly increases this cost. Rather, I want to make it possible to work with immutable objects.\n* Everybody passes data around, to JSPs, to remote services, to a library function, etc. Assuming that the remote interface requires almost all available fields of the entity, why not passing it the immutable entity as is, instead of wrapping it with yet another transfer object?", "aSentId": 35421, "answer": "Yeah i'm not going into a debate with someone who is passing entities to client side. Just continue your mental masturbation.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35423, "question": "What is the need for immutable objects in a data store? It's easy to know if an entity is associated with a persistence layer; the identifier field is not null. I'm at a loss for why you find it necessary to add this layer of complexity when the developers of the persistence frameworks have not over the past 15 years. ", "aSentId": 35424, "answer": "The need comes from the fact that 1) you want to use immutable objects throughout your entire code base (I prefer not go into discussion about this point) and 2) you want a mechanism to differentiate instances that are retrieved from the data store and that are generated by the application artificially.\n\nAbout the null `id` field solution, what if I'd update the `name` of an `Employee` instance who already has an `id`? Will it sill be a valid `Employee`? But it has a valid `id`!\n\nI am not claiming that there is no known solution. I just said, there is none that *I* know of. And, I really do not think persistence frameworks do really care about immutability. After all, most of the time they are modifying the instance in various hairy ways.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35425, "question": "The need comes from the fact that 1) you want to use immutable objects throughout your entire code base (I prefer not go into discussion about this point) and 2) you want a mechanism to differentiate instances that are retrieved from the data store and that are generated by the application artificially.\n\nAbout the null `id` field solution, what if I'd update the `name` of an `Employee` instance who already has an `id`? Will it sill be a valid `Employee`? But it has a valid `id`!\n\nI am not claiming that there is no known solution. I just said, there is none that *I* know of. And, I really do not think persistence frameworks do really care about immutability. After all, most of the time they are modifying the instance in various hairy ways.", "aSentId": 35426, "answer": "&gt; 1) you want to use immutable objects throughout your entire code base (I prefer not go into discussion about this point)\n\nImmutable objects throughout your code base? Are you using J2EE? Perhaps you should look into a paper-based solution.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35428, "question": "Why not take the Hibernate-esque route and only allow instantiation of entity objects (well, the interface they implement) via a factory that spits out a simple Proxy that only knows how to hold on to an ID value?\n\nYou can even hot-swap the actual entity impl object underneath if/when the persistence layer finds the data for it. All this can be accomplished using an InvocationHandler (read: no need to get super fancy and use AspectJ, CGLIB, etc).\n\nAll that said, if you really, really want to use immutable objects as your persistence layer, you'd be better off using Hibernate + a custom Cursor that knows how to read the fields/properties of the objects: you'd get transactions, multi-level caching, etc, all with only a minimal amount of configuration.", "aSentId": 35429, "answer": "I have never gone into that route. But one thing that I had learnt from purposing a framework for a goal that itself was not designed to provide feels like swimming against stream and most of the time ends in misery. That being said, your mileage may vary and I would appreciate a sample implementation.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35431, "question": "when you use a repository in a java framework (like spring) does it ALWAYS make database calls or does it use some magic to save DB calls?  Asking because the software I'm working on has too many DB calls and I'm trying to beef up my repository classes.", "aSentId": 35432, "answer": "Depends. If you're using JPA, each EntityManager caches the entities it's loaded, so subsequent loads of entities won't hit the DB. Also, Hibernate can use EHCache, Infinispan, etc for L2 caching of queries and entities.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35433, "question": "Depends. If you're using JPA, each EntityManager caches the entities it's loaded, so subsequent loads of entities won't hit the DB. Also, Hibernate can use EHCache, Infinispan, etc for L2 caching of queries and entities.", "aSentId": 35434, "answer": "thanks!  What about using a DTO as an intermediate?  to move the objects from an expensive database to a cheaper local one for instance?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35438, "question": "Switching to uuids seems like a far simpler solution.   Just assign on initial construction to a new value.  Solves the issues without adding complexity", "aSentId": 35439, "answer": "But it still does not solve the problem of knowing whether a given instance is actually associated with a repository record or not.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35440, "question": "But it still does not solve the problem of knowing whether a given instance is actually associated with a repository record or not.", "aSentId": 35441, "answer": "Why do you care?   Way to much overhead for a worse case extra unsert.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35443, "question": "Why we chose Ember", "aSentId": 35444, "answer": "&gt; Backbone serves as a light and flexible framework in true configuration over convention fashion. It allows users to implement features in whatever way that suits their fancy. While this might allow for quick development in the short-term, in the long-term, development with little or convention leads to spaghetti code and code reviews resembling boxing matches. \n\nI disagree with most of this comment.  My opinion is that configuration slows down development short-term but gives you the flexibility to do things you never anticipated long term.  Although I *do* agree that configuration leads to more spaghetti code.  ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35445, "question": "&gt; Backbone serves as a light and flexible framework in true configuration over convention fashion. It allows users to implement features in whatever way that suits their fancy. While this might allow for quick development in the short-term, in the long-term, development with little or convention leads to spaghetti code and code reviews resembling boxing matches. \n\nI disagree with most of this comment.  My opinion is that configuration slows down development short-term but gives you the flexibility to do things you never anticipated long term.  Although I *do* agree that configuration leads to more spaghetti code.  ", "aSentId": 35446, "answer": "Depends. Configuration may be faster or slower than grokking a new convention. \n\nIf you have strong opinions about how to accomplish something, may be faster to use your existing paradigm now than to learn a new paradigm before starting. \n\nIf you have no idea how to accomplish something, learning conventions may get you started faster start than reinventing wheels. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35445, "question": "&gt; Backbone serves as a light and flexible framework in true configuration over convention fashion. It allows users to implement features in whatever way that suits their fancy. While this might allow for quick development in the short-term, in the long-term, development with little or convention leads to spaghetti code and code reviews resembling boxing matches. \n\nI disagree with most of this comment.  My opinion is that configuration slows down development short-term but gives you the flexibility to do things you never anticipated long term.  Although I *do* agree that configuration leads to more spaghetti code.  ", "aSentId": 35448, "answer": "I was confused by that at first too, but I think I get what he means.  If you're *familiar* with a framework that favors convention (like Angular), it makes it easy to get up an running quickly.  But, if you also need to learn the framework, it can be a long time learning all the conventions, vocabulary, file structure, etc before you can even start working on your app.  \n\nThat's why larger apps that you foresee growing in the future are better-suited for convention-heavy frameworks. But, if you're doing something quick and dirty it doesn't really make sense to use something so opinionated, you don't want 90% of your code base to end up skeleton code generated by s framework.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35443, "question": "Why we chose Ember", "aSentId": 35450, "answer": "At work we recently had to make a similar decision. It's cool other people are going through the same thought process as us, and ended up making the same decision. Ember does seem like the framework everyone overlooks on the cutting edge blogs, but their team seems to be the only sane one when it comes to real-life constraints.\n\nIt's like the React and especially Angular team don't understand that businesses are not going to dedicate time and resources to updating to a new version if it doesn't immediately contribute to their bottom line. Certainly not at the pace that they're developing now.\n\nWeb development has an attitude of 'move fast, break things' that is simply not realistic for 90% of businesses out there, and Ember is the only framework that seems to understand this.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35451, "question": "At work we recently had to make a similar decision. It's cool other people are going through the same thought process as us, and ended up making the same decision. Ember does seem like the framework everyone overlooks on the cutting edge blogs, but their team seems to be the only sane one when it comes to real-life constraints.\n\nIt's like the React and especially Angular team don't understand that businesses are not going to dedicate time and resources to updating to a new version if it doesn't immediately contribute to their bottom line. Certainly not at the pace that they're developing now.\n\nWeb development has an attitude of 'move fast, break things' that is simply not realistic for 90% of businesses out there, and Ember is the only framework that seems to understand this.", "aSentId": 35452, "answer": "Not comparable in terms of scope but the knockout guys do this very well as well.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35451, "question": "At work we recently had to make a similar decision. It's cool other people are going through the same thought process as us, and ended up making the same decision. Ember does seem like the framework everyone overlooks on the cutting edge blogs, but their team seems to be the only sane one when it comes to real-life constraints.\n\nIt's like the React and especially Angular team don't understand that businesses are not going to dedicate time and resources to updating to a new version if it doesn't immediately contribute to their bottom line. Certainly not at the pace that they're developing now.\n\nWeb development has an attitude of 'move fast, break things' that is simply not realistic for 90% of businesses out there, and Ember is the only framework that seems to understand this.", "aSentId": 35454, "answer": "To be fair to the React team, their library isn't yet 1.0 and seems to be stable enough for internal use at Facebook. Hype-driven posts on blogs aside, Ember has a decent following (plenty of carry-over from the Rails community, I'd imagine) and quite a few successful apps in production, so it's not overlooked in that regard. \n\n&gt; Web development has an attitude of 'move fast, break things'... Ember is the only framework that seems to understand this.\n\nAnd Ember is successful for that reason. Hard to say if it's the fault of users for selecting unstable frameworks or framework maintainers for pushing out code like there's no tomorrow. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35451, "question": "At work we recently had to make a similar decision. It's cool other people are going through the same thought process as us, and ended up making the same decision. Ember does seem like the framework everyone overlooks on the cutting edge blogs, but their team seems to be the only sane one when it comes to real-life constraints.\n\nIt's like the React and especially Angular team don't understand that businesses are not going to dedicate time and resources to updating to a new version if it doesn't immediately contribute to their bottom line. Certainly not at the pace that they're developing now.\n\nWeb development has an attitude of 'move fast, break things' that is simply not realistic for 90% of businesses out there, and Ember is the only framework that seems to understand this.", "aSentId": 35456, "answer": "&gt; Ember does seem like the framework everyone overlooks on the  cutting edge blogs\n\nThose damn kids and their dogpile weblogs and hotmail hotbots!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35443, "question": "Why we chose Ember", "aSentId": 35458, "answer": "&gt; React.js promised potential but was young and in **flux**\n\nYep.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35460, "question": "Top Mobile Test Automation Frameworks with Code Examples", "aSentId": 35461, "answer": "Plenty of great information in about test automation and frameworks", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35460, "question": "Top Mobile Test Automation Frameworks with Code Examples", "aSentId": 35463, "answer": "Awesome, thanks for sharing. \n\nRegarding Appium - does it work identically on both Android and iOS?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35464, "question": "Awesome, thanks for sharing. \n\nRegarding Appium - does it work identically on both Android and iOS?", "aSentId": 35465, "answer": "Yes, it should, but according to Appium site Android is more flaky than iOS and lots of changes are constantly done for that.\n\nI've had working well for some time now (for Android and iOS).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35467, "question": "A General Theory of Reactivity", "aSentId": 35468, "answer": "This is really a lot of grand sounding prattle.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35470, "question": "How to take input from user in java", "aSentId": 35471, "answer": "scanner", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35473, "question": "Replacing Photoshop With NSString", "aSentId": 35474, "answer": "This reminds me of a testing technique I've used for code that generates 2D coordinates. My tests plot points into a 2D character array, then compare to an expected result. This technique makes it easier for a human to verify that the code is generating the right output, e.g.\n\n    . . 1 . .\n    . . . . .\n    . . 0 . .\n    2 . . . 3\n\nis easier to understand than this, where an incorrect number could easily go unnoticed:\n\n    {{2, 2}, {2, 0}, {0, 3}, {4, 3}}\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35475, "question": "This reminds me of a testing technique I've used for code that generates 2D coordinates. My tests plot points into a 2D character array, then compare to an expected result. This technique makes it easier for a human to verify that the code is generating the right output, e.g.\n\n    . . 1 . .\n    . . . . .\n    . . 0 . .\n    2 . . . 3\n\nis easier to understand than this, where an incorrect number could easily go unnoticed:\n\n    {{2, 2}, {2, 0}, {0, 3}, {4, 3}}\n", "aSentId": 35476, "answer": "I do something similar with data structures - a routine that dumps it to a file in graphviz's format. I can then turn it into an image and make sure everything's sorted right or linked properly with a glance.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35475, "question": "This reminds me of a testing technique I've used for code that generates 2D coordinates. My tests plot points into a 2D character array, then compare to an expected result. This technique makes it easier for a human to verify that the code is generating the right output, e.g.\n\n    . . 1 . .\n    . . . . .\n    . . 0 . .\n    2 . . . 3\n\nis easier to understand than this, where an incorrect number could easily go unnoticed:\n\n    {{2, 2}, {2, 0}, {0, 3}, {4, 3}}\n", "aSentId": 35478, "answer": "...Why do you have humans verifying code instead of code? :) You could always write a test helper that helps humans identify any discrepancies.\n\nAlso, what about rounding errors?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35479, "question": "...Why do you have humans verifying code instead of code? :) You could always write a test helper that helps humans identify any discrepancies.\n\nAlso, what about rounding errors?", "aSentId": 35480, "answer": "There are some use cases for human verification, I suppose. To protect from sophisticated hacking attempts, maybe. \n\nOpenSSH's `randomart` comes to mind. It's much easier for the human eye to see if someone has messed with it, compared to a regular hexadecimal representation of the fingerprint:\n\n    Generating public/private rsa key pair.\n    The key fingerprint is:\n    05:1e:1e:c1:ac:b9:d1:1c:6a:60:ce:0f:77:6c:78:47 you@i\n    The key's randomart image is:\n    +--[ RSA 2048]----+\n    |       o=.       |\n    |    o  o++E      |\n    |   + . Ooo.      |\n    |    + O B..      |\n    |     = *S.       |\n    |      o          |\n    |                 |\n    |                 |\n    |                 |\n    +-----------------+\n\nhttp://superuser.com/questions/22535/what-is-randomart-produced-by-ssh-keygen", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35481, "question": "There are some use cases for human verification, I suppose. To protect from sophisticated hacking attempts, maybe. \n\nOpenSSH's `randomart` comes to mind. It's much easier for the human eye to see if someone has messed with it, compared to a regular hexadecimal representation of the fingerprint:\n\n    Generating public/private rsa key pair.\n    The key fingerprint is:\n    05:1e:1e:c1:ac:b9:d1:1c:6a:60:ce:0f:77:6c:78:47 you@i\n    The key's randomart image is:\n    +--[ RSA 2048]----+\n    |       o=.       |\n    |    o  o++E      |\n    |   + . Ooo.      |\n    |    + O B..      |\n    |     = *S.       |\n    |      o          |\n    |                 |\n    |                 |\n    |                 |\n    +-----------------+\n\nhttp://superuser.com/questions/22535/what-is-randomart-produced-by-ssh-keygen", "aSentId": 35482, "answer": "That's a good use-case. There are some things that the human eye is better at immediately recognizing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35479, "question": "...Why do you have humans verifying code instead of code? :) You could always write a test helper that helps humans identify any discrepancies.\n\nAlso, what about rounding errors?", "aSentId": 35484, "answer": "Because if I was 100% sure how to solve [problem involving 2D coordinates] in code, I wouldn't be trying to debug the function for solving [problem involving 2D coordinates].", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35485, "question": "Because if I was 100% sure how to solve [problem involving 2D coordinates] in code, I wouldn't be trying to debug the function for solving [problem involving 2D coordinates].", "aSentId": 35486, "answer": "I think you're saying it helps with debugging.\n\nBut so do well-written tests.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35475, "question": "This reminds me of a testing technique I've used for code that generates 2D coordinates. My tests plot points into a 2D character array, then compare to an expected result. This technique makes it easier for a human to verify that the code is generating the right output, e.g.\n\n    . . 1 . .\n    . . . . .\n    . . 0 . .\n    2 . . . 3\n\nis easier to understand than this, where an incorrect number could easily go unnoticed:\n\n    {{2, 2}, {2, 0}, {0, 3}, {4, 3}}\n", "aSentId": 35488, "answer": "Nice. I'll have to remember that trick.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35473, "question": "Replacing Photoshop With NSString", "aSentId": 35490, "answer": "Hi, I am the author of the blog post. Just to clarify based on the comments: this was supposed to be a fun post about a one-day hack that I use for very simple icons, to avoid the hassle of an image editor (or vector editor), get pixel alignment easily, and also just because I can. Having the image right there in the code is a nice plus.\n\nAbout the plug for Findings at the top of the post: it makes me cringe a bit but I am happy with it and I stand by it. I am very proud of the app and I think it is genuinely useful for scientists and researchers. So there :-)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35491, "question": "Hi, I am the author of the blog post. Just to clarify based on the comments: this was supposed to be a fun post about a one-day hack that I use for very simple icons, to avoid the hassle of an image editor (or vector editor), get pixel alignment easily, and also just because I can. Having the image right there in the code is a nice plus.\n\nAbout the plug for Findings at the top of the post: it makes me cringe a bit but I am happy with it and I stand by it. I am very proud of the app and I think it is genuinely useful for scientists and researchers. So there :-)", "aSentId": 35492, "answer": "I always appreciate fun \"I want to see if I can do this\" projects. This is definitely something I've thought of doing in the past, so thanks for sharing.\n\nAlso, fuck the haters. You worked hard on something, promote it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35491, "question": "Hi, I am the author of the blog post. Just to clarify based on the comments: this was supposed to be a fun post about a one-day hack that I use for very simple icons, to avoid the hassle of an image editor (or vector editor), get pixel alignment easily, and also just because I can. Having the image right there in the code is a nice plus.\n\nAbout the plug for Findings at the top of the post: it makes me cringe a bit but I am happy with it and I stand by it. I am very proud of the app and I think it is genuinely useful for scientists and researchers. So there :-)", "aSentId": 35494, "answer": "What you did, effectively, is reinvent pixmaps. I've been making icons as ASCII for over a decade... never thought about how cool it is!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35495, "question": "What you did, effectively, is reinvent pixmaps. I've been making icons as ASCII for over a decade... never thought about how cool it is!", "aSentId": 35496, "answer": "I think this is actually a step _further_ than pixmaps, in fact, since it retrieves a _vector_ description of the image, whereas pixmaps are raster graphics.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35491, "question": "Hi, I am the author of the blog post. Just to clarify based on the comments: this was supposed to be a fun post about a one-day hack that I use for very simple icons, to avoid the hassle of an image editor (or vector editor), get pixel alignment easily, and also just because I can. Having the image right there in the code is a nice plus.\n\nAbout the plug for Findings at the top of the post: it makes me cringe a bit but I am happy with it and I stand by it. I am very proud of the app and I think it is genuinely useful for scientists and researchers. So there :-)", "aSentId": 35498, "answer": "Nice job! It looks pretty fun; it never would have occurred to me to represent anything other than bitmaps specially in code. Although I worry that if some of the more complex icons such as the bug and lock are difficult for the eye to interpret, wouldn't it defeat the purpose of storing them in a ASCII-graphical format?\n\nI know it can be difficult to make Inkscape output simple SVG files (some other commenters recommended specific settings to use -- I'll have to try them sometime). My biggest annoyances are its placing the origin in the bottom-left corner and its zeal to use the translate=\"\" attribute instead of simply moving the elements. For toy projects and simple icons I've taken to simply writing the SVG code by hand, and websites such as Codepen make the write-save-test cycle stupidly short.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35473, "question": "Replacing Photoshop With NSString", "aSentId": 35502, "answer": "The concept is cute but that looks outrageously unmanageable. I can't help but think this creates more problems than it solves.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35503, "question": "The concept is cute but that looks outrageously unmanageable. I can't help but think this creates more problems than it solves.", "aSentId": 35504, "answer": "Expressed well by this comment...\n\n&gt;That's impressive. But have you ever heard of SVG?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35505, "question": "Expressed well by this comment...\n\n&gt;That's impressive. But have you ever heard of SVG?", "aSentId": 35506, "answer": "Is there is a decent SVG editor out there that is as good as this at creating pixel-aligned icons quickly? That's really all you need.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35507, "question": "Is there is a decent SVG editor out there that is as good as this at creating pixel-aligned icons quickly? That's really all you need.", "aSentId": 35508, "answer": "It'd be easy to whip up any of those icons in Inkscape in a few seconds.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35509, "question": "It'd be easy to whip up any of those icons in Inkscape in a few seconds.", "aSentId": 35510, "answer": "Yes, but would the output be as simple?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35511, "question": "Yes, but would the output be as simple?", "aSentId": 35512, "answer": "Yes, if you setup the size properly.\n\n    inkscape icon.svg -jC -i icon -e png/icon-x1.png -d 90\n    inkscape icon.svg -jC -i icon -e png/icon-x2.png -d 180\n    inkscape icon.svg -jC -i icon -e png/icon-x3.png -d 270 ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35513, "question": "Yes, if you setup the size properly.\n\n    inkscape icon.svg -jC -i icon -e png/icon-x1.png -d 90\n    inkscape icon.svg -jC -i icon -e png/icon-x2.png -d 180\n    inkscape icon.svg -jC -i icon -e png/icon-x3.png -d 270 ", "aSentId": 35514, "answer": "Damn'it... how the hell I was not aware of this? :D\n\nI've spent way too much trying to get logos look pixel perfect (also didn't know how to call it) - never found a nice way to do it. Even experimented with font software, i.e. draw the icon as a font and do the hinting there. PS: Any other good tips for making icons look good?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35507, "question": "Is there is a decent SVG editor out there that is as good as this at creating pixel-aligned icons quickly? That's really all you need.", "aSentId": 35516, "answer": "[Sketch](http://bohemiancoding.com/) is amazing for that. I've started using it for every project. It's a really easy vector editor made for UI design.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35507, "question": "Is there is a decent SVG editor out there that is as good as this at creating pixel-aligned icons quickly? That's really all you need.", "aSentId": 35518, "answer": "Any vector graphics software can create pixel perfect vector icons. The trick is to draw on a canvas that starts with the correct size. Don't design on a 500x500px canvas when it should work as a 16x16 icon. The downscaling will be unpredictable. You need to design small and then on the web it'll upscale (for example for retina displays).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35519, "question": "Any vector graphics software can create pixel perfect vector icons. The trick is to draw on a canvas that starts with the correct size. Don't design on a 500x500px canvas when it should work as a 16x16 icon. The downscaling will be unpredictable. You need to design small and then on the web it'll upscale (for example for retina displays).", "aSentId": 35520, "answer": "I disagree. If you want a good vector icon, just make sure your canvas size is *a multiple of your target size*. So if you're aiming for 16x16, 256x256 would be fine, but then you can set up a grid that's 16x16 px large so you can align to pixels as needed.\n\nGitHub's work on Octicons used a method similar to what I just outlined, and as we see, their icons came out pretty awesome. Despite vectors scaling up mostly AOK, it's easy to tell when something's been designed at a lower res and been blown up. When something starts out huge, but was designed with downscaling in mind, it'll look good at any size.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35521, "question": "I disagree. If you want a good vector icon, just make sure your canvas size is *a multiple of your target size*. So if you're aiming for 16x16, 256x256 would be fine, but then you can set up a grid that's 16x16 px large so you can align to pixels as needed.\n\nGitHub's work on Octicons used a method similar to what I just outlined, and as we see, their icons came out pretty awesome. Despite vectors scaling up mostly AOK, it's easy to tell when something's been designed at a lower res and been blown up. When something starts out huge, but was designed with downscaling in mind, it'll look good at any size.", "aSentId": 35522, "answer": "Absolutely, going from low rez to high rez is a bad idea for almost all requirements. In fact if you read apple/android guidelines on creating multi size icons for mobiles, they always ask you to start with a high resolution icon and then resize it to whatever lower rez you need.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35525, "question": "You can specify point coordinates and that's it which results in a lot less than the ASCII approach and is better for higher precision. As pointed out above, the only real benefit to this system is human readability in code for simple images. I wouldn't entirely dismiss it though. It is nice to see in code what things are right away and to be able to easily edit them. For example think of the buttons in a media player. It depends on what you are doing. Honestly though, I think the use cases are niche. Typically separated presentation resources is the way to go.", "aSentId": 35526, "answer": "Yes, that's exactly what I use it for: small simple images. It's actually not that niche with the trend towards simpler icons on iOS and OS X. I have quite a few of those in my app.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35527, "question": "Yes, that's exactly what I use it for: small simple images. It's actually not that niche with the trend towards simpler icons on iOS and OS X. I have quite a few of those in my app.", "aSentId": 35528, "answer": "Perhaps in that case it might be good. Where I come from it would make skinning, internationalisation, automatic asset management, etc difficult. Basically for very large software SOC becomes critical and jumping files/folders like a hyperactive flea is the norm. Still, the format does not have to be embedded but then you lose the advantage of \"seeing everything\" in the code so might as well use some kind of GUI graphical editor anyway. Nevertheless even for me something like this could be well justified for prototyping. Everything is geared for throughput in large apps and sometimes setting up the framework just to experiment with something small takes ten times longer than straight coding it. It's also an nice way to specify masks. A lot of us have probably done that already (but it's just binary/2D array).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35505, "question": "Expressed well by this comment...\n\n&gt;That's impressive. But have you ever heard of SVG?", "aSentId": 35531, "answer": "&gt; This \u201cdrawing\u201d described very nicely what I wanted to do, better than any comment I could ever write for any kind of code, in fact. That ASCII art was a great way to show directly in my code what image would be used in that part of the UI, without having to dig into the resources folder.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35533, "question": "\"Replacing Photoshop\" is a bit of a misnomer -- this is an efficient ASCII-based vector graphics format, not a replacement for raster editing tools.  Somewhat reminiscent of RIPscrip.", "aSentId": 35534, "answer": "No way. Why use Photoshop for anything when you can just use NSString? Need to adjust photos you took with your $2000 Nikon? Use NSString!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35535, "question": "No way. Why use Photoshop for anything when you can just use NSString? Need to adjust photos you took with your $2000 Nikon? Use NSString!", "aSentId": 35536, "answer": "Well if you're at *that* level you'd be using NSDictionary. Duh.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35533, "question": "\"Replacing Photoshop\" is a bit of a misnomer -- this is an efficient ASCII-based vector graphics format, not a replacement for raster editing tools.  Somewhat reminiscent of RIPscrip.", "aSentId": 35538, "answer": "&gt; \"Replacing Photoshop\" is a bit of a misnomer\n\nOK, you got me ;-)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35540, "question": "You know why I dig this so much? Because plain text diffs and version control.", "aSentId": 35541, "answer": "You could use SVG and still get plain text diffs and use version control.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35542, "question": "You could use SVG and still get plain text diffs and use version control.", "aSentId": 35543, "answer": "The SVG source does not in any way *look* like the image it represents.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35544, "question": "The SVG source does not in any way *look* like the image it represents.", "aSentId": 35545, "answer": "No, but there are plenty of SVG editors so you can see the image as you are drawing it, rather than trying to make a circle out of a square of numbers.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35546, "question": "No, but there are plenty of SVG editors so you can see the image as you are drawing it, rather than trying to make a circle out of a square of numbers.", "aSentId": 35547, "answer": "You can do that in Photoshop as well.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35548, "question": "You can do that in Photoshop as well.", "aSentId": 35549, "answer": "Photoshop saves raster images that won't scale well to different sizes.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35542, "question": "You could use SVG and still get plain text diffs and use version control.", "aSentId": 35551, "answer": "If you hand-code your SVG, yes. If the SVG is generated by some external tools there's so much more extra crapola in there that it's a PITA.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35552, "question": "If you hand-code your SVG, yes. If the SVG is generated by some external tools there's so much more extra crapola in there that it's a PITA.", "aSentId": 35553, "answer": "You know what's less PITA in the long run though? Learning to properly use an appropriate graphics software.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35554, "question": "You know what's less PITA in the long run though? Learning to properly use an appropriate graphics software.", "aSentId": 35555, "answer": "Worthless without a realtime SVG editor, akin to a REPL for a programming language.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35556, "question": "Worthless without a realtime SVG editor, akin to a REPL for a programming language.", "aSentId": 35557, "answer": "[Codepen](http://codepen.io/codebje/pen/PwXqWe) or similar, or the dom edit capabilities of your browser, if you're doing REPL-like stuff. For more intensive SVG development, your favourite JS/HTML tool chain should be adaptable to it.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35556, "question": "Worthless without a realtime SVG editor, akin to a REPL for a programming language.", "aSentId": 35559, "answer": "You're looking at one now.\n\nA web browser is an amazing svg REPL", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35554, "question": "You know what's less PITA in the long run though? Learning to properly use an appropriate graphics software.", "aSentId": 35561, "answer": "For text diffs and version control, not really. Even when you know how to use your (vector) graphics software properly (which I can do, thankyouverymuch), the SVG they produce is never as clean and consistent as hand-created stuff, because they need to store a lot of additional stuff in it to ensure roundtripping (if it's not their native formant) and consistency between open/save UI presentation.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35563, "question": "I had a hard time getting past the regurgitated links. And just use SVG, christ. ", "aSentId": 35564, "answer": "There are legitimate reasons to rasterize if you're really embracing a ton of different resolutions and scales, because different amounts of detail make sense at those different scales...\n\n...but to make an entire article reinventing the wheel of vector graphics, without mentioning the word \"vector\" once? Wow. The ASCII art isn't a terrible concept, but it really is like they haven't heard of SVG.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35565, "question": "There are legitimate reasons to rasterize if you're really embracing a ton of different resolutions and scales, because different amounts of detail make sense at those different scales...\n\n...but to make an entire article reinventing the wheel of vector graphics, without mentioning the word \"vector\" once? Wow. The ASCII art isn't a terrible concept, but it really is like they haven't heard of SVG.", "aSentId": 35566, "answer": "&gt; it really is like they haven't heard of SVG.\n\nIt is just me, no 'they'.\n\nI agree the word vector should be in there. I started the hack thinking it would be about pixel, but it was too hard to get right, and the connect-the-numbers technique just came out of that. To me, though, it was all about pixel alignment. I did not realize it could be use to make vector graphics at more than the scale at which it is displayed in the ASCII.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35565, "question": "There are legitimate reasons to rasterize if you're really embracing a ton of different resolutions and scales, because different amounts of detail make sense at those different scales...\n\n...but to make an entire article reinventing the wheel of vector graphics, without mentioning the word \"vector\" once? Wow. The ASCII art isn't a terrible concept, but it really is like they haven't heard of SVG.", "aSentId": 35568, "answer": "You can rasterize SVGs at build time. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35569, "question": "You can rasterize SVGs at build time. ", "aSentId": 35570, "answer": "Sure, but that's not the point. The point is that different amounts of detail make sense, so scaling the same SVG up and down isn't always the best idea.\n\nI don't have the link handy, but the best article I found about this mentioned a word processor -- I guess an early Microsoft Word? -- which had a logo with an ink pen pointed at a page of written text. At different scales, there's a different amount of text on that page. Go small enough, and I think even the pen disappears. With an SVG, you'd have the same amount of text, but shrunken down so it looks way worse.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35571, "question": "Sure, but that's not the point. The point is that different amounts of detail make sense, so scaling the same SVG up and down isn't always the best idea.\n\nI don't have the link handy, but the best article I found about this mentioned a word processor -- I guess an early Microsoft Word? -- which had a logo with an ink pen pointed at a page of written text. At different scales, there's a different amount of text on that page. Go small enough, and I think even the pen disappears. With an SVG, you'd have the same amount of text, but shrunken down so it looks way worse.", "aSentId": 35572, "answer": "And how does this ASCII drawing format help with that? ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35563, "question": "I had a hard time getting past the regurgitated links. And just use SVG, christ. ", "aSentId": 35574, "answer": "&gt; I had a hard time getting past the regurgitated links\n\nSorry about that. I really wrote this post w/o thinking it would be #1 on HN and reddit. Blown away. But still cool enough head to add a plug at the top. TBH, HN/reddit is not my market at all. I don't expect to sell any copy of Findings to anybody in this crowd. And so far I have not in fact, despite dozens of thousands of page views on the blog.\n\n&gt; And just use SVG, christ.\n\nI can't see an image by just looking at the SVG. That's the whole point of that hack. Which I only use for tiny simple images (and I have a lot).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35563, "question": "I had a hard time getting past the regurgitated links. And just use SVG, christ. ", "aSentId": 35576, "answer": "Can a person not do something just to see if it can be done?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35579, "question": "Very neat, but SVG. :-(", "aSentId": 35580, "answer": "Well, to be fair, this is much more compact than SVG, and can be easily edited directly as ASCII.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35583, "question": "quality clickbait, 10/10", "aSentId": 35584, "answer": "Thanks! I must be a natural!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35586, "question": "What is this, the Basic programming days? That's how we bitmaps in the past on the Commodores, with strings and strings of characters for bitmap.", "aSentId": 35587, "answer": "Ever heard of Organic food? Well that was what ppl used to eat 100 years before.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35586, "question": "What is this, the Basic programming days? That's how we bitmaps in the past on the Commodores, with strings and strings of characters for bitmap.", "aSentId": 35589, "answer": "Or if you wanted it more compact, the good-ole DRAW string.\n\n    DRAW \"BM161,0C8D12GD5GD65FDFEUEU65HU5BM162,13C7D5FD65GDG\"\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35591, "question": "I know this person wants to promote their app but c'mon, every occurrence of \"Findings\" on that page is a link!", "aSentId": 35592, "answer": "I am super proud of my app and I get carried away.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35596, "question": "For all of you saying \"just use SVG/PDF\", that method doesn't guarantee pixel-perfect assets. This does.\n\nI will never use SVG. Rasters or code assets are the way to go.", "aSentId": 35597, "answer": "You can do pixel perfect with SVG and other vector formats as long as you follow the same tactics mentioned in the \u201cTricky Bits\u201d section of the article. Basically:\n\n* put your nodes in the _middle_ of the \u201cpixels\u201d;\n* set the line thickness to half a \u201cpixel\u201d for straight lines;\n* set the line thickness to that times the square root of  for diagonal lines if you're not antialiasing (e.g. if the SVG [shape-rendering](http://www.w3.org/TR/SVG11/painting.html#ShapeRenderingProperty) property is set to cripEdges).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35598, "question": "You can do pixel perfect with SVG and other vector formats as long as you follow the same tactics mentioned in the \u201cTricky Bits\u201d section of the article. Basically:\n\n* put your nodes in the _middle_ of the \u201cpixels\u201d;\n* set the line thickness to half a \u201cpixel\u201d for straight lines;\n* set the line thickness to that times the square root of  for diagonal lines if you're not antialiasing (e.g. if the SVG [shape-rendering](http://www.w3.org/TR/SVG11/painting.html#ShapeRenderingProperty) property is set to cripEdges).", "aSentId": 35599, "answer": "That sounds like a lot more work than drawing it in Sketch or PS and exporting the assets once\u2026 but I guess if that works, it is possible. TIL", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35600, "question": "That sounds like a lot more work than drawing it in Sketch or PS and exporting the assets once\u2026 but I guess if that works, it is possible. TIL", "aSentId": 35601, "answer": "It is more work, even more so if you write the SVG yourself, but it's going to come out pretty cleanly.\n\nHonestly, at this point I'm considering writing something that would convert those kind of strings into SVG. (I have been looking for a way to markup SVG in a simpler way \u2014think Markdown for vector graphics\u2014 for a long time.)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35602, "question": "It is more work, even more so if you write the SVG yourself, but it's going to come out pretty cleanly.\n\nHonestly, at this point I'm considering writing something that would convert those kind of strings into SVG. (I have been looking for a way to markup SVG in a simpler way \u2014think Markdown for vector graphics\u2014 for a long time.)", "aSentId": 35603, "answer": "As far as marking up SVG, there are languages you can use for that, e.g. Asymptote. That's what gets used as \"markdown\" for sketches on mathematic/geometric sites like the Art of Problem Solving wiki.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35604, "question": "As far as marking up SVG, there are languages you can use for that, e.g. Asymptote. That's what gets used as \"markdown\" for sketches on mathematic/geometric sites like the Art of Problem Solving wiki.", "aSentId": 35605, "answer": "Yes, I've considered Asymptote in the past, but it didn't really \u201cclick\u201d with me. I suspect it might be due to my METAPOST experience, so that every time I try it, it ends up in the uncanny valley of being _apparently_ familiar, but different enough to be uncomfortable to use. Or maybe it's because it's so obviously based on METAPOST that I end up wondering why I'm not using METAPOST in the first place\u00a0\u2026 I don't know.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35606, "question": "Yes, I've considered Asymptote in the past, but it didn't really \u201cclick\u201d with me. I suspect it might be due to my METAPOST experience, so that every time I try it, it ends up in the uncanny valley of being _apparently_ familiar, but different enough to be uncomfortable to use. Or maybe it's because it's so obviously based on METAPOST that I end up wondering why I'm not using METAPOST in the first place\u00a0\u2026 I don't know.", "aSentId": 35607, "answer": " I had similar feelings, but I basically consider it a more modern update to MetaPost. Doing stuff MP is good at, they're very similar. Otherwise, Asymptote has 3D and is far more programmable. Asymptote is more like a conventional programming language geared towards drawing than a drawing language.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35598, "question": "You can do pixel perfect with SVG and other vector formats as long as you follow the same tactics mentioned in the \u201cTricky Bits\u201d section of the article. Basically:\n\n* put your nodes in the _middle_ of the \u201cpixels\u201d;\n* set the line thickness to half a \u201cpixel\u201d for straight lines;\n* set the line thickness to that times the square root of  for diagonal lines if you're not antialiasing (e.g. if the SVG [shape-rendering](http://www.w3.org/TR/SVG11/painting.html#ShapeRenderingProperty) property is set to cripEdges).", "aSentId": 35609, "answer": "My point is indeed that it is a PITA to do it in code. Let ASCII art do it for you!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35596, "question": "For all of you saying \"just use SVG/PDF\", that method doesn't guarantee pixel-perfect assets. This does.\n\nI will never use SVG. Rasters or code assets are the way to go.", "aSentId": 35611, "answer": "You just need an editor that will snap points to a grid, and export the files as bitmaps to your target resolutions.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35612, "question": "You just need an editor that will snap points to a grid, and export the files as bitmaps to your target resolutions.", "aSentId": 35613, "answer": "\u2026 isn't that what I just sad? A bitmap is a raster.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35614, "question": "\u2026 isn't that what I just sad? A bitmap is a raster.", "aSentId": 35615, "answer": "Oh, I thought you were talking about not even using vector files when creating the assets.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35596, "question": "For all of you saying \"just use SVG/PDF\", that method doesn't guarantee pixel-perfect assets. This does.\n\nI will never use SVG. Rasters or code assets are the way to go.", "aSentId": 35617, "answer": "Pixel-perfect does not exist when your image may be drawn at any arbitrary resolution and size.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35618, "question": "Pixel-perfect does not exist when your image may be drawn at any arbitrary resolution and size.", "aSentId": 35619, "answer": "It will always be drawn pixel-perfect in an iPhone app on a physical device, except in the case of the current \"@3x\" which is just 1242 \u00d7 2208 scaled down to 1080p. Eventually though, we will have *real* @3x and it will be pixel-perfect.\n\nIf, aside from that, the assets are drawn at an arbitrary size, it's not our problem because the assets are not being used as intended.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35622, "question": "ObjC is one of the ugliest languages in the world. Elegance be damned, eh?", "aSentId": 35623, "answer": "Beauty is in the eye of the beholder, I guess...", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35622, "question": "ObjC is one of the ugliest languages in the world. Elegance be damned, eh?", "aSentId": 35625, "answer": "NSUgly", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35629, "question": "Look, No Mocks! Functional TDD with F#", "aSentId": 35630, "answer": "[PDF slides from a previous presentation from a non-shitty site](http://gotocon.com/dl/goto-aar-2014/slides/MarkSeemann_LookNoMocksFunctionalTDDWithF.pdf)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35631, "question": "[PDF slides from a previous presentation from a non-shitty site](http://gotocon.com/dl/goto-aar-2014/slides/MarkSeemann_LookNoMocksFunctionalTDDWithF.pdf)", "aSentId": 35632, "answer": "The site syncs the presentation to his talk. You make it less of a tiny tiny screen by hitting the \"full\" icon just above the video itself (looks like a monitor).", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35631, "question": "[PDF slides from a previous presentation from a non-shitty site](http://gotocon.com/dl/goto-aar-2014/slides/MarkSeemann_LookNoMocksFunctionalTDDWithF.pdf)", "aSentId": 35634, "answer": "Thank you.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35629, "question": "Look, No Mocks! Functional TDD with F#", "aSentId": 35636, "answer": "he really could have mentioned auto mocking.  I use AutoMoq and it makes my life so much easier.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35637, "question": "he really could have mentioned auto mocking.  I use AutoMoq and it makes my life so much easier.", "aSentId": 35638, "answer": "Yeah, but I think when he was talking about the C# code he was trying to get across the kind of pain inflicted onto the business code itself to use TDD.\n\nThere was also his point about the amount of ceremony to get that kind of design going. New file, new interface (which should itself be in a new file) then DI'd through constructor injection. So even if you just move a single part out with absolutely no changes you're still up some 20 loc in just ceremony (usings, braces, etc.). ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35639, "question": "Yeah, but I think when he was talking about the C# code he was trying to get across the kind of pain inflicted onto the business code itself to use TDD.\n\nThere was also his point about the amount of ceremony to get that kind of design going. New file, new interface (which should itself be in a new file) then DI'd through constructor injection. So even if you just move a single part out with absolutely no changes you're still up some 20 loc in just ceremony (usings, braces, etc.). ", "aSentId": 35640, "answer": "LOC is a terrible measurement of productivity or effort.  Many tools can generate lines very quickly. ReSharper for example can place an interface into a new file with a couple keyboard shortcuts.  DI is not just for TDD though.  It seems like he is trying to make all of these things seem negative when they are great patterns.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35629, "question": "Look, No Mocks! Functional TDD with F#", "aSentId": 35642, "answer": "It was an interesting talk. F# is getting bigger", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35645, "question": "tldw?", "aSentId": 35646, "answer": "Use stubs when testing your pure functions. Use mocks when testing your side effect operations.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35648, "question": "I really like the pragmatism that is linked to the F# community. Too many other functional programming communities in the past (and present) focus on considerations orthogonal to any kind of productivity or efficacy, to the detriment of the perception of functional programming in general by non-functional programmers.\n\nI honestly believe F# is doing more to strengthen the cause of functional programming than most other functional languages ever managed.", "aSentId": 35649, "answer": "To be fair, they get a huge advantage over other languages by having a well known IDE and standard library. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35648, "question": "I really like the pragmatism that is linked to the F# community. Too many other functional programming communities in the past (and present) focus on considerations orthogonal to any kind of productivity or efficacy, to the detriment of the perception of functional programming in general by non-functional programmers.\n\nI honestly believe F# is doing more to strengthen the cause of functional programming than most other functional languages ever managed.", "aSentId": 35651, "answer": "&gt;focus on considerations orthogonal to any kind of productivity or efficacy\n\nI don't know of any communities that tout a focus on things that are anti-productivity.  Do you have examples?  Is it possible the perception is wrong here?   We evaluated F# for our next project as the team was currently an experienced .NET team.  Eventually Scala was chosen. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35652, "question": "&gt;focus on considerations orthogonal to any kind of productivity or efficacy\n\nI don't know of any communities that tout a focus on things that are anti-productivity.  Do you have examples?  Is it possible the perception is wrong here?   We evaluated F# for our next project as the team was currently an experienced .NET team.  Eventually Scala was chosen. ", "aSentId": 35653, "answer": "Could you give some reasons for choosing Scala?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35655, "question": "Static analysis of Vim source code", "aSentId": 35656, "answer": "&gt; Its code proved to be of a very high quality and I found no obvious bugs in it (though the coding style is somewhat arguable in certain places, but I think it has to do with the project age)\n\nThis amazes me. It's no wonder it's taken so long for a big fork to appear. Vim is exceptionally stable, and Bram's attitude about accepting outsider's contributions probably kept the codebase a lot cleaner that it otherwise would've been.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35659, "question": "HippyVM (PHP on PyPy/RPython) goes to Y Combinator and fails", "aSentId": 35660, "answer": "Unsurprising and his analysis is pretty spot on. All the major players in systems and languages are backed by corporate powerhouses or educational institutions and no VC is going to invest money in a software endeavor that will take more than a year or two unless it has already been incubating at some other place for long enough to be ready for commercialization almost right away.\n\nWhat people forget is that silicon valley is not about technology research. Silicon valley these days is about businesses that just happen to use technology. The technology is still considered a cost center. The example I keep bringing is eBay and Java. At the end of the day neither the top brass nor the consumer care whether the backend services powering eBay are in Java or language X. All they care about is that it continues to deliver some kind of value to the people that use it. The same is true of 99% of all tech companies out there.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35661, "question": "Unsurprising and his analysis is pretty spot on. All the major players in systems and languages are backed by corporate powerhouses or educational institutions and no VC is going to invest money in a software endeavor that will take more than a year or two unless it has already been incubating at some other place for long enough to be ready for commercialization almost right away.\n\nWhat people forget is that silicon valley is not about technology research. Silicon valley these days is about businesses that just happen to use technology. The technology is still considered a cost center. The example I keep bringing is eBay and Java. At the end of the day neither the top brass nor the consumer care whether the backend services powering eBay are in Java or language X. All they care about is that it continues to deliver some kind of value to the people that use it. The same is true of 99% of all tech companies out there.", "aSentId": 35662, "answer": "&gt;Silicon valley these days is about businesses that just happen to use technology. \n\nI don't think this has ever not been the case. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35663, "question": "&gt;Silicon valley these days is about businesses that just happen to use technology. \n\nI don't think this has ever not been the case. ", "aSentId": 35664, "answer": "The older Silicon Valley companies (Apple, HP, Sun, Oracle, Xerox PARC, Adobe) made money by selling/researching software and hardware, rather than selling a service that needed software and hardware.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35665, "question": "The older Silicon Valley companies (Apple, HP, Sun, Oracle, Xerox PARC, Adobe) made money by selling/researching software and hardware, rather than selling a service that needed software and hardware.", "aSentId": 35666, "answer": "All of the companies you just listed are either a) major software distributors or b) major hardware distributors. There are far less of those in existence in comparison to companies which provide software as a service, and as a result it's far, far more difficult to even consider a start up which has a similar business model to that of, say, HP. Investors know this, hence why they're skeptical of things like HippyVM", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35667, "question": "All of the companies you just listed are either a) major software distributors or b) major hardware distributors. There are far less of those in existence in comparison to companies which provide software as a service, and as a result it's far, far more difficult to even consider a start up which has a similar business model to that of, say, HP. Investors know this, hence why they're skeptical of things like HippyVM", "aSentId": 35668, "answer": "Yes, I was responding to the idea that Silicon Valley has always been about the services-focused companies, when of course the entire name \"Silicon Valley\" came from its earlier role in technology products and innovations.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35665, "question": "The older Silicon Valley companies (Apple, HP, Sun, Oracle, Xerox PARC, Adobe) made money by selling/researching software and hardware, rather than selling a service that needed software and hardware.", "aSentId": 35670, "answer": "None of them have ever done academic research as businesses. They do R&amp;D but that involves optimizing, commercializing and scaling the results of academic research. I would say the shortest turn-around time from academic research to commercial product was with Google. Larry and Sergey started the company during their PhD at Stanford, and their dissertation was about the graph structure of the Internet.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35671, "question": "None of them have ever done academic research as businesses. They do R&amp;D but that involves optimizing, commercializing and scaling the results of academic research. I would say the shortest turn-around time from academic research to commercial product was with Google. Larry and Sergey started the company during their PhD at Stanford, and their dissertation was about the graph structure of the Internet.", "aSentId": 35672, "answer": "Sure, but they're not \"businesses that happen to use technology\" (eBay being the example given), they're companies whose business *is* technology -- specifically, technology products. Academic or not, their innovations are primarily technological in nature, rather than business or service innovations that happen to be enabled by technology.\n\nThat's all I was trying to say.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35673, "question": "Sure, but they're not \"businesses that happen to use technology\" (eBay being the example given), they're companies whose business *is* technology -- specifically, technology products. Academic or not, their innovations are primarily technological in nature, rather than business or service innovations that happen to be enabled by technology.\n\nThat's all I was trying to say.", "aSentId": 35674, "answer": "I would say then, it doesn't necessarily relate to one another. For example, Whatsapp's business is text messaging, but to enable that they built a network architecture in erlang and have become the biggest contributor to the open-source erlang project. \n\nOn the other hand, Xerox has hardly done anything to advance technology in its field in the past 30 years. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35675, "question": "I would say then, it doesn't necessarily relate to one another. For example, Whatsapp's business is text messaging, but to enable that they built a network architecture in erlang and have become the biggest contributor to the open-source erlang project. \n\nOn the other hand, Xerox has hardly done anything to advance technology in its field in the past 30 years. ", "aSentId": 35676, "answer": "I don't get your point, then... You replied to a post that said Silicon Valley *these days* isn't about technology per se as a profit center. Your reply implied you thought it was *never* about technology. When I pointed out that it *used* to be about technology, you seem to disagree by... saying Xerox *used* to be about technology?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35677, "question": "I don't get your point, then... You replied to a post that said Silicon Valley *these days* isn't about technology per se as a profit center. Your reply implied you thought it was *never* about technology. When I pointed out that it *used* to be about technology, you seem to disagree by... saying Xerox *used* to be about technology?", "aSentId": 35678, "answer": "Top comment: SV is about money, not tech.  \nMy reply: It was never not about money.  \nYour reply: Businesses primarily used to make money from tech  \nMy reply: They sold existing tech commercialized  \nYour reply: clarification about distinction between tech vs. tech based services  \nMy reply: Its not so clear cut who contributes to the growth of technology\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35679, "question": "Top comment: SV is about money, not tech.  \nMy reply: It was never not about money.  \nYour reply: Businesses primarily used to make money from tech  \nMy reply: They sold existing tech commercialized  \nYour reply: clarification about distinction between tech vs. tech based services  \nMy reply: Its not so clear cut who contributes to the growth of technology\n", "aSentId": 35680, "answer": "Top comment: SV today is not about tech as a profit center.\n\n\"It was always about money\" is a pretty facile sentiment in a market economy. Of course it was always about money. The question is whether it was about money via selling technology, or money via selling services. SV used to be about the former, and now is about the latter.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35665, "question": "The older Silicon Valley companies (Apple, HP, Sun, Oracle, Xerox PARC, Adobe) made money by selling/researching software and hardware, rather than selling a service that needed software and hardware.", "aSentId": 35682, "answer": "Silicon Valley is the brainchild of Stanford administrators. Through the 30s to 50s, Stanford leadership made the deliberate choice to instruct professors to guide their promising students into starting companies, commercializing and entering industry instead of continuing on an academic path. The first companies in the Valley (including HP and Varian Associates) were started with investments from Stanford professors, not VCs. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35684, "question": "So I guess that makes Microsoft a \"newer\" SV company even though it was founded in 1975.", "aSentId": 35685, "answer": "No, that makes Microsoft a Seattle-area company. Or, back then, an Albuquerque, NM company.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35684, "question": "So I guess that makes Microsoft a \"newer\" SV company even though it was founded in 1975.", "aSentId": 35687, "answer": "HP was founded in 1935 by two Stanford EE grads, Hewlett and Packard, on a grant from their professor Frederick Terman. Their first product was an audio oscilloscope.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35663, "question": "&gt;Silicon valley these days is about businesses that just happen to use technology. \n\nI don't think this has ever not been the case. ", "aSentId": 35689, "answer": "That is why I only work on open-source projects\n\nEarn less than 25k/year, but at least I have my own programming language (interpreter)", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35690, "question": "That is why I only work on open-source projects\n\nEarn less than 25k/year, but at least I have my own programming language (interpreter)", "aSentId": 35691, "answer": "Ooc, how do you earn that money?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35692, "question": "Ooc, how do you earn that money?", "aSentId": 35693, "answer": "Something entirely unrelated...\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35659, "question": "HippyVM (PHP on PyPy/RPython) goes to Y Combinator and fails", "aSentId": 35695, "answer": "The money is in the tooling and surrounding ecosystem. Look at Microsoft. They're giving .NET away and now TypeScript too. .NET is even now part of a Foundation. The company is investing in these technologies to encourage adoption and licenses on their Windows and Azure platforms. \n\nPerhaps there is money in VMs that can be licenced to hosting providers that can reduce operational overhead with resource saving installations? \n\nEven so. One suspects consulting is the best way to chafe for infrastructure when your competition is free?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35696, "question": "The money is in the tooling and surrounding ecosystem. Look at Microsoft. They're giving .NET away and now TypeScript too. .NET is even now part of a Foundation. The company is investing in these technologies to encourage adoption and licenses on their Windows and Azure platforms. \n\nPerhaps there is money in VMs that can be licenced to hosting providers that can reduce operational overhead with resource saving installations? \n\nEven so. One suspects consulting is the best way to chafe for infrastructure when your competition is free?", "aSentId": 35697, "answer": "Or look at git and github. Even though git wasn't developed by github. Github is able to monetize git.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35698, "question": "Or look at git and github. Even though git wasn't developed by github. Github is able to monetize git.", "aSentId": 35699, "answer": "It's unsurprisingly depressing, actually: about $1 billion valuation for overpriced online backups attached to an image board.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35659, "question": "HippyVM (PHP on PyPy/RPython) goes to Y Combinator and fails", "aSentId": 35701, "answer": "**tl;dr**: This guy went to Y Combinator with HippyVM which is a compiler for PHP based on the concept of facebooks very own HHVM compiler. \n\nThe Business Model was based on the premise that 'people are selling various \"PHP optimizers\" for money that don't really do much'. \n\nApart from this the author says that they also did not progress after two rounds of interviews because they did not have anything tangible which would take 1-2 years to build rather than 3 months. \"Compilers take more time than Americans typically have in their sights.\"\n\nI'm sorry but although I agree with some of his statements. The negativity in his post is too hard for me to feel any remorse for his situation. I am not American and I was insulted !", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35702, "question": "**tl;dr**: This guy went to Y Combinator with HippyVM which is a compiler for PHP based on the concept of facebooks very own HHVM compiler. \n\nThe Business Model was based on the premise that 'people are selling various \"PHP optimizers\" for money that don't really do much'. \n\nApart from this the author says that they also did not progress after two rounds of interviews because they did not have anything tangible which would take 1-2 years to build rather than 3 months. \"Compilers take more time than Americans typically have in their sights.\"\n\nI'm sorry but although I agree with some of his statements. The negativity in his post is too hard for me to feel any remorse for his situation. I am not American and I was insulted !", "aSentId": 35703, "answer": "HippyVM is older than HHVM or at least older than working HHVM. I would not do it right now. Other than that, if you accuse us of having a crap business model, I'm willing to agree with you, but that was NOT the main problem with Y C.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35702, "question": "**tl;dr**: This guy went to Y Combinator with HippyVM which is a compiler for PHP based on the concept of facebooks very own HHVM compiler. \n\nThe Business Model was based on the premise that 'people are selling various \"PHP optimizers\" for money that don't really do much'. \n\nApart from this the author says that they also did not progress after two rounds of interviews because they did not have anything tangible which would take 1-2 years to build rather than 3 months. \"Compilers take more time than Americans typically have in their sights.\"\n\nI'm sorry but although I agree with some of his statements. The negativity in his post is too hard for me to feel any remorse for his situation. I am not American and I was insulted !", "aSentId": 35705, "answer": "I think you're missing the point of the post", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35702, "question": "**tl;dr**: This guy went to Y Combinator with HippyVM which is a compiler for PHP based on the concept of facebooks very own HHVM compiler. \n\nThe Business Model was based on the premise that 'people are selling various \"PHP optimizers\" for money that don't really do much'. \n\nApart from this the author says that they also did not progress after two rounds of interviews because they did not have anything tangible which would take 1-2 years to build rather than 3 months. \"Compilers take more time than Americans typically have in their sights.\"\n\nI'm sorry but although I agree with some of his statements. The negativity in his post is too hard for me to feel any remorse for his situation. I am not American and I was insulted !", "aSentId": 35707, "answer": "he also seemed fairly ignorant of the outside world and wanted everyone to cater to him... the kind of entitlement an //*american*// would expect!", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35713, "question": "Clojure: Refactoring Functions to Data", "aSentId": 35714, "answer": "This would be so, so much better with narration.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35715, "question": "This would be so, so much better with narration.", "aSentId": 35716, "answer": "So, most screencasts use a combination of narration and coding to teach. But with this series I'm working on teaching entirely through live-coding.\n\nThere's definitely a learning curve involved, especially if you're used to watching narrated screencasts.\n\nIn the process of making these, a lot of times it would be /so/ much easier to just narrate something. But it's a useful constraint, as it forces me to trim the fat.\n\nI stick with live-coding because I feel like there's a specific appeal to simply showing the material and respecting the viewer to draw their own conclusions.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35717, "question": "So, most screencasts use a combination of narration and coding to teach. But with this series I'm working on teaching entirely through live-coding.\n\nThere's definitely a learning curve involved, especially if you're used to watching narrated screencasts.\n\nIn the process of making these, a lot of times it would be /so/ much easier to just narrate something. But it's a useful constraint, as it forces me to trim the fat.\n\nI stick with live-coding because I feel like there's a specific appeal to simply showing the material and respecting the viewer to draw their own conclusions.", "aSentId": 35718, "answer": "The video is terrible without narration. Most people don't know clojure much less what you are showing.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35720, "question": "YouTuber to Offer Free Game Dev Lessons + Source Code!", "aSentId": 35721, "answer": "Jesus stop fucking spamming.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35723, "question": "The C++ 'const' Declaration: Why &amp; How", "aSentId": 35724, "answer": "If used sensible, const is very useful in C++. If you make a mess of it, like in the article, it is a mess. Useless article imo.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35723, "question": "The C++ 'const' Declaration: Why &amp; How", "aSentId": 35726, "answer": "&gt;  In later versions of C++, an object or variable which has been declared \u2018const\u2019 can be converted to changeable by use of \u2018const_cast\u2019 which is a similar bodge to \u2018mutable\u2019 and using it likewise renders \u2018const\u2019 virtually useless. \n\nNote that even with const_cast it's undefined behavior to modify a const object (object in the C++ object model sense, not the OO sense).\n\nThis would be undefined behavior:\n\n\t#include &lt;iostream&gt;\n\tint main() {\n\t\tconst int a = 1;\n\t\tconst_cast&lt;int&amp;&gt;(a) = 2;\n\t\tstd::cout &lt;&lt; a &lt;&lt; std::endl;\n\t}\n\nand on both `gcc` and `clang` compiles without warning and outputs `1`.\n\nWhile this would be well defined:\n\n\t#include &lt;iostream&gt;\n\tint main() {\n\t\tint a = 1;\n\t\tconst int &amp;aref = a;\n\t\tconst_cast&lt;int&amp;&gt;(aref) = 2;\n\t\tstd::cout &lt;&lt; a &lt;&lt; std::endl;\n\t}\n\nand outputs `2`.\n    ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35727, "question": "&gt;  In later versions of C++, an object or variable which has been declared \u2018const\u2019 can be converted to changeable by use of \u2018const_cast\u2019 which is a similar bodge to \u2018mutable\u2019 and using it likewise renders \u2018const\u2019 virtually useless. \n\nNote that even with const_cast it's undefined behavior to modify a const object (object in the C++ object model sense, not the OO sense).\n\nThis would be undefined behavior:\n\n\t#include &lt;iostream&gt;\n\tint main() {\n\t\tconst int a = 1;\n\t\tconst_cast&lt;int&amp;&gt;(a) = 2;\n\t\tstd::cout &lt;&lt; a &lt;&lt; std::endl;\n\t}\n\nand on both `gcc` and `clang` compiles without warning and outputs `1`.\n\nWhile this would be well defined:\n\n\t#include &lt;iostream&gt;\n\tint main() {\n\t\tint a = 1;\n\t\tconst int &amp;aref = a;\n\t\tconst_cast&lt;int&amp;&gt;(aref) = 2;\n\t\tstd::cout &lt;&lt; a &lt;&lt; std::endl;\n\t}\n\nand outputs `2`.\n    ", "aSentId": 35728, "answer": "Yup. Essentially the only reason to use a const_cast is if a function's arguments are not properly declared const. ", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35729, "question": "Yup. Essentially the only reason to use a const_cast is if a function's arguments are not properly declared const. ", "aSentId": 35730, "answer": "Not true.  Here's an example:\n\n    Class W;\n\n    Class R\n    {\n        W w;\n\n    public:\n\n        const W&amp; Bar(/*some args...*/) const\n        {\n            // some complicated code...\n            return w[/*some calculated index*/];\n        }\n\n        W&amp; Bar(/*some args...*/)\n        {\n            const auto const_this = this;\n            return const_cast&lt;W&amp;&gt;(const_this-&gt;Bar(/*args*/));\n        }\n    };\n\nScott Meyers and others have talked about the above.  It's a good way to preserve const correctness and still avoid code duplication.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35731, "question": "Not true.  Here's an example:\n\n    Class W;\n\n    Class R\n    {\n        W w;\n\n    public:\n\n        const W&amp; Bar(/*some args...*/) const\n        {\n            // some complicated code...\n            return w[/*some calculated index*/];\n        }\n\n        W&amp; Bar(/*some args...*/)\n        {\n            const auto const_this = this;\n            return const_cast&lt;W&amp;&gt;(const_this-&gt;Bar(/*args*/));\n        }\n    };\n\nScott Meyers and others have talked about the above.  It's a good way to preserve const correctness and still avoid code duplication.\n", "aSentId": 35732, "answer": "hmm. Why not refactor \"some complicated code\" into a different function 'W&amp; barImpl() const' and call barImpl from both bar const and bar. I guess your example is I've simplified. Got a link to any discuion?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35733, "question": "hmm. Why not refactor \"some complicated code\" into a different function 'W&amp; barImpl() const' and call barImpl from both bar const and bar. I guess your example is I've simplified. Got a link to any discuion?", "aSentId": 35734, "answer": "&gt; Why not refactor \"some complicated code\" into a different function 'W&amp; barImpl() const' and call barImpl from both bar const and bar.\n\nYou could still do that, but you still have to deal with const at some point:\n\n    Class W;\n\n    Class R\n    {\n        W w;\n\n        const W&amp; BarImpl(/*some args...*/) const\n        {\n            // some complicated code...\n            return w[/*some calculated index*/];\n        }\n\n    public:\n\n        const W&amp; Bar(/*some args...*/) const\n        {\n            return BarImpl(/*args*/);\n        }\n\n        W&amp; Bar(/*some args...*/)\n        {\n            const auto const_this = this;\n            return const_cast&lt;W&amp;&gt;(const_this-&gt;BarImpl(/*args*/));\n        }\n    };\n\nNot much help is it?\n\nOf course, if you only needed an index as in my naive example, then your 'complex code' function could return an index (in which case I would support refactoring).  But sometimes things get more complicated than just an index.  The idiom I present really does come in handy from time to time.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35733, "question": "hmm. Why not refactor \"some complicated code\" into a different function 'W&amp; barImpl() const' and call barImpl from both bar const and bar. I guess your example is I've simplified. Got a link to any discuion?", "aSentId": 35736, "answer": "&gt; Got a link to any discuion?\n\nhttp://stackoverflow.com/a/123995/2913902\n\nhttp://stackoverflow.com/a/856839/2913902\n\nhttps://stackoverflow.com/questions/4589622/simplifying-const-overloading\n\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35723, "question": "The C++ 'const' Declaration: Why &amp; How", "aSentId": 35738, "answer": "Mutable is not a kludge. The practical application of const methods is to provide an interface to clients of const references of your class. You program toward logical constness, not bitwise constness. Mutable allows these interfaces to actually be useful.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35740, "question": "    int const &amp; \n\nvs\n\n    const int &amp;\n\n**FIGHT!**\n", "aSentId": 35741, "answer": "I've always used the latter. Putting access modifiers before types just feels more natural.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35742, "question": "I've always used the latter. Putting access modifiers before types just feels more natural.", "aSentId": 35743, "answer": "I wonder if non English speakers think differently on this.  ie. is this just because we put adjectives in front of the noun?  Was this ability to put it either way an intentional way to add flexibilty to C for multi cultural reasons?", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35744, "question": "I wonder if non English speakers think differently on this.  ie. is this just because we put adjectives in front of the noun?  Was this ability to put it either way an intentional way to add flexibilty to C for multi cultural reasons?", "aSentId": 35745, "answer": "German here: `const int&amp;` definitely sounds much better to me, though this may be partially because German would use the same order: \u201ckonstante `int` Referenz\u201d \n\n&gt; for multi cultural reasons\n\nI'd be **shocked** if this were the case. My guess is that this is more of a case that they didn't put too much thought into it and just made their compiler collect all specifiers around the type-name. I doubt that this whole social-justice/radical-feminism-bullshit that wants to treat everyone as a super-special snowflake existed back than in a way that normal people would care about.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35740, "question": "    int const &amp; \n\nvs\n\n    const int &amp;\n\n**FIGHT!**\n", "aSentId": 35747, "answer": "I prefer the first because I can always read it right to left: a reference to a constant int. It really helps out with pointers, where\n\n    // pointer to a constant int\n    int const* p\n\nand\n\n    // constant pointer to an int\n    int* const p\n\nand\n\n    // constant pointer to a constant int\n    int const* const p\n\nare all different things.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35748, "question": "I prefer the first because I can always read it right to left: a reference to a constant int. It really helps out with pointers, where\n\n    // pointer to a constant int\n    int const* p\n\nand\n\n    // constant pointer to an int\n    int* const p\n\nand\n\n    // constant pointer to a constant int\n    int const* const p\n\nare all different things.", "aSentId": 35749, "answer": "The right-to-left reading breaks down as soon as you use array or function types in your type declaration.\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35750, "question": "The right-to-left reading breaks down as soon as you use array or function types in your type declaration.\n", "aSentId": 35751, "answer": "C++ only:\n\n    template&lt;typename T&gt; using ptr = T*;\n\nAfter that:\n\n    ptr&lt;int&gt; p1 = nullptr;  // mutable pointer to mutable int\n    ptr&lt;const int&gt; p2 = nullptr;  // mutable pointer to constant int\n    const ptr&lt;int&gt; p3 = nullptr;  // constant pointer to mutable int\n    const ptr&lt;const int&gt; p4 = nullptr;  // constant pointer to constant int\n\n    ptr&lt;void()&gt; f1; // pointer to function taking no arguments returning void\n    ptr&lt;int()&gt; f2; // pointer to function taking no arguments returning int\n    ptr&lt;void(int, int)&gt; f3; // pointer to function taking two integers as arguments returning void\n    ptr&lt;ptr&lt;void()&gt;(int)&gt; f4; // pointer to function taking one int, returning a function\n                                 with no arguments and returntype void\n    ptr&lt;void(ptr&lt;void()&gt;)&gt; f5; // pointer to function taking a pointer to a function\n                                  [taking no arguments returning void] returning void\n\n    // Arrays (If you do something else in C++, you'd better be an expert):\n    std::vector&lt;int&gt; vec1; // mutable dynamic array with mutable elements\n    const std::vector&lt;int&gt; vec2; // const dynamic array with const elements\n    std::array&lt;int, 4&gt; arr1; // compile-time-constant-sized array with mutable elements\n    const std::array&lt;int, 4&gt; arr2; // compile-time-constant-sized array with const elements\n    // soon:\n    std::dynamic_array&lt;int&gt; dyn1(23); // constant sized array with mutable elements\n    const std::dynamic_array&lt;int&gt; dyn2(23); // constant sized array with constant elements\n\n\nI think it doesn't get better than that.\n\nHowever: At least in C++ it is usually a very good idea to avoid naked pointers because they can mean everything (owning or non-owning? If the later, how must it be freed? Is `nullptr` a valid value?). In my experience is that it is usually much better to only work with user-defined pointer-like types (iterators, all kinds of smart-pointers, \u2026) because they state these things much clearer.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35753, "question": "&gt; Ideally, the programmer should not need control this detail of specifying exactly how it variables are passed, just say which direction the information goes and leave the compiler to optimize it automatically\n\nFrom that statement, I don't think the author of that page understands the purpose of const members and references at all.\n\nIn OO languages without const, it would be simulated by a pattern like this (in pseudo-Java or C#):\n\n    interface ConstList&lt;T&gt; {\n        T getItem(int index);\n        int getLength();\n    }\n\n    class List&lt;T&gt; implements ConstList&lt;T&gt; {\n        // const methods:\n        T getItem(int index) { ... }\n        int getLength() { ... }\n        // non-const methods:\n        void setItem(int index, T item) { ... }\n    }\n\nThen:\n\n    List&lt;Person&gt; l;\n    l.setItem(0, new Person()); // allowed\n\n    ConstList&lt;Person&gt; cl = l;\n    Person p = cl.getItem(0);\n    cl.setItem(0, p); // not allowed \n\nWhereas in C++ all you have to say is:\n\n    template &lt;typename T&gt;\n    class List \n    {\n        T getItem(int index) { ... }\n        int getLength() { ... }\n        void setItem(int index, T item) const { ... }\n    }\n\nThis in effect describes two ways of referring to an object: `T&amp;` and `const &amp;T`, the latter only including the `setItem` function because it is marked `const`.\n\nClearly this is not something the compiler could or should work out for itself. It's something capturing the intent of the user that they have to state somehow.\n\nAnd that's before we even get into [the effect of C++11 on the meaning of const/mutable relating to threads](http://channel9.msdn.com/posts/C-and-Beyond-2012-Herb-Sutter-You-dont-know-blank-and-blank).", "aSentId": 35754, "answer": "Your C++ example is backwards: `getItem()` and `getLength()` should have the const specifier (e.g: `T getLength() const {...}`); `setItem()` cannot be called on a const instance, so it should not be marked const.", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35757, "question": "One reason I don't like using C anymore is you can't use consts all the way down the pointer hole. If I had a function like this all my arrays would have to share the same type signature. This works fine in C++ but not in C as GCC &amp; MSVC each have their own opinion.\n\n    void foo(const char * const * const bar);", "aSentId": 35758, "answer": "This seems to work as intended with gcc 4.8.2:\n\n    void func(const char * const * const array)\n    {\n        array = 0;         // error: assignment of read-only parameter \u2018array\u2019\n        array[0] = \"Hi\";   // error: assignment of read-only location \u2018*array\u2019\n        array[0][0] = 'h'; // error: assignment of read-only location \u2018**array\u2019\n    }\n\n    int main(int argc, char** argv)\n    {\n        const char* strings[] = {\"Hello\", \"World\"};\n        func(strings);\n    }\n", "corpus": "reddit"},{"docID": "t5_2fwo", "qSentId": 35761, "question": "Question:\n\n    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n    \n    int main(int argc,char* argv[])\n    {\n    \tconst int a=1;\n    \tint b=2;\n    \tprintf(\"%i, %i\\r\\n\",a,b);\n    \tmemcpy((int*)&amp;a,&amp;b,sizeof(int));\n    \tprintf(\"%i, %i\\r\\n\",a,b);\n    \n    \treturn 0;\n    }\n\nThis will print (C):\n\n    1, 2\n    2, 2\n\nOr C++\n\n    1, 2\n    1, 2\n\n\n\nso in C++ it will not copy the memory block (but also do not create warnings)\nbut in C it actually does overwrite the value of the const.\n\nThe code compiles with gcc using ``-Wall -pedantic -Werror -Wfatal-errors``\n\nShouldn't a constant be in protected memory and throw errors when you try to overwrite it?", "aSentId": 35762, "answer": "&gt; Shouldn't a constant be in protected memory and throw errors when you try to overwrite it?\n\nNo, of course not. Constants have to be initialized at some point and must be deleted at a later. This is completely normal. The constness of a variable is ensured by invariants that are checked via the type-system.\n\nYou code uses a very explicit \u201cCompiler: Go fuck yourself, I know better then you!!\u201d-cast (yes, this is about the tone that you are using when doing that) to override all it's safety-mechanisms in order to create undefined behavior (so your code really isn't C or C++. It is a string of characters that a compiler is not required to reject).\n\nYou are basically breaking the law here: You are not guaranteed that the ~~police~~ compiler will catch and punish you, but it is certainly possible.\n\nNow, concerning the output:\n\n    $ clang main.c &amp;&amp; ./a.out \n    1, 2\n    1, 2\n    $ gcc main.c &amp;&amp; ./a.out\n    1, 2\n    2, 2\n\nI am not sure whether this points to a suboptimal-code-generation-bug in GCC: It might be a good idea to research further whether there are cases with legal code in which it could do better.\n\n**tl;dr**: This is the true reason why C and C++ are so powerful: You are able to tell the compiler that you know better, but if you do so, you'd better really do. Otherwise there are dragons that will kill you in gruesome ways and the compiler will just watch the spectacle.", "corpus": "reddit"}]