[{"docID": "t5_2qhmr", "qSentId": 45263, "question": "Third year CS student and confused...", "aSentId": 45264, "answer": "&gt;I'm am no longer sure this is the right major for me\n\nThis kind of thinking will majorly fuck you up. Just ask yourself if this is the degree you want. If it really is then you will find a way to make it happen. You'll have to work harder than other students, but you're definitely intelligent enough to get it done. Bug your TA's with questions every day. Go see tutors. Take a class over if you have too. Just get it done.  I believe in you, OP!  \n\nIf you must work 20-30 hours a week then don't rush through college. Take 5 years if you need to. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45265, "question": "&gt;I'm am no longer sure this is the right major for me\n\nThis kind of thinking will majorly fuck you up. Just ask yourself if this is the degree you want. If it really is then you will find a way to make it happen. You'll have to work harder than other students, but you're definitely intelligent enough to get it done. Bug your TA's with questions every day. Go see tutors. Take a class over if you have too. Just get it done.  I believe in you, OP!  \n\nIf you must work 20-30 hours a week then don't rush through college. Take 5 years if you need to. ", "aSentId": 45266, "answer": "I can vouch for this.  I finished a CS degree while working 30+ hours and I can't tell you how many times I thought the same thing... but eventually I finished the degree.\n\nSome professors suck, so you might consider dropping a class and taking it with another professor.  That can help a lot.\n\nI derived much inspiration from the Sly and the Family Stone song \" You Can Make it if You Try\".  Check it out... I listened it to it quite a bit on the way to class.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45265, "question": "&gt;I'm am no longer sure this is the right major for me\n\nThis kind of thinking will majorly fuck you up. Just ask yourself if this is the degree you want. If it really is then you will find a way to make it happen. You'll have to work harder than other students, but you're definitely intelligent enough to get it done. Bug your TA's with questions every day. Go see tutors. Take a class over if you have too. Just get it done.  I believe in you, OP!  \n\nIf you must work 20-30 hours a week then don't rush through college. Take 5 years if you need to. ", "aSentId": 45268, "answer": "Most CS/Eng degress need 5 years unless you're antisocial or genius anyway.  I tried to get done too fast and almost burned myself out.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45263, "question": "Third year CS student and confused...", "aSentId": 45270, "answer": "&gt; I almost feel like I am pretending at times and relying on outside sources too much.\n\nCS grad and professional software engineer now: You probably aren't relying on outside sources enough. I'm paid big bucks to know how to wade through the documentation mess that is the internet.\n\nThe only big change in c++ vs java is memory management. Get a good hold on that and pointers. Objective C might actually help you out a bit here for learning.\n\nOh and the little voice in the back of your head that constantly tells you you're a fraud? It never goes away.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45271, "question": "&gt; I almost feel like I am pretending at times and relying on outside sources too much.\n\nCS grad and professional software engineer now: You probably aren't relying on outside sources enough. I'm paid big bucks to know how to wade through the documentation mess that is the internet.\n\nThe only big change in c++ vs java is memory management. Get a good hold on that and pointers. Objective C might actually help you out a bit here for learning.\n\nOh and the little voice in the back of your head that constantly tells you you're a fraud? It never goes away.", "aSentId": 45272, "answer": "That little voice is a bitch", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45273, "question": "That little voice is a bitch", "aSentId": 45274, "answer": "Left my old job to get a sick gig that pays twice as much.\n\nThat little bastard has never been louder.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45263, "question": "Third year CS student and confused...", "aSentId": 45276, "answer": "&gt; I almost feel like I am pretending at times and relying on outside sources too much.\n\nget used to this, the feeling will never go away. if it ever does go away it means you're not challenging yourself enough and have settled into a comfort zone. don't ever settle. don't get too comfortable.\n\ncomputer programming is hard. there is nearly limitless depth to this subject and a huge variety of applications, each of which involves bringing in significant knowledge from another domain in addition to programming. its a hard thing to do.\n\ndon't get discouraged though! if you're struggling in class then the right thing to do is take steps to learn what you need to learn to catch up. its not an easy major and you need to be prepared to spend a lot of time learning about programming, and teaching yourself new technologies. that's what working as a programmer in industry is like too. \n\nmy advice to you is to just not sweat the exams so much. that's just school stuff. learn programming first and the exams won't be so hard anymore. the only real way to learn programming is by doing it. your homework assignments are probably not nearly enough to teach you what you need to know. you'll have to branch out on your own and learn how to do this kind of stuff for real.\n\nyou've already taken a really important first step though, which is engaging the larger community of programmers beyond your university. keep doing this! talk to programmers, write programs of your own, learn about more than just what is assigned in class. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45293, "question": "Just to aid with your peace of mind, in the tech world, people are more concerned with the work you have done than the CS degree you've attained.\n\nI worked for years as a freelance dev, then got a job in silicon valley after college. When I asked the CEO/guy who hired me how much my degree meant to him, his answer was \"none. you could have left it off your resume.\"\n\nI learned absolutely nothing about what I'm doing at my job while getting my CS degree. If there is an aspect of coding you enjoy, then become an expert in that little slice and prove it by contributing to open-source projects. Employers want to see your _code_ not your _degree_. A solid github account is more attractive than a solid resume in the tech world.", "aSentId": 45294, "answer": "This is not, exclusively, the case for all software employers. Some niche startups that are doing fancy research things, and some big companies just as a point of pride, will in fact care about your education. But if I had to rely on one or the other to get me a job, it'd be my work experience, and mostly the parts that I piled on as internships when I was still in school.\n\nBut also, you should probably have at least a couple CS classes that you're really good at, even if it's just because you like them and think the rest are boring. If there wasn't *one* interesting, challenging CS class that you're good at, then software *might* not be for you.\n\nOTOH it's a difficult field with lots to learn, and most people enter school with *zero* of that knowledge. So bear with it for a while.\n\nAlso, don't worry about faking your knowledge of the programming language. Again there should probably be one that you really know backwards and forwards, but if all the rest of the times you're cribbing from SO... welcome to the club.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45296, "question": "New student advice", "aSentId": 45297, "answer": "The amount of work you do will be proportional to how much you are invested in your education.  This is true irrespective of the major.  Furthermore, the amount of time spent varies student-by-student by work ethic and efficiency, so it isn't very meaningful to compare across majors.\n\nThat being said, computer science, being a young and rapidly evolving field, offers a wealth of opportunities outside of the classroom, e.g., hackathons, internships, research opportunities, and side projects.  To stand out when you enter the industry, you'll need to participate in some of these activities. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45296, "question": "New student advice", "aSentId": 45299, "answer": "I am studying Computer Science, and I use a desktop for heavy work, with a Mac for portability. I find a MacBook Air 2013 is more than powerful enough with an i5, at least for lightweight coding. It's thin, light and has a ridiculous battery. Also boot camp lets you install Windows with hardly any effort, which is built into Mac os. I use visual studio in that partition. Also Mac OS is useful for learning how UNIX works.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45300, "question": "I am studying Computer Science, and I use a desktop for heavy work, with a Mac for portability. I find a MacBook Air 2013 is more than powerful enough with an i5, at least for lightweight coding. It's thin, light and has a ridiculous battery. Also boot camp lets you install Windows with hardly any effort, which is built into Mac os. I use visual studio in that partition. Also Mac OS is useful for learning how UNIX works.", "aSentId": 45301, "answer": "Whatever macbook you get, just make sure it's 8GB RAM. 4GB just doesn't cut it nowadays.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45300, "question": "I am studying Computer Science, and I use a desktop for heavy work, with a Mac for portability. I find a MacBook Air 2013 is more than powerful enough with an i5, at least for lightweight coding. It's thin, light and has a ridiculous battery. Also boot camp lets you install Windows with hardly any effort, which is built into Mac os. I use visual studio in that partition. Also Mac OS is useful for learning how UNIX works.", "aSentId": 45303, "answer": "I second this. Macbook Air is awesome and the MBPr Pro is the best laptop I have ever used. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45296, "question": "New student advice", "aSentId": 45305, "answer": "I suggest you buy something cheap for 1st and 2nd year. Chances are, you won't be doing anything too intensive until you start to specialize. After 2nd year, you will most likely know what you need. \n\nSource: person who dropped 1.3k on a laptop in first year and it was outdated by 4th year.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45307, "question": "UMD CS senior here - hopefully I can offer a more specific perspective on the advice you've received so far. \n\nUMD's campus is huge, and the CS building is about as far away from literally everything as it could be, so size/weight will probably be your biggest concern, especially if you're dorming your first year, in which case it'll be at least a 15-minute walk to CSIC - pack light!\n\nThe UMD CS curriculum uses Unix pretty heavily - for example, the 3rd major track course (CMSC216) will have you working in C for the entire semester, and the second half of that course is all about interfacing with Unix through system calls. This would be a reason to go for the MBA, but if you're comfortable virtualizing with something like Vagrant, you could be fine with a windows machine as well.\n\nGenerally though, if you go with a windows box, you're probably going to be virtualizing Linux anyways, since most languages and toolchains you'll need for classes (OCaml, Ruby, C) will be easiest to work with in a Unix environment.\n\nHowever, if I may offer a different suggestion - since you have a tower already, go for an iPad and Bluetooth keyboard instead. UMD CS has two clusters of Linux machines that CS students can SSH into (linuxlab and grace) that have everything you'll need for classes below the 400-level already installed. Since the entire campus is wifi-accessible, with the iSSH app you could easily work on all your projects with just the iPad when you're away from your room, and with a stylus it'll serve double duty as a paperless notebook. I worked this way for 2 semesters before I bought my MBA and had no issues whatsoever.\n\nThe main advantage of the iPad would be that it would force you to become proficient with the Unix command line and Vim/Emacs, both extremely valuable skills that you're going to need. The one drawback of course is that it'll be a bit more difficult working in Java (which the first two courses CMSC131, CMSC132 will use), but you can easily find editor plugins to get more IDE-like features. And if iSSH supports x-forwarding, I think you could even fire up eclipse on linuxlab from your iPad. Or you could just RDP into your tower from class.\n\nAt UMD, make sure you work your butt off in 216 - this is the weed out course for the major, and it has a well-earned reputation for being tough. If you're a strong coder and are familiar with C, you'll be fine, I think it's mostly the students with only 2 semesters of programming experience when they take the course (ie came in as freshmen with no experience) who really really struggle. When you take your upper-level electives, I'd recommend\n\n451 - upper level algo\n420 - data structures, has a beast of a project involving quad trees that will make you a much better coder\n433 - basically a class on concurrency in Java, with side-tracks about Erlang, Scala, and a quick Hadoop project. IMO, one of the best courses offered\n414/417 - 414 is net sec, 417 is networking. 417 is all in C, and it's tough, but a valuable class. 414 is a bit easier but you'll still learn a lot of useful networking\n\nIf you have any other questions, feel free to PM me. UMD is an awesome school for CS, I think you'll like it here!", "aSentId": 45308, "answer": "Thanks, I had a lot of questions about my specific school and that was really helpful.  Good to know about the IDE's so I can go with something light/durable", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45310, "question": "Glad to hear you're thinking about CS.  To answer your second question first, CS is far more time consuming than many other subjects.  You will have more work to do than your peers.  I don't know if you will be working significantly harder as that is something only you can control.\n\nIn regards to laptops, I wouldn't listen to half of the people in this thread.  You do not need a powerful laptop, in fact technically you probably don't need your own laptop at all since the school will have computer labs dedicated to the CS department which you will be able to do your work on anyway.\n\nThat being said, I do recommend getting a laptop, but nothing super fancy.  Personally I use an Acer C720 Chromebook with an upgraded SSD and Linux installed on it (instead of ChromeOS).  That's $350 **with the SSD upgrade** and it was more than sufficient for my needs while I was finishing my CS degree.  In fact, I now work as a software engineer for a small company and I still use at work it on a daily basis.  I probably won't replace it until at least the end of 2015.  In regards to laptops, smaller and better battery life is more valuable than a big screen and extra processing power.  But make sure you have AT LEAST 4 GB of RAM.\n\nOn a slightly different note, I strongly suggest you learn Linux as soon as possible.  Even if you do not use it in class initially, you will definitely encounter it at some point in your CS career and you will thank yourself for having gotten comfortable with it early.  My recommendation would be to just install only Linux on your laptop so you force yourself to use it 100% of the time.  I did this in 2013 and I haven't looked back.  Now every single computer I own runs only Linux.", "aSentId": 45311, "answer": "I concur with this.  Chromebooks are extremely portable (light + battery life), and cheap.\n\nIf you really need to do heavy computational work, you can set up a remote connection into your desktop at home or the university's servers. I don't think that 4GB of RAM is even necessary, but hey - you seem to have a large budget, so I'd also recommend it.  \n\nIf you're looking to do intense gaming on your laptop, then the Chromebook isn't for you. Most light/casual games run fine on Chromebooks with Intel Haswell/Broadwell processors.  However, if you want to focus on your studies, then the Chromebook will be great for keeping you away from the MMOs that suck away your time. :\\^) \n\nIf you have any questions, feel free to ask in this thread or head over to /r/ChromeOS  or /r/Chrubuntu.\n\ntl;dr: Save cash and use a less expensive laptop for your earlier years of college. Most of that time is introductory material/GenEds, anyway.  Then make your friends jealous by purchasing a shiny new laptop come junior year, or wait until after graduation to buy a more powerful laptop for a cheaper price. (Moore's Law)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45310, "question": "Glad to hear you're thinking about CS.  To answer your second question first, CS is far more time consuming than many other subjects.  You will have more work to do than your peers.  I don't know if you will be working significantly harder as that is something only you can control.\n\nIn regards to laptops, I wouldn't listen to half of the people in this thread.  You do not need a powerful laptop, in fact technically you probably don't need your own laptop at all since the school will have computer labs dedicated to the CS department which you will be able to do your work on anyway.\n\nThat being said, I do recommend getting a laptop, but nothing super fancy.  Personally I use an Acer C720 Chromebook with an upgraded SSD and Linux installed on it (instead of ChromeOS).  That's $350 **with the SSD upgrade** and it was more than sufficient for my needs while I was finishing my CS degree.  In fact, I now work as a software engineer for a small company and I still use at work it on a daily basis.  I probably won't replace it until at least the end of 2015.  In regards to laptops, smaller and better battery life is more valuable than a big screen and extra processing power.  But make sure you have AT LEAST 4 GB of RAM.\n\nOn a slightly different note, I strongly suggest you learn Linux as soon as possible.  Even if you do not use it in class initially, you will definitely encounter it at some point in your CS career and you will thank yourself for having gotten comfortable with it early.  My recommendation would be to just install only Linux on your laptop so you force yourself to use it 100% of the time.  I did this in 2013 and I haven't looked back.  Now every single computer I own runs only Linux.", "aSentId": 45313, "answer": "I actually have an Acer AC70 chromebook, I lost the adaptor and would have to buy a new one ($30 not too bad).  Can you send me a link on that sdd upgrade?\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45314, "question": "I actually have an Acer AC70 chromebook, I lost the adaptor and would have to buy a new one ($30 not too bad).  Can you send me a link on that sdd upgrade?\n", "aSentId": 45315, "answer": "[SSD](http://amzn.com/B00LNF1RVM)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45318, "question": "Laptop: get the most robust, powerful windows-based thing you can get that's within your price range. In my experience, laptops typically last about 4 years of heavy use before you need to start replacing parts (only my opinion), so you should use that knowledge to decide your budget; I personally wouldn't go over $800 for a simple programming station.\n\nOnce you've got the laptop set up and Windows in your reigns, dual boot it into linux. I recommend Ubuntu if you're just starting out. My school's computer labs, as well as just about any professional environment, use a form of Linux for production. You need to get used to it, because it's sooo much easier to program in. I dual booted mine after I was sick of staying in the lab for 5 hours straight every 3 days in my Junior year. \n\nTime: I would say kinda-sorta-not-really to this. Yes, there will be times later in the major when you will be in the lab at 3 am stressing about whether or not you can get your program to do what it's supposed to, but every major has moments like this. Understand that CS is a practical science that's just starting out and you'll probably be completely unaware of nearly every mechanic involved, since it isn't regularly taught in public schools, so it will seem unnecessarily daunting at first. However, every major will be hard in its own way, it's college. \n\nEDIT: When I say robust, I mean get something that looks like a black brick that could survive a 3 foot drop. I got a brand new nifty looking Dell Studio when I started and over my 4 years I had to personally replace the screen, the hard drive, a stick of Ram, and the keyboard. It was heavy, but couldn't survive the constant carrying and heavy use. ", "aSentId": 45319, "answer": "Yes, this is very critical:\n\nInstall Ubuntu Linux on the pc as dual-boot right when you receive it (don't wait to do it.)\n\nIf it's confusing as to why, don't worry, you'll thank us later.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45320, "question": "Yes, this is very critical:\n\nInstall Ubuntu Linux on the pc as dual-boot right when you receive it (don't wait to do it.)\n\nIf it's confusing as to why, don't worry, you'll thank us later.", "aSentId": 45321, "answer": "Why dual boot? Why not just use a VM? It seems the easier solution.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45320, "question": "Yes, this is very critical:\n\nInstall Ubuntu Linux on the pc as dual-boot right when you receive it (don't wait to do it.)\n\nIf it's confusing as to why, don't worry, you'll thank us later.", "aSentId": 45323, "answer": "To tack on a little but here. Dual booting is much easier in a Windows 7 machine because Windows 8's new \"quick boot up\" procedures need to be mainly turned off. It was much less of a pain to dual boot my Windows 7 Dell than my Windows 8 Toshiba. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45324, "question": "To tack on a little but here. Dual booting is much easier in a Windows 7 machine because Windows 8's new \"quick boot up\" procedures need to be mainly turned off. It was much less of a pain to dual boot my Windows 7 Dell than my Windows 8 Toshiba. ", "aSentId": 45325, "answer": "Only the setup is harder on W8, once you hammer GRUB in, you are golden.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45318, "question": "Laptop: get the most robust, powerful windows-based thing you can get that's within your price range. In my experience, laptops typically last about 4 years of heavy use before you need to start replacing parts (only my opinion), so you should use that knowledge to decide your budget; I personally wouldn't go over $800 for a simple programming station.\n\nOnce you've got the laptop set up and Windows in your reigns, dual boot it into linux. I recommend Ubuntu if you're just starting out. My school's computer labs, as well as just about any professional environment, use a form of Linux for production. You need to get used to it, because it's sooo much easier to program in. I dual booted mine after I was sick of staying in the lab for 5 hours straight every 3 days in my Junior year. \n\nTime: I would say kinda-sorta-not-really to this. Yes, there will be times later in the major when you will be in the lab at 3 am stressing about whether or not you can get your program to do what it's supposed to, but every major has moments like this. Understand that CS is a practical science that's just starting out and you'll probably be completely unaware of nearly every mechanic involved, since it isn't regularly taught in public schools, so it will seem unnecessarily daunting at first. However, every major will be hard in its own way, it's college. \n\nEDIT: When I say robust, I mean get something that looks like a black brick that could survive a 3 foot drop. I got a brand new nifty looking Dell Studio when I started and over my 4 years I had to personally replace the screen, the hard drive, a stick of Ram, and the keyboard. It was heavy, but couldn't survive the constant carrying and heavy use. ", "aSentId": 45327, "answer": "Im not sure why you specified windows based. Many many CS students do just fine (even prefer) OS X as a primary platform. Starting with OS X makes the desire to dual boot linux a moot point, and any Windows development needed can dual boot from OS X just as easily, or, more preferably, use a VM.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45328, "question": "Im not sure why you specified windows based. Many many CS students do just fine (even prefer) OS X as a primary platform. Starting with OS X makes the desire to dual boot linux a moot point, and any Windows development needed can dual boot from OS X just as easily, or, more preferably, use a VM.", "aSentId": 45329, "answer": "In my personal experience, Windows machines are typically easier to tinker with. Not every machine is made equal, especially with laptops since every manufacturer has different standards, but products made by Apple are not designed to be easily altered by the user on both the hardware and software end. Then you have to consider the price point. \n\nDon't get me wrong, I've spent a lot of time developing on and for macs (XCode, OpenGL stuff, tons of hours on photoshop, etc.). It feels too uncooperative to me, like I'm developing with chopsticks. I have friends who develop with it and my computer graphics professor used it exclusively, but it just isn't my cup of tea. It also isn't usually used in professional development environments, so I don't see a point in choosing it over more widely accepted and robust alternatives. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45330, "question": "In my personal experience, Windows machines are typically easier to tinker with. Not every machine is made equal, especially with laptops since every manufacturer has different standards, but products made by Apple are not designed to be easily altered by the user on both the hardware and software end. Then you have to consider the price point. \n\nDon't get me wrong, I've spent a lot of time developing on and for macs (XCode, OpenGL stuff, tons of hours on photoshop, etc.). It feels too uncooperative to me, like I'm developing with chopsticks. I have friends who develop with it and my computer graphics professor used it exclusively, but it just isn't my cup of tea. It also isn't usually used in professional development environments, so I don't see a point in choosing it over more widely accepted and robust alternatives. ", "aSentId": 45331, "answer": "&gt; It also isn't usually used in professional development environments, so I don't see a point in choosing it over more widely accepted and robust alternatives.\n\nThat was probably true in 2000, when Macs ran OS 9 and most development was done for desktop (predominantly Windows) applications. Things changed with OSX and even more so with the switch to Intel x86 architecture. Things also changed with the shift from desktop apps to web and mobile development. \n\nSince OSX is based on BSD and uses a bash terminal, most developers prefer it to Windows/DOS. Plus, as someone who has both OSX and Windows 7  machines (with \\*nix virtual machines), I can attest that setting up web development environments in particular are *so* much easier on OSX and \\*nix than doing so on Windows.\n\nI've been told by several of my former colleagues who now work at Google that it is usually assumed that new employee's work machines will be Linux machines and/or MacBooks, unless specifically requested otherwise.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45330, "question": "In my personal experience, Windows machines are typically easier to tinker with. Not every machine is made equal, especially with laptops since every manufacturer has different standards, but products made by Apple are not designed to be easily altered by the user on both the hardware and software end. Then you have to consider the price point. \n\nDon't get me wrong, I've spent a lot of time developing on and for macs (XCode, OpenGL stuff, tons of hours on photoshop, etc.). It feels too uncooperative to me, like I'm developing with chopsticks. I have friends who develop with it and my computer graphics professor used it exclusively, but it just isn't my cup of tea. It also isn't usually used in professional development environments, so I don't see a point in choosing it over more widely accepted and robust alternatives. ", "aSentId": 45333, "answer": "Ive had almost the exact opposite professional experience than you. If anything I would recommend OS platform not being a factor in the decision.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45330, "question": "In my personal experience, Windows machines are typically easier to tinker with. Not every machine is made equal, especially with laptops since every manufacturer has different standards, but products made by Apple are not designed to be easily altered by the user on both the hardware and software end. Then you have to consider the price point. \n\nDon't get me wrong, I've spent a lot of time developing on and for macs (XCode, OpenGL stuff, tons of hours on photoshop, etc.). It feels too uncooperative to me, like I'm developing with chopsticks. I have friends who develop with it and my computer graphics professor used it exclusively, but it just isn't my cup of tea. It also isn't usually used in professional development environments, so I don't see a point in choosing it over more widely accepted and robust alternatives. ", "aSentId": 45335, "answer": "The non-retina pros, although they haven't been updated for a little while, aren't too bad.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45336, "question": "The non-retina pros, although they haven't been updated for a little while, aren't too bad.", "aSentId": 45337, "answer": "I love and adore my 2012 unibody.  As much as I'd like to upgrade (the new graphics cards are pretty slick) I still use this laptop as my daily driver and likely will for a good time to come.  It does fine for light gaming (I can play League, WoW, and CSGO just fine on my windows partition.)  I'm planning on upgrading to 16gb of ram and an SSD soon (I run a lot of VM's, and 8gb of ram is proving to be a major limitation.)  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45318, "question": "Laptop: get the most robust, powerful windows-based thing you can get that's within your price range. In my experience, laptops typically last about 4 years of heavy use before you need to start replacing parts (only my opinion), so you should use that knowledge to decide your budget; I personally wouldn't go over $800 for a simple programming station.\n\nOnce you've got the laptop set up and Windows in your reigns, dual boot it into linux. I recommend Ubuntu if you're just starting out. My school's computer labs, as well as just about any professional environment, use a form of Linux for production. You need to get used to it, because it's sooo much easier to program in. I dual booted mine after I was sick of staying in the lab for 5 hours straight every 3 days in my Junior year. \n\nTime: I would say kinda-sorta-not-really to this. Yes, there will be times later in the major when you will be in the lab at 3 am stressing about whether or not you can get your program to do what it's supposed to, but every major has moments like this. Understand that CS is a practical science that's just starting out and you'll probably be completely unaware of nearly every mechanic involved, since it isn't regularly taught in public schools, so it will seem unnecessarily daunting at first. However, every major will be hard in its own way, it's college. \n\nEDIT: When I say robust, I mean get something that looks like a black brick that could survive a 3 foot drop. I got a brand new nifty looking Dell Studio when I started and over my 4 years I had to personally replace the screen, the hard drive, a stick of Ram, and the keyboard. It was heavy, but couldn't survive the constant carrying and heavy use. ", "aSentId": 45339, "answer": "IMHO, running Linux isn't a requirement at all. Just go with what you're familiar with, there are lots of great tools for every major OS. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45342, "question": "To go slightly against the grain, I didn't find a use for a laptop during my computer science degree. I used my tower at home and the computers in the labs at uni.", "aSentId": 45343, "answer": "I rolled without a laptop (out of 'pride') for the first one or two years of CS, and then subsequently bought a used Macbook Air. Having a Unix based laptop hugely advanced my programming skills. Learning Bash and C helped me step away from the IDE/Java based programming I was used to doing my first two years of CS. I now work in the wonderful world of Bash/Vim and I love it a lot more than an IDE which abstracts a lot of command line stuff away from you.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45344, "question": "I rolled without a laptop (out of 'pride') for the first one or two years of CS, and then subsequently bought a used Macbook Air. Having a Unix based laptop hugely advanced my programming skills. Learning Bash and C helped me step away from the IDE/Java based programming I was used to doing my first two years of CS. I now work in the wonderful world of Bash/Vim and I love it a lot more than an IDE which abstracts a lot of command line stuff away from you.", "aSentId": 45345, "answer": "That seems like a bit of a nonsequitur; you don't need a laptop to use *nix. My point (perhaps not well explained) was that a laptop gives you portability, but I didn't personally find a need for that.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45347, "question": "&gt; light, long lasting, durable, and that it doesn't really need power. \n\nYes. Yes. Yes. Whoooa there. Nooo. It needs as much power as you can possibly squeeze into those first three (as much CPU, RAM and as fast a hard drive as possible). I'm not sure about the UoM's curriculum, but you need to make sure if they teach all MS products (visual studio or some such) or if they teach using cross platform tools. If it's all MS then you'll need to find some windows laptop you're happy with. Otherwise the macbook pro could be a good choice, but I'm a linux guy and would highly recommend anything from system76.com (right now the requirements would be best met by https://system76.com/laptops/galago)\n\nYour peers will end up being computer scientist students. But, in general, you'll all spend the same amount of time doing work, because college classes quickly scale to the ability of the student. ", "aSentId": 45348, "answer": "What are you going to use the power for? What I seem to use my computer for is primarily editing text files, browsing the internet, reading documents and compiling programs. Neither of which requires much from your computer. 4 semesters into my CS bachelor the most taxing thing I have done is compiling the Linux Kernel.\n\nIf he really need to do some high performance computing, he could always SSH into his tower at home. (or just go home and do it). But if you have a course revolving around HPC, I guess you would be granted access to a super computer somewhere anyways...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45349, "question": "What are you going to use the power for? What I seem to use my computer for is primarily editing text files, browsing the internet, reading documents and compiling programs. Neither of which requires much from your computer. 4 semesters into my CS bachelor the most taxing thing I have done is compiling the Linux Kernel.\n\nIf he really need to do some high performance computing, he could always SSH into his tower at home. (or just go home and do it). But if you have a course revolving around HPC, I guess you would be granted access to a super computer somewhere anyways...", "aSentId": 45350, "answer": "&gt; What are you going to use the power for? ... compiling programs\n\nYou totally just answered your own question. Fire up and IDE for coding java and bam. . .slooow. Well, slower than it needs to be. Early on in a programming career the write-compile-test cycle happens a LOT. No reason to sit and wait for a compile. Just get it done as fast as possible so you can get back to figuring out how to program, not waiting for something to compile. The more instantaneous you can get the compile-test part of that to be the quicker you can get on with the writing. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45351, "question": "&gt; What are you going to use the power for? ... compiling programs\n\nYou totally just answered your own question. Fire up and IDE for coding java and bam. . .slooow. Well, slower than it needs to be. Early on in a programming career the write-compile-test cycle happens a LOT. No reason to sit and wait for a compile. Just get it done as fast as possible so you can get back to figuring out how to program, not waiting for something to compile. The more instantaneous you can get the compile-test part of that to be the quicker you can get on with the writing. ", "aSentId": 45352, "answer": "&gt;Early on in a programming career the write-compile-test cycle happens a LOT. No reason to sit and wait for a compile.\n\nBut most of those programs are super small and take almost no time to compile.\n\nPersonally, I would recommend saving the money and setting up a remote server of some kind back to the desktop if you have compile heavy stuff. Odds are you won't be able to best the tower with a laptop anyway. \n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45353, "question": "&gt;Early on in a programming career the write-compile-test cycle happens a LOT. No reason to sit and wait for a compile.\n\nBut most of those programs are super small and take almost no time to compile.\n\nPersonally, I would recommend saving the money and setting up a remote server of some kind back to the desktop if you have compile heavy stuff. Odds are you won't be able to best the tower with a laptop anyway. \n\n", "aSentId": 45354, "answer": "Except, almost all college courses work off an IDE. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45355, "question": "Except, almost all college courses work off an IDE. ", "aSentId": 45356, "answer": "Guess it depends on the University. At my university, everything is ran on Linux, so most students SSH into a few Linux servers on campus to compile and run.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45351, "question": "&gt; What are you going to use the power for? ... compiling programs\n\nYou totally just answered your own question. Fire up and IDE for coding java and bam. . .slooow. Well, slower than it needs to be. Early on in a programming career the write-compile-test cycle happens a LOT. No reason to sit and wait for a compile. Just get it done as fast as possible so you can get back to figuring out how to program, not waiting for something to compile. The more instantaneous you can get the compile-test part of that to be the quicker you can get on with the writing. ", "aSentId": 45358, "answer": "I don't know. I'm totally fine with my cheap 4-year-old laptop that has an i3. Endures all the shit I do to it and I ain't complaining either. But I guess if you've got the money, sure, take the best you find.\n\nAlso to note: you can get quite a bit better laptop today for what I paid back then (and I didn't pay that much).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45347, "question": "&gt; light, long lasting, durable, and that it doesn't really need power. \n\nYes. Yes. Yes. Whoooa there. Nooo. It needs as much power as you can possibly squeeze into those first three (as much CPU, RAM and as fast a hard drive as possible). I'm not sure about the UoM's curriculum, but you need to make sure if they teach all MS products (visual studio or some such) or if they teach using cross platform tools. If it's all MS then you'll need to find some windows laptop you're happy with. Otherwise the macbook pro could be a good choice, but I'm a linux guy and would highly recommend anything from system76.com (right now the requirements would be best met by https://system76.com/laptops/galago)\n\nYour peers will end up being computer scientist students. But, in general, you'll all spend the same amount of time doing work, because college classes quickly scale to the ability of the student. ", "aSentId": 45360, "answer": "If I buy a laptop with an SSD, how big should it be?\n\nEdit: Do I need power in the form of a CPU or a GPU?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45361, "question": "If I buy a laptop with an SSD, how big should it be?\n\nEdit: Do I need power in the form of a CPU or a GPU?", "aSentId": 45362, "answer": "If it has a usb3 (or thunderbolt) it probably doesn't need to be huge because you can buy a large external drive and shuffle things off onto that when you don't need them (or just store them there, like movies, etc), so maybe 200G would be just fine.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45363, "question": "If it has a usb3 (or thunderbolt) it probably doesn't need to be huge because you can buy a large external drive and shuffle things off onto that when you don't need them (or just store them there, like movies, etc), so maybe 200G would be just fine.", "aSentId": 45364, "answer": "So I need something light, durable, powerful (CPU not GPU), RAMful, with a long lasting battery?  Sounds expensive, but I'm willing to make an investment because college.  What is a reasonable amount to pay.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45361, "question": "If I buy a laptop with an SSD, how big should it be?\n\nEdit: Do I need power in the form of a CPU or a GPU?", "aSentId": 45366, "answer": "Powerful cpu is important but a good gpu in addition can be a great help if the development environment you use is able to leverage the gpu for additional power.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45375, "question": "Wait until you get to school.  You only need a laptop if you find yourself wanting to work all over the place.  Some people find it easier to focus if they just work in their room or a lab.\n\nIf you do get a laptop, *don't* bring it to class.\n\nSource: 4.0 GPA, never owned a laptop in college", "aSentId": 45376, "answer": "While that works well for some people, I'd say most CS majors will want a laptop.  I know I would hate life if I was stuck coding in my room/lab for every single assignment - I like a change of scenery.\n\nThe program I'm in is a bit different from most, but we've had a lot of group projects where I would have been completely useless in if I didn't have a laptop.  Not to mention times during classes where I was able to use the software/code alongside the professor to enhance my learning.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45379, "question": "Recursion", "aSentId": 45380, "answer": "Since you're into Java, check out A book called *Thinking Recursively with Java*.  It really helped me with, well, thinking about recursion.\n\nThe other thing I would suggest is to actually write out the entire call stack for a few recursive functions. Start with something simple like a factorial, then do Fibonacci, then move on to something like merge sort, binary search, or DFS. And here is the key: don't cheat yourself by stopping early! Literally trace the execution as if you were the interpreter, writing out every call and then following the recursion until you get to a terminating case that will be passed back up the stack.  See what happens to the arguments (I.e problem size) with each recursive call. See how much work the CPU must do before being able to return. \n\nThere may be people out there who just grok recursion without doing this, but that was the only way I got it. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45379, "question": "Recursion", "aSentId": 45382, "answer": "Recursion is a thing you *will* have to grok in the field. You will very likely be tested on this in interviews, and I've used it a few times in my career (which is only about a year of interning and a few months full-time, so far), in real-world applications.\n\nThat having been said, I think it's something that you will very likely pick up throughout your college career, just because it'll be in a bunch of different things you learn. I agree with /u/rossdub, though, maybe play around with a few standard examples of recursion and you'll likely start to get it.\n\nIt takes a bit of practice to start to think about algorithms in a generalized sense. Like, \"Okay, for most cases, this algorithm will have to do X and then it'll have to do X again on a smaller subset of the data. Cool, I'll just have the function call itself.\" Basically you then have to only think about when that sort of thinking doesn't work, like base cases.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45384, "question": "Can you apply Kruskal's algorithm to a matrix?", "aSentId": 45385, "answer": "Get list of edged from the matrix.\n\nApply Kruskal.\n\n???\n\nPROFIT!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45384, "question": "Can you apply Kruskal's algorithm to a matrix?", "aSentId": 45387, "answer": "From what I understand and have been able to research online, I think you can it just its efficient becuase of assess time for the information needed is increased. The stack overflow link below maybe able to clear it up better then I can.\nhttp://stackoverflow.com/questions/9092339/time-efficiency-in-kruskals-algorithm-using-adjacency-matrix-as-data-structure", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45391, "question": "I can prove P = NP with a constructive proof", "aSentId": 45392, "answer": "&gt; I can prove P = NP with a constructive proof\n\nNo you can't.\n\n&gt;  I am not connected to any academic community and am facing a problem with understanding how to publish to a peer-reviewed journal.\n\nAs a general rule, you follow their submission guidelines, and send them your paper. Most journals will accept submissions from anyone. I suggest spending some time in a library, reading journals, studying the structure and process of papers, and researching this subject. You might even discover why your proof is wrong (and it almost certainly is- don't feel bad), and save yourself the embarrassment of rejection.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45393, "question": "&gt; I can prove P = NP with a constructive proof\n\nNo you can't.\n\n&gt;  I am not connected to any academic community and am facing a problem with understanding how to publish to a peer-reviewed journal.\n\nAs a general rule, you follow their submission guidelines, and send them your paper. Most journals will accept submissions from anyone. I suggest spending some time in a library, reading journals, studying the structure and process of papers, and researching this subject. You might even discover why your proof is wrong (and it almost certainly is- don't feel bad), and save yourself the embarrassment of rejection.", "aSentId": 45394, "answer": "I won't be embarrassed if rejected. I look forward to learning either way about what I could have done wrong.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45391, "question": "I can prove P = NP with a constructive proof", "aSentId": 45396, "answer": "If you're worried about somebody  stealing your work without crediting you, all you have to do is get proof that you wrote it first.\n\nPrint it out and get it notarized with the date. Publish it in a newspaper. Whatever floats your boat.\n\nThen go to a professor.  Bet them $20 you have a proof of P=NP. If they're not interested, bump it to $50. They'll laugh. They'll take your money. They'll read it. They'll tell you what's wrong. \n\nIf they publish a proof that P=NP in the next few years, sue them with your proof. \n\nBam! Only cost you $50.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45397, "question": "If you're worried about somebody  stealing your work without crediting you, all you have to do is get proof that you wrote it first.\n\nPrint it out and get it notarized with the date. Publish it in a newspaper. Whatever floats your boat.\n\nThen go to a professor.  Bet them $20 you have a proof of P=NP. If they're not interested, bump it to $50. They'll laugh. They'll take your money. They'll read it. They'll tell you what's wrong. \n\nIf they publish a proof that P=NP in the next few years, sue them with your proof. \n\nBam! Only cost you $50.", "aSentId": 45398, "answer": "I like the way you think.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45397, "question": "If you're worried about somebody  stealing your work without crediting you, all you have to do is get proof that you wrote it first.\n\nPrint it out and get it notarized with the date. Publish it in a newspaper. Whatever floats your boat.\n\nThen go to a professor.  Bet them $20 you have a proof of P=NP. If they're not interested, bump it to $50. They'll laugh. They'll take your money. They'll read it. They'll tell you what's wrong. \n\nIf they publish a proof that P=NP in the next few years, sue them with your proof. \n\nBam! Only cost you $50.", "aSentId": 45400, "answer": "I belive publishing on arXiv stands and proof of concept, no need for a notary. (http://arxiv.org/) and this way the entire community would have input on the work.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45391, "question": "I can prove P = NP with a constructive proof", "aSentId": 45402, "answer": "Email Scott Aaronson. In one of his talks he says he gets these emails all the time. He's happy to receive claims of P=NP because all he does in response is sends them a huge number and tells them to factor it for him. Should be easy since you have it implemented and it will get your foot in the door with him.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45403, "question": "Email Scott Aaronson. In one of his talks he says he gets these emails all the time. He's happy to receive claims of P=NP because all he does in response is sends them a huge number and tells them to factor it for him. Should be easy since you have it implemented and it will get your foot in the door with him.", "aSentId": 45404, "answer": "A prime number cannot be factored ;) ... but I understand what you are saying.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45405, "question": "A prime number cannot be factored ;) ... but I understand what you are saying.", "aSentId": 45406, "answer": "You beat my edit!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45407, "question": "You beat my edit!", "aSentId": 45408, "answer": "One problem I've got is that I can solve one specific NP-Complete problem in polynomial time. I don't know how to reduce Integer Factorization to it, but I could get him to give me a big 3SAT problem!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45411, "question": "Why is it sufficient for a language to be recognizable to be recursively enumerable?", "aSentId": 45412, "answer": "If I understand you correctly, you ask why semi-decidability and enumerability are equivalent?\n\nFrom RE to semi-rec, you can just enumerate all words until you find the input.\n\nThe other direction is more complicated. The idea is to execute the semi-deciding TM in parallel on multiple words. You first let it run on the first word in some order (e.g. the empty word) for one step. If it accepts, the enumerator outputs it. Then you let it run on the first and second word for 2 steps and output those which are accepted. Then for 3 words and 3 steps and so on.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45411, "question": "Why is it sufficient for a language to be recognizable to be recursively enumerable?", "aSentId": 45414, "answer": "Dovetailing. You'll find a more detail in any introductory book (or lecture notes) on computation theory.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45416, "question": "Weird windows8 caching behavior", "aSentId": 45417, "answer": "You have a couple of flaws in your testing method. When you are switching machines you are using different compilers, they might be doing different optimisations, you could try to use same compiler with same optimisation level. Also, your mult_jumping method includes memory allocation and deallocation into multiplication time, this will take different amount of time on different OS. Same goes with clock function", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45418, "question": "You have a couple of flaws in your testing method. When you are switching machines you are using different compilers, they might be doing different optimisations, you could try to use same compiler with same optimisation level. Also, your mult_jumping method includes memory allocation and deallocation into multiplication time, this will take different amount of time on different OS. Same goes with clock function", "aSentId": 45419, "answer": "You're absolutely right with the deallocation. That is just stupid. I fixed the error, but it didn't do much. In hindsight allocation/deallocation should be more work for larger arrays so it wouldn't explain the smaller array -&gt; larger running time either. Or am i missing something?\n\ngcc 4.8.1 was used for all compilation. I've tried different optimisation levels for the windowstests and they all come out the same. Below is the output after fixing the mistake.\n  \nD:\\UNI\\AlgEng&gt;g++ -o3 CacheSpeedVsFloatingPoint.cpp  \n  \nD:\\UNI\\AlgEng&gt;3.exe  \nStarting  \nL1 mat mult done in 107.82  \nL2 mat mult done in 94.53  \nL3 mat mult done in 94.44  \nRAM mat mult done in 94.64  \n\nD:\\UNI\\AlgEng&gt;g++ CacheSpeedVsFloatingPoint.cpp  \n\nD:\\UNI\\AlgEng&gt;3.exe  \nStarting  \nL1 mat mult done in 107.65  \nL2 mat mult done in 94.47  \nL3 mat mult done in 94.41  \nRAM mat mult done in 94.68  \n\nD:\\UNI\\AlgEng&gt;g++ --version  \ng++ (GCC) 4.8.1  \nCopyright (C) 2013 Free Software Foundation, Inc.  \nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45420, "question": "You're absolutely right with the deallocation. That is just stupid. I fixed the error, but it didn't do much. In hindsight allocation/deallocation should be more work for larger arrays so it wouldn't explain the smaller array -&gt; larger running time either. Or am i missing something?\n\ngcc 4.8.1 was used for all compilation. I've tried different optimisation levels for the windowstests and they all come out the same. Below is the output after fixing the mistake.\n  \nD:\\UNI\\AlgEng&gt;g++ -o3 CacheSpeedVsFloatingPoint.cpp  \n  \nD:\\UNI\\AlgEng&gt;3.exe  \nStarting  \nL1 mat mult done in 107.82  \nL2 mat mult done in 94.53  \nL3 mat mult done in 94.44  \nRAM mat mult done in 94.64  \n\nD:\\UNI\\AlgEng&gt;g++ CacheSpeedVsFloatingPoint.cpp  \n\nD:\\UNI\\AlgEng&gt;3.exe  \nStarting  \nL1 mat mult done in 107.65  \nL2 mat mult done in 94.47  \nL3 mat mult done in 94.41  \nRAM mat mult done in 94.68  \n\nD:\\UNI\\AlgEng&gt;g++ --version  \ng++ (GCC) 4.8.1  \nCopyright (C) 2013 Free Software Foundation, Inc.  \nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.", "aSentId": 45421, "answer": "I started looking into this. On my machine it takes 14-16ms for every loop, no matter what array sizes I am using. After some research I found that calls to rand took 12ms from that 14.\n\nAfter looking into rand() I found out that it returns random number from 0 to RAND_MAX, which for me (Visual studio compiler) is 32k. This means that there were not a single L2 cache miss. \n\nWhat is RAND_MAX for g++? add \"\n\tstd::cout &lt;&lt; RAND_MAX &lt;&lt; std::endl;\" somewhere to check that", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45424, "question": "Discrete Math help?", "aSentId": 45425, "answer": "can you be more specific about what is confusing to you? the procedure is just a pseudo-code definition of a function that takes a list of numbers (of length n) as input and returns the largest value in the list as output.\n\nthe question at the bottom of the page is phrased \"if we run maximum(3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4) what is the value of _n_?\"\n\nif we interpret the question very literally then we should conclude that _n_ is the length of the list of numbers, so in this case its 11 since length([3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4]) is 11. if we interpret the question to mean \"what is the result of this procedure call?\" then the answer would be that the procedure returns the value 14, which is the largest value in the list. \n\nI'm inclined to go with the more literal interpretation here since the question seems incredibly simple and looks a little like a trick question just to check that you're understanding the terminology and reading carefully enough to find the trick.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45426, "question": "can you be more specific about what is confusing to you? the procedure is just a pseudo-code definition of a function that takes a list of numbers (of length n) as input and returns the largest value in the list as output.\n\nthe question at the bottom of the page is phrased \"if we run maximum(3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4) what is the value of _n_?\"\n\nif we interpret the question very literally then we should conclude that _n_ is the length of the list of numbers, so in this case its 11 since length([3, 1, 10, 8, 2, 7, 12, 11, 9, 14, 4]) is 11. if we interpret the question to mean \"what is the result of this procedure call?\" then the answer would be that the procedure returns the value 14, which is the largest value in the list. \n\nI'm inclined to go with the more literal interpretation here since the question seems incredibly simple and looks a little like a trick question just to check that you're understanding the terminology and reading carefully enough to find the trick.", "aSentId": 45427, "answer": "You are correct with the answer being 11. We didn't have a full understanding of what it was asking and since the answer was so simple we just over complicated and confused ourselves. Thank you for the help!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45424, "question": "Discrete Math help?", "aSentId": 45429, "answer": "Well, the procedure is taking a list of numbers as the parameter \"a1...an\", and then analyzing each number to determine the maximum. So \"n\" is the number of numbers passed in as parameters.\n\nIn other words, how many numbers are being analyzed in that procedure call?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45430, "question": "Well, the procedure is taking a list of numbers as the parameter \"a1...an\", and then analyzing each number to determine the maximum. So \"n\" is the number of numbers passed in as parameters.\n\nIn other words, how many numbers are being analyzed in that procedure call?", "aSentId": 45431, "answer": "11", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45430, "question": "Well, the procedure is taking a list of numbers as the parameter \"a1...an\", and then analyzing each number to determine the maximum. So \"n\" is the number of numbers passed in as parameters.\n\nIn other words, how many numbers are being analyzed in that procedure call?", "aSentId": 45433, "answer": "Thank you for the help. We over complicated it and ended up confusing ourselves not realizing how easy it was.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45436, "question": "C++ Code help!!", "aSentId": 45437, "answer": "If I'm understanding this right, considering there's only one output, it looks you need a program to find these numbers, not just print them. However, I don't think you need a computer as using mathematical logic 941\\*852\\*763 would be best, so just print that. I might not be understanding what your task is though.\n\nEDIT: I can explain my reasoning for this if you want.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45438, "question": "If I'm understanding this right, considering there's only one output, it looks you need a program to find these numbers, not just print them. However, I don't think you need a computer as using mathematical logic 941\\*852\\*763 would be best, so just print that. I might not be understanding what your task is though.\n\nEDIT: I can explain my reasoning for this if you want.", "aSentId": 45439, "answer": "Yeah, the programs supposed to find those numbers though. Its beyond ridiculous, but its for an assignment. I have no clue where to start\n\nEDIT: if you could explain, that would be awesome :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45440, "question": "Yeah, the programs supposed to find those numbers though. Its beyond ridiculous, but its for an assignment. I have no clue where to start\n\nEDIT: if you could explain, that would be awesome :)", "aSentId": 45441, "answer": "Alright, here's the reasoning.\n\nThe first digit of each number should be the 3 largest possible numbers, which are 7,8,9. The second digits should be the second largest, which are 4,5,6. Third digits are 1,2,3. I did a semi-proof in my brain for this, but intuitively it makes and I don't want to go into that. Next remember the basic rule that if a + b = n (for some fixed n), then a\\*b is maximized when a = b. For example, let's say n = 6:\n\na|b|a+b|a\\*b\n:--|:--|:--|:-- \n0|6|6|0\n1|5|6|5\n2|4|6|8\n3|3|6|9\n4|2|6|8\n5|1|6|5\n6|0|6|0\n\n(This isn't hard to prove, but I won't do it here). So what does this mean? Notice that _any_ 3 numbers we choose (with the above constraint) will add to the same number (namely, 2556).This means that we want the largest digits to be placed on the smallest numbers, and vice versa for the largest numbers, to make the numbers \"closer\" to each other. So, the number whose first digit is 9 should have a second digit of 4, and third digit of 1, and so on for the rest, while the smallest number (whose first digit is 7) will be followed by the largest (EDIT: typo) possible digits, namely a 6, then 3. \n\nThis gives 941 \\* 852 \\* 763 as the maximum. \n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45442, "question": "Alright, here's the reasoning.\n\nThe first digit of each number should be the 3 largest possible numbers, which are 7,8,9. The second digits should be the second largest, which are 4,5,6. Third digits are 1,2,3. I did a semi-proof in my brain for this, but intuitively it makes and I don't want to go into that. Next remember the basic rule that if a + b = n (for some fixed n), then a\\*b is maximized when a = b. For example, let's say n = 6:\n\na|b|a+b|a\\*b\n:--|:--|:--|:-- \n0|6|6|0\n1|5|6|5\n2|4|6|8\n3|3|6|9\n4|2|6|8\n5|1|6|5\n6|0|6|0\n\n(This isn't hard to prove, but I won't do it here). So what does this mean? Notice that _any_ 3 numbers we choose (with the above constraint) will add to the same number (namely, 2556).This means that we want the largest digits to be placed on the smallest numbers, and vice versa for the largest numbers, to make the numbers \"closer\" to each other. So, the number whose first digit is 9 should have a second digit of 4, and third digit of 1, and so on for the rest, while the smallest number (whose first digit is 7) will be followed by the largest (EDIT: typo) possible digits, namely a 6, then 3. \n\nThis gives 941 \\* 852 \\* 763 as the maximum. \n", "aSentId": 45443, "answer": "OMG!! :D That actually makes sense! Thanks mate. Now I just have to figure out how to code this and get it working. \nBut i really do appreciate the help :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45436, "question": "C++ Code help!!", "aSentId": 45445, "answer": "Try r/learnprogramming", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45446, "question": "Try r/learnprogramming", "aSentId": 45447, "answer": "Will do! Thanks :D", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45436, "question": "C++ Code help!!", "aSentId": 45449, "answer": "The algorithm would be the same in any language. So that's where you have to start, with the algorithm.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45451, "question": "Are there lecture notes on the more recent developments in Complexity Theory (i.e., within the last 5-10 years)?", "aSentId": 45452, "answer": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45453, "question": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "aSentId": 45454, "answer": "Overall I enjoyed that book, but some of the later chapters have an enormous amount of typos and errors that made it more difficult to read than it should be.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45453, "question": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "aSentId": 45456, "answer": "Note in one of the online appendices it includes an outline of Ryan Williams's recent proof that NEXP does not have nonuniform ACC circuits. However, I personally like Ryan's writeup better: http://arxiv.org/abs/1111.1261", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45457, "question": "Note in one of the online appendices it includes an outline of Ryan Williams's recent proof that NEXP does not have nonuniform ACC circuits. However, I personally like Ryan's writeup better: http://arxiv.org/abs/1111.1261", "aSentId": 45458, "answer": "Here's a lecture script on ACC: http://eccc.hpi-web.de/static/books/A_taste_of_Curcuit_Complexity/", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45459, "question": "Here's a lecture script on ACC: http://eccc.hpi-web.de/static/books/A_taste_of_Curcuit_Complexity/", "aSentId": 45460, "answer": "On an unrelated note, that set of lecture notes has a really nice exposition on matrix rigidity! ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45453, "question": "You probably want Arora &amp; Barak's *A Modern Approach*. It's \"capstone\" is Dinur's proof of the PCP theorem, which was published in 2005. That's *just* at the edge of your region, but going by your post history you don't seem to have studied the field in depth yet, so it'll have plenty of novel material to entertain you.", "aSentId": 45462, "answer": "Thank you for that, I have read some of it before. However, I heard that there were a lot of grammatical errors, such as what /u/shitalwayshappens has said.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45463, "question": "Thank you for that, I have read some of it before. However, I heard that there were a lot of grammatical errors, such as what /u/shitalwayshappens has said.", "aSentId": 45464, "answer": "There are. But I've never found a thick, contemporary, graduate-level textbook that doesn't have the same problem. I worked through the fourth printing of *Machine Learning: A Probabilistic Perspective* recently, and came out the other side with a list of a hundred mistakes. Simple fact is that there's a very small pool of people qualified to proofread such books, and they've all got better things to do.\n\nUsually errors get fixed in later printings thanks to reader errata, but I bought my copy years ago so I can't confirm  that's happened with CC:AMA.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45465, "question": "There are. But I've never found a thick, contemporary, graduate-level textbook that doesn't have the same problem. I worked through the fourth printing of *Machine Learning: A Probabilistic Perspective* recently, and came out the other side with a list of a hundred mistakes. Simple fact is that there's a very small pool of people qualified to proofread such books, and they've all got better things to do.\n\nUsually errors get fixed in later printings thanks to reader errata, but I bought my copy years ago so I can't confirm  that's happened with CC:AMA.", "aSentId": 45466, "answer": "Murphy's book is full of mistakes. I found Koller's book much easier to read.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45451, "question": "Are there lecture notes on the more recent developments in Complexity Theory (i.e., within the last 5-10 years)?", "aSentId": 45468, "answer": "You can take a look at some of Subhash Khot's more recent surveys on the Unique Games Conjecture which may be of interest. Very active research area, and Khot just released a preprint with a candidate Lasserre hierarchy to confirm the conjecture. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45470, "question": "Is my understanding of pipeline forwarding correct?", "aSentId": 45471, "answer": "&gt; The general idea is that, if I have an instruction that performs arithmetic and then writes to memory, the ALU can \"keep\" the result of the operation and use it in the next pipeline cycle, rather than waiting for the memory to be written right?\n\nYes. Also works that way with registers.\n\n&gt; but if the ALU must read from memory, then we add a \"bubble\" to give the last cycle time to write to memory before the result can be sent back to the ALU.\n\nOnce you're at the point of using the ALU to compute an arithmetic instruction's result, you should already know what address its memory operand is coming from. (Otherwise, how would you get it to the ALU?) Depending on how your pipeline is set up, you may also already know the address the previous instruction is writing to. (What stage of your pipeline computes the target address?) If so, that's enough to decide whether you need to actually stall while you read from memory what the program has as a memory operand or just get it from a recent instruction via forwarding. \n\nBut really, the details of when you need to stall vs when you can forward (or when you must do some combination of both) depend on your particular pipeline. There is no universal \"an arithmetic instruction can forward its result to the next instruction\" -- even that depends on the pipeline (x86 has been spending multiple pipeline stages in a single ALU for a while now).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45472, "question": "&gt; The general idea is that, if I have an instruction that performs arithmetic and then writes to memory, the ALU can \"keep\" the result of the operation and use it in the next pipeline cycle, rather than waiting for the memory to be written right?\n\nYes. Also works that way with registers.\n\n&gt; but if the ALU must read from memory, then we add a \"bubble\" to give the last cycle time to write to memory before the result can be sent back to the ALU.\n\nOnce you're at the point of using the ALU to compute an arithmetic instruction's result, you should already know what address its memory operand is coming from. (Otherwise, how would you get it to the ALU?) Depending on how your pipeline is set up, you may also already know the address the previous instruction is writing to. (What stage of your pipeline computes the target address?) If so, that's enough to decide whether you need to actually stall while you read from memory what the program has as a memory operand or just get it from a recent instruction via forwarding. \n\nBut really, the details of when you need to stall vs when you can forward (or when you must do some combination of both) depend on your particular pipeline. There is no universal \"an arithmetic instruction can forward its result to the next instruction\" -- even that depends on the pipeline (x86 has been spending multiple pipeline stages in a single ALU for a while now).", "aSentId": 45473, "answer": "&gt;There is no universal \"an arithmetic instruction can forward its result to the next instruction\".   \n    \nThat's why I'm so confused, my textbook is implying that there is. The homework problems give me a series of MIPS instructions and nothing else, and asks me to identify hazards and add no-ops. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45474, "question": "&gt;There is no universal \"an arithmetic instruction can forward its result to the next instruction\".   \n    \nThat's why I'm so confused, my textbook is implying that there is. The homework problems give me a series of MIPS instructions and nothing else, and asks me to identify hazards and add no-ops. ", "aSentId": 45475, "answer": "The book is probably talking specifically about MIPS in some parts, probably the 5-stage (well... three and two halves, perhaps) version.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45470, "question": "Is my understanding of pipeline forwarding correct?", "aSentId": 45477, "answer": "it makes sense to me at first glance\n\nnon pipelined: time between instructions = number of stages * length of each stage (this should be obvious)\n\npipelined: time between instruction = length of a stage (you'll assume for now that each stage takes the same length until you get into more advances stuff like scoreboarding / tomasulos algorithm if im not mistaking).\n\ndo you see how number of pipe stages cancels out?\n\nto be extra clear\n\n     time between instructions = time between instruction (non-pipelined) / number of pipe stages \n     where: time between instructions (non-pipelined) = time it takes to complete one stage (usually x number of clock cycles?) * number of pipe stages \n     so substituting that back in to the original: \n     time between instructions = (time it takes to complete one stage * number of pipe stages) / number of pipe stages\n \n\nbasically with pipelining the first instruction will be in stage 1, then when it gets to stage 2 the second instruction will be in stage 2 and the first one will be in stage 1, then the third one will go to stage one, second instruction to stage two, etc... so the time it takes to get an instruction into the pipeline (in the best case) is == length of the pipeline stage. \n\nyou are correct that stalls will change this, but given a set of mips instructions you should be able to detect these data hazards and show where to insert the stalls, and how many cycles that would add.\n\n\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45479, "question": "Where can we find free developer swag?", "aSentId": 45480, "answer": "University career fairs. I get a lot of my gym shirts there.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45479, "question": "Where can we find free developer swag?", "aSentId": 45482, "answer": "Hackathons, university career fairs, and all sorts of places where people might want to tempt you into applying to their company.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45479, "question": "Where can we find free developer swag?", "aSentId": 45484, "answer": "Conferences and internships are good places along with those already mentioned.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45486, "question": "Workshop exercises for an industry audience involving the use of SAT solvers?", "aSentId": 45487, "answer": "Throw in some planning problems and use some SAT based planners.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45486, "question": "Workshop exercises for an industry audience involving the use of SAT solvers?", "aSentId": 45489, "answer": "Register allocation is a tough problem that should encode well into SAT. I also know a much more obscure reduction of the problem of existence of LPO (an interesting order over logic expressions) into SAT, can provide the ref if needed.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45490, "question": "Register allocation is a tough problem that should encode well into SAT. I also know a much more obscure reduction of the problem of existence of LPO (an interesting order over logic expressions) into SAT, can provide the ref if needed.", "aSentId": 45491, "answer": "Also, with SMT solvers that support bitvectors, a lot of low level problems can be encoded. Not exactly SAT, but a nice extension.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45490, "question": "Register allocation is a tough problem that should encode well into SAT. I also know a much more obscure reduction of the problem of existence of LPO (an interesting order over logic expressions) into SAT, can provide the ref if needed.", "aSentId": 45493, "answer": "Graph-coloring register allocation is a fantastic example for my scenario -- thanks a lot!  I'd love to read the reference that you mention if you could dig it up.  As for propositional encoding of bit-vector transformations, the workshop later covers SMT and the Bit-Vector theory, so I'll shy away from being too copious with that type of exercise -- but a few to whet the appetite would work well.  Maybe some exercises modelling boolean conditionals from C too.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45495, "question": "How do you manage research idea lists?", "aSentId": 45496, "answer": "I use [workflowy](https://workflowy.com/) and have about 1200 \"nodes\" (not all distinct ideas obviously) in my *research ideas* subtree. It's indispensable for me, and could only be improved by allowing LaTeX formatting.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45495, "question": "How do you manage research idea lists?", "aSentId": 45498, "answer": "Either with Google Keep or [this](https://snim2.wordpress.com/2014/07/02/research-diaries-and-lab-notes/). The advantage of the second option is that it is easier to turn rough notes into papers if the rough notes are already in LaTeX.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45500, "question": "So You Want to be a Game Developer? Tips for Coders", "aSentId": 45501, "answer": "I don't like how general the article is. It sounds like he wants to tell you more and expand on his points with actual advice but never does.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45503, "question": "What aspect of your college helped you the most?", "aSentId": 45504, "answer": "The little piece of paper at the end was quite helpful. The rest probably could have been learned on the job. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45503, "question": "What aspect of your college helped you the most?", "aSentId": 45506, "answer": "Figuring out how I work the best with a lot of mentorship and guidance. Also some heavily theory-based topics like Machine Learning I doubt I would ever pick up on my own without an expert I could ask questions.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45508, "question": "The Ghost in the MP3", "aSentId": 45509, "answer": "TIL lossy compression loses things", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45508, "question": "The Ghost in the MP3", "aSentId": 45511, "answer": "The idea that the difference between perceptually encoded data and the source it was encoded from reveals some flaw isn't just wrong, it begs the question. That there is a difference is the entire premise of perceptual encoding. If there is any point to be made you have to start with proving that the difference is registered and significant to the human ear. And nothing in this project addresses that in any way.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45512, "question": "The idea that the difference between perceptually encoded data and the source it was encoded from reveals some flaw isn't just wrong, it begs the question. That there is a difference is the entire premise of perceptual encoding. If there is any point to be made you have to start with proving that the difference is registered and significant to the human ear. And nothing in this project addresses that in any way.", "aSentId": 45513, "answer": "I don't think this page tries to imply that the encoding is flawed in any way. Recovering data lost through lossy compression and presenting it in a form that is hearable to the user, in my opinion, makes for a fascinating art piece.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45512, "question": "The idea that the difference between perceptually encoded data and the source it was encoded from reveals some flaw isn't just wrong, it begs the question. That there is a difference is the entire premise of perceptual encoding. If there is any point to be made you have to start with proving that the difference is registered and significant to the human ear. And nothing in this project addresses that in any way.", "aSentId": 45515, "answer": "I don't think its relevant to this application whether the perceptual coding is effective or not. It is interesting in itself to hear components of sound that are considered to have no impact on the perception of a particular song. It also would be interesting to hear the presumably differeent impact of other formats such as the real audio, microsoft and apple lossy formats.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45508, "question": "The Ghost in the MP3", "aSentId": 45517, "answer": "This is an interesting exploration of how MP3's lossy compression was developed and how it's being misused in many situations nowadays.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45520, "question": "Does soundcloud even stream audio in 320kbps?", "aSentId": 45521, "answer": "Not even close.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45525, "question": "The \ufeffgenetic algorithms explained", "aSentId": 45526, "answer": "Something important to note is that selection according to fitness is a major point in GA's. However, in many GA's the population converges on a specific area of the search space during later generations. When this happens we can see many different chromosomes (members of the population) that have the same fitness, especially if the fitness is an integer value.\n\nThis means that the GA could get to a point where two candidates are being compared but both have the same fitness (even though they represent two different solutions). It would essentially be selecting one of the two candidates at random even though what makes it work is selection according to fitness. So the moral of the story is that using a secondary measure for another layer of fitness can help the GA continue to select according to fitness even when the population has converged onto a very narrow space.\n\nFor example, we may wish to minimize the time something takes and want to use a GA to find this minimum (or something near it) for some NP-hard problem. Our primary fitness would be time, since that is what we care about. If two candidates we are comparing have the same time value then we could look at a secondary characteristic like which of the two could be more easily improved (by mutation or whatever, it depends on the problem). The one that could be more easily improved would then be the preferred candidate for reproduction (crossover+mutation%).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45527, "question": "Something important to note is that selection according to fitness is a major point in GA's. However, in many GA's the population converges on a specific area of the search space during later generations. When this happens we can see many different chromosomes (members of the population) that have the same fitness, especially if the fitness is an integer value.\n\nThis means that the GA could get to a point where two candidates are being compared but both have the same fitness (even though they represent two different solutions). It would essentially be selecting one of the two candidates at random even though what makes it work is selection according to fitness. So the moral of the story is that using a secondary measure for another layer of fitness can help the GA continue to select according to fitness even when the population has converged onto a very narrow space.\n\nFor example, we may wish to minimize the time something takes and want to use a GA to find this minimum (or something near it) for some NP-hard problem. Our primary fitness would be time, since that is what we care about. If two candidates we are comparing have the same time value then we could look at a secondary characteristic like which of the two could be more easily improved (by mutation or whatever, it depends on the problem). The one that could be more easily improved would then be the preferred candidate for reproduction (crossover+mutation%).", "aSentId": 45528, "answer": "Wouldn't time as a minimization goal tend to be non-integer?  Also, if secondary goals exist, should they only be used for tie-breaking, or always factored into scoring?   ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45529, "question": "Wouldn't time as a minimization goal tend to be non-integer?  Also, if secondary goals exist, should they only be used for tie-breaking, or always factored into scoring?   ", "aSentId": 45530, "answer": "In practice time would probably tend to be non-integer I suppose. If for example though we want to schedule a bunch of tasks across different machines like in the assembly line balancing problem, the times associated with each task may only be given as integers on the scale of nanoseconds or something. The point is that ties will happen and percentage of tie comparisons grows logarithmically with generations.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45527, "question": "Something important to note is that selection according to fitness is a major point in GA's. However, in many GA's the population converges on a specific area of the search space during later generations. When this happens we can see many different chromosomes (members of the population) that have the same fitness, especially if the fitness is an integer value.\n\nThis means that the GA could get to a point where two candidates are being compared but both have the same fitness (even though they represent two different solutions). It would essentially be selecting one of the two candidates at random even though what makes it work is selection according to fitness. So the moral of the story is that using a secondary measure for another layer of fitness can help the GA continue to select according to fitness even when the population has converged onto a very narrow space.\n\nFor example, we may wish to minimize the time something takes and want to use a GA to find this minimum (or something near it) for some NP-hard problem. Our primary fitness would be time, since that is what we care about. If two candidates we are comparing have the same time value then we could look at a secondary characteristic like which of the two could be more easily improved (by mutation or whatever, it depends on the problem). The one that could be more easily improved would then be the preferred candidate for reproduction (crossover+mutation%).", "aSentId": 45532, "answer": "[Genetic Cars](http://rednuht.org/genetic_cars_2/) is a good example of this problem.  I'm not really familiar with the implementation details in the web version that I linked, but in [my version](https://github.com/mbcrawfo/genetic-cars) the fitness is simply the maximum forward distance traveled by the car.  When a track has a significant obstacle (say, a steep hill) you'll start out with only 1-2 cars that reach the hill.  After a number of generation have passed, the population's designs converge towards those leaders who are making it to the obstacle until all of the cars are essentially identical.  At that point, you basically end up waiting for a mutation to occur that lets the population push past the obstacle.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45535, "question": "What's wrong with this custom hashing algorithm?", "aSentId": 45536, "answer": "I wish we'd had this level of cs education at my high school. Great to see how far it's come!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45537, "question": "I wish we'd had this level of cs education at my high school. Great to see how far it's come!", "aSentId": 45538, "answer": "Indeed. I will say though that it's a pretty unique program, and I put more work into it than I'm paid for. So education still has a ways to go :P", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45539, "question": "Indeed. I will say though that it's a pretty unique program, and I put more work into it than I'm paid for. So education still has a ways to go :P", "aSentId": 45540, "answer": "Well in which case, thank you personally for broadening the horizons of your students education.\n\nThis is how it starts. The few and sparse, 'unique', programs which show us what is possible and open the door to greater funding for these types of courses in the future.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45539, "question": "Indeed. I will say though that it's a pretty unique program, and I put more work into it than I'm paid for. So education still has a ways to go :P", "aSentId": 45542, "answer": "I remember my high school programming course. It was GW-Basic! We touched no where near the level of stuff you are. Bravo, to you, sir!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45543, "question": "I remember my high school programming course. It was GW-Basic! We touched no where near the level of stuff you are. Bravo, to you, sir!", "aSentId": 45544, "answer": "Thanks :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45537, "question": "I wish we'd had this level of cs education at my high school. Great to see how far it's come!", "aSentId": 45546, "answer": "Same here. My HS was grade 10 where we programmed in Turing, grade 11 Java (never learned objects), and grade 12 class was cancelled because only 5 people registered! This was 2004 though and CS wasn't as popular then.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45537, "question": "I wish we'd had this level of cs education at my high school. Great to see how far it's come!", "aSentId": 45548, "answer": "Ah so true. I'm in my senior year right now and it's quite shit. Outdated stuff. I learn 10x more from the internet and online courses. If only my parents, and other parents, and education organisations would understand that. But oh well, have to waste precious time in low level classes.\n\nOP's students are so lucky. I know there's many schools out there that have really high standards of education, but unfortunately mine isn't one. And sadly there's a larger section of schools worldwide that teach very low levels of education, especially in CS/ICT.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45535, "question": "What's wrong with this custom hashing algorithm?", "aSentId": 45550, "answer": "Permute the characters in data, you get the same hash. Makes it pretty trivial to find collisions.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45551, "question": "Permute the characters in data, you get the same hash. Makes it pretty trivial to find collisions.", "aSentId": 45552, "answer": "What do you mean exactly?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45553, "question": "What do you mean exactly?", "aSentId": 45554, "answer": "Strings with the same characters but in a different order will have the same hashes - \"aabbb\" has the same hash as \"bbabb\". (This is true for both versions of the hash).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45555, "question": "Strings with the same characters but in a different order will have the same hashes - \"aabbb\" has the same hash as \"bbabb\". (This is true for both versions of the hash).", "aSentId": 45556, "answer": "Ah! That's a good idea.\n\nI feel like it may be a bit frail though? If a student merely skips the first character and does the same process, they've completely broken that test. Is there anything more general with this line of thinking?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45557, "question": "Ah! That's a good idea.\n\nI feel like it may be a bit frail though? If a student merely skips the first character and does the same process, they've completely broken that test. Is there anything more general with this line of thinking?", "aSentId": 45558, "answer": "It should be pretty easy to iterate through all permutations of \"aabbcc\" or something like that. It'll generate more collisions if they're throwing out data. (for _ in itertools.permutations(???): reduce(concat, _) etc etc etc) You can probably safely go out to 10 or 11 characters before your test starts taking more than a few seconds.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45557, "question": "Ah! That's a good idea.\n\nI feel like it may be a bit frail though? If a student merely skips the first character and does the same process, they've completely broken that test. Is there anything more general with this line of thinking?", "aSentId": 45560, "answer": "They would need to know the test data and would also have a pretty impossible time getting around each permutation - in fact if they a managed to do so at all they would have a solid hash function...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45535, "question": "What's wrong with this custom hashing algorithm?", "aSentId": 45562, "answer": "I haven't examined your scoring algorithm, but your test set should consist of alot of strings that will collide based on their ascii sums (like icendoan and rosulek noted...sorry, thought I replied to their post when I wrote this). Use palindromes if you are feeling creative or simply reverse strings of existing data in your test set if it is late. Then your scoring algorithm should significantly reduce their score based on the collisions. Collisions are bad, bad, bad for hashing algorithms and should be penalized appropriately.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45563, "question": "I haven't examined your scoring algorithm, but your test set should consist of alot of strings that will collide based on their ascii sums (like icendoan and rosulek noted...sorry, thought I replied to their post when I wrote this). Use palindromes if you are feeling creative or simply reverse strings of existing data in your test set if it is late. Then your scoring algorithm should significantly reduce their score based on the collisions. Collisions are bad, bad, bad for hashing algorithms and should be penalized appropriately.", "aSentId": 45564, "answer": "Indeed. Someone else mentioned something similar.\n\nBut if the student merely skips the first character and then applies the same process, it completely wrecks this test. Is there anything more general you can think of?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45565, "question": "Indeed. Someone else mentioned something similar.\n\nBut if the student merely skips the first character and then applies the same process, it completely wrecks this test. Is there anything more general you can think of?", "aSentId": 45566, "answer": "Just get a list of a few thousand or tens of thousands of English words, hash them, and count the collisions. Perhaps consider both direct collisions (identical hashes) and collisions after taking the hash modulo various divisors, to simulate the way a hash table would actually be implemented.\n\nThere are lots of English words that are identical except for the first letter, or identical except for the first two letters, or identical except for the last letter, or are anagrams of each other, or whatever.\n\nAs a bonus, this is a very realistic test set.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45567, "question": "Just get a list of a few thousand or tens of thousands of English words, hash them, and count the collisions. Perhaps consider both direct collisions (identical hashes) and collisions after taking the hash modulo various divisors, to simulate the way a hash table would actually be implemented.\n\nThere are lots of English words that are identical except for the first letter, or identical except for the first two letters, or identical except for the last letter, or are anagrams of each other, or whatever.\n\nAs a bonus, this is a very realistic test set.", "aSentId": 45568, "answer": "I really like this idea a lot. I feel it is testing more than just this one case.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45569, "question": "I really like this idea a lot. I feel it is testing more than just this one case.", "aSentId": 45570, "answer": "Actually, when you're simulating a real hash table by using the hash to put the words into bins, the *number* of collisions probably isn't quite the right metric\u2014what you are looking for is an *even distribution* of hashes into the various bins. So maybe calculate the variance or standard deviation of how many words get hashed into each bin, and use that as your measure instead.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45565, "question": "Indeed. Someone else mentioned something similar.\n\nBut if the student merely skips the first character and then applies the same process, it completely wrecks this test. Is there anything more general you can think of?", "aSentId": 45572, "answer": "Try pairs where only the first m character is different to prevent this.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45563, "question": "I haven't examined your scoring algorithm, but your test set should consist of alot of strings that will collide based on their ascii sums (like icendoan and rosulek noted...sorry, thought I replied to their post when I wrote this). Use palindromes if you are feeling creative or simply reverse strings of existing data in your test set if it is late. Then your scoring algorithm should significantly reduce their score based on the collisions. Collisions are bad, bad, bad for hashing algorithms and should be penalized appropriately.", "aSentId": 45574, "answer": "I think this should comprise at least a subset of the test data.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45576, "question": "Assuming a 32-bit integer for total, this will only end up using the last 10 bytes of the input data. All the other input data will have been shifted out of the range of the hash function by the total = total ** 10 line.\n\nEdit: I misread total ** 10 as total * 10, my point is incorrect.", "aSentId": 45577, "answer": "Well it's python, so the number can get arbitrarily large.\n\n*Edit:* Oh... edit. I see :P", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45579, "question": "Isn't a hashing function supposed to map to a uniform distribution? You could use a Kolmogorov-Smirnov test. I.e. you have random input data and test if the output data is uniform. For starters you could make a histogram of the domain to get a visual impression.", "aSentId": 45580, "answer": "It's ideal to have a uniform distribution, but you don't HAVE to.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45579, "question": "Isn't a hashing function supposed to map to a uniform distribution? You could use a Kolmogorov-Smirnov test. I.e. you have random input data and test if the output data is uniform. For starters you could make a histogram of the domain to get a visual impression.", "aSentId": 45582, "answer": "&gt;Kolmogorov-Smirnov\n\nThanks for mentioning this. I am doing my own home brewed uniformity test, but this looks better.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45586, "question": "Where in the code are they putting this 'to the power of ten' line? And what format are these numbers in?", "aSentId": 45587, "answer": "Just after the for loop. The numbers are... numbers? Like the digits 0-9.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45588, "question": "Just after the for loop. The numbers are... numbers? Like the digits 0-9.", "aSentId": 45589, "answer": "&gt;Just after the for loop.\n\nOkay, I was assuming it was *inside* the loop body.\n\n&gt;The numbers are... numbers? Like the digits 0-9.\n\nI'm wondering how they're stored. Floats, ints, longs, signed, unsigned, you get the idea.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45590, "question": "&gt;Just after the for loop.\n\nOkay, I was assuming it was *inside* the loop body.\n\n&gt;The numbers are... numbers? Like the digits 0-9.\n\nI'm wondering how they're stored. Floats, ints, longs, signed, unsigned, you get the idea.", "aSentId": 45591, "answer": "Ah. Python, so the type is flexible. Python numbers can grow arbitrarily large or become floats if the arithmetic requires it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45592, "question": "Ah. Python, so the type is flexible. Python numbers can grow arbitrarily large or become floats if the arithmetic requires it.", "aSentId": 45593, "answer": "Hmm, I'm not very familiar with Python. Can we assume that a precise integer of any length (that can fit in the program's available memory) is possible? If so, what are you doing about numbers that come out longer than HASHSIZE?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45594, "question": "Hmm, I'm not very familiar with Python. Can we assume that a precise integer of any length (that can fit in the program's available memory) is possible? If so, what are you doing about numbers that come out longer than HASHSIZE?", "aSentId": 45595, "answer": "&gt; If so, what are you doing about numbers that come out longer than HASHSIZE?\n\nI simplified the pseudocode. It just trims the number if it's too long.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45596, "question": "&gt; If so, what are you doing about numbers that come out longer than HASHSIZE?\n\nI simplified the pseudocode. It just trims the number if it's too long.", "aSentId": 45597, "answer": "Okay then.\n\nAs I think others have pointed out, the 'power of ten' trick still has the weakness that permuting the input string (same characters, different order) will always give the same hash value. So you can test against that.\n\nWith longer strings, the truncating step also causes some other bad behavior. For instance, if the sum of the character values in a string ends in '0000' (that is to say, ten thousand, twenty thousand, etc), it will collide with every other string possessing that property. That's about 1/10^4 of sufficiently long strings, much worse than the roughly 1/10^32 you're looking for. Running so many long strings through might be a bit expensive for your testing software, though.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45600, "question": "Bachelor of Technology - Software Development Degree VS computer science degree", "aSentId": 45601, "answer": "I would speculate that with a technology degree, you are going to be (basically) limited to the professional world. So pick the one that you enjoy the most. I would guess that the comp sci part is going to be more theory and math based, and the dev part is a practical approach to programming (e.g. to do this, write this, etc) . Also, this is the wrong subreddit for this question, it would be better answered at /r/cscareerquestions or /r/askcomputerscience.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45602, "question": "I would speculate that with a technology degree, you are going to be (basically) limited to the professional world. So pick the one that you enjoy the most. I would guess that the comp sci part is going to be more theory and math based, and the dev part is a practical approach to programming (e.g. to do this, write this, etc) . Also, this is the wrong subreddit for this question, it would be better answered at /r/cscareerquestions or /r/askcomputerscience.", "aSentId": 45603, "answer": "I would still prefer the CS degree for general programming ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45604, "question": "I would still prefer the CS degree for general programming ", "aSentId": 45605, "answer": "Fully agree with that.  I don't know anything about the \"Software Development Degree\" curriculum, but I doubt it has very much emphasis on problem-solving skills which is the spirit of CS itself.  I would much rather hire a programmer with no domain knowledge who can learn the skill already knowing what he or she knows, versus a programmer whose education was primarily field knowledge (which is what I assume the software dev degree provides) with little flexibility.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45606, "question": "Fully agree with that.  I don't know anything about the \"Software Development Degree\" curriculum, but I doubt it has very much emphasis on problem-solving skills which is the spirit of CS itself.  I would much rather hire a programmer with no domain knowledge who can learn the skill already knowing what he or she knows, versus a programmer whose education was primarily field knowledge (which is what I assume the software dev degree provides) with little flexibility.", "aSentId": 45607, "answer": "&gt; I would much rather hire a programmer with no domain knowledge who can learn the skill already knowing what he or she knows, versus a programmer whose education was primarily field knowledge \n\nHow many years professional software development experience in a production setting do you have?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45602, "question": "I would speculate that with a technology degree, you are going to be (basically) limited to the professional world. So pick the one that you enjoy the most. I would guess that the comp sci part is going to be more theory and math based, and the dev part is a practical approach to programming (e.g. to do this, write this, etc) . Also, this is the wrong subreddit for this question, it would be better answered at /r/cscareerquestions or /r/askcomputerscience.", "aSentId": 45609, "answer": "In my experience the Software Engineering modules have been to do with managing software projects and software architectures. The software engineering modules have mostly been boring, unchallening and pointless in my opinion. These are generally the things one can only truly learn on the job. \nAcademic institutions are often better for learning academic things.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45610, "question": "In my experience the Software Engineering modules have been to do with managing software projects and software architectures. The software engineering modules have mostly been boring, unchallening and pointless in my opinion. These are generally the things one can only truly learn on the job. \nAcademic institutions are often better for learning academic things.", "aSentId": 45611, "answer": "Furthermore, I feel like if you understand the core principles of computer science, then software engineering can be easily learned on your own time. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45600, "question": "Bachelor of Technology - Software Development Degree VS computer science degree", "aSentId": 45613, "answer": "Here's my take FWIW... \n\nProgramming is getting a computer to do what you want it to. Software development is evolving valuable software with a team. Computer science is a theoretical understanding of various aspects of computing (algorithms, complexity, networking, data storage and indexing, etc.)\n\nCS is helpful but not necessary to be a professional software developer. In fact CS largely omits teaching professional development skills. For example, my [developer's reading list](http://stevewedig.com/2014/02/03/software-developers-reading-list/) covers 16 concepts that are more or less not part of a typical CS program.\n\nWhich is better? Unfortunately I can't say. If you want to \"know everything\", then do CS. If you want to dive into practical development, perhaps SD. However a decent argument could be made that you can't really learn SD until you're on the job, so I would take any academic SD training with a grain of salt. \n\n*edit: Perhaps more important than degree choice is what you build on the side. I'm not sure if I am representative, but if I see a person's code and can discuss the rationale behind their projects, then a degree would be far less relevant.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45614, "question": "Here's my take FWIW... \n\nProgramming is getting a computer to do what you want it to. Software development is evolving valuable software with a team. Computer science is a theoretical understanding of various aspects of computing (algorithms, complexity, networking, data storage and indexing, etc.)\n\nCS is helpful but not necessary to be a professional software developer. In fact CS largely omits teaching professional development skills. For example, my [developer's reading list](http://stevewedig.com/2014/02/03/software-developers-reading-list/) covers 16 concepts that are more or less not part of a typical CS program.\n\nWhich is better? Unfortunately I can't say. If you want to \"know everything\", then do CS. If you want to dive into practical development, perhaps SD. However a decent argument could be made that you can't really learn SD until you're on the job, so I would take any academic SD training with a grain of salt. \n\n*edit: Perhaps more important than degree choice is what you build on the side. I'm not sure if I am representative, but if I see a person's code and can discuss the rationale behind their projects, then a degree would be far less relevant.", "aSentId": 45615, "answer": "I was/am being taught most of the subjects in your list in different disciplines in my CS course. Some of them were mandatory and some were not, but I think the view that CS courses are purely theoretical is outdated, and that each program should be evaluated independently. For example, I had available disciplines such as:\n\n- Software Engineering (and follow-up laboratory)\n- Extreme Programming (and agile development) lab\n- An introductory, mostly theoretical database design class and follow-up applied database lab\n- Human-computer interaction (including design principles in practical projects)\n- Object-oriented programming\n- Combined theoretical crypto and applied security\n\nI would say that practical development was not neglected at all. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45616, "question": "I was/am being taught most of the subjects in your list in different disciplines in my CS course. Some of them were mandatory and some were not, but I think the view that CS courses are purely theoretical is outdated, and that each program should be evaluated independently. For example, I had available disciplines such as:\n\n- Software Engineering (and follow-up laboratory)\n- Extreme Programming (and agile development) lab\n- An introductory, mostly theoretical database design class and follow-up applied database lab\n- Human-computer interaction (including design principles in practical projects)\n- Object-oriented programming\n- Combined theoretical crypto and applied security\n\nI would say that practical development was not neglected at all. ", "aSentId": 45617, "answer": "I'm sure it varies by school, mine were Santa Clara University and then as TA for 3 years at UCLA. Also much of that experience was around 10 years ago, so it could be somewhat out of date I suppose. Either way, my understanding is that some/many departments emphasis in the CS curriculum on theory over practice is an intentional decision. The rationale makes sense to me, but it isn't always presented to students.\n\n\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45614, "question": "Here's my take FWIW... \n\nProgramming is getting a computer to do what you want it to. Software development is evolving valuable software with a team. Computer science is a theoretical understanding of various aspects of computing (algorithms, complexity, networking, data storage and indexing, etc.)\n\nCS is helpful but not necessary to be a professional software developer. In fact CS largely omits teaching professional development skills. For example, my [developer's reading list](http://stevewedig.com/2014/02/03/software-developers-reading-list/) covers 16 concepts that are more or less not part of a typical CS program.\n\nWhich is better? Unfortunately I can't say. If you want to \"know everything\", then do CS. If you want to dive into practical development, perhaps SD. However a decent argument could be made that you can't really learn SD until you're on the job, so I would take any academic SD training with a grain of salt. \n\n*edit: Perhaps more important than degree choice is what you build on the side. I'm not sure if I am representative, but if I see a person's code and can discuss the rationale behind their projects, then a degree would be far less relevant.", "aSentId": 45619, "answer": "I agree with you about not properly learning SD until on a job.  I was fortunate to have a college CS curriculum which put focus on software development and design,  but it didn't all really click until my first developer position. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45600, "question": "Bachelor of Technology - Software Development Degree VS computer science degree", "aSentId": 45621, "answer": "Get the CS degree. Otherwise you're going to spend the rest of your life trying to explain what your software development degree is.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45623, "question": "Do not post questions such as \"should I study computer science?\", \"how do I get an internship?\", \"what sort of job can I get after school?\", etc... There have been too many of these threads; they bore the regulars and scare away experts. If you have a question like this, please consider posting on cscareerquestions or askcomputerscience.", "aSentId": 45624, "answer": "Completely understand what you're saying. Definitely better places to post such questions. Sorry, new to this. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45629, "question": "Computer science doesn't teach you software development, generally.\n\nYou'll learn about proving algorithms instead of architecting large software projects.\n\nBut that said, some software development employers prefer CS degrees, anyway, because of the notion that the theoretical stuff is harder, I guess (which I won't comment on).\n\nEdit: apparently some of you disagree, but the fact that CS is mostly theoretical (which I don't think is a bad thing) is why there are separate software development degrees in the first place.", "aSentId": 45630, "answer": "Your mileage may vary, standard disclaimers, etc. etc.\n\n&gt; You'll learn about proving algorithms instead of architecting large software projects.\n\nIn my computer science degree program, we learned a lot about algorithms and proving them in classes like *Discrete Mathematics* and *Algorithms and Data Structures*.\n\nBut classes like *Software Engineering I* and *Software Engineering II* teach a lot of things about principles of software engineering, API design, version control, etc.\n\nClasses like *Compiler Design* obviously cover a lot of theory stuff, but we still had to implement a compiler.\n\nI know every school and every degree program is going to be different, but the idea that computer scientists don't learn about designing or working on large projects runs very counter to my experiences, and the experiences of the other computer scientists I work with. We had lots of large projects and had to learn a lot of things about the development process, but I will grant you that my program never dealt with any code bases as large as what I was dealing with in my first job after graduation.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45631, "question": "Your mileage may vary, standard disclaimers, etc. etc.\n\n&gt; You'll learn about proving algorithms instead of architecting large software projects.\n\nIn my computer science degree program, we learned a lot about algorithms and proving them in classes like *Discrete Mathematics* and *Algorithms and Data Structures*.\n\nBut classes like *Software Engineering I* and *Software Engineering II* teach a lot of things about principles of software engineering, API design, version control, etc.\n\nClasses like *Compiler Design* obviously cover a lot of theory stuff, but we still had to implement a compiler.\n\nI know every school and every degree program is going to be different, but the idea that computer scientists don't learn about designing or working on large projects runs very counter to my experiences, and the experiences of the other computer scientists I work with. We had lots of large projects and had to learn a lot of things about the development process, but I will grant you that my program never dealt with any code bases as large as what I was dealing with in my first job after graduation.", "aSentId": 45632, "answer": "I didn't have any required software engineering courses. I did implement an interpreter for a programming languages class, but that is not a large software project. It can be completed by a single person as a final project.\n\nThe focus in most programs is on theory, and that's the way I think it should be. It's a science degree. That's why separate degrees were created for people more interested in software engineering/development.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45633, "question": "I didn't have any required software engineering courses. I did implement an interpreter for a programming languages class, but that is not a large software project. It can be completed by a single person as a final project.\n\nThe focus in most programs is on theory, and that's the way I think it should be. It's a science degree. That's why separate degrees were created for people more interested in software engineering/development.", "aSentId": 45634, "answer": "&gt; I didn't have any required software engineering courses.\n\nI think only the first one was required in my program, but since I wanted to get a job as a software engineer, I took the second one to fulfill one of my degree requirements for \"any three 400-level (senior) computer science courses.\"\n\n&gt; I did implement an interpreter for a programming languages class, but that is not a large software project. It can be completed by a single person as a final project.\n\nWe did, too, as a prerequisite for the compilers class. And we wrote an assembler as a prerequisite for that class (in *Computer Organization*), and these were both fairly small projects. But the compiler was, in my opinion, a fairly large project (especially for the time constraints of one semester, and we needed to have some understanding before we started organizing and writing code).\n\n&gt; The focus in most programs is on theory, and that's the way I think it should be. It's a science degree.\n\nI agree, but I really like the programs that call for us to demonstrate our understanding by actually implementing the things we talk about, and I don't think they're that uncommon.\n\nAlso, have an upvote for taking the time to respond to my differing experience.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45635, "question": "&gt; I didn't have any required software engineering courses.\n\nI think only the first one was required in my program, but since I wanted to get a job as a software engineer, I took the second one to fulfill one of my degree requirements for \"any three 400-level (senior) computer science courses.\"\n\n&gt; I did implement an interpreter for a programming languages class, but that is not a large software project. It can be completed by a single person as a final project.\n\nWe did, too, as a prerequisite for the compilers class. And we wrote an assembler as a prerequisite for that class (in *Computer Organization*), and these were both fairly small projects. But the compiler was, in my opinion, a fairly large project (especially for the time constraints of one semester, and we needed to have some understanding before we started organizing and writing code).\n\n&gt; The focus in most programs is on theory, and that's the way I think it should be. It's a science degree.\n\nI agree, but I really like the programs that call for us to demonstrate our understanding by actually implementing the things we talk about, and I don't think they're that uncommon.\n\nAlso, have an upvote for taking the time to respond to my differing experience.", "aSentId": 45636, "answer": "I also think that implementation is good, and I had to do my share of it for my degree, I just don't think that it teaches software development. Academic code is pretty far off from enterprise code. And usually without versioning, testing, architecting, etc.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45637, "question": "I also think that implementation is good, and I had to do my share of it for my degree, I just don't think that it teaches software development. Academic code is pretty far off from enterprise code. And usually without versioning, testing, architecting, etc.", "aSentId": 45638, "answer": "Again, standard disclaimers apply, but in my experience, the biggest difference between academic code and enterprise code is just that enterprise code is terrible.\n\nObviously there's been a huge surge lately in automated unit tests (and test driven development as a whole), but a lot of places still just have a bunch of humans over in QA running through a list of use cases and looking for things that seem wrong.\n\nWriting test harnesses/drivers was actually covered in my first computer science class (though, it was severely lacking, and I also stupidly didn't fully appreciate it until years later, but they tried to at least touch on it).\n\nYou're right, of course, that there are very few projects an undergrad is going to encounter in their academic career that are anywhere near the size of a typical production code base, but I think that's simply a side-effect of having only a single semester to learn a topic and work on code relevant to it. Working on multiple sorting algorithms in a single large code base would obviously not add anything of value to the experience, for example. But I also haven't seen any Software Development themed academic programs that do a better job at preparing people to work on large code bases, and computer scientists the world over still seem to wind up doing the job well enough to create production quality software (regardless of my opinion of the quality).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45639, "question": "Again, standard disclaimers apply, but in my experience, the biggest difference between academic code and enterprise code is just that enterprise code is terrible.\n\nObviously there's been a huge surge lately in automated unit tests (and test driven development as a whole), but a lot of places still just have a bunch of humans over in QA running through a list of use cases and looking for things that seem wrong.\n\nWriting test harnesses/drivers was actually covered in my first computer science class (though, it was severely lacking, and I also stupidly didn't fully appreciate it until years later, but they tried to at least touch on it).\n\nYou're right, of course, that there are very few projects an undergrad is going to encounter in their academic career that are anywhere near the size of a typical production code base, but I think that's simply a side-effect of having only a single semester to learn a topic and work on code relevant to it. Working on multiple sorting algorithms in a single large code base would obviously not add anything of value to the experience, for example. But I also haven't seen any Software Development themed academic programs that do a better job at preparing people to work on large code bases, and computer scientists the world over still seem to wind up doing the job well enough to create production quality software (regardless of my opinion of the quality).", "aSentId": 45640, "answer": "&gt;I think that's simply a side-effect of having only a single semester to learn a topic and work on code relevant to it. Working on multiple sorting algorithms in a single large code base would obviously not add anything of value to the experience, for example\n\nI would assume a software development degree would go over common patterns, the structure of such large projects, how they're managed, common methodologies like Agile, versioning and build systems, unit testing, collecting requirements, and stuff like that. Even without actually implementing a large software project. But I didn't actually get a software development degree, so I don't know for sure.\n\nOf course, CS grads can usually figure that stuff out when they get their first job, but it's usually not what they learned in school.", "corpus": "reddit"}]
