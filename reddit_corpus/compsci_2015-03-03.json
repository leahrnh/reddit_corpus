[{"docID": "t5_2qhmr", "qSentId": 45768, "question": "ELI5 Difference between a tree and a graph.", "aSentId": 45769, "answer": "Every tree is a graph. If it has a path going from every node to every node and doesn't have any loops it is a tree.\n\nedit: corrected", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45770, "question": "Every tree is a graph. If it has a path going from every node to every node and doesn't have any loops it is a tree.\n\nedit: corrected", "aSentId": 45771, "answer": "Only if it's connected. For instance, the graph consisting of the vertices A and B and no edges is not a tree, although it is an acyclic graph.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45772, "question": "Only if it's connected. For instance, the graph consisting of the vertices A and B and no edges is not a tree, although it is an acyclic graph.", "aSentId": 45773, "answer": "All trees are graphs. Not all graphs are trees.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45774, "question": "All trees are graphs. Not all graphs are trees.", "aSentId": 45775, "answer": "Yup, I was replying to /u/TheCaterpillar's original comment, which only mentioned the lack of cycles, I think.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45776, "question": "Yup, I was replying to /u/TheCaterpillar's original comment, which only mentioned the lack of cycles, I think.", "aSentId": 45777, "answer": "Dem ninja edits", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45768, "question": "ELI5 Difference between a tree and a graph.", "aSentId": 45779, "answer": "Trees, DAGs, polytrees, and all those other terms are ways of classifying graphs. Many graph-related algorithms only work on graphs that have certain properties, so those names are there to give short labels to sets of properties that are often important.\n\nA tree is a graph where there is exactly one way to get between any pair of nodes. That means that there aren't any cycles, and that every node is somehow connected to every other one.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45768, "question": "ELI5 Difference between a tree and a graph.", "aSentId": 45781, "answer": "A k-ary tree is a connected, directed, acyclic graph with the restriction that any vertex has one vertex that points to it (incoming degree = 1) and at most k children (outgoing degree &lt;= k). ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45792, "question": "A tree is a set of vertices and edges, where each edge connects two vertices and one can traverse the tree from one node to all others.\n\n\nA graph is a tree where paths(consecutive edges) form cycles. ie: One can traverse the graph from a vertex and back to the same vertex without using the same edge twice.\n\n\n\nI did not take into account disconnected, directed, and other types of graphs.\n\n\n\nHope this helps. Ask if you still dont understand!", "aSentId": 45793, "answer": "Can I ask why I am being downwoted? I see no obvious error on my somewhat unformal description.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45794, "question": "Can I ask why I am being downwoted? I see no obvious error on my somewhat unformal description.", "aSentId": 45795, "answer": " I can't speak for whoever voted on it, but it may be because you use a lot of terminology that a 5 year old wouldn't know/understand. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45796, "question": " I can't speak for whoever voted on it, but it may be because you use a lot of terminology that a 5 year old wouldn't know/understand. ", "aSentId": 45797, "answer": "Well sure, and thats why I tried to give brief shallow expanations of said terminology.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45799, "question": "Every graph can be categorized as a cyclic or an acyclic graph. A graph is acyclic iff it is a tree. ", "aSentId": 45800, "answer": "Not really - a disconnected acyclic graph is not a tree.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45799, "question": "Every graph can be categorized as a cyclic or an acyclic graph. A graph is acyclic iff it is a tree. ", "aSentId": 45802, "answer": "That \"iff\" is too restrictive and makes your statement false.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45804, "question": "What does /r/compsci think of green computing? We've developed an online compiler that measures software energy consumption.", "aSentId": 45805, "answer": "Very interesting!  I can imagine that if Amazon Web Services had a pricing tier where the instance was charged based on power used rather than time, that would certainly motivate people to optimize that way.  There probably is a lot of motivation for this in terms of mobile computing where increased energy consumption means shorter battery life.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45808, "question": "Yale Computer Science Students Petition for More Faculty", "aSentId": 45809, "answer": "Computer Science enrollment is up everywhere.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45808, "question": "Yale Computer Science Students Petition for More Faculty", "aSentId": 45811, "answer": "Same at my school, classes are getting super full. Enrollment rates are up by crazy amounts. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45808, "question": "Yale Computer Science Students Petition for More Faculty", "aSentId": 45813, "answer": "I think /r/yale would be a more appropriate sub for this petition", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45814, "question": "I think /r/yale would be a more appropriate sub for this petition", "aSentId": 45815, "answer": "Can it be moved or should I just delete/resubmit?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45816, "question": "Can it be moved or should I just delete/resubmit?", "aSentId": 45817, "answer": "I guess it can be viewed as a resource for students looking at colleges for computer science (it would negatively impact the person's opinion of Yale for cs). \n\nI didn't know this though. The college I go to has pretty colinear growth in undergrad, graduate, and faculty. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45818, "question": "I guess it can be viewed as a resource for students looking at colleges for computer science (it would negatively impact the person's opinion of Yale for cs). \n\nI didn't know this though. The college I go to has pretty colinear growth in undergrad, graduate, and faculty. ", "aSentId": 45819, "answer": "If you are an academic in CS then any petition at any (decent) school to hire more faculty is of interest to you since it might create more job openings. So I think this post is fine here...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45820, "question": "If you are an academic in CS then any petition at any (decent) school to hire more faculty is of interest to you since it might create more job openings. So I think this post is fine here...", "aSentId": 45821, "answer": "I'm not convinced -- we don't announce job openings in this sub and it would be pretty boring.\n\nThe over-the-top comments are amusing, though\n\n&gt; a friend had realized his passion was in computer science (after taking a couple courses), but was crushed at the thought that he had to take it at Yale\n\nI think I'm going to cry.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45822, "question": "I'm not convinced -- we don't announce job openings in this sub and it would be pretty boring.\n\nThe over-the-top comments are amusing, though\n\n&gt; a friend had realized his passion was in computer science (after taking a couple courses), but was crushed at the thought that he had to take it at Yale\n\nI think I'm going to cry.", "aSentId": 45823, "answer": "I cry every time ....", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45820, "question": "If you are an academic in CS then any petition at any (decent) school to hire more faculty is of interest to you since it might create more job openings. So I think this post is fine here...", "aSentId": 45825, "answer": "Very valid point. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45816, "question": "Can it be moved or should I just delete/resubmit?", "aSentId": 45827, "answer": "Moving posts isn't something reddit does.  It's interesting to think about why (even if a bit off-topic for this sub), or how it should be done if it were implemented.\n\nIf a post that got moved did not keep its vote totals, then the act of moving it would be semantically equivalent to delete and repost.\n\nIf the post did keep its vote totals, then you could get some strange phenomena.  Imagine two wildly different subreddits A and B.  A votes a post up (consistent with its average ideology) and then pranks B by moving the post to B.  Visitors to B would see highly-upvoted posts completely inconsistent with the average ideology of B.  So /r/evildudes gets to send a highly-upvoted \"10 Reasons to Kill Yourself Now\" listicle to /r/suicidewatch, and the moderators of /r/suicidewatch get to play whack-a-mole with them.\n\nOne can imagine countermeasures to this: when A tries to move its post to B, it gets enqueued somewhere for moderators to review before making public.  Or maybe A can't push its post onto B, but the moderators of B could pull a post from A and choose to retain its vote totals.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45814, "question": "I think /r/yale would be a more appropriate sub for this petition", "aSentId": 45829, "answer": "&gt; I think /r/yale would be a more appropriate sub for this petition\n\nWell, with all respect, I don't.\n\nAs a CS professor, I find the petition interesting. As someone with no connections to Yale, I would never have seen it in /r/yale.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45833, "question": "Good study resources for Discrete Math?", "aSentId": 45834, "answer": "&gt;Computer Science students are grouped with math majors at my college, making our class very abstract and proof based. \n\nAnd...? I am going to sound like a dick here... but Computer Science **IS** itself very abstract and proof based. Computer science is studying the logical structures and algorithms that make up \"computing\". How do you design a programming language? It is with a lot of abstract ideas and making a logical proof to design a language that is turing complete.. Just making programs itself while an applicable practice with immediate returns and engineering concerns, is still quite abstract as you consider all of the various parts of making a larger program.\n\nFor a more introductory, easier introduction into the subject look into \"Mathematics: A Discrete Introduction\" by Scheinerman. If you want a more complicated introduction look into \"Discrete Mathematics and its Applications\" by Rosen. If you want a more serious introduction that is more specifically applicable to computer science get \"Concrete Mathematics: A Foundation for Computer Science\" by Graham and Knuth. \n\nAlso work problems, as bargle0 says. Like CS, math is a field you learn by doing not by watching.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45835, "question": "&gt;Computer Science students are grouped with math majors at my college, making our class very abstract and proof based. \n\nAnd...? I am going to sound like a dick here... but Computer Science **IS** itself very abstract and proof based. Computer science is studying the logical structures and algorithms that make up \"computing\". How do you design a programming language? It is with a lot of abstract ideas and making a logical proof to design a language that is turing complete.. Just making programs itself while an applicable practice with immediate returns and engineering concerns, is still quite abstract as you consider all of the various parts of making a larger program.\n\nFor a more introductory, easier introduction into the subject look into \"Mathematics: A Discrete Introduction\" by Scheinerman. If you want a more complicated introduction look into \"Discrete Mathematics and its Applications\" by Rosen. If you want a more serious introduction that is more specifically applicable to computer science get \"Concrete Mathematics: A Foundation for Computer Science\" by Graham and Knuth. \n\nAlso work problems, as bargle0 says. Like CS, math is a field you learn by doing not by watching.", "aSentId": 45836, "answer": "Its not so much the abstract part I'm struggling with, its more the proofs. I've never been very good with proofs, even in geometry that was weak spot. A big part of it is I don't know exactly what you can assume.\n\nIn a programming language, it is very clear what you can assume will be handled automatically. You anticipate that Python will handle memory allocation automatically, and that C will require you to declare pointer variables.\n\nA big problem with discrete for me is I I don't know what we are allowed to assume and what we are not allowed to assume. We are allowed to assume certain things about data sets, such as natural numbers N contains 1, 2, 3, etc, but we obviously cannot use all known laws or otherwise the proof would be done in an instant. \n\nI know this will become clearer by doing more problems and going to office hours, but this is my biggest beef with discrete math. It would be as if you were told to program something and you had no idea whether the language you'd be using is machine code or Matlab.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45837, "question": "Its not so much the abstract part I'm struggling with, its more the proofs. I've never been very good with proofs, even in geometry that was weak spot. A big part of it is I don't know exactly what you can assume.\n\nIn a programming language, it is very clear what you can assume will be handled automatically. You anticipate that Python will handle memory allocation automatically, and that C will require you to declare pointer variables.\n\nA big problem with discrete for me is I I don't know what we are allowed to assume and what we are not allowed to assume. We are allowed to assume certain things about data sets, such as natural numbers N contains 1, 2, 3, etc, but we obviously cannot use all known laws or otherwise the proof would be done in an instant. \n\nI know this will become clearer by doing more problems and going to office hours, but this is my biggest beef with discrete math. It would be as if you were told to program something and you had no idea whether the language you'd be using is machine code or Matlab.", "aSentId": 45838, "answer": "You are proving those laws, that's the whole hing. Do problems in the book, practice proofs, you will do better. Programming is so similar to proofs.\n\nThink of it this way. Lets say you are writing a program to find the most similar websites in a set. When you write that program you are literally writing a proof that given some condition you can prove by some metric that you can every time find which websites are most similar. So how do you do that? You say okay let x1, x2, x3... be some website. Then let y1[], y2[], y3[] be an array of all of the words in the corresponding website. So you take x, get the website and parse through it and put all of the words into this array y. Then you go through perform some comparison between y1,y2,y3,...,yn and say okay so y1 is most similar to 3 then 2 then 4, etc. You are essentially writing a proof in code that you can choose which websites are most similar by some constraints using some algorithm. \n\nMath proofs are doing much the same thing. But instead of doing this with an immediate application you are instead starting from the bare bones stuff. Lets say you are proving that the sum of two odd integers is even. Now you can write the proof very similar to how you would write a program. You start off the proof by wanting to prove something, just like how you start a program with a direction. Then the first thing you do is declare your variables, just like in a code. So instead of saying int x = 3; you instead say \"Let there be an integer, x, such that some condition holds\". \n\nProof the sum of two odd integers is even.\n\nIn this case you could say \"Let there be an integer x, such that x is odd. Likewise, let there be an integer y such that y is odd.\" This is the same as saying int x,y; with some kind of condition x and y are not even. This is you making your assumption and is the same as declaring variables. You state your assumption, which is usually a condition presented in the problem, the same way you declare an int instead of a character or instead of a string, because that is what you are working with.\n\n Next you would then say what the implication of your assumption is. \"Since x in an odd integer, by the definition of odd, there must be some integer j such that x=2j+1. Likewise for y with y=2k+1...\". This is basically you making a method/function. You are saying \n\n    public int odd(int j){\n    this.x=2*j+1;\n    }\n\nBecause this is you forcing x to be odd. Then you do the implication of that. Which is that you can then add x+y, which right now in the proof are completely arbitrary integers, just that they are odd. \"Since x=2j+1, and y=2k+1, we can sum x+y=2k+1+2j+1 since integers are closed under addition\" Then when you want to simplify you just state WHY you can simplify, as in a proof you have to justify everything you do. Basically these are your comments. \"x+y=2j+2k+2=2(j+k+1) because of the distributive property of integers.\" Then it would be something like \"Since integers are closed under addition, there is some integer i such that i = j+j+1. By substitution x+y=2i. Therefore 2 divides the sum of x and y by the definition of divides, therefore x+y is even by the definition of even. QED\" Every step of the way you justify why you are doing it. This is like your professor asking after every method you write \"Why are you doing this, why does this work?\" And you say because:\n\n    public int oddsum(int x, int y){return x+y;}\n\nwill always be odd due to the odd function here ensures it. X and y are then both odd numbers all of the time. And because of that\n\n    public boolean isEven(int z){if(2%z==0;){returntrue;}\n    else{return false;}}\n\nwill always return true for that. And \n\n    while(isEven(oddSum(odd(j++),odd(k++))))\n\nis an infinite loop (until overflows). Programming is just a sort of proof. The difference is discrete math is just the absolute basic proofs from first principles.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45833, "question": "Good study resources for Discrete Math?", "aSentId": 45840, "answer": "All discrete math courses are abstract and proof-based. At least, they should be. I have some meta-advice: find a good discrete math textbook with problems, and then work every single problem. One possibility is *Discrete Mathematics with Applications* by Epp. Pick up an old edition, since the material doesn't change and the pedagogy probably doesn't change that much either. No amount of watching videos is going to substitute for working problems. If you have questions and need more personal guidance, don't be afraid to go to office hours.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45841, "question": "All discrete math courses are abstract and proof-based. At least, they should be. I have some meta-advice: find a good discrete math textbook with problems, and then work every single problem. One possibility is *Discrete Mathematics with Applications* by Epp. Pick up an old edition, since the material doesn't change and the pedagogy probably doesn't change that much either. No amount of watching videos is going to substitute for working problems. If you have questions and need more personal guidance, don't be afraid to go to office hours.", "aSentId": 45842, "answer": "Hey that's the book I used! It's a really good book. The answers often show the proofs step by step and the questions often provide hints that lead you on the right track. Like most math classes the best way to learn is to really just start doing problems", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45841, "question": "All discrete math courses are abstract and proof-based. At least, they should be. I have some meta-advice: find a good discrete math textbook with problems, and then work every single problem. One possibility is *Discrete Mathematics with Applications* by Epp. Pick up an old edition, since the material doesn't change and the pedagogy probably doesn't change that much either. No amount of watching videos is going to substitute for working problems. If you have questions and need more personal guidance, don't be afraid to go to office hours.", "aSentId": 45844, "answer": "I figured they usually were, I just gave that for some context. \n\nAs I mentioned in the OP, one of the big problems I have is that our class doesn't have a textbook, so thank you for the recommendation. I know that videos never compare to doing sample problems, I was just wondering if there were any particularly good websites out there for supplementary instruction.\n\nUnfortunately I am incredibly busy, being a double neuro and comp sci major, so missing office hours is less due to fear and more due to being preoccupied but I'm definitely going to try to head there more in the future.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45833, "question": "Good study resources for Discrete Math?", "aSentId": 45846, "answer": "Are you just struggling with proofs or is it actually the material? Sounds like you're just not confident when it comes to writing proofs. If that's the case, download a pdf of How to Prove It by Velleman and read it this week. It's not long and very conversational, but will serve as an excellent guide to writing basic proofs. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45849, "question": "Conflicting methods for Hamming Codewords?", "aSentId": 45850, "answer": "The positions of the parity bits within each word don't really matter, as long as whoever's communicating agrees which parity bits go where.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45851, "question": "The positions of the parity bits within each word don't really matter, as long as whoever's communicating agrees which parity bits go where.", "aSentId": 45852, "answer": "So there is no standard for generating the parity bits though? His technique generates completely different bits.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45853, "question": "So there is no standard for generating the parity bits though? His technique generates completely different bits.", "aSentId": 45854, "answer": "There's really a lot of freedom in picking which bits go where. There's only one (7,4) Hamming code *up to isomorphism*, but that equates a whole lot of codes. Permute the columns of the generator matrix, and you get another valid generator matrix for a (7,4) Hamming code. Permute the rows, and you get another.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45849, "question": "Conflicting methods for Hamming Codewords?", "aSentId": 45856, "answer": "What is the exact quote of the question?\n\nAlso, good for you for learning. That's what tests are really for.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45857, "question": "What is the exact quote of the question?\n\nAlso, good for you for learning. That's what tests are really for.", "aSentId": 45858, "answer": "\"Consider the format for Hamming Code for 4-bit data if we want to detect and correct single-bit error. Assume even parity. Determine the code for data 1101.\"", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45859, "question": "\"Consider the format for Hamming Code for 4-bit data if we want to detect and correct single-bit error. Assume even parity. Determine the code for data 1101.\"", "aSentId": 45860, "answer": "I would suggest emailing/talking to the teacher and showing what you've found. It may be the teacher had something in mind, but didn't specify the question correctly, or perhaps simply forgot about the common case.\n\nRemember, the point is learning.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45861, "question": "I would suggest emailing/talking to the teacher and showing what you've found. It may be the teacher had something in mind, but didn't specify the question correctly, or perhaps simply forgot about the common case.\n\nRemember, the point is learning.", "aSentId": 45862, "answer": "Yeah I planning on it, he only has 2 office hours a week which are during a class I have. I just wanted to get as much input as possible while I wait for a response. I'm also hesitant because he has like a 1.2 Star rating on ratemyprof and our book seems pretty criticized. Thanks for you help.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45863, "question": "Yeah I planning on it, he only has 2 office hours a week which are during a class I have. I just wanted to get as much input as possible while I wait for a response. I'm also hesitant because he has like a 1.2 Star rating on ratemyprof and our book seems pretty criticized. Thanks for you help.", "aSentId": 45864, "answer": "If the professor turns into a defensive ass, at that point, raise it up to the chair of the department.\n\nHopefully, learning will be the end result, rather than semantics.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45866, "question": "Who are the gems of computer science today?", "aSentId": 45867, "answer": "Erik Demaine. Youngest professor ever at MIT, Ph.D. and proved that [Tetris is NP-complete](http://erikdemaine.org/papers/Tetris_COCOON2003/paper.pdf) by the time he was old enough to drink.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45868, "question": "Erik Demaine. Youngest professor ever at MIT, Ph.D. and proved that [Tetris is NP-complete](http://erikdemaine.org/papers/Tetris_COCOON2003/paper.pdf) by the time he was old enough to drink.", "aSentId": 45869, "answer": "Second Demaine. Met him at SoDA 2015, was a very nice and supremely intelligent guy.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45868, "question": "Erik Demaine. Youngest professor ever at MIT, Ph.D. and proved that [Tetris is NP-complete](http://erikdemaine.org/papers/Tetris_COCOON2003/paper.pdf) by the time he was old enough to drink.", "aSentId": 45871, "answer": "Went to my Uni :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45868, "question": "Erik Demaine. Youngest professor ever at MIT, Ph.D. and proved that [Tetris is NP-complete](http://erikdemaine.org/papers/Tetris_COCOON2003/paper.pdf) by the time he was old enough to drink.", "aSentId": 45873, "answer": "&gt; Erik Demaine\n\nThat guy is cool. I have gone through his Advanced Algorithms Lectures on OCW ....", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45866, "question": "Who are the gems of computer science today?", "aSentId": 45875, "answer": "Leslie Lamport", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45866, "question": "Who are the gems of computer science today?", "aSentId": 45877, "answer": "Let's all not forget the great Peter Norvig.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45880, "question": "Donald Knuth for sure ", "aSentId": 45881, "answer": "I totally agree he's a living legend, but has he been publishing recently though?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45882, "question": "I totally agree he's a living legend, but has he been publishing recently though?", "aSentId": 45883, "answer": "He's supposedly working on the rest of Volume 4 of TAOCP, plus three more volumes, but he's not a young man any more. I just hope Volume 5 gets published; that's the one I'm really interested in reading.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45882, "question": "I totally agree he's a living legend, but has he been publishing recently though?", "aSentId": 45885, "answer": "Ahh, so you mean not only often cited, but also active?\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45886, "question": "Ahh, so you mean not only often cited, but also active?\n", "aSentId": 45887, "answer": "Right!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45888, "question": "Right!", "aSentId": 45889, "answer": "Simon Peyton Jones then. But it becomes very field-specific. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45891, "question": "Disclaimer: I don't know much outside of type theory and functional programming.\n\n* Pretty much everyone listed as an \"official participant\" in the Homotopy Type Theory book, most notably Peter Aczel, Steve Awodey, Thierry Coquand, Andr\u00e9 Joyal, Per Martin-L\u00f6f, and Vladimir Voevodsky. Best known for their contributions to type theory, theorem proving, programming language theory, and a bunch of mathematics that I don't really understand.\n\n* Bob Harper, Philip Wadler, and Neelakantan R. Krishnaswami are amazing in type theory and PLT.\n\n* Lindsey Kuper isn't on the same level as others on this list - she hasn't even completed her Ph. D - but I think she's up to an amazing start with her work on deterministic concurrency.\n\n* Yan Cui, Yann LeCun, Yoshua Bengio, and Andrew Ng in machine learning.\n\n* My professor, mentor and friend Prakash Panangaden in various areas of TCS. He's also an exceptional pedagogue. Having access to him feels completely unreal.\n\n* Dana Scott in TCS, notably automata theory.\n\n* Simon Peyton Jones and Simon Marlowe in applied PLT. They're some of the most important leaders/contributors to the Glasgow Haskell Compiler.", "aSentId": 45892, "answer": "Prakash is awesome!  One of my favorite weeks ever was with him at his workshop in Barbados.  I have never been so productive in such a beautiful place!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45893, "question": "Prakash is awesome!  One of my favorite weeks ever was with him at his workshop in Barbados.  I have never been so productive in such a beautiful place!", "aSentId": 45894, "answer": "+1 for Prakash.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45891, "question": "Disclaimer: I don't know much outside of type theory and functional programming.\n\n* Pretty much everyone listed as an \"official participant\" in the Homotopy Type Theory book, most notably Peter Aczel, Steve Awodey, Thierry Coquand, Andr\u00e9 Joyal, Per Martin-L\u00f6f, and Vladimir Voevodsky. Best known for their contributions to type theory, theorem proving, programming language theory, and a bunch of mathematics that I don't really understand.\n\n* Bob Harper, Philip Wadler, and Neelakantan R. Krishnaswami are amazing in type theory and PLT.\n\n* Lindsey Kuper isn't on the same level as others on this list - she hasn't even completed her Ph. D - but I think she's up to an amazing start with her work on deterministic concurrency.\n\n* Yan Cui, Yann LeCun, Yoshua Bengio, and Andrew Ng in machine learning.\n\n* My professor, mentor and friend Prakash Panangaden in various areas of TCS. He's also an exceptional pedagogue. Having access to him feels completely unreal.\n\n* Dana Scott in TCS, notably automata theory.\n\n* Simon Peyton Jones and Simon Marlowe in applied PLT. They're some of the most important leaders/contributors to the Glasgow Haskell Compiler.", "aSentId": 45896, "answer": "Great list, damn. Extra props to Bob Harper and Neel Krishnaswami; the former has contributed in a huge way to the two sides of type theory (meaning-theoretic/realizability-based type theory on the one hand, and logical frameworks on the other), and the latter has written some of the most aesthetic papers I have had the pleasure of reading.\n\nTo the \"established\" list, I'd add Conor McBride, whose numerous contributions and sense of style are impossible to discount; and Frank Pfenning. To the \"up and coming\", I would add Dan Licata and Noam Zeilberger. And of course there are many more!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45897, "question": "Great list, damn. Extra props to Bob Harper and Neel Krishnaswami; the former has contributed in a huge way to the two sides of type theory (meaning-theoretic/realizability-based type theory on the one hand, and logical frameworks on the other), and the latter has written some of the most aesthetic papers I have had the pleasure of reading.\n\nTo the \"established\" list, I'd add Conor McBride, whose numerous contributions and sense of style are impossible to discount; and Frank Pfenning. To the \"up and coming\", I would add Dan Licata and Noam Zeilberger. And of course there are many more!", "aSentId": 45898, "answer": "Can't believe I forgot Frank Pfenning!\n\nAnd I'm not 100% up-to-date with Krishnaswami's work, but reading him is always a pleasure.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45891, "question": "Disclaimer: I don't know much outside of type theory and functional programming.\n\n* Pretty much everyone listed as an \"official participant\" in the Homotopy Type Theory book, most notably Peter Aczel, Steve Awodey, Thierry Coquand, Andr\u00e9 Joyal, Per Martin-L\u00f6f, and Vladimir Voevodsky. Best known for their contributions to type theory, theorem proving, programming language theory, and a bunch of mathematics that I don't really understand.\n\n* Bob Harper, Philip Wadler, and Neelakantan R. Krishnaswami are amazing in type theory and PLT.\n\n* Lindsey Kuper isn't on the same level as others on this list - she hasn't even completed her Ph. D - but I think she's up to an amazing start with her work on deterministic concurrency.\n\n* Yan Cui, Yann LeCun, Yoshua Bengio, and Andrew Ng in machine learning.\n\n* My professor, mentor and friend Prakash Panangaden in various areas of TCS. He's also an exceptional pedagogue. Having access to him feels completely unreal.\n\n* Dana Scott in TCS, notably automata theory.\n\n* Simon Peyton Jones and Simon Marlowe in applied PLT. They're some of the most important leaders/contributors to the Glasgow Haskell Compiler.", "aSentId": 45900, "answer": "John Reynolds was stunningly active in the 2000s (on separation logic), *and* was also one of the pioneers of programming languages, so I think he deserves a mention.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45905, "question": "Bjarne Stroustrup is a good one, \n\nSince ML is my area and I'm kinda anoyed with everytone listing 4 guys from Neural Network as if that is the whole of Machine Learning, some other big ML names from all over the place (not comprehensive)\n\n* Lin, Chih-Jen (LIBLINEAR and LIBSVM) \n* Shalev-Shwartz, Shai (Lots of theory and papers I see cited all the time) \n* Freund, Yoav (AdaBoost Fame)\n* Schapire, Robert (AdaBoost Fame)\n* Friedman, Jerome H. (KDTrees, Lasso, Elasic Net, Gradient Boosting, MARS, GLMNET)\n* Blei, David (LDA and everything topic models related) \n* Jordan, Michael I (LDA, and all sorts of Bayes stuff. A serious living legend still very active. Andrew Ng, David Blei, and Yoshua Bengio were all grad students of his) \n\n2 more I should have included that I see \n\n* Bernhard Sch\u00f6lkopf and Alex Smola did a lot on SVMs / Kernel methods. ", "aSentId": 45906, "answer": "No Geoff Hinton love? ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45907, "question": "No Geoff Hinton love? ", "aSentId": 45908, "answer": "The point was to list some of the non neural network people because ML is bigger than just NNa", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45909, "question": "The point was to list some of the non neural network people because ML is bigger than just NNa", "aSentId": 45910, "answer": "&gt;  everytone listing 4 guys from Neural Network \n\nTotally read over that. My bad. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45912, "question": "&gt; I do my daily Hail Knuths and Dijkstras but I haven't seen many recent papers from them.\n\nThe reason you haven't seen any recent papers from Dijkstra is that he's been dead for over a decade...", "aSentId": 45913, "answer": "He's not dead.  Just waiting for results from the lab...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45915, "question": "Complexity Theory: Luca Trevisan, Arora, Barak, Goldreich, Goldwasser, Ryan Williams.\n\nCrypto: Jonathan Katz, Amit Sahai, Micali, Goldwasser, Goldreich, Dan Boneh.", "aSentId": 45916, "answer": "I feel Gentry's gotta be in there for crypto.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45917, "question": "I feel Gentry's gotta be in there for crypto.", "aSentId": 45918, "answer": "I was wondering whether to put the more recent awesome people in, but it seems to me this list was meant more as a list of longstanding contributors to their fields who are active today.\n\nOtherwise I'd have put more recent people as well.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45917, "question": "I feel Gentry's gotta be in there for crypto.", "aSentId": 45920, "answer": "Homomorphic encryption", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45915, "question": "Complexity Theory: Luca Trevisan, Arora, Barak, Goldreich, Goldwasser, Ryan Williams.\n\nCrypto: Jonathan Katz, Amit Sahai, Micali, Goldwasser, Goldreich, Dan Boneh.", "aSentId": 45922, "answer": "I remember dan boneh from coursera.  \n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45925, "question": "My guess is whoever was considered \"the coal\" are now considered \"the gems.\" Kinda depends on how much pressure they've been under. Okay I'm done with my puns and I'll see myself out.", "aSentId": 45926, "answer": "&gt; My guess is whoever was considered \"the coal\" are now considered \"the gems.\"\n\nSome of them might have just got burned out or turned to coke.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45928, "question": "Yann LeCun, Geoff Hinton, Andrew Ng, Yoshua Bengio", "aSentId": 45929, "answer": "(the machine learning gods, for those unaware)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45930, "question": "(the machine learning gods, for those unaware)", "aSentId": 45931, "answer": "(the ~~machine learning~~ neural network ~~gods~~ prolific researchers, for those unaware)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45933, "question": "Mark Guzdial, Beth Simon, Stephen Edwards, a few others.", "aSentId": 45934, "answer": "I had the best opportunity to work with Beth Simon throughout my undergraduate career.\n\nShe was actually the main reason why I became a CS major! ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45940, "question": "Ben Goertzel.\n\nSubversive.", "aSentId": 45941, "answer": "&gt; Ben Goertze\n\nI was an Intern at Intelligenesis, his first company, which had a branch in Brazil with about 50 employees, mostly from UFMG (a Brazilian university). It was my first job, but less than an year after I lost it because of the NASDAQ crash... It was a research company whose goal was to build just the first computational brain, but in hindsight they were a bit too ambitious.\n\nSince the company was research only and depended solely on investors, the crash in the market meant the money dried and jobless I was.\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45942, "question": "&gt; Ben Goertze\n\nI was an Intern at Intelligenesis, his first company, which had a branch in Brazil with about 50 employees, mostly from UFMG (a Brazilian university). It was my first job, but less than an year after I lost it because of the NASDAQ crash... It was a research company whose goal was to build just the first computational brain, but in hindsight they were a bit too ambitious.\n\nSince the company was research only and depended solely on investors, the crash in the market meant the money dried and jobless I was.\n\n", "aSentId": 45943, "answer": "That sucks. When I hear stories like this I always wonder what they could have made with a couple more years of funding. The really \"ambitious\" companies are by far the most interesting and can produce great stuff by accident. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45946, "question": "Paul Hilfinger", "aSentId": 45947, "answer": "Ha. Hahahaha. Haha.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45951, "question": "What about Tim Berners-Lee, dude invented the World Wide Web you know, launched the World Wide Web Foundation, and is president of the Open Data Institute.", "aSentId": 45952, "answer": "Physicists not welcome evidently! :p ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45956, "question": "Minimizing Maximum Distance", "aSentId": 45957, "answer": "This link might help:\n\nhttp://stackoverflow.com/questions/15346216/minimize-maximum-manhattan-distance-of-a-point-to-a-set-of-points", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45959, "question": "Do You Want To To Make Your Own Computer Operating System? Here Is A Free Guide And Some Bonuses", "aSentId": 45960, "answer": "i was just sharing", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45962, "question": "If the world really is a simulation, what are some ways, if there's any, in which we can figure out it is a simulation?", "aSentId": 45963, "answer": "It really depends on what the universe outside the simulation looks like. People usually assume that the outside universe looks like ours, but that assumption is grounded in pretty much nothing. Think about it; whenever we simulate a universe, that universe is much simpler and much smaller. As an example, Game of Life is arguably a tiny universe, obviously with completely different laws of physics.\n\nIf the outside universe isn't like ours, there's no reason to assume that math like the standard model of particle physics isn't *really easy* to compute to essentially infinite precision in the outside universe. This means that we can't use rounding-arguments or anything similar.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45964, "question": "It really depends on what the universe outside the simulation looks like. People usually assume that the outside universe looks like ours, but that assumption is grounded in pretty much nothing. Think about it; whenever we simulate a universe, that universe is much simpler and much smaller. As an example, Game of Life is arguably a tiny universe, obviously with completely different laws of physics.\n\nIf the outside universe isn't like ours, there's no reason to assume that math like the standard model of particle physics isn't *really easy* to compute to essentially infinite precision in the outside universe. This means that we can't use rounding-arguments or anything similar.", "aSentId": 45965, "answer": "&gt; People usually assume that the outside universe looks like ours, but that assumption is grounded in pretty much nothing\n\nActually, there are good reasons (philosophically) to start there. \n\n(1) humans build computer to solve problems relevant to our universe. The design of our computers don't simulate the physical world directly, but they do reflect the kinds of design tasks we wish to solve, which is driven indirectly by the laws of the universe we inhabit. \n\n(2) Virtual machines. The less the simulated model deviates from the universe it inhabits, the cheaper simulation becomes. Game emulators have high overhead because they often simulate a different processor, while CPU virtualization is much cheaper as it can re-use the existing processor for much of the work directly. Also, transpiling can speed up emulation immensely, but that can change timing of instructions unless you're very careful, allowing characteristics of the \"real\" processor to bleed through the simulation. \n\nYou generally don't bother to hide any of the leaks unless you have an imperative reason (e.g. the game doesn't work unless you hide it), and even then, you hide as little as you can get away with (e.g. small glitches that don't affect gameplay, keeping performance better)\n\nFor many practical reasons, the simulations we produce \"leak\" information about our world into the simulation. Likewise, the computer we are simulated on might have similar leaks for similar practical reasons.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45964, "question": "It really depends on what the universe outside the simulation looks like. People usually assume that the outside universe looks like ours, but that assumption is grounded in pretty much nothing. Think about it; whenever we simulate a universe, that universe is much simpler and much smaller. As an example, Game of Life is arguably a tiny universe, obviously with completely different laws of physics.\n\nIf the outside universe isn't like ours, there's no reason to assume that math like the standard model of particle physics isn't *really easy* to compute to essentially infinite precision in the outside universe. This means that we can't use rounding-arguments or anything similar.", "aSentId": 45967, "answer": "I like this response. In the grand scope of things, all philosophy, science, and religion falls prey to the quandary of limited scope. There is a proper term, but it is an ancient concept: the idea that we could all be in a universe riding on the back of a giant turtle floating through a further larger pond. There is a definite limit to attainable knowledge that most people don't recognize. There is an attitude of near-attainable omniscience in the sciences that is over assumptive.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45964, "question": "It really depends on what the universe outside the simulation looks like. People usually assume that the outside universe looks like ours, but that assumption is grounded in pretty much nothing. Think about it; whenever we simulate a universe, that universe is much simpler and much smaller. As an example, Game of Life is arguably a tiny universe, obviously with completely different laws of physics.\n\nIf the outside universe isn't like ours, there's no reason to assume that math like the standard model of particle physics isn't *really easy* to compute to essentially infinite precision in the outside universe. This means that we can't use rounding-arguments or anything similar.", "aSentId": 45969, "answer": "I guess there's a great difference between math and physical world; it is completely legit to take the sqrt(5). but try to draw it... It's impossible because it is irrational and we have a \"shortest\" possible distance in the universe (the Planck' distance) so we cannot construct irrational numbers, but we can calculate them on infinite precision.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45970, "question": "I guess there's a great difference between math and physical world; it is completely legit to take the sqrt(5). but try to draw it... It's impossible because it is irrational and we have a \"shortest\" possible distance in the universe (the Planck' distance) so we cannot construct irrational numbers, but we can calculate them on infinite precision.", "aSentId": 45971, "answer": "Math was never intended to address reality.  It is a set of statements which are the necessary logical outcome of certain assumed truths, and nothing else.  There is no connection between mathematics and physical reality.  They do correlate in some amazing ways, but there are also many ways in which mathematics falls far short.  Some of the assumptions underlying mathematics, like a continuous space, are likely not held by physical reality (where spacetime is probably quantized on a certain level), so we should expect many things in mathematics to not apply to reality.  Pi, for instance, taken as the division of the circumference to diameter of a circle, is an irrational number in mathematics, but in physical reality that ratio has an exact answer for a given scale in quantized space.  Mathematics is still useful though, because Pi calculated on physical bases would be different on different scales, but would approach mathematical pi in the infinite.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45972, "question": "Math was never intended to address reality.  It is a set of statements which are the necessary logical outcome of certain assumed truths, and nothing else.  There is no connection between mathematics and physical reality.  They do correlate in some amazing ways, but there are also many ways in which mathematics falls far short.  Some of the assumptions underlying mathematics, like a continuous space, are likely not held by physical reality (where spacetime is probably quantized on a certain level), so we should expect many things in mathematics to not apply to reality.  Pi, for instance, taken as the division of the circumference to diameter of a circle, is an irrational number in mathematics, but in physical reality that ratio has an exact answer for a given scale in quantized space.  Mathematics is still useful though, because Pi calculated on physical bases would be different on different scales, but would approach mathematical pi in the infinite.", "aSentId": 45973, "answer": "I'm very much aware of that. If maths would be linked to reality it would very much hinder it.\n\nMy point was: if we construct a length we can only measure how often the Planck length fits in. So there is a certain precision bounding our universe, which is in my opinion a argument for the simulation theorem.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45962, "question": "If the world really is a simulation, what are some ways, if there's any, in which we can figure out it is a simulation?", "aSentId": 45975, "answer": "The world, as we experience it, **is a simulation**. Pay careful attention to my wording: the world *as we experience it*, is a simulation.\n\nA photon strikes your eye, triggering a response in a rod or cone. This fires of a chain of neural activity, which involves a huge amount of processing- inside the eye itself a modelling process begins, and successive layers of analysis handle this signal, searching for lines, movement, and other forms of feature detection.\n\nEventually, this new input gets merged into your internal model about the state of the world. Everything you do, everything you experience, everything you think, is *operations upon this model*.\n\nThink of this as \"weak solipsism\". There *is* a real world out there- the photons striking your eye right now are real objects, originating from the screen in front of you, itself a real object. But your sensorium- your experience of this screen, those photons- is simulated. You can't actually *see* the screen, as it actually is. You interpret a set of signals and construct a mental model of the screen.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45976, "question": "The world, as we experience it, **is a simulation**. Pay careful attention to my wording: the world *as we experience it*, is a simulation.\n\nA photon strikes your eye, triggering a response in a rod or cone. This fires of a chain of neural activity, which involves a huge amount of processing- inside the eye itself a modelling process begins, and successive layers of analysis handle this signal, searching for lines, movement, and other forms of feature detection.\n\nEventually, this new input gets merged into your internal model about the state of the world. Everything you do, everything you experience, everything you think, is *operations upon this model*.\n\nThink of this as \"weak solipsism\". There *is* a real world out there- the photons striking your eye right now are real objects, originating from the screen in front of you, itself a real object. But your sensorium- your experience of this screen, those photons- is simulated. You can't actually *see* the screen, as it actually is. You interpret a set of signals and construct a mental model of the screen.", "aSentId": 45977, "answer": "Came here for solipsism, was not disappointed.\n\n&gt; There *is* a real world out there\n\nActually the way the OP worded the question, you could probably switch over to hard solipsism. We *agree* there's a \"real world\" but unless there's some kind of Morpheus character running around telling everyone they're in a simulation, there might not be any way of ever knowing *for sure*. You might just be a brain in a jar being fed some very convincing signals.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45978, "question": "Came here for solipsism, was not disappointed.\n\n&gt; There *is* a real world out there\n\nActually the way the OP worded the question, you could probably switch over to hard solipsism. We *agree* there's a \"real world\" but unless there's some kind of Morpheus character running around telling everyone they're in a simulation, there might not be any way of ever knowing *for sure*. You might just be a brain in a jar being fed some very convincing signals.", "aSentId": 45979, "answer": "&gt; You might just be a brain in a jar being fed some very convincing signals.\n\nNot to go Cartesian, but even if I'm a brain in a jar- there's a real world out there. My model of it isn't accurate, but the signals have an origin. My statements are founded on the idea that our senses detect signals that exist outside of themselves- hence my *weak solipsism*.\n\nRegardless, our ability to experience the world *is* a simulation. We're at least \"one level deep\". The next question is: \"are the signals themselves simulated or fabricated in some fashion?\" It's impossible to know for certain, because we can't actually interact with the signals directly- our only interaction with them is the simulation that we build based on them.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45980, "question": "&gt; You might just be a brain in a jar being fed some very convincing signals.\n\nNot to go Cartesian, but even if I'm a brain in a jar- there's a real world out there. My model of it isn't accurate, but the signals have an origin. My statements are founded on the idea that our senses detect signals that exist outside of themselves- hence my *weak solipsism*.\n\nRegardless, our ability to experience the world *is* a simulation. We're at least \"one level deep\". The next question is: \"are the signals themselves simulated or fabricated in some fashion?\" It's impossible to know for certain, because we can't actually interact with the signals directly- our only interaction with them is the simulation that we build based on them.", "aSentId": 45981, "answer": "Touch\u00e9. Very good point. Yes I suppose if you really want to drink the hard-solipsism kool-aid you'd have to doubt the existence of the entire universe, and take some transcendental leap like saying that you're god or something.\n\nSo back to the OPs point, yes reality could be a simulation if reality isn't really real and you're just god pretending you're not god. So Buddhism\n basically.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45978, "question": "Came here for solipsism, was not disappointed.\n\n&gt; There *is* a real world out there\n\nActually the way the OP worded the question, you could probably switch over to hard solipsism. We *agree* there's a \"real world\" but unless there's some kind of Morpheus character running around telling everyone they're in a simulation, there might not be any way of ever knowing *for sure*. You might just be a brain in a jar being fed some very convincing signals.", "aSentId": 45983, "answer": "&gt; You might just be a brain in a jar being fed some very convincing signals\n\nOr, you might be a model of a brain in a file in a computer. That too. \n\n(And the computer could be a model of a computer in another computer. That's called a virtual machine, and your web browser is running in one of those!)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45984, "question": "&gt; You might just be a brain in a jar being fed some very convincing signals\n\nOr, you might be a model of a brain in a file in a computer. That too. \n\n(And the computer could be a model of a computer in another computer. That's called a virtual machine, and your web browser is running in one of those!)", "aSentId": 45985, "answer": "And the javascript running within the web browser is running the latest crap from github which simulates a VM emulating another VM. Which is running BeOS for some reason.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45962, "question": "If the world really is a simulation, what are some ways, if there's any, in which we can figure out it is a simulation?", "aSentId": 45987, "answer": "The more perfect the simulation, the harder it would be to prove.  Improbable coincidences (e.g., the fact that Earth's two most visible heavenly bodies appear to be the same size) or the breakdown of classical physics at the extremes of perception might suggest a simulated reality, but hardly constitute proof.  If at some point we encountered an otherwise inexplicable limit on the amount of computing power extant in the world, then this might delineate a simulation boundary, as all that hardware must effectively be being simulated in software, assuming of course that the hardware/software distinction exists in the first place, outside the simulation.  Or, if our computational abilities advanced to the point that we could ourselves construct a near-perfect simulation of the universe, then it might become evident that we must be occupying one as well, as   it would be too improbable that our reality be the outermost of a potentially large number of layers.   ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45988, "question": "The more perfect the simulation, the harder it would be to prove.  Improbable coincidences (e.g., the fact that Earth's two most visible heavenly bodies appear to be the same size) or the breakdown of classical physics at the extremes of perception might suggest a simulated reality, but hardly constitute proof.  If at some point we encountered an otherwise inexplicable limit on the amount of computing power extant in the world, then this might delineate a simulation boundary, as all that hardware must effectively be being simulated in software, assuming of course that the hardware/software distinction exists in the first place, outside the simulation.  Or, if our computational abilities advanced to the point that we could ourselves construct a near-perfect simulation of the universe, then it might become evident that we must be occupying one as well, as   it would be too improbable that our reality be the outermost of a potentially large number of layers.   ", "aSentId": 45989, "answer": "&gt; if at some point we encountered an otherwise inexplicable limit on the amount of computing power extant in the world, then this might delineate a simulation boundary, as all that hardware must effectively be being simulated in software\n\nThe software doing the simulating isn't bound by our time-frame though. The simulator can have slower hardware simulating more advance hardware by running the simulation at 1/10th of the speed. From the perspective of the simulated, there'd be no change in time.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45990, "question": "&gt; if at some point we encountered an otherwise inexplicable limit on the amount of computing power extant in the world, then this might delineate a simulation boundary, as all that hardware must effectively be being simulated in software\n\nThe software doing the simulating isn't bound by our time-frame though. The simulator can have slower hardware simulating more advance hardware by running the simulation at 1/10th of the speed. From the perspective of the simulated, there'd be no change in time.", "aSentId": 45991, "answer": "that's the only way my ecology simulation works", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45988, "question": "The more perfect the simulation, the harder it would be to prove.  Improbable coincidences (e.g., the fact that Earth's two most visible heavenly bodies appear to be the same size) or the breakdown of classical physics at the extremes of perception might suggest a simulated reality, but hardly constitute proof.  If at some point we encountered an otherwise inexplicable limit on the amount of computing power extant in the world, then this might delineate a simulation boundary, as all that hardware must effectively be being simulated in software, assuming of course that the hardware/software distinction exists in the first place, outside the simulation.  Or, if our computational abilities advanced to the point that we could ourselves construct a near-perfect simulation of the universe, then it might become evident that we must be occupying one as well, as   it would be too improbable that our reality be the outermost of a potentially large number of layers.   ", "aSentId": 45993, "answer": "&gt;  Improbable coincidences (e.g., the fact that Earth's two most visible heavenly bodies appear to be the same size)\n\nWe do need to keep in mind though that at the scale of the universe, very improbable things happen all the time.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45994, "question": "&gt;  Improbable coincidences (e.g., the fact that Earth's two most visible heavenly bodies appear to be the same size)\n\nWe do need to keep in mind though that at the scale of the universe, very improbable things happen all the time.  ", "aSentId": 45995, "answer": "Sometimes I've believed as many as six improbable coincidences before breakfast!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45997, "question": "We get to apply the pigeonhole principle!\n\nWe have n bits of matter in the universe, so an ideal simulation can, at most, simulate 2^n different states.  Energy (and, thus, matter) are constant in our universe.  If there's absolutely NO overhead in the simulation, then things can go on pretty much forever and it's unlikely we're in the top layer.  However, since it is likely that at least some of the matter doesn't go directly to the simulation (I'm an asshole and I'm not going to contribute to any simulations below this), then we have lossy encoding, with each layer of simulation becoming less and less powerful.  In this scenario, the likelihood that we're at the top level of the simulation becomes very high.\n\nThere are other ways to disprove that we're in certain types of simulations.  (For example, we can be sure that we're not in some cellular automata-esque simulation because of the rotationally invariant properties of physics events.)\n\nAt its heart, however, the problem is that the simulation \"theory\" doesn't contribute anything useful because (1) it doesn't have predictive power, (2) it doesn't offer any explanatory power beyond what is already explained by existing models of the universe, (3) it doesn't simplify current understandings, and (4) it's not falsifyable or testable in the case of perfect simulations.", "aSentId": 45998, "answer": "What exactly do you mean when you talk about levels of the simulation? ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45999, "question": "What exactly do you mean when you talk about levels of the simulation? ", "aSentId": 46000, "answer": "If the simulation is realistic enough, the people inside the simulation would wanna make a simulation just like the people that created the original simulation did; and this might go on for many levels.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45997, "question": "We get to apply the pigeonhole principle!\n\nWe have n bits of matter in the universe, so an ideal simulation can, at most, simulate 2^n different states.  Energy (and, thus, matter) are constant in our universe.  If there's absolutely NO overhead in the simulation, then things can go on pretty much forever and it's unlikely we're in the top layer.  However, since it is likely that at least some of the matter doesn't go directly to the simulation (I'm an asshole and I'm not going to contribute to any simulations below this), then we have lossy encoding, with each layer of simulation becoming less and less powerful.  In this scenario, the likelihood that we're at the top level of the simulation becomes very high.\n\nThere are other ways to disprove that we're in certain types of simulations.  (For example, we can be sure that we're not in some cellular automata-esque simulation because of the rotationally invariant properties of physics events.)\n\nAt its heart, however, the problem is that the simulation \"theory\" doesn't contribute anything useful because (1) it doesn't have predictive power, (2) it doesn't offer any explanatory power beyond what is already explained by existing models of the universe, (3) it doesn't simplify current understandings, and (4) it's not falsifyable or testable in the case of perfect simulations.", "aSentId": 46002, "answer": "&gt; then we have lossy encoding, with each layer of simulation becoming less and less powerful\n\nCould QM be a manifestation of such lossy encoding? Things work \"nicely\" at macro-scale, but start getting uncertain at micro-scale.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46003, "question": "&gt; then we have lossy encoding, with each layer of simulation becoming less and less powerful\n\nCould QM be a manifestation of such lossy encoding? Things work \"nicely\" at macro-scale, but start getting uncertain at micro-scale.", "aSentId": 46004, "answer": "I always like to think of quantum uncertainty as the universe's approach to \"lazy evaluation\"- instead of tracking the state of a particle, just use a function to derive its state when you actually need it. Given the relative rarity of interactions between particles (space being mostly empty), it'd be super efficient.\n\nNB: I'm not saying it's a shortcut for simulation. I am saying that the universe is efficient and parsimonious.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46005, "question": "I always like to think of quantum uncertainty as the universe's approach to \"lazy evaluation\"- instead of tracking the state of a particle, just use a function to derive its state when you actually need it. Given the relative rarity of interactions between particles (space being mostly empty), it'd be super efficient.\n\nNB: I'm not saying it's a shortcut for simulation. I am saying that the universe is efficient and parsimonious.", "aSentId": 46006, "answer": "The reason why this doesn't work though is that the state of the particle does matter throughout its evolution. The probability of measuring a specific state at time t depends directly on the last state at t-dt and so the universe must keep track of the information during evolution. Similarly quantum states can affect other quantum states in a deterministic way, it is just the final outcome upon measurement that is probabilistic.  \n\nI have thought of quantum mechanics as a type of lossy encoding before but it is not immediate to me how it would work to make simulation easier in trying to simulate a classical world from another classical world (classical top level sim -&gt; quantum approximation sim step -&gt; our classical but somewhat approximate due to quantum intermediary step sim)  it doesn't immediately make sense why the quantum intermediate step would be necessary as the subject of quantum information shows us that simulating quantum systems is inherently more difficult then classical systems. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46007, "question": "The reason why this doesn't work though is that the state of the particle does matter throughout its evolution. The probability of measuring a specific state at time t depends directly on the last state at t-dt and so the universe must keep track of the information during evolution. Similarly quantum states can affect other quantum states in a deterministic way, it is just the final outcome upon measurement that is probabilistic.  \n\nI have thought of quantum mechanics as a type of lossy encoding before but it is not immediate to me how it would work to make simulation easier in trying to simulate a classical world from another classical world (classical top level sim -&gt; quantum approximation sim step -&gt; our classical but somewhat approximate due to quantum intermediary step sim)  it doesn't immediately make sense why the quantum intermediate step would be necessary as the subject of quantum information shows us that simulating quantum systems is inherently more difficult then classical systems. ", "aSentId": 46008, "answer": "&gt;  The probability of measuring a specific state at time t depends directly on the last state at t-dt and so the universe must keep track of the information during evolution\n\nThis simply isn't true. Spin, for example- a simple, binary property, goes from an undefined state to a randomly chosen state when it decoheres. It doesn't matter what the original spin was.\n\n&gt; Similarly quantum states can affect other quantum states in a deterministic way, it is just the final outcome upon measurement that is probabilistic.\n\nEntanglement *is* deterministic, but the way it achieves that is by merging multiple particles into a single quantum system. Two entangled qubits can be essentially treated as a single object (failing to do so breaks the entanglement). Again, with spin, if you take an undefined spin and apply a NOT operation to put a second qubit in the opposite spin, we have *no* information about the spin of either particle, aside from their relationship- they're opposite. The universe can safely discard information about the individual spins until it finally needs to interact this system with another.\n\n&gt; in trying to simulate a classical world from another classical world\n\nYou're going at it backwards. Quantum mechanics, with its ability to represent multiple states in a single entity, makes it easier to simulate a classical world. Classical physics is the lossy encoding. Quantum mechanics isn't lossy- it's *lazy*.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46009, "question": "&gt;  The probability of measuring a specific state at time t depends directly on the last state at t-dt and so the universe must keep track of the information during evolution\n\nThis simply isn't true. Spin, for example- a simple, binary property, goes from an undefined state to a randomly chosen state when it decoheres. It doesn't matter what the original spin was.\n\n&gt; Similarly quantum states can affect other quantum states in a deterministic way, it is just the final outcome upon measurement that is probabilistic.\n\nEntanglement *is* deterministic, but the way it achieves that is by merging multiple particles into a single quantum system. Two entangled qubits can be essentially treated as a single object (failing to do so breaks the entanglement). Again, with spin, if you take an undefined spin and apply a NOT operation to put a second qubit in the opposite spin, we have *no* information about the spin of either particle, aside from their relationship- they're opposite. The universe can safely discard information about the individual spins until it finally needs to interact this system with another.\n\n&gt; in trying to simulate a classical world from another classical world\n\nYou're going at it backwards. Quantum mechanics, with its ability to represent multiple states in a single entity, makes it easier to simulate a classical world. Classical physics is the lossy encoding. Quantum mechanics isn't lossy- it's *lazy*.", "aSentId": 46010, "answer": "I knew Haskell was the language of the universe!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46011, "question": "I knew Haskell was the language of the universe!", "aSentId": 46012, "answer": "Actually, they [hacked most of it together in Perl](https://xkcd.com/224/).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46009, "question": "&gt;  The probability of measuring a specific state at time t depends directly on the last state at t-dt and so the universe must keep track of the information during evolution\n\nThis simply isn't true. Spin, for example- a simple, binary property, goes from an undefined state to a randomly chosen state when it decoheres. It doesn't matter what the original spin was.\n\n&gt; Similarly quantum states can affect other quantum states in a deterministic way, it is just the final outcome upon measurement that is probabilistic.\n\nEntanglement *is* deterministic, but the way it achieves that is by merging multiple particles into a single quantum system. Two entangled qubits can be essentially treated as a single object (failing to do so breaks the entanglement). Again, with spin, if you take an undefined spin and apply a NOT operation to put a second qubit in the opposite spin, we have *no* information about the spin of either particle, aside from their relationship- they're opposite. The universe can safely discard information about the individual spins until it finally needs to interact this system with another.\n\n&gt; in trying to simulate a classical world from another classical world\n\nYou're going at it backwards. Quantum mechanics, with its ability to represent multiple states in a single entity, makes it easier to simulate a classical world. Classical physics is the lossy encoding. Quantum mechanics isn't lossy- it's *lazy*.", "aSentId": 46014, "answer": "&gt; This simply isn't true. Spin, for example- a simple, binary property, goes from an undefined state to a randomly chosen state when it decoheres. It doesn't matter what the original spin was.\n\nThis simply isn't true. A known quantum state will de-cohere to a mixed state (or weakly polarized depending on the system, ie. NMR). Upon measuring this de-cohered state it will result in an approximately uniformly random distribution (approximate due to energy splitting causing probability unbalance in the thermal Boltzmann state). However, given a known quantum state it very much so has a defined behaviour according to Schr\u00f6dinger's equation and its evolution depends on initial state at t=0 as it is a second order differential equation. Of course on the macro scale it does not matter what the initial state was, as according to the large statistical nature of the universe, any single particle plays no large role and that is how classical physics emerge. But when tracking individual states their evolution does matter. \n\n&gt; Entanglement is deterministic, but the way it achieves that is by merging multiple particles into a single quantum system. Two entangled qubits can be essentially treated as a single object (failing to do so breaks the entanglement). Again, with spin, if you take an undefined spin and apply a NOT operation to put a second qubit in the opposite spin, we have no information about the spin of either particle, aside from their relationship- they're opposite. The universe can safely discard information about the individual spins until it finally needs to interact this system with another.\n\nWhile I agree with this, the universe must still track the entangled system evolution under the system Hamiltonian as the eventual result will depend on the entangled state at some time t, not at the moment of entanglement. \n\n&gt; You're going at it backwards. Quantum mechanics, with its ability to represent multiple states in a single entity, makes it easier to simulate a classical world. Classical physics is the lossy encoding. Quantum mechanics isn't lossy- it's lazy.\n\nI'm not going at it backwards, I'm looking at it from one level above that. I am arguing that it wouldn't make sense for someone living in a \"classical\" universe to implement the quantum intermediary step to simulate our \"classical\" universe as this quantum intermediary step would take exponentially more computational power then a classical system. \n\nI am not saying that quantum mechanics is not an approximation that is introduced to make simulating our universe computationally less complex. I am just saying if it is, then those simulating are universe would not be living in a universe that is purely classical as it would not make sense to implement. \n\n\nedit -- The way I could see QM as being a useful simulation tool in the sense of lazy evaluation. Is that if it had some intelligent subroutine that would detect when a system was being looked at, at on the \"quantum-scale\" and then simulated Quantum Mechanics in its entirety. That way in the day to day sense it could do lazy evaluation and when pesky people started mucking about with physics, it would substitute in QM for that portion of the sim. Of course this would have a large overhead, and would actually slow the entire system down pretty quickly for large quantum mechanics experiments. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46003, "question": "&gt; then we have lossy encoding, with each layer of simulation becoming less and less powerful\n\nCould QM be a manifestation of such lossy encoding? Things work \"nicely\" at macro-scale, but start getting uncertain at micro-scale.", "aSentId": 46016, "answer": "No, because QM is much more specific than just \"weirdness at the micro scale\". The specifics are complicated, but you can try looking at some of the quantum computation simulators to understand it (this won't teach you quantum physics, of course, but it will teach a lot (dare I say most) of the weirdness in QM).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 45997, "question": "We get to apply the pigeonhole principle!\n\nWe have n bits of matter in the universe, so an ideal simulation can, at most, simulate 2^n different states.  Energy (and, thus, matter) are constant in our universe.  If there's absolutely NO overhead in the simulation, then things can go on pretty much forever and it's unlikely we're in the top layer.  However, since it is likely that at least some of the matter doesn't go directly to the simulation (I'm an asshole and I'm not going to contribute to any simulations below this), then we have lossy encoding, with each layer of simulation becoming less and less powerful.  In this scenario, the likelihood that we're at the top level of the simulation becomes very high.\n\nThere are other ways to disprove that we're in certain types of simulations.  (For example, we can be sure that we're not in some cellular automata-esque simulation because of the rotationally invariant properties of physics events.)\n\nAt its heart, however, the problem is that the simulation \"theory\" doesn't contribute anything useful because (1) it doesn't have predictive power, (2) it doesn't offer any explanatory power beyond what is already explained by existing models of the universe, (3) it doesn't simplify current understandings, and (4) it's not falsifyable or testable in the case of perfect simulations.", "aSentId": 46018, "answer": "Well all the arguments are sound, but I don't think we can apply out understanding of universe outside of it. If our universe is simulation, then somebody running the simulation could just state that the rule of the simulation is \"Energy cannot be destroyed.\" But in his real world the energy could easily be destroyed/created at will, there even can be no such thing as energy...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46019, "question": "Well all the arguments are sound, but I don't think we can apply out understanding of universe outside of it. If our universe is simulation, then somebody running the simulation could just state that the rule of the simulation is \"Energy cannot be destroyed.\" But in his real world the energy could easily be destroyed/created at will, there even can be no such thing as energy...", "aSentId": 46020, "answer": "Sure, but this is when that last paragraph of the top level post comes in. \n\nIf your theory meets none of the criteria for an empirical theory, and you believe it has merit anyway, then you're experiencing faith, not reason. And that's religion, not science. \n\nA weird tron-esque science fictiony religion, but still.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46021, "question": "Sure, but this is when that last paragraph of the top level post comes in. \n\nIf your theory meets none of the criteria for an empirical theory, and you believe it has merit anyway, then you're experiencing faith, not reason. And that's religion, not science. \n\nA weird tron-esque science fictiony religion, but still.", "aSentId": 46022, "answer": "&gt; If your theory meets none of the criteria for an empirical theory, and you believe it has merit anyway, then you're experiencing faith, not reason. And that's religion, not science.\n\nThat really depends on what you consider 'criteria for an empirical theory'. Some people require positivist-style criteria, but that is arguably too strict; for instance, I would say that the idea that photons continue existing even if they are so far away that the expansion of the the universe prevents me from ever interacting with them has merit (for Occamian reasons), but it doesn't really satisfy criteria like falsifiability.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46025, "question": "&gt;There are other ways to disprove that we're in certain types of simulations. \n\n:&lt; I thought that maybe that is how physics works. That we will find out quantized spacetime, and quantized energy. Then, universe would be grid, with fields either filled with energy(1), or not(0). As of laws of physics, there could be simple algorithm that evolves these patterns of energy, like a game of life.\n\nI wouldn't agree about (3) in this case. It would greatly simplify current understandings.\n\nAs for grid, physically it could be 1-dimensional, of course, like arrays. But logically, 3-or-more D.\n\nIt would be awesome if our universe algo could be expressed with  single array of bits and few lines of code in C :D\n\nAre you sure that it's impossible? AFAIK certain cellular automata, like Game of Life, are Turing-Complete.", "aSentId": 46026, "answer": "Yes, there are experiments showing that the laws of nature are rotationally invariant.  Equally, measurable relativistic events (Like Lorentz Contraction) means the grid would have to change size and rotation and deform.  Basically, the grid would have to have properties which preclude it from being a grid.\n\nAdditionally, a grid structure would be detectable through variations in energy requirements to induce measurable amounts of motion.\n\nIf you really wanted to say that the universe obeyed some rules of automata, you would have to change the definition of automata to something that I don't think most informed people would find agreeable, or change the definition of grid to something meaningless.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46027, "question": "Yes, there are experiments showing that the laws of nature are rotationally invariant.  Equally, measurable relativistic events (Like Lorentz Contraction) means the grid would have to change size and rotation and deform.  Basically, the grid would have to have properties which preclude it from being a grid.\n\nAdditionally, a grid structure would be detectable through variations in energy requirements to induce measurable amounts of motion.\n\nIf you really wanted to say that the universe obeyed some rules of automata, you would have to change the definition of automata to something that I don't think most informed people would find agreeable, or change the definition of grid to something meaningless.", "aSentId": 46028, "answer": "But maybe granularity of grid is too small to us to detect this?\n\nBut I know next to nothing about physics(I will learn more, someday), so I guess you're right.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46027, "question": "Yes, there are experiments showing that the laws of nature are rotationally invariant.  Equally, measurable relativistic events (Like Lorentz Contraction) means the grid would have to change size and rotation and deform.  Basically, the grid would have to have properties which preclude it from being a grid.\n\nAdditionally, a grid structure would be detectable through variations in energy requirements to induce measurable amounts of motion.\n\nIf you really wanted to say that the universe obeyed some rules of automata, you would have to change the definition of automata to something that I don't think most informed people would find agreeable, or change the definition of grid to something meaningless.", "aSentId": 46030, "answer": "&gt; Basically, the grid would have to have properties which preclude it from being a grid.\n\nAmusingly, this is a pretty good characterization of the state of film and video game raster graphics techniques. We can \"fake\" a lot more than was thought possible 10 years ago.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46032, "question": "This comment makes no sense.  You're just saying words until the last paragraph.  Where are you using the pigeonhole principle?  Where are you using 2^n ?  2^n doesn't even make sense---why 2?  Each bit of matter can be on or off?  None of this makes any sense!", "aSentId": 46033, "answer": "I suppose I could do a better job explaining the intuition.  I wanted to apply pigeonhole to show that there is a finite complexity to any simulation that can be done with a finite amount of matter.  It does make some simplifying assumptions about the nature of computation and the importance of unique states.  (We know the universe will keep expanding, so we do need an infinite number of states to be simulated.)  I'll come back to that tonight.  What I had hoped to show is that simulations are bound strictly by the complexity of the 'host machine', if I can steal the term.  Each simulation within a simulation must be less complicated, then. (Fewer states to use, due to the overhead of the machine and due to matter in the system not being a part of the machine.). If the complexity keeps decreasing, eventually we get a system where a meaningful simulation can't be created.  I'm assuming since our universe is not 100% dedicated to a simulation (as near as science can detect), other levels exhibit the same lossiness.  That indicates that we are not one level of an infinite set of simulations.\n\nPerhaps that's not much better.  I suppose I'll have to go back and try to revise the response.\n\nIs it at least clear what I'm trying to demonstrate?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46035, "question": "Unless there is some official definition of \"simulation\" I am not aware of, this is mostly a philosophical question. If you think of a simulation in the sense of our current computers, the usual arguments about limited memory and such apply.\nIf you do not want to make this assumption you are basically left with a \"Is there a god?\"-kind of question. In the universe which \"simulates\" us, there could be models of computing beyond our grasp. Our current computers are LBAs, maybe our simulation runs on a \"super Turing machine\" which uses the real numbers as a tape and can store infinitely many values in each cell.", "aSentId": 46036, "answer": "&gt; Unless there is some official definition of \"simulation\" I am not aware of, this is mostly a philosophical question.\n\nIt's also a modeling question. Suppose we could figure out the computation complexity of the \"computer\" we exist in. That would put limits on the complexity class of computers we could hope to build within said simulation. It might even provide insights on how to design them. (Quantum computers, for instance, are turning out to be notoriously difficult to design).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46038, "question": "There are two obvious things that we could look for: resolution and frame rate.\n\nBoth of which exist in the universe - in the form of Planck Length and Planck Time.\n\nBut as far as evidence goes it's pretty weak. For Planck Length \"it is impossible to determine the difference between two locations less than one Planck length apart\" while Planck Time \"is the time required for light to travel, in a vacuum, a distance of 1 Planck length\". It just means that (according to the math) things of that order of magnitude are incoherent to any form of measurement.\n\nBut suppose our instruments got powerful enough to measure such small orders of magnitude. One thing that we could do to prove we are a simulation is to show that *nothing* happens between Planck Time intervals.\n\nIt would be like a Sim noticing that absolutely no updates happen to their world between frames. Such a Sim would be unaware of how much time passes in the \"real world\" between frames, but would be able to tell that some calculations happen and then things change. Any attempt to measure things at an interval less than N frames per second results in null data. They would experience similar problems attempting to measure a distance less than one pixel.\n\nBut to even measure something at a 1 frame interval, would require instruments that operated faster than 1 frame. So said Sim would probably only be able to deduce this mathematically.", "aSentId": 46039, "answer": "But even if you did carry out that experiment, how would that show that it is a simulation and not just a function of how the universe works?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46038, "question": "There are two obvious things that we could look for: resolution and frame rate.\n\nBoth of which exist in the universe - in the form of Planck Length and Planck Time.\n\nBut as far as evidence goes it's pretty weak. For Planck Length \"it is impossible to determine the difference between two locations less than one Planck length apart\" while Planck Time \"is the time required for light to travel, in a vacuum, a distance of 1 Planck length\". It just means that (according to the math) things of that order of magnitude are incoherent to any form of measurement.\n\nBut suppose our instruments got powerful enough to measure such small orders of magnitude. One thing that we could do to prove we are a simulation is to show that *nothing* happens between Planck Time intervals.\n\nIt would be like a Sim noticing that absolutely no updates happen to their world between frames. Such a Sim would be unaware of how much time passes in the \"real world\" between frames, but would be able to tell that some calculations happen and then things change. Any attempt to measure things at an interval less than N frames per second results in null data. They would experience similar problems attempting to measure a distance less than one pixel.\n\nBut to even measure something at a 1 frame interval, would require instruments that operated faster than 1 frame. So said Sim would probably only be able to deduce this mathematically.", "aSentId": 46041, "answer": "I used to think the same thing.\n\nHowever, Planck values do not mean that the universe is quantized at these distances. It is merely where the formulae we use to describe the universe stop working. Science is fairly certain that time and space are infinitely divisible.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46042, "question": "I used to think the same thing.\n\nHowever, Planck values do not mean that the universe is quantized at these distances. It is merely where the formulae we use to describe the universe stop working. Science is fairly certain that time and space are infinitely divisible.", "aSentId": 46043, "answer": "&gt; Science is fairly certain that time and space are infinitely divisible.\n\nWell, we'd think that in the simulation, by doing the maths. But physically, there would be those limits of simulation.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46038, "question": "There are two obvious things that we could look for: resolution and frame rate.\n\nBoth of which exist in the universe - in the form of Planck Length and Planck Time.\n\nBut as far as evidence goes it's pretty weak. For Planck Length \"it is impossible to determine the difference between two locations less than one Planck length apart\" while Planck Time \"is the time required for light to travel, in a vacuum, a distance of 1 Planck length\". It just means that (according to the math) things of that order of magnitude are incoherent to any form of measurement.\n\nBut suppose our instruments got powerful enough to measure such small orders of magnitude. One thing that we could do to prove we are a simulation is to show that *nothing* happens between Planck Time intervals.\n\nIt would be like a Sim noticing that absolutely no updates happen to their world between frames. Such a Sim would be unaware of how much time passes in the \"real world\" between frames, but would be able to tell that some calculations happen and then things change. Any attempt to measure things at an interval less than N frames per second results in null data. They would experience similar problems attempting to measure a distance less than one pixel.\n\nBut to even measure something at a 1 frame interval, would require instruments that operated faster than 1 frame. So said Sim would probably only be able to deduce this mathematically.", "aSentId": 46045, "answer": "That's, of course, assuming the simulation is running on digital computers like ours.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46049, "question": "We find the server room :P. ", "aSentId": 46050, "answer": "Got root?\n\nI always hope it's like this: We get root on the universe and we begin to realize that the universe exists as a simulation inside the processing component of a robot in the reality \"above\" ours. We then learn to control the robot and have a whole new universe to explore.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46053, "question": "When you do something that requires heavy processing power, like traveling at the speed of light, everything around it slows down to compensate and save processing power, so you can't have create a spinning wheel on a spinning wheel that crashes the system.\n\nA notion of time and velocity affecting each other, as they do.", "aSentId": 46054, "answer": "That's not how time dilation works though, unless you're suggestion that \"true observers\" can't experience it. If you were to accelerate to near light speed, you'd observe the universe shrinking in the direction of travel, becoming a flat pancake, and whizzing by at near the speed of light. That seems computationally intensive, not to mention the load time problems!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46061, "question": "It depends entirely on whether our simulated 'verse is causally entangled with the simulator 'verse.\n\n**IF** the simulation is a \"look, but don't touch,\" kind of mathematical exploration of a universe like our's computed from first principles; **THEN** it has no impact on us whatsoever. At all.\n\nSuppose you simulate Conway's game of life on your computer; you input a starting pattern, and your computer doesn't get hit by cosmic rays or anything. Then what you are doing is following a set of strict rules which would have applied to the system *whether you simulated it or not!* Whether you simulate a glider pattern or not, it is still a glider and has certain properties under the laws of the C'sGoL universe.\n\nThe other side of the coin is, if the simulators are poking us... That is a lot harder to answer, since it is currently an open problem in mathematical cosmological, anthropological measure theory how to distinguish the experience of really, really good non-atomic VR and actual atomic matter configurations.", "aSentId": 46062, "answer": "&gt; The other side of the coin is, if the simulators are poking us...\n\nOr if there's a way we can explore that connection. E.g. if you're software on a computer, you might be interested in what else is running on that computer, whether you can explore that other software, learn from it, or maybe import parts of it into your program to make use of it. \"[import antigravity](http://xkcd.com/353/)\" for instance.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46064, "question": "Assuming that any simulation of reality is not beyond imperfections, if our universe was a simulation, we should be able to detect glitches within it.  Just as all computers require updates to continue operating properly, the simulation of our universe would need to be updated over time.  In these degrading periods, we may see aspects of nature that we know to be static (such as the speed of light or various constants defining the force of electromagnetic attraction) slightly drift from their constant values.  If we could detect these abnormal drifts in the natural constants of our world (though setting up experiments to prove these abnormal shifts beyond a reasonable doubt is no easy task) we might be able to show our universe is a simulation.  ", "aSentId": 46065, "answer": "To discover a \"bug\", wouldn't that require a reference point? How do you differ between a bug and complex behavior? Remember that even very implausible things happen all the time.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46066, "question": "To discover a \"bug\", wouldn't that require a reference point? How do you differ between a bug and complex behavior? Remember that even very implausible things happen all the time.", "aSentId": 46067, "answer": " the world probably has at least basic exception handling.  The heart attack try, catch statement is really messy.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46064, "question": "Assuming that any simulation of reality is not beyond imperfections, if our universe was a simulation, we should be able to detect glitches within it.  Just as all computers require updates to continue operating properly, the simulation of our universe would need to be updated over time.  In these degrading periods, we may see aspects of nature that we know to be static (such as the speed of light or various constants defining the force of electromagnetic attraction) slightly drift from their constant values.  If we could detect these abnormal drifts in the natural constants of our world (though setting up experiments to prove these abnormal shifts beyond a reasonable doubt is no easy task) we might be able to show our universe is a simulation.  ", "aSentId": 46069, "answer": "I would pause the simulation while updating.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46064, "question": "Assuming that any simulation of reality is not beyond imperfections, if our universe was a simulation, we should be able to detect glitches within it.  Just as all computers require updates to continue operating properly, the simulation of our universe would need to be updated over time.  In these degrading periods, we may see aspects of nature that we know to be static (such as the speed of light or various constants defining the force of electromagnetic attraction) slightly drift from their constant values.  If we could detect these abnormal drifts in the natural constants of our world (though setting up experiments to prove these abnormal shifts beyond a reasonable doubt is no easy task) we might be able to show our universe is a simulation.  ", "aSentId": 46071, "answer": "In terms of programming I don't think statics are failing if ever. Because they are immutable. A cache can provide statics during the update. If we get a chance to write a unit test it would fail so easily that we could prove this in no time... :)  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46073, "question": "Simulations of the world will have to solve computationally intractable problems, so no, we are not in a simulation.", "aSentId": 46074, "answer": "*\"It's hard to compute Physics on an Apple IIe therefore simulating phyiscs on a computer is impossible.\"*\n\nThat's you.  That's what you sound like.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46078, "question": "Convert IEEE Standard 754 number to its binary equivalent", "aSentId": 46079, "answer": "I'm assuming you mean convert it to decimal.\n\nThe first bit is your sign so it is going to be negative. \n\nThe next 8 bits give you your exponential power = 133. 133-127 = 6. 127 is a constant based on it being 32 bits. \n\nThe remaining bits are the decimal portion. each bit is 1/2^n so .11 = 1/2 + 1/4 = .75 (index of 1) In this case 00011010100000000000000 comes out to .103516.\n\nYou always add 1 to that decimal based on the formula you would of learned by paying attention in class. Now you have 1.103516. Multiply that by 2^6. The 6 is from the exponent above and the 2 is constant. Make it negative because of that leading 1.\n\nThe answer is -70.625 which is useless to any teacher unless you can write out the steps above. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46078, "question": "Convert IEEE Standard 754 number to its binary equivalent", "aSentId": 46081, "answer": "32 bit format, so 1st bit/msb is the sign, next 8 bits is the biased exponent and the next 23 bits the mantissa with an implicit j bit which is 1. The exponent bias is 0x7f, so subtract this number from the biased exponent to get the actual exponent. I am guessing you should express this number in fixed point format binary.\n\nPing me if you have questions.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46083, "question": "Freshman interested in distributed systems where should I start", "aSentId": 46084, "answer": "The question of \"How do I distributed systems?!\" is fairly tied to what it you want to distribute. If it's something easily parallelisable, then functional languages (e.g. Scala) seem to be all the rage these days.\n\nIf you need a bit more control, something like Ada is well worth looking into (if only to understand how it handles concurrency and distribution, as it has probably the best in-language mechanisms I've ever seen).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46083, "question": "Freshman interested in distributed systems where should I start", "aSentId": 46086, "answer": "I would study C and get a good understanding of operating systems. Then I would study computer networks and algorithms analysis (parallel algorithms as well). With all that knowledge I think you would definitely be able to tackle it. But unfortunately this is one of those times where knowing the things leading up to it is going to helpful. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46083, "question": "Freshman interested in distributed systems where should I start", "aSentId": 46088, "answer": "Coursera's Cloud Computing class is in progress right now. It is free. So far it is a decent intro/overview. It will give you a starting point to advance. \n\nJava/Scala will work ok, depends on what you'll experiment with. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46091, "question": "My day to day work is in DS (though depending if you are coming from the HPC community or the \"BigData\" community that term has different meaning).  \n\nThe language is less important than the algorithms IMO, I've shipped systems in C# / F#, Scala / Java and Ruby (as well as a little bit of native work), the problems tend to be the same. \n\nThere's many types of distributed systems, from parallel algorithms in the HPC community, MPP databases, stream processing, various non-relational stores, things like hadoop, and then more advanced things like graph processing / distributed spatial stores etc.  It can get overwhelming if you just start with distributed systems.\n\nOne thing that helped me in learning distributed systems, is really really understanding databases at a deep level (not SQL necessarily, actually how they are implemented), before there's even a multi-machine component, databases have to solve similar problems and are well documented.  Understanding what it takes to build a DB requires an computer science understanding that will serve you well when you start to reason about systems in a distributed way.", "aSentId": 46092, "answer": "That's some great advice, thank you!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46094, "question": "I'd suggest learning a little more about computer science before arbitrarily choosing a topic to become an expert in.", "aSentId": 46095, "answer": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46096, "question": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "aSentId": 46097, "answer": "If you had enough exposure, you would know where to start. You decided to advertise your class status, which is an indicator of inexperience in the CS field. Coming off as a fedora wearing autist is a bad idea when asking strangers for help.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46098, "question": "If you had enough exposure, you would know where to start. You decided to advertise your class status, which is an indicator of inexperience in the CS field. Coming off as a fedora wearing autist is a bad idea when asking strangers for help.", "aSentId": 46099, "answer": "There is knowing \"where to start\" and getting input for good resources on the subject. Sorry if I came out as an ass, it was not my intention.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46096, "question": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "aSentId": 46101, "answer": "You don't have to be a dick about it though...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46096, "question": "Well you don't know much about my background. It's a little unfortunate that you chose to question it instead of being actually helpful... Thank you for your input, I think that I had enough exposure to different areas/fields of CS to chose a topic to specialize in. I actually worked a couple years as a software engineer before starting college. ", "aSentId": 46103, "answer": "You said yourself that you're a freshman and don't even know the fundamentals of distributed computing. That's plenty enough information for me to advise that studying the fundamentals of computer science will be infinitely more helpful for you now than trying to become an expert in a random field that you don't know anything about.\n\nAs much as you don't want to hear it, this is advice coming from a current \"expert\" in distributed computing.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46104, "question": "You said yourself that you're a freshman and don't even know the fundamentals of distributed computing. That's plenty enough information for me to advise that studying the fundamentals of computer science will be infinitely more helpful for you now than trying to become an expert in a random field that you don't know anything about.\n\nAs much as you don't want to hear it, this is advice coming from a current \"expert\" in distributed computing.", "aSentId": 46105, "answer": "You are right, I over-reacted sorry about that. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46106, "question": "You are right, I over-reacted sorry about that. ", "aSentId": 46107, "answer": "Given that 90% of CS questions on the internet go like the following, you'll fit in great.\n\nA: \"how do I do X?\"\n\nB: \"X is kind of weird, maybe try Y?\"\n\nA: \"Wow, this person B is a big asshole.\"\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46111, "question": "Best way to run Windows on a Mac?", "aSentId": 46112, "answer": "you can boot camp your mac, which will install windows alongside OSX and allow you to pick when you start up, or you can use VM software and run windows from within OSX.\n\nI have boot camped before and it was fine.\n\nYou will require a valid windows key for both options. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46113, "question": "you can boot camp your mac, which will install windows alongside OSX and allow you to pick when you start up, or you can use VM software and run windows from within OSX.\n\nI have boot camped before and it was fine.\n\nYou will require a valid windows key for both options. ", "aSentId": 46114, "answer": "And does it lack audio or anything?\n\nCan I run both simultaneously?\n\nDo I need internet connection?\n\nIs there anything bad about having a VM?\n\nThanks a lot!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46115, "question": "And does it lack audio or anything?\n\nCan I run both simultaneously?\n\nDo I need internet connection?\n\nIs there anything bad about having a VM?\n\nThanks a lot!", "aSentId": 46116, "answer": "1. No, everything should work (should being the key word).\n2. With a VM, yes; with dual-boot you need to restart to go to the other OS.\n3. No... unless you want one.\n4. It's slower: A VM emulates a complete computer inside your computer, so everything must go through a layer of indirection. Forget about gaming inside a VM.\n\nAlso this is not a compsci question, you'd be better off at.. /r/techsupport, I guess?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46117, "question": "1. No, everything should work (should being the key word).\n2. With a VM, yes; with dual-boot you need to restart to go to the other OS.\n3. No... unless you want one.\n4. It's slower: A VM emulates a complete computer inside your computer, so everything must go through a layer of indirection. Forget about gaming inside a VM.\n\nAlso this is not a compsci question, you'd be better off at.. /r/techsupport, I guess?", "aSentId": 46118, "answer": "Thanks a lot! I will go there, and sorry.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46119, "question": "Thanks a lot! I will go there, and sorry.", "aSentId": 46120, "answer": "There is one issue with audio. Macs with a combined mic/headphone jack cannot use the headphone mic on windows.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46111, "question": "Best way to run Windows on a Mac?", "aSentId": 46122, "answer": "I use Parallels Desktop to run Windows. It runs fine for everything I need to do. You can drag and drop from OSX to Windows seamlessly and works as expected. Don't expect to game or do anything intensive while using a VM though.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46111, "question": "Best way to run Windows on a Mac?", "aSentId": 46124, "answer": "This is definitely not the correct subredfit to post that in.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46126, "question": "The simulated annealing algorithm (with an emphasis on the schedule function)", "aSentId": 46127, "answer": "This is a very cool augmentation of the local search paradigm.  Thanks for sharing.\n\nIs it possible to provide any expectation of alpha based on the exponential decay function chosen? \n\nThe reason I ask is because I'm currently taking a seminar on approximation algorithms. If the analysis is interesting, perhaps I can bring it up with my classmates/professor for discussion.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46128, "question": "This is a very cool augmentation of the local search paradigm.  Thanks for sharing.\n\nIs it possible to provide any expectation of alpha based on the exponential decay function chosen? \n\nThe reason I ask is because I'm currently taking a seminar on approximation algorithms. If the analysis is interesting, perhaps I can bring it up with my classmates/professor for discussion.", "aSentId": 46129, "answer": "Hey thanks for your feedback! Good question! Let me see if I can add something. The transition probability to an immediately worse state is given by P(x &lt; e^(E/T(n) ), right? If T(n) is high (n=0), the exponential (i.e., the Boltzmann factor) goes to 1, so the transition is likely to occur. As time goes by (n=100), T(n) decreases and the exponential goes to 0, so the transition becomes unlikely. The expected value (average) of the decay is given by the sum of a geometric progression, so 1/(1-alpha). For simplicity, let's state that since alpha is negative (decay), the formula gets 1/(1+|alpha|). Thus, the smaller the magnitude of alpha, the greater the expectation that the search process will accept the \"bad\" transition as the temperature will stay large more time.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46132, "question": "Hypothetical : What restrictions will I need to add to Java so that I can remove its GC?", "aSentId": 46133, "answer": "Here's how I'd think about how to GC works in Java. It's super trivial.\n\nConsider what it would be like taking something written in Java and porting it to C++ with very minimal changes-- you're not allowed to add anything to avoid memory leaks, all you're allowed to do is change the syntax to match. How do you do that?\n\nIt's very simple; any time you deal with \"objects\", they become \"object pointers\" instead. So your `Class* c = new Class();` still works, and instead of having `Object getObject();` you have `Object* getObject();`\n\nSo now you have an equivalent C++ program that leaks for every object created but otherwise acts identical to Java.\n\nWhat you could then do in C++ is create a \"GabageCollector\" singleton class. Add a method called `::trackPointer(Object* obj);` and implement it so it adds to a vector owned by the class, any pointer added to it. Then you can (for example purposes here) find every \"new\" statement in your program, and have it call \"trackPointer.\"\n\nNot quite garbage collection yet, but now you're tracking pointers for every object created by new. You're still \"leaking\", but you know where all the leaks are at this point.\n\nTo make the garbage collector class complete, you'll need to add reference counting. Reference counting is not something I do regularly myself but there's plenty of material on it online with regards to C++. Basically though, you would add two methods to your garbage collector class: `::addReference(Object*);` and `::removeReference(Object*);`.\n\nYour internal list is now a \"pointer\" and a \"reference count\"; and any time your reference count is zero you should be safe to delete the pointer (from within `::removeReference`.)\n\nThat's how you could emulate garbage collection for an app written in Java but ported to C++.\n\nSo what do you need to remove garbage collection?\n\nPersonally I'd say it's as simple as adding a delete operator to the language and removing the garbage component.\n\nTwo consequences here though:\n\n * You have to possibly recompile everything with your new language spec to ensure delete is supported\n * You will have memory leaks with anything that doesn't use delete or legacy Java code that expected delete to begin with\n\nYou can make this issue easier for yourself though, by including the first version of the garbage collection class we talked about above (the pointer list.) when your app ends, any pointer left is a \"leak\", and if you include a file and line where the \"new\" occurred, you can determine locations where leaks happen and write updates to include deleted and such.\n\nHope that helps.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46134, "question": "Here's how I'd think about how to GC works in Java. It's super trivial.\n\nConsider what it would be like taking something written in Java and porting it to C++ with very minimal changes-- you're not allowed to add anything to avoid memory leaks, all you're allowed to do is change the syntax to match. How do you do that?\n\nIt's very simple; any time you deal with \"objects\", they become \"object pointers\" instead. So your `Class* c = new Class();` still works, and instead of having `Object getObject();` you have `Object* getObject();`\n\nSo now you have an equivalent C++ program that leaks for every object created but otherwise acts identical to Java.\n\nWhat you could then do in C++ is create a \"GabageCollector\" singleton class. Add a method called `::trackPointer(Object* obj);` and implement it so it adds to a vector owned by the class, any pointer added to it. Then you can (for example purposes here) find every \"new\" statement in your program, and have it call \"trackPointer.\"\n\nNot quite garbage collection yet, but now you're tracking pointers for every object created by new. You're still \"leaking\", but you know where all the leaks are at this point.\n\nTo make the garbage collector class complete, you'll need to add reference counting. Reference counting is not something I do regularly myself but there's plenty of material on it online with regards to C++. Basically though, you would add two methods to your garbage collector class: `::addReference(Object*);` and `::removeReference(Object*);`.\n\nYour internal list is now a \"pointer\" and a \"reference count\"; and any time your reference count is zero you should be safe to delete the pointer (from within `::removeReference`.)\n\nThat's how you could emulate garbage collection for an app written in Java but ported to C++.\n\nSo what do you need to remove garbage collection?\n\nPersonally I'd say it's as simple as adding a delete operator to the language and removing the garbage component.\n\nTwo consequences here though:\n\n * You have to possibly recompile everything with your new language spec to ensure delete is supported\n * You will have memory leaks with anything that doesn't use delete or legacy Java code that expected delete to begin with\n\nYou can make this issue easier for yourself though, by including the first version of the garbage collection class we talked about above (the pointer list.) when your app ends, any pointer left is a \"leak\", and if you include a file and line where the \"new\" occurred, you can determine locations where leaks happen and write updates to include deleted and such.\n\nHope that helps.", "aSentId": 46135, "answer": "Java GC also cyclical references, which is something simple reference counting doesn't do.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46136, "question": "Java GC also cyclical references, which is something simple reference counting doesn't do.", "aSentId": 46137, "answer": "Correct.  The first thing someone who has worked in GC will tell you is:  \"reference counting is NOT garbage collection!\"\n\nCycles aren't even a rare boundary case but pretty well the defining shape of any non-trivial data model.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46134, "question": "Here's how I'd think about how to GC works in Java. It's super trivial.\n\nConsider what it would be like taking something written in Java and porting it to C++ with very minimal changes-- you're not allowed to add anything to avoid memory leaks, all you're allowed to do is change the syntax to match. How do you do that?\n\nIt's very simple; any time you deal with \"objects\", they become \"object pointers\" instead. So your `Class* c = new Class();` still works, and instead of having `Object getObject();` you have `Object* getObject();`\n\nSo now you have an equivalent C++ program that leaks for every object created but otherwise acts identical to Java.\n\nWhat you could then do in C++ is create a \"GabageCollector\" singleton class. Add a method called `::trackPointer(Object* obj);` and implement it so it adds to a vector owned by the class, any pointer added to it. Then you can (for example purposes here) find every \"new\" statement in your program, and have it call \"trackPointer.\"\n\nNot quite garbage collection yet, but now you're tracking pointers for every object created by new. You're still \"leaking\", but you know where all the leaks are at this point.\n\nTo make the garbage collector class complete, you'll need to add reference counting. Reference counting is not something I do regularly myself but there's plenty of material on it online with regards to C++. Basically though, you would add two methods to your garbage collector class: `::addReference(Object*);` and `::removeReference(Object*);`.\n\nYour internal list is now a \"pointer\" and a \"reference count\"; and any time your reference count is zero you should be safe to delete the pointer (from within `::removeReference`.)\n\nThat's how you could emulate garbage collection for an app written in Java but ported to C++.\n\nSo what do you need to remove garbage collection?\n\nPersonally I'd say it's as simple as adding a delete operator to the language and removing the garbage component.\n\nTwo consequences here though:\n\n * You have to possibly recompile everything with your new language spec to ensure delete is supported\n * You will have memory leaks with anything that doesn't use delete or legacy Java code that expected delete to begin with\n\nYou can make this issue easier for yourself though, by including the first version of the garbage collection class we talked about above (the pointer list.) when your app ends, any pointer left is a \"leak\", and if you include a file and line where the \"new\" occurred, you can determine locations where leaks happen and write updates to include deleted and such.\n\nHope that helps.", "aSentId": 46139, "answer": "Yes, this is the naive implementation I will likely focus on, but the cyclical references and perf are a concern, but well let's see. Thanks for the detailed writeup!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46132, "question": "Hypothetical : What restrictions will I need to add to Java so that I can remove its GC?", "aSentId": 46141, "answer": "Eliminate all uses of new, and you should be fine.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46142, "question": "Eliminate all uses of new, and you should be fine.", "aSentId": 46143, "answer": "Resolving memory management by allocating everything static? Nope, that can't be fine.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46144, "question": "Resolving memory management by allocating everything static? Nope, that can't be fine.", "aSentId": 46145, "answer": "That's basically what NASA does with their python-generated C code that powers the latest mars river. They're actually allowed to make dynamic allocations at start time, but not once they begin doing anything useful.\n\nThere are plenty of languages that don't have a heap at all. If you teach someone Scheme, and then ask them to write Java without giving them any stylistic guidance, there's a pretty good chance you'll end up without any uses of new. There's also a chance you'll get functions calling themselves recursively to implement loops (I once saw this with main() in C++), but it will work, at least until you overflow the stack.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46146, "question": "That's basically what NASA does with their python-generated C code that powers the latest mars river. They're actually allowed to make dynamic allocations at start time, but not once they begin doing anything useful.\n\nThere are plenty of languages that don't have a heap at all. If you teach someone Scheme, and then ask them to write Java without giving them any stylistic guidance, there's a pretty good chance you'll end up without any uses of new. There's also a chance you'll get functions calling themselves recursively to implement loops (I once saw this with main() in C++), but it will work, at least until you overflow the stack.", "aSentId": 46147, "answer": "You're right, but that wasn't my point.  \nI wasn't implying that dynamic allocation is essential, I was just saying that your previous comment is wrong. You can't port a Java code in which everything is dynamically allocated to C++ by changing the allocations to static and expect it to work.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46142, "question": "Eliminate all uses of new, and you should be fine.", "aSentId": 46149, "answer": "Could also not cause an allocation to get GC'd.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46132, "question": "Hypothetical : What restrictions will I need to add to Java so that I can remove its GC?", "aSentId": 46151, "answer": "In short:  you cannot do this.  Garbage collection is NOT reference counting (they are very different things with different edge cases and different profiles which only vaguely \"solve\" the same problem).\n\nThere would be some ways to do things which would give the effect (since you control the compiler, convert all objects to primitive locals, etc - this is VERY restrictive to what you could do, however).\n\nI would expect that the JIT will do a better job of handing these cases for you (dynamic escape analysis to stack allocate objects, etc).\n\nThe biggest question here is _why_?  Why do you want to \"remove\" the GC?  If it is due to real-time constraints (in which case you don't want to reference count, either), then can you use a real-time collector (or just JSR1)?  What actual concerns do you have?  Even if this is a purely intellectual exercise to work through the thought experiment, why are you assuming that the GC is a problem?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46153, "question": "Check out [Virgil](http://lambda-the-ultimate.org/node/4716). It's not exactly Java, but it's an Java-like embedded programming language whose whole runtime, including the GC, is writting in Virgil.", "aSentId": 46154, "answer": "thanks for this ... it's around the same ballpark of vision, but I want to take different route.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46155, "question": "thanks for this ... it's around the same ballpark of vision, but I want to take different route.\n", "aSentId": 46156, "answer": "You should also look into the [MMTk](http://jikesrvm.org/MMTk). The research papers on Java GCs of the past 10 years have mostly been written in a Java subset for the Jikes RVM.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46160, "question": "What's faster, logarithmic time or linear time?", "aSentId": 46161, "answer": "Depends on what you mean by \"faster.\" Do you mean asymptotically faster, or faster in practice? For the former, log n definitely is faster. For the latter, it depends on the constants involved in your particular algorithm, but most likely log n will be faster. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46160, "question": "What's faster, logarithmic time or linear time?", "aSentId": 46163, "answer": "log n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 46160, "question": "What's faster, logarithmic time or linear time?", "aSentId": 46165, "answer": "In practice, it depends on the size and coefficients for each (i.e. if you have an n of 500 and it's between an O((log2 n) * 8) and an O(n/8) algorithm (probably parallel or some other method of processing multiple elements at once), you probably want the O(n/8) algorithm), but generally the O(log n) will be faster for most uses.", "corpus": "reddit"}]