[{"docID": "t5_2qhmr", "qSentId": 50147, "question": "Maze Algorithms (visual)", "aSentId": 50148, "answer": "It's really interesting how they all have their own distinctive look. I kind of wonder if there is some connection to different noise colours?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50149, "question": "It's really interesting how they all have their own distinctive look. I kind of wonder if there is some connection to different noise colours?", "aSentId": 50150, "answer": "if by distinctive you mean all but 2 are bad mazes, definitely.\n\ni'm sure the others are super useful in other capacities though.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50147, "question": "Maze Algorithms (visual)", "aSentId": 50152, "answer": "Is there a particular advantage to using a algorithm that takes longer? Or is it just there as an example?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50158, "question": "Search De-Optimization", "aSentId": 50159, "answer": "I can think of a few stumbling blocks.\n\none of which is simply that this would give a lot of insight into how that search engine ranks pages and this would be gamed. \n\nthis is rudimentarily implemented with the suggested related searches at the bottom of most engines.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50160, "question": "I can think of a few stumbling blocks.\n\none of which is simply that this would give a lot of insight into how that search engine ranks pages and this would be gamed. \n\nthis is rudimentarily implemented with the suggested related searches at the bottom of most engines.", "aSentId": 50161, "answer": "Hey, thank you for the thoughtful input. Wouldn't exploitation here depend on access to individual user histories though? Are you talking about third party hacking or some kind of top down distortion practice?\n\nAnyways, I'm just heading to bed but I would be glad to continue this tomorrow if you're so inclined.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50162, "question": "Hey, thank you for the thoughtful input. Wouldn't exploitation here depend on access to individual user histories though? Are you talking about third party hacking or some kind of top down distortion practice?\n\nAnyways, I'm just heading to bed but I would be glad to continue this tomorrow if you're so inclined.", "aSentId": 50163, "answer": "If I could greatly customize the \"depth\" of my search with the results and related pages you could learn a lot more on why certain pages are ranking for certain words.\n\nAlso, this doesn't really make the search algorithm any better and it may be that 99% of those other results from different branches are worthless.\n\nBut there is a big problem.\n\nGo search any medical term on google, and you will get pages and pages of spam websites like livestrong or about.com, or ehow, all of which just contain regurgitated scrapped information, all of which is complete crap.\n\njust a better tagging system would be good enough. A way to separate popsci, from journals, from forums or discussions.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50164, "question": "If I could greatly customize the \"depth\" of my search with the results and related pages you could learn a lot more on why certain pages are ranking for certain words.\n\nAlso, this doesn't really make the search algorithm any better and it may be that 99% of those other results from different branches are worthless.\n\nBut there is a big problem.\n\nGo search any medical term on google, and you will get pages and pages of spam websites like livestrong or about.com, or ehow, all of which just contain regurgitated scrapped information, all of which is complete crap.\n\njust a better tagging system would be good enough. A way to separate popsci, from journals, from forums or discussions.", "aSentId": 50165, "answer": "How would a greater customization depth on sites like YouTube, Google, etc reveal anything of significance to third parties? My own knowledge here is limited but I honestly don't see any new problem. Also, the optimization I was advocating was addressing spam type content explicitly. Because all content would be embedded with a relatively comprehensive description. So the user would have the power to exclude precisely that content.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50167, "question": "Contextual String Manipulation", "aSentId": 50168, "answer": "I'm the author and this is kind of like a reality check. Do you think I'm on to something or are my ideas stupid? Are there better ways to solve `\"Vacation2008Photo_034.jpg\"` that I'm overlooking? Are there libraries in other languages that tries to solve the same problem?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50170, "question": "Logic solvers in JavaScript", "aSentId": 50171, "answer": "Awesome idea! I have a bug to report though: when generating a truth table with 10 variables or more, the variable labels are displayed at the top of the table sorted as a string. This means that the variables 1 - 10 appear as:\n\n1  10  2  3  4  5  6  7  8  9 \n\ninstead of \n\n1  2  3  4  5  6  7  8  9  10\n\nI think this is because the \"numbers\" are sorted by their string representation, instead of their numerical value. However, maybe this is purposeful-- if it is, please ignore.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50172, "question": "Awesome idea! I have a bug to report though: when generating a truth table with 10 variables or more, the variable labels are displayed at the top of the table sorted as a string. This means that the variables 1 - 10 appear as:\n\n1  10  2  3  4  5  6  7  8  9 \n\ninstead of \n\n1  2  3  4  5  6  7  8  9  10\n\nI think this is because the \"numbers\" are sorted by their string representation, instead of their numerical value. However, maybe this is purposeful-- if it is, please ignore.", "aSentId": 50173, "answer": "did anyone say static typing?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50170, "question": "Logic solvers in JavaScript", "aSentId": 50175, "answer": "Neat!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50170, "question": "Logic solvers in JavaScript", "aSentId": 50177, "answer": "cool.  but... i have a hard time thinking of ways to use SAT solvers in my day job.  i hate to think how hard it is to find a justified use embedded in a web page!\n\nedit: how do i trigger the generate part?  am i misundertsanding the UI?\n\nedit2: the \"generate\" button should be blue! (and i am a bit dumb)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50178, "question": "cool.  but... i have a hard time thinking of ways to use SAT solvers in my day job.  i hate to think how hard it is to find a justified use embedded in a web page!\n\nedit: how do i trigger the generate part?  am i misundertsanding the UI?\n\nedit2: the \"generate\" button should be blue! (and i am a bit dumb)", "aSentId": 50179, "answer": "SAT solvers basically let you efficiently attack NP problems.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50180, "question": "SAT solvers basically let you efficiently attack NP problems.", "aSentId": 50181, "answer": "how efficiently? ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50182, "question": "how efficiently? ", "aSentId": 50183, "answer": "It is hard to quantify it, but for practical purposes they seem to get the job done. However most NP problems are not known to have reductions to sat that can be used for practical purposes. So you usually won't use a SAT solver for other NP problems. There are other heuristic methods apllied there.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50182, "question": "how efficiently? ", "aSentId": 50185, "answer": "I'm not sure how it works, but tractable inputs become a lot quicker. There still are inputs that take exponential time.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50180, "question": "SAT solvers basically let you efficiently attack NP problems.", "aSentId": 50187, "answer": "it kind of boggles my mind that you think someone who knows what SAT solvers are doesn't know what they do.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50189, "question": "Turing Machines and the Busy Beaver Game", "aSentId": 50190, "answer": "&gt;Though it is difficult to overstate the importance of it, very few people know anything about one of the first computing machines ever: the Turing machine. For the most part, the Turing machine has been relegated to history and referential pages, but it shouldn\u2019t be.\n\nIn what universe does this author live? Pretty much every single CS undergrad is going to learn about Turing Machines in the first year of his/her study.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50191, "question": "&gt;Though it is difficult to overstate the importance of it, very few people know anything about one of the first computing machines ever: the Turing machine. For the most part, the Turing machine has been relegated to history and referential pages, but it shouldn\u2019t be.\n\nIn what universe does this author live? Pretty much every single CS undergrad is going to learn about Turing Machines in the first year of his/her study.", "aSentId": 50192, "answer": "They might be more concerned about teaching the turing machine to a wider population than people with compsci degrees. A tremendous number of professions do programming daily that may have never heard of Turing at all. Him (or his machines) were never mentioned once in my math or physics undergrad, which is particularly sad since I think the busy beaver sequence is some pretty neat math.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50191, "question": "&gt;Though it is difficult to overstate the importance of it, very few people know anything about one of the first computing machines ever: the Turing machine. For the most part, the Turing machine has been relegated to history and referential pages, but it shouldn\u2019t be.\n\nIn what universe does this author live? Pretty much every single CS undergrad is going to learn about Turing Machines in the first year of his/her study.", "aSentId": 50194, "answer": "it would have been nice to learn about it sooner... i'm in my senior year and just now taking theory of computation and i don't think i've ever been more confused by anything in my entire life :/", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50189, "question": "Turing Machines and the Busy Beaver Game", "aSentId": 50196, "answer": "&gt;Interestingly enough, the Busy Beaver Turing machine (BBTM) has been shown to be the fastest growing computable algorithm asymptotically.\n\nBusy beaver is non-computable, no?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50197, "question": "&gt;Interestingly enough, the Busy Beaver Turing machine (BBTM) has been shown to be the fastest growing computable algorithm asymptotically.\n\nBusy beaver is non-computable, no?", "aSentId": 50198, "answer": "yes, and Busy Beaver is not the fastest growing algorithm either.\n\nBusyBeaver^2 is faster.\n\nI think he is confusing several things.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50199, "question": "yes, and Busy Beaver is not the fastest growing algorithm either.\n\nBusyBeaver^2 is faster.\n\nI think he is confusing several things.", "aSentId": 50200, "answer": "BusyBeaver() is faster-growing than any computable function, but it is itself non-computable.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50197, "question": "&gt;Interestingly enough, the Busy Beaver Turing machine (BBTM) has been shown to be the fastest growing computable algorithm asymptotically.\n\nBusy beaver is non-computable, no?", "aSentId": 50202, "answer": "Well, the example shown in this Article shows a BBTM with one state which produces a valid output after a finit number of steps.\n\n The same goes for one with 2 states, just that the output is already much bigger.. And this keeps growing steeply.. (Although I don't know if it's the algorithm with the fastes growth)\n\nSo it's not non-computable.. There's just no final solution to the BBGame because this would probably need a Turing machine with infinitly many states which already harms the \"haltable\" requirement.\n\nThat's how I understood that. Just wanted to write that down...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50203, "question": "Well, the example shown in this Article shows a BBTM with one state which produces a valid output after a finit number of steps.\n\n The same goes for one with 2 states, just that the output is already much bigger.. And this keeps growing steeply.. (Although I don't know if it's the algorithm with the fastes growth)\n\nSo it's not non-computable.. There's just no final solution to the BBGame because this would probably need a Turing machine with infinitly many states which already harms the \"haltable\" requirement.\n\nThat's how I understood that. Just wanted to write that down...", "aSentId": 50204, "answer": "Busy beaver numbers are non-computable in the general case, we just happen to have the first few.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50197, "question": "&gt;Interestingly enough, the Busy Beaver Turing machine (BBTM) has been shown to be the fastest growing computable algorithm asymptotically.\n\nBusy beaver is non-computable, no?", "aSentId": 50206, "answer": "No, it just takes very very long.  \nBut, afaik, it is proven to halt.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50207, "question": "No, it just takes very very long.  \nBut, afaik, it is proven to halt.", "aSentId": 50208, "answer": "how many steps does it take?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50210, "question": "Software Test Engineer", "aSentId": 50211, "answer": "You're getting downvotes because computer science is a mathematical discipline whereas \"software test engineering\" is a practical endeavor more related to quality assurance. Try an engineering sub.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50213, "question": "the SMT solver Z3 (MSR) now free software!", "aSentId": 50214, "answer": "An excellent news, thanks for passing around!\n\nI much prefer to contribute to free software on my research time, and I would have felt guilty if developing new research prototypes depending in non-trivial ways on other tools that are not open source. In theory SMT solvers can be swapped, in practice many people don't bother and only test their result with one they like -- often Z3. When it's good enough (Z3 definitely is), chances are it would in fact not work as well for other solvers -- and I understand there is a certain amount of tuning that happens when people decide which encoding strategies to adopt to feed the solver, which can led to solver-specialized inputs.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50215, "question": "An excellent news, thanks for passing around!\n\nI much prefer to contribute to free software on my research time, and I would have felt guilty if developing new research prototypes depending in non-trivial ways on other tools that are not open source. In theory SMT solvers can be swapped, in practice many people don't bother and only test their result with one they like -- often Z3. When it's good enough (Z3 definitely is), chances are it would in fact not work as well for other solvers -- and I understand there is a certain amount of tuning that happens when people decide which encoding strategies to adopt to feed the solver, which can led to solver-specialized inputs.", "aSentId": 50216, "answer": "Indeed. Some research that depends on z3 (I'm thinking for instance on synthesis of Scala code by Kuncak&amp;al) is now usable/tinkerable in more situations.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50215, "question": "An excellent news, thanks for passing around!\n\nI much prefer to contribute to free software on my research time, and I would have felt guilty if developing new research prototypes depending in non-trivial ways on other tools that are not open source. In theory SMT solvers can be swapped, in practice many people don't bother and only test their result with one they like -- often Z3. When it's good enough (Z3 definitely is), chances are it would in fact not work as well for other solvers -- and I understand there is a certain amount of tuning that happens when people decide which encoding strategies to adopt to feed the solver, which can led to solver-specialized inputs.", "aSentId": 50218, "answer": "I want to use this in a type system design :D", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50219, "question": "I want to use this in a type system design :D", "aSentId": 50220, "answer": "LiquidHaskell", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50213, "question": "the SMT solver Z3 (MSR) now free software!", "aSentId": 50222, "answer": "Hasn't it been for some time now, judging by the git history?  I thought only the license was changed to the (most) liberal MIT license.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50213, "question": "the SMT solver Z3 (MSR) now free software!", "aSentId": 50224, "answer": "I'm not familiar with the field but I imagine there's lots of cool things you can do with this beyond solving sudoku. Can anyone give some examples?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50227, "question": "Visual Programming Is Unbelievable\u2026 Here\u2019s Why We Don\u2019t Believe In It", "aSentId": 50228, "answer": "If visual iconography were superior to general text, then his thesis should have been written in Emoji.  But the author chose text because it works and visual symbolism is inferior.\n\nE.g. [Emoji Dick](http://emojidick.com/) is a crowd funded translation of Mobi Dick into Emoji.  I doubt the visual nature of that text will outlive the current fad.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50227, "question": "Visual Programming Is Unbelievable\u2026 Here\u2019s Why We Don\u2019t Believe In It", "aSentId": 50230, "answer": "The thing visual programming is good for is allowing non-programmers to be more productive. Most people can't write code, a kid can follow a flowchart though.\n\nEngineering is not about building the optimal solution, it's about optimizing based on finite resources and constraints. In most small business cases, the infinite resources is hardware and the biggest limiting factor is employees. Performance isn't on the radar as long as it happens in a reasonable time frame. Scientists use LabView for instance, to automate instruments and setup experiments without needing a actual programmer on staff. The reason is because equipment is cheap and the priority is saving money with a high turnover.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50227, "question": "Visual Programming Is Unbelievable\u2026 Here\u2019s Why We Don\u2019t Believe In It", "aSentId": 50232, "answer": "I don't think there is a need for them.\n\nVisualizations can be nice though, being able to see the graph view of a disassembled program can significantly help in understanding it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50235, "question": "How to create DFA from regular expression without using NFA?", "aSentId": 50236, "answer": "Consider...  \n\n* an automaton which recognises the empty language.  \n* given a singleton language, i.e. a language with exactly one (finite) string, how do you form an automaton which recognises that language.  \n* given an automaton how do you form another which recognises the Kleene closure of the language the given automaton recognises.\n* given two automata how do you form another which recognises the union of the languages the given automata recognise.  \n* given two automata how do you form another which recognises the concatenation of the languages the given automata recognise.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50235, "question": "How to create DFA from regular expression without using NFA?", "aSentId": 50238, "answer": "Do you know about Brzozowski's derivative?  (If not, first go and learn how it can be used to match an input word against a regular expression without needing to construct an NFA or DFA.)\n\nWell, it turns out that the Brzozowski derivative can also be used to directly construct a DFA given a regular expression...  and another derivative, introduced by Antimirov, can be used to construct an NFA in a similar manner.\n\n(Quite surprisingly, I think it has been shown that the \"classical\" textbook algorithms for constructing finite automata from regular expressions are all instances of the same generic algorithm - the only difference is which notion of derivative you plug in...)\n\nThis should be more than enough to get you started in the right direction.  :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50235, "question": "How to create DFA from regular expression without using NFA?", "aSentId": 50240, "answer": "&gt; but he told me that we can use intuition\n\nSounds like a bad professor. If you had that intuition, you wouldn't need their course now would you?\n\n/u/PvtPoopyPants has some good advice, which boils down to divide and conquer. When faced with a problem in algorithm design, don't try to design the whole thing at once. First try simpler problems that seem related. Regex has a few different operators (union, kleene star, etc.); try solving for each operator separately. Even if the results don't work together, solving related problems can often give you insights on how to solve the original problem.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50242, "question": "Who's interested in a study group for Nand2Tetris, a self-paced course that teaches you to build a computer from the ground up?", "aSentId": 50243, "answer": "This is awesome, I will definitely be joining this.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50242, "question": "Who's interested in a study group for Nand2Tetris, a self-paced course that teaches you to build a computer from the ground up?", "aSentId": 50245, "answer": "I believe there is a Coursera course starting in a couple of weeks.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50242, "question": "Who's interested in a study group for Nand2Tetris, a self-paced course that teaches you to build a computer from the ground up?", "aSentId": 50247, "answer": "I", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50249, "question": "Does interning for a small company have any effect later on working for a big company?", "aSentId": 50250, "answer": "No experience is bad experience", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50249, "question": "Does interning for a small company have any effect later on working for a big company?", "aSentId": 50252, "answer": "Having to review CV times to times for technical position in a big company, I always look at real experience, an internship even in a small company will get you on top of the pile compare to any CV with no internship at all, whatever school you come from.\n\nWhen you are new on job market, every bit of experience is a big plus.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50249, "question": "Does interning for a small company have any effect later on working for a big company?", "aSentId": 50254, "answer": "A small company allows more latitude in decision making (usually).  There are fewer levels of politics to deal with, and fewer policies.\n\nLarger companies have more rules, and your boundaries are usually more clear.  But the rules prevent experimentation..", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50255, "question": "A small company allows more latitude in decision making (usually).  There are fewer levels of politics to deal with, and fewer policies.\n\nLarger companies have more rules, and your boundaries are usually more clear.  But the rules prevent experimentation..", "aSentId": 50256, "answer": "Also it may let you wear many hats, plus they may want to swipe you up after college", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50262, "question": "You'll hate working at a big company.\n\nIn a small company you matter. You won't matter at google.", "aSentId": 50263, "answer": "Quite presumptuous.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50262, "question": "You'll hate working at a big company.\n\nIn a small company you matter. You won't matter at google.", "aSentId": 50265, "answer": "Doesn't match what friends I know who work for large companies say.\n\nYou matter in your team, on your project...\n\nIf you matter to the company, you're not a software developer anymore, you're management.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50274, "question": "From what I've heard, I really don't think you want to work at Google. \n\nThat said, any internship is a good one if you want to work **anywhere**. If you feel good about your skills, I'd take any offers you have and run with it. ", "aSentId": 50275, "answer": "I kind of know what you are talking about =)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50274, "question": "From what I've heard, I really don't think you want to work at Google. \n\nThat said, any internship is a good one if you want to work **anywhere**. If you feel good about your skills, I'd take any offers you have and run with it. ", "aSentId": 50277, "answer": "What have you heard, that makes you think this?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50282, "question": "What is necessary for getting the minimal amount of coins when calculating change with a greedy algorithm?", "aSentId": 50283, "answer": "This is an interesting and deceptively difficult problem.  See [here](http://arxiv.org/pdf/0801.0120.pdf) (PDF) for a good survey of results, including the particularly amusing 1994 exchange in the MAA Monthly where a \"nice\" characterization was published, with a subsequent article pointing out that the nice characterization was flawed.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50284, "question": "This is an interesting and deceptively difficult problem.  See [here](http://arxiv.org/pdf/0801.0120.pdf) (PDF) for a good survey of results, including the particularly amusing 1994 exchange in the MAA Monthly where a \"nice\" characterization was published, with a subsequent article pointing out that the nice characterization was flawed.\n", "aSentId": 50285, "answer": "Thanks, I'll look into it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50282, "question": "What is necessary for getting the minimal amount of coins when calculating change with a greedy algorithm?", "aSentId": 50287, "answer": "I believe each coin must be at least double the value of the next lower denomination, but I didn't do a proof or look all that hard for counterexamples.\n\nEDIT: This is wrong, see below.  This is what happens when you just \"have a feeling\" in math.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50288, "question": "I believe each coin must be at least double the value of the next lower denomination, but I didn't do a proof or look all that hard for counterexamples.\n\nEDIT: This is wrong, see below.  This is what happens when you just \"have a feeling\" in math.", "aSentId": 50289, "answer": "If we have 1, 3, 5 cent coins, the greedy algorithm is correct even though 2 * 3 &gt; 5. \n\n(I was going down the same route you were and got stuck trying to prove it.)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50290, "question": "If we have 1, 3, 5 cent coins, the greedy algorithm is correct even though 2 * 3 &gt; 5. \n\n(I was going down the same route you were and got stuck trying to prove it.)", "aSentId": 50291, "answer": "I haven't tested this, but I think each coin, when doubled, must be less than or equal to the next coin + 1 (assuming 1 is the lowest denomination. Otherwise use that value)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50290, "question": "If we have 1, 3, 5 cent coins, the greedy algorithm is correct even though 2 * 3 &gt; 5. \n\n(I was going down the same route you were and got stuck trying to prove it.)", "aSentId": 50293, "answer": "Hmm maybe it's that the gaps between coin values must be monotonically increasing? I'll play around with it a little after work.\n\nEDIT: This is wrong too, take (1, 5, 9, 16) from the pdf posted above.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50294, "question": "Hmm maybe it's that the gaps between coin values must be monotonically increasing? I'll play around with it a little after work.\n\nEDIT: This is wrong too, take (1, 5, 9, 16) from the pdf posted above.", "aSentId": 50295, "answer": "I was thinking that the pairwise sums of coin values must not be equal to another coin value. Alternatively, perhaps something involving relative primeness? ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50296, "question": "I was thinking that the pairwise sums of coin values must not be equal to another coin value. Alternatively, perhaps something involving relative primeness? ", "aSentId": 50297, "answer": "&gt; I was thinking that the pairwise sums of coin values must not be equal to another coin value\n\nI think that's sufficient, but not necessary.  For coins 1, 2, 3, the greedy algorithm works, but your condition doesn't hold.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50290, "question": "If we have 1, 3, 5 cent coins, the greedy algorithm is correct even though 2 * 3 &gt; 5. \n\n(I was going down the same route you were and got stuck trying to prove it.)", "aSentId": 50299, "answer": "Hmm, how about each coin must be at least double the next lowest coin *minus two of the lowest coin.*\n\nReasoning: we want to avoid the case where taking two of a lower coin helps more than taking the highest coin.  But it only helps when we'd have to take more than one additional coin after taking the highest coin.\n\nThis still may not cover all the cases, I haven't thought about it much, but it does repair this counterexample.\n\n(I say minus two of the lowest coin instead of minus one to avoid cases where there are multiple combinations that work, e.g. 5+1 and 3+3.  If the coin set was 1, 2, 5 then this would not be possible.)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50300, "question": "Hmm, how about each coin must be at least double the next lowest coin *minus two of the lowest coin.*\n\nReasoning: we want to avoid the case where taking two of a lower coin helps more than taking the highest coin.  But it only helps when we'd have to take more than one additional coin after taking the highest coin.\n\nThis still may not cover all the cases, I haven't thought about it much, but it does repair this counterexample.\n\n(I say minus two of the lowest coin instead of minus one to avoid cases where there are multiple combinations that work, e.g. 5+1 and 3+3.  If the coin set was 1, 2, 5 then this would not be possible.)", "aSentId": 50301, "answer": "CounterExample: coins 1 50 and 101..  fail horribly on a value of 200.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50302, "question": "CounterExample: coins 1 50 and 101..  fail horribly on a value of 200.", "aSentId": 50303, "answer": "Good one.  And now I want to live in a country with a 101 denomination coin, just to mess with barristas.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50282, "question": "What is necessary for getting the minimal amount of coins when calculating change with a greedy algorithm?", "aSentId": 50305, "answer": "I think to make this work easily you want every coin to be a factor of the one larger than it.  I don't think this includes the set of all possible answers, but I believe it is a set of correct answers.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50310, "question": "Michael Stonebraker wins $1 million Turing Award. This year marks the first time that the Turing Award comes with a Google-funded $1 million prize.", "aSentId": 50311, "answer": "I'm sure he's pleased by it, but the award is probably far more than the cash prize to most recipients. It almost certainly doesn't need mention, nor does the fact that the sponsor got to buy their way onto the ticket. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50312, "question": "I'm sure he's pleased by it, but the award is probably far more than the cash prize to most recipients. It almost certainly doesn't need mention, nor does the fact that the sponsor got to buy their way onto the ticket. ", "aSentId": 50313, "answer": "He sold his big data startup for $340M, at that point I'm not sure it made much of a difference.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50314, "question": "He sold his big data startup for $340M, at that point I'm not sure it made much of a difference.", "aSentId": 50315, "answer": "Exactly. And he's got another one going right now (VoltDB), likely to be very successful too. He doesn't need the $1m.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50310, "question": "Michael Stonebraker wins $1 million Turing Award. This year marks the first time that the Turing Award comes with a Google-funded $1 million prize.", "aSentId": 50317, "answer": "That feel when EVEN THIS GUY doesn't have tenure.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50318, "question": "That feel when EVEN THIS GUY doesn't have tenure.", "aSentId": 50319, "answer": "He's an adjunct.  It's not like associate which is strictly less than full prof, he's just busy doing other stuff (like starting companies).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50318, "question": "That feel when EVEN THIS GUY doesn't have tenure.", "aSentId": 50321, "answer": "I'm sure he was tenured at Berkeley, where he spent his career.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50318, "question": "That feel when EVEN THIS GUY doesn't have tenure.", "aSentId": 50323, "answer": "maybe he didn't apply for it. Maybe he thinks it should go to someone else given how successful he already is. \n\nAnd being this rich, why would he care about tenure? If he wants, he can just sit in his mansion and do research with no admin hassle. \n\nIf I were that rich, I sure as hell would not work at a university!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50325, "question": "Why don't colleges teach ARM instead of MIPS?", "aSentId": 50326, "answer": "I like what /u/kphth said, but I think there's another major concern:\n\nThere just isn't as much academic source material for ARM as there is for MIPS. If you want to teach a course with MIPS, you've got something like 20 years of material created expressly for teaching students. ARM doesn't have that wealth of material, so any course teaching it basically gets to start from scratch.\n\nThat isn't to say that there aren't ARM courses out there. Some of my school's \"Topics In\" classes have covered ARM in the past, but the structure of those classes is a lot more, uh, \"seat of the pants\" learning than a more traditional classroom setting.\n\nIn short, the professor needs to write the ARM curriculum from scratch, whereas the structure and material for MIPS courses is already pretty much established.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50327, "question": "I like what /u/kphth said, but I think there's another major concern:\n\nThere just isn't as much academic source material for ARM as there is for MIPS. If you want to teach a course with MIPS, you've got something like 20 years of material created expressly for teaching students. ARM doesn't have that wealth of material, so any course teaching it basically gets to start from scratch.\n\nThat isn't to say that there aren't ARM courses out there. Some of my school's \"Topics In\" classes have covered ARM in the past, but the structure of those classes is a lot more, uh, \"seat of the pants\" learning than a more traditional classroom setting.\n\nIn short, the professor needs to write the ARM curriculum from scratch, whereas the structure and material for MIPS courses is already pretty much established.", "aSentId": 50328, "answer": "Building on this, my school teaches ARM but the textbook we use had to be written by a professor. I guess they couldn't find any good preexisting texts out there. Unfortunately, the textbook is filled with errors. Apparently they just paid a grad student to write the answer key so basically every other solution is incorrect. The errata list my previous professor maintains is embarrassingly long. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50327, "question": "I like what /u/kphth said, but I think there's another major concern:\n\nThere just isn't as much academic source material for ARM as there is for MIPS. If you want to teach a course with MIPS, you've got something like 20 years of material created expressly for teaching students. ARM doesn't have that wealth of material, so any course teaching it basically gets to start from scratch.\n\nThat isn't to say that there aren't ARM courses out there. Some of my school's \"Topics In\" classes have covered ARM in the past, but the structure of those classes is a lot more, uh, \"seat of the pants\" learning than a more traditional classroom setting.\n\nIn short, the professor needs to write the ARM curriculum from scratch, whereas the structure and material for MIPS courses is already pretty much established.", "aSentId": 50330, "answer": "My school teaches ARM. It is so hard to find resources online for ARM when doing the programming assignment that half the time I end up giving up on my homework. Always have to go talk to my professor for help, which always turns out to be small mistake in my code. But having resources is a huge plus when learning a new language. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50327, "question": "I like what /u/kphth said, but I think there's another major concern:\n\nThere just isn't as much academic source material for ARM as there is for MIPS. If you want to teach a course with MIPS, you've got something like 20 years of material created expressly for teaching students. ARM doesn't have that wealth of material, so any course teaching it basically gets to start from scratch.\n\nThat isn't to say that there aren't ARM courses out there. Some of my school's \"Topics In\" classes have covered ARM in the past, but the structure of those classes is a lot more, uh, \"seat of the pants\" learning than a more traditional classroom setting.\n\nIn short, the professor needs to write the ARM curriculum from scratch, whereas the structure and material for MIPS courses is already pretty much established.", "aSentId": 50332, "answer": "Agreed.  The availability and usability of reference material is something that's not often talked about, but it really can drive adoption and usage of different technologies.  This is definitely the case with ARM vs MIPS, and the same is being seem with Objective-C vs Swift.  I'm sure Swift will surpass Obj-C soon enough, but my iOS dev class in college used Obj-C and my coworkers chose the same because there's just not enough reference material yet.\n\nSimilarly, I'm of the opinion that PHP would not be *nearly* as ubiquitous if it weren't for its phenomenally useful and accessible documentation and reference materiel.  Same thing for choosing Python 2 over Python 3, although there are other factors at play, there.\n\nDocs are important.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50325, "question": "Why don't colleges teach ARM instead of MIPS?", "aSentId": 50334, "answer": "Honestly, what is important is to learn principles of low level programming and processor architecture. Whatever the processor family is used appears to me as quite irrelevant.\n\nIf you make a career in low level programming, you'll soon enough have to deal with different processor families, depending on the specific needs of each project. There are very few people working on bsp level code nowadays.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50335, "question": "Honestly, what is important is to learn principles of low level programming and processor architecture. Whatever the processor family is used appears to me as quite irrelevant.\n\nIf you make a career in low level programming, you'll soon enough have to deal with different processor families, depending on the specific needs of each project. There are very few people working on bsp level code nowadays.", "aSentId": 50336, "answer": "Yup - I did introduction to assembly with ARM Thumb2 instruction sets, and our professor said that it was purely to get us thinking in that direction. He said we'd never use it in 98% of Dev jobs, and the 2% that we might use it in will require waaaay more skill development and that class would be pretty irrelevant. \n\nI guess that's actually pretty much the case for nearly all computer engineering/science classes except some of the intro to programming classes if you've never done anything like that before. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50325, "question": "Why don't colleges teach ARM instead of MIPS?", "aSentId": 50338, "answer": "Here's a side note for those who are interested:\n\nThe original ARM instruction set made a lot of weird (dumb) choices that made sense for simpler pipelines 25 years ago, and they got stuck with them. The newer \"v8\" 64-bit ARM instruction set that the newer ARMs use is surprisingly MIPS-like. A lot of the baroque cruft of the old ARM ISA has been shaved off. Turns out MIPS had the right idea all along.\n\nThe more you know \u2248\u2248\u2248\u2248\u2248\u2605\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50340, "question": "They teach MIPS because that architecture is easier to learn on than modern day architectures. Everything is simpler. At least that's the reasoning they gave at my school. ", "aSentId": 50341, "answer": "I don't know about ARM, but why not teach Atmel? Especially for intro to assembly it's appropriate. Added bonus is you can run it on real hardware which is dead cheap.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50342, "question": "I don't know about ARM, but why not teach Atmel? Especially for intro to assembly it's appropriate. Added bonus is you can run it on real hardware which is dead cheap.", "aSentId": 50343, "answer": "At my university, they taught both. We studied MIPS as an example of computer architecture, writing disassemblers and simulators for it without ever touching actual hardware. Then we used AVR chips for hands-on assembly programming and embedded stuff like radio-controlled model cars and temperature alarms.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50342, "question": "I don't know about ARM, but why not teach Atmel? Especially for intro to assembly it's appropriate. Added bonus is you can run it on real hardware which is dead cheap.", "aSentId": 50345, "answer": "I've never heard of that. I'll have to look into it. At my university we do an intro assembly in NASM, followed by architecture in MIPS, and we touch on ARM slightly in that class.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50342, "question": "I don't know about ARM, but why not teach Atmel? Especially for intro to assembly it's appropriate. Added bonus is you can run it on real hardware which is dead cheap.", "aSentId": 50347, "answer": "AVR is a terrible architecture. It doesn't allow classes to expand coverage to OoOE or even pipelining. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50352, "question": "Were writing a compiler to mips. I'm pretty pissed to be learning a Dino language, but I see the reasoning. Writing a compiler is hard. My teacher wrote a reference implementation for us to test, and him to grade against. Rewriting it for arm is just too much work when mips is just fine I guess. ", "aSentId": 50353, "answer": "As much as MIPS is a dying instruction set, it's not dead yet. A lot of embedded devices and things like routers still use it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50354, "question": "As much as MIPS is a dying instruction set, it's not dead yet. A lot of embedded devices and things like routers still use it.", "aSentId": 50355, "answer": "As long as it works and it's cheap, there's no reason why a company would put resources in migrating to ARM based systems. That's the same reason why a lot of financial institutions still use programs written in Fortran or COBOL.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50356, "question": "As long as it works and it's cheap, there's no reason why a company would put resources in migrating to ARM based systems. That's the same reason why a lot of financial institutions still use programs written in Fortran or COBOL.", "aSentId": 50357, "answer": "Lots of new scientific computing code is being written in FORTRAN all the time even today. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50356, "question": "As long as it works and it's cheap, there's no reason why a company would put resources in migrating to ARM based systems. That's the same reason why a lot of financial institutions still use programs written in Fortran or COBOL.", "aSentId": 50359, "answer": "I actually thought that the reason for FORTRAN persisting to this day was that it was slightly easier to optimize in comparison to C/C++. I could be 100% wrong on this, though, so feel free to refute me. :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50354, "question": "As much as MIPS is a dying instruction set, it's not dead yet. A lot of embedded devices and things like routers still use it.", "aSentId": 50361, "answer": "And it seems that Imagination, the new owner of MIPS, is trying really hard to make it not die. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50352, "question": "Were writing a compiler to mips. I'm pretty pissed to be learning a Dino language, but I see the reasoning. Writing a compiler is hard. My teacher wrote a reference implementation for us to test, and him to grade against. Rewriting it for arm is just too much work when mips is just fine I guess. ", "aSentId": 50363, "answer": "You're not writing a compiler to understands MIPS though. The chances that you will ever need to write assembly for any architecture once you graduate is not that large, and if you do chances are that you're implementing some new feature that may not exist now (SSE6?). Plus you're not likely to be doing any complex ops, or trying to do processor specific optimisations.\n\nIts more about the concepts. When I did a compiler course (2001) we targeted the JVM bytecode as the output. No one ever expected to write JVM opcodes directly. Although writing peephole optimisations that survive the jvm's validation rules is interesting....", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50364, "question": "You're not writing a compiler to understands MIPS though. The chances that you will ever need to write assembly for any architecture once you graduate is not that large, and if you do chances are that you're implementing some new feature that may not exist now (SSE6?). Plus you're not likely to be doing any complex ops, or trying to do processor specific optimisations.\n\nIts more about the concepts. When I did a compiler course (2001) we targeted the JVM bytecode as the output. No one ever expected to write JVM opcodes directly. Although writing peephole optimisations that survive the jvm's validation rules is interesting....", "aSentId": 50365, "answer": "I feel people have this misconception that a computer science or equivalent degree is about teaching you how to program. It's really not. \n\nYou learn the theory and the math. My university only had a basic introduction to programming course for CS majors (IIRC), as you were expected to use code only to demonstrate the concepts, and what language you used was largely irrelevant. \n\nWe also used MIPS though.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50364, "question": "You're not writing a compiler to understands MIPS though. The chances that you will ever need to write assembly for any architecture once you graduate is not that large, and if you do chances are that you're implementing some new feature that may not exist now (SSE6?). Plus you're not likely to be doing any complex ops, or trying to do processor specific optimisations.\n\nIts more about the concepts. When I did a compiler course (2001) we targeted the JVM bytecode as the output. No one ever expected to write JVM opcodes directly. Although writing peephole optimisations that survive the jvm's validation rules is interesting....", "aSentId": 50367, "answer": "The JVM is an odd target for a compiler course, though, not least because it's stack based.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50352, "question": "Were writing a compiler to mips. I'm pretty pissed to be learning a Dino language, but I see the reasoning. Writing a compiler is hard. My teacher wrote a reference implementation for us to test, and him to grade against. Rewriting it for arm is just too much work when mips is just fine I guess. ", "aSentId": 50369, "answer": "our compiler design course used ARM, rewriting it wasnt hard since all they did was check the assembled program output, not the assembler itself.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50373, "question": "I was taught x86 right after being taught mips. I genuinely don't get the argument that mips is more teachable.\n\nArm and x86 aren't that different and certainly aren't really more difficult.", "aSentId": 50374, "answer": "I loved x86. MIPS annoys the hell out of me. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50387, "question": "Is there an algorithm that shows when a queue is empty, a consumer can insert itself into the queue?", "aSentId": 50388, "answer": "Thus seems like a semaphore consumer producer problem. I think it'd be better to have two queues, both locked together. When a consumer (worker thread) comes for work, it looks the system, checks the work queue, and either does work or enqueues itself. A producer will drop off work and wake up threads as needed. I'm on my phone so I glossed over some details. Just search Wikipedia for consumer producer. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50387, "question": "Is there an algorithm that shows when a queue is empty, a consumer can insert itself into the queue?", "aSentId": 50390, "answer": "Kind of sounds like a thread pool. Just more specialized, with the resource queue acting as either a resource or a thread.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50387, "question": "Is there an algorithm that shows when a queue is empty, a consumer can insert itself into the queue?", "aSentId": 50392, "answer": "Why not just have the consumers wait on the queue? That achieves the same effect, but the consumer queuing is then handled by the language, and you don't have to deal with as much state-switching in your implementation.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50395, "question": "Cannot wrap my head around error correction.", "aSentId": 50396, "answer": "&gt; why the distance always has to be &gt;= error+1 for detection\n\nIf an e-bit error produces another valid code word, you cannot detect e-bit errors. You'll just see another valid word and have no way to know it should have been something else. If every valid code word is at least e+1 bits away from each other valid word, then an e-bit error must produce an invalid word.\n\n&gt; why does it have to be 2*e + 1 for correction\n\nWhen we see an invalid word, we figure it was probably supposed to be the nearest valid word (n bits of error is more likely than n+1 bits of error). If we have two words that are only 2e bits apart, then an e-bit error could give us a word that's exactly halfway between them. We can't tell which valid word to interpret that as. If they're 2e+1 bits apart, then that e-bit error must be closer to one than to the other, so that's the one we choose.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50395, "question": "Cannot wrap my head around error correction.", "aSentId": 50398, "answer": "Work some exercises, once you see it in practice it's not so bad. Take an example dictionary of words, corrupt e bits, and see how you can still tell what the original word was. Corrupt e+1 and see how you think it's some other word now.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50400, "question": "The Nature of Code", "aSentId": 50401, "answer": "What is this website? It's brilliant. Tons of useful stuff.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50402, "question": "What is this website? It's brilliant. Tons of useful stuff.", "aSentId": 50403, "answer": "It's the companion website to the book/video series called \"Nature of Code\", which were a set of tutorials/chapters on various techniques to bring processing drawings (https://processing.org/) to life.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50400, "question": "The Nature of Code", "aSentId": 50405, "answer": "I didn't read the entire article, but I remember making those random drawing programs on my TI-84 during math class instead of paying attention.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 50400, "question": "The Nature of Code", "aSentId": 50407, "answer": "bookmarked for later.  This looks very interesting.", "corpus": "reddit"}]