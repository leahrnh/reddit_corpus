[{"docID": "t5_2qhmr", "qSentId": 37510, "question": "Computer Science Themed Art?", "aSentId": 37511, "answer": "There's a whole genre of emerging art where the artist designs creative algorithms to generate art.  There's a subreddit here: /r/creativecoding/.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37510, "question": "Computer Science Themed Art?", "aSentId": 37513, "answer": "First thoughts would be 3d animation, of course, but that steers towards the applied side of things.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37510, "question": "Computer Science Themed Art?", "aSentId": 37515, "answer": "Assuredly not what you mean, but I found [this](http://nautil.us/issue/21/information/how-i-taught-my-computer-to-write-its-own-music) the other day and thought it was really cool.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37521, "question": "What do you call the #?", "aSentId": 37522, "answer": "hash or pound", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37521, "question": "What do you call the #?", "aSentId": 37524, "answer": "octothorpe", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37525, "question": "octothorpe", "aSentId": 37526, "answer": "There's always someone...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37525, "question": "octothorpe", "aSentId": 37528, "answer": "As a GIS guy, seeing the old mapping term made me smile.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37521, "question": "What do you call the #?", "aSentId": 37530, "answer": "I'd call those \"pound includes\" if I had to call them anything other than \"includes.\" But C# is C-sharp. Just one of those things.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37531, "question": "I'd call those \"pound includes\" if I had to call them anything other than \"includes.\" But C# is C-sharp. Just one of those things.", "aSentId": 37532, "answer": "It's a musical terminology pun.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37533, "question": "It's a musical terminology pun.", "aSentId": 37534, "answer": "It's not a pun, the language is named C\u266f. It's just usually written C#.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37535, "question": "It's not a pun, the language is named C\u266f. It's just usually written C#.", "aSentId": 37536, "answer": "&gt; C\u266f\n\nIt is a pun.\n\nC++ is \"C + 1\" whici is \"more than C\", and \"\u266f\" in music, \"increments half a tone\", which, again, is \"more than C\". ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37537, "question": "&gt; C\u266f\n\nIt is a pun.\n\nC++ is \"C + 1\" whici is \"more than C\", and \"\u266f\" in music, \"increments half a tone\", which, again, is \"more than C\". ", "aSentId": 37538, "answer": "I believe the pun here is just C++++ because you can make a hash out of them.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37535, "question": "It's not a pun, the language is named C\u266f. It's just usually written C#.", "aSentId": 37540, "answer": "c# is a pun... it's 100% a pun.\n\nJust like c++ is a programming pun.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37543, "question": "I used to say \"hash\" but with the advent of the \"hashtag\" I mostly say \"sharp\" now. ", "aSentId": 37544, "answer": "To annoy you:\n\n* Hash / Number sign / octothorpe has two parallel horizontal lines crossed by two backwards slanting parallel lines.\n\n* Sharp has two parallel vertical lines crossed by two upwards slanting parallel lines.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37545, "question": "To annoy you:\n\n* Hash / Number sign / octothorpe has two parallel horizontal lines crossed by two backwards slanting parallel lines.\n\n* Sharp has two parallel vertical lines crossed by two upwards slanting parallel lines.", "aSentId": 37546, "answer": "Sure, but there's no ASCII character for a sharp, so I can conflate them (in ASCII text) as much as I conflate a hyphen and a minus :p", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37545, "question": "To annoy you:\n\n* Hash / Number sign / octothorpe has two parallel horizontal lines crossed by two backwards slanting parallel lines.\n\n* Sharp has two parallel vertical lines crossed by two upwards slanting parallel lines.", "aSentId": 37548, "answer": "&gt; backwards slanting\n\nIs that the same as forward-slanting?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37549, "question": "&gt; backwards slanting\n\nIs that the same as forward-slanting?", "aSentId": 37550, "answer": "Nope. Backslash (\\\\) leans backwards and forward slash (/) leans forwards, assuming left-to-right.\n\nAnd the hash has forward slanting lines.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37551, "question": "Nope. Backslash (\\\\) leans backwards and forward slash (/) leans forwards, assuming left-to-right.\n\nAnd the hash has forward slanting lines.", "aSentId": 37552, "answer": "But the post I replied to said that the number sign has backwards-slanting lines. :-|", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37553, "question": "But the post I replied to said that the number sign has backwards-slanting lines. :-|", "aSentId": 37554, "answer": "That is incorrect. # they are forward slanting. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37556, "question": "C# is definitely pronounced \"C Pound\".", "aSentId": 37557, "answer": "I once got a call from a recruiter asking if I knew C hashtag", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37556, "question": "C# is definitely pronounced \"C Pound\".", "aSentId": 37559, "answer": "u srs? ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37563, "question": "In\n\n    #!/bin/bash\nit is \"Pound bang bin bash\"\n\nhowever almost all other contexts I call it a \"hash\"", "aSentId": 37564, "answer": "That combo can also be called sha-bang. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37570, "question": "How necessary is it to understand memory management and learning the internal workings of languages for the CS real world?", "aSentId": 37571, "answer": "Credentials: I work in industry. I've worked at most layers of the stack above hardware interop. I've gone as low as C in an operating system kernel and as high as web services in Java. My current job is working on a NT service in C#.\n\nThese things are very important. They are not needed every day, but they are very important. The knowledge of low-level constructs is extremely important in understanding the unexpected. I am going to base my examples off of C# because that is the language I know best right now, but everything I say will hold true for Java.\n\nC# is a garbage collected language. You don't need to worry about explicitly allocating and deallocating memory. So you don't need to know about memory layout. Until the day you do.\n\nHere are a couple of examples for you:\n\n**How variables are saved**\n\nLet's say you need to process a picture. You need to apply a filter to it (like say Instagram). Or you need to create a low resolution image to send while the high-resolution (lets go with 1920x1080) image downloads (like Facebook does). An image is represented as a two-dimensional array of pixels. You are doing the same operation on each pixel. How would you structure your loop? Would you do row first or column first? Logically it does not matter. But one choice is at *least* 10x faster than the other.\n\nWhy? A two dimensional array is actually just a one dimensional array with some syntax sugar. So let's walk through how the CPU sees each of these.\n\n1) Row first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (call it 100,000 cycles). The section you need is read from RAM (10,000 cycles). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1, L2, and L3 cache. You request\n\n    pixel[0][1]\n\nwhich is just\n\n    pixel[1]\n\nThat pixel is already loaded into the L1 cache. So it gets it from there (10 cycles). You keep doing this. The OS memory manager notices you are reading a continuous block of memory. It pre-fetches memory into L2 cache in the background. This does not affect the run-time of your method. When you exhaust the 8KB block, the next block is already living in L2 so it is fetched from there (100 cycles) which is 10x more expensive than L1, but 100x cheaper than RAM (and 1000x cheaper than disc).\n\n2) Column first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (very expensive). The section you need is read from RAM into the CPU caches (pretty expensive). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1 cache. You request\n\n    pixel[1][0]\n\nwhich is just\n\n    pixel[1920]\n\nThat pixel belongs to a separate block that is in RAM, but it is not in the CPU cache. So the memory manger moves the 8KB block from RAM to the CPU (10,000 cycles). You keep doing this. Every single access is a cache miss. The OS memory manager notices you are reading from a random block of memory. It is very confused and can't pre-fetch anything.\n\n**Where variables are saved and knowing the internals**\n\nIn a garbage collected language, memory management is done by a garbage collector. There are generally two different ways of implementing this. The first is a mark-and-sweep which is the approach most languages (Python, C#, Java, and Go) use. This algorithm freezes the program execution, analyzes the heap, marks the variables that are not in use, sweeps them up, and compacts the heap. This can cause major performance problems because your program pauses execution to clean-up the memory. Some places have more advanced versions of this (incremental &amp; concurrent collectors are very notable here).\n\nThe second is a reference counter. This is the way Apple (Objective-C and Swift) do it. The problem is that it is very prone to memory leaks due to cycles.\n\nYou need to understand the algorithm that is managing memory for you so you can understand the problems that it creates. For instance most mark-and-sweep languages these days use a generational garbage collector. The assumption is that most memory allocations are very transient in nature. So the collectors create the concept of generations and then mark and sweep each generation separately. Generation 0 (the new things) way more often than generation 1 which is swept way more often than generation 2. Generation 0 is usually very small (several MB), generation 1 is larger, and generation 2 is unbounded. Sweeps are initiated by memory pressure. If generation 0 is full, then generation 0 is swept.\n\nAs a developer, if you see a huge amount of generation 0 sweeps, you know there is something wrong. Your program execution time is getting dominated by garbage collection instead of your logic. So you are going to need to analyze the memory layout of your program to see what is creating and destroying huge amounts of data very quickly. On the other hand, if your generation 2 is huge, you probably have a memory leak. You need to take a dump and look at the raw memory to identify what is leaking and then backtrace the references to find the object that is living longer than it should.\n\nKnowing that your have a generational garbage collector lets you know where to start looking in the first place. In Swift, I don't need to worry about the generations, but I need to be rigidly aware to create acyclic data structures if I don't want to manage memory.\n\nNow all of that goes away if the variable is stored on the stack. Instead you need to understand whether your language does pass-by-value or pass-by-reference or something in between. The problems of the heap don't exist on the stack and vice versa. So don't bother looking for leaks on the stack for instance.\n\n**Getting a job**\n\nThe image scenario was a question asked when I was interviewing for my first full-time job out of college. Managed memory leaks are actually pretty common. The generation garbage collection problem is rare but really nasty.\n\nNow you can do every day things without knowing these things, but the moment you run into a hard problem, you *need* to know your fundamentals. Otherwise you are shit out of luck.\n\n\nEdits: formatting", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37572, "question": "Credentials: I work in industry. I've worked at most layers of the stack above hardware interop. I've gone as low as C in an operating system kernel and as high as web services in Java. My current job is working on a NT service in C#.\n\nThese things are very important. They are not needed every day, but they are very important. The knowledge of low-level constructs is extremely important in understanding the unexpected. I am going to base my examples off of C# because that is the language I know best right now, but everything I say will hold true for Java.\n\nC# is a garbage collected language. You don't need to worry about explicitly allocating and deallocating memory. So you don't need to know about memory layout. Until the day you do.\n\nHere are a couple of examples for you:\n\n**How variables are saved**\n\nLet's say you need to process a picture. You need to apply a filter to it (like say Instagram). Or you need to create a low resolution image to send while the high-resolution (lets go with 1920x1080) image downloads (like Facebook does). An image is represented as a two-dimensional array of pixels. You are doing the same operation on each pixel. How would you structure your loop? Would you do row first or column first? Logically it does not matter. But one choice is at *least* 10x faster than the other.\n\nWhy? A two dimensional array is actually just a one dimensional array with some syntax sugar. So let's walk through how the CPU sees each of these.\n\n1) Row first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (call it 100,000 cycles). The section you need is read from RAM (10,000 cycles). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1, L2, and L3 cache. You request\n\n    pixel[0][1]\n\nwhich is just\n\n    pixel[1]\n\nThat pixel is already loaded into the L1 cache. So it gets it from there (10 cycles). You keep doing this. The OS memory manager notices you are reading a continuous block of memory. It pre-fetches memory into L2 cache in the background. This does not affect the run-time of your method. When you exhaust the 8KB block, the next block is already living in L2 so it is fetched from there (100 cycles) which is 10x more expensive than L1, but 100x cheaper than RAM (and 1000x cheaper than disc).\n\n2) Column first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (very expensive). The section you need is read from RAM into the CPU caches (pretty expensive). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1 cache. You request\n\n    pixel[1][0]\n\nwhich is just\n\n    pixel[1920]\n\nThat pixel belongs to a separate block that is in RAM, but it is not in the CPU cache. So the memory manger moves the 8KB block from RAM to the CPU (10,000 cycles). You keep doing this. Every single access is a cache miss. The OS memory manager notices you are reading from a random block of memory. It is very confused and can't pre-fetch anything.\n\n**Where variables are saved and knowing the internals**\n\nIn a garbage collected language, memory management is done by a garbage collector. There are generally two different ways of implementing this. The first is a mark-and-sweep which is the approach most languages (Python, C#, Java, and Go) use. This algorithm freezes the program execution, analyzes the heap, marks the variables that are not in use, sweeps them up, and compacts the heap. This can cause major performance problems because your program pauses execution to clean-up the memory. Some places have more advanced versions of this (incremental &amp; concurrent collectors are very notable here).\n\nThe second is a reference counter. This is the way Apple (Objective-C and Swift) do it. The problem is that it is very prone to memory leaks due to cycles.\n\nYou need to understand the algorithm that is managing memory for you so you can understand the problems that it creates. For instance most mark-and-sweep languages these days use a generational garbage collector. The assumption is that most memory allocations are very transient in nature. So the collectors create the concept of generations and then mark and sweep each generation separately. Generation 0 (the new things) way more often than generation 1 which is swept way more often than generation 2. Generation 0 is usually very small (several MB), generation 1 is larger, and generation 2 is unbounded. Sweeps are initiated by memory pressure. If generation 0 is full, then generation 0 is swept.\n\nAs a developer, if you see a huge amount of generation 0 sweeps, you know there is something wrong. Your program execution time is getting dominated by garbage collection instead of your logic. So you are going to need to analyze the memory layout of your program to see what is creating and destroying huge amounts of data very quickly. On the other hand, if your generation 2 is huge, you probably have a memory leak. You need to take a dump and look at the raw memory to identify what is leaking and then backtrace the references to find the object that is living longer than it should.\n\nKnowing that your have a generational garbage collector lets you know where to start looking in the first place. In Swift, I don't need to worry about the generations, but I need to be rigidly aware to create acyclic data structures if I don't want to manage memory.\n\nNow all of that goes away if the variable is stored on the stack. Instead you need to understand whether your language does pass-by-value or pass-by-reference or something in between. The problems of the heap don't exist on the stack and vice versa. So don't bother looking for leaks on the stack for instance.\n\n**Getting a job**\n\nThe image scenario was a question asked when I was interviewing for my first full-time job out of college. Managed memory leaks are actually pretty common. The generation garbage collection problem is rare but really nasty.\n\nNow you can do every day things without knowing these things, but the moment you run into a hard problem, you *need* to know your fundamentals. Otherwise you are shit out of luck.\n\n\nEdits: formatting", "aSentId": 37573, "answer": "Yes, OP listen to this guy.  This stuff is important and useful.  I'm sure that you will learn far more about it in a later course; be sure to pay attention to it when it comes up.\n\nAnyway, the reason I'm commenting: I would suggest that you stop asking \"Do I need to know this?\" at all.  Anything you learn can only be helpful.  Worst case, you have a little more knowledge in your head.  Where is the harm in that?\n\nI think that most of a STEM undergraduate degree is simply learning how to reason and approach difficult problems.  Of course you learn important things about your subject area along the way, but you have very little knowledge which is immediately applicable.  There will still be a learning curve at any job you get out of college.  So focus on developing a solid understanding of everything you cover in every class (not just STEM classes!) and you will find that you have acquired a useful skill - you know how to learn.  When you later come across some complex topic that you need to understand, the process will be familiar and easy to you.  Sounds trivial, but it really is an important skill and you can always get better at it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37574, "question": "Yes, OP listen to this guy.  This stuff is important and useful.  I'm sure that you will learn far more about it in a later course; be sure to pay attention to it when it comes up.\n\nAnyway, the reason I'm commenting: I would suggest that you stop asking \"Do I need to know this?\" at all.  Anything you learn can only be helpful.  Worst case, you have a little more knowledge in your head.  Where is the harm in that?\n\nI think that most of a STEM undergraduate degree is simply learning how to reason and approach difficult problems.  Of course you learn important things about your subject area along the way, but you have very little knowledge which is immediately applicable.  There will still be a learning curve at any job you get out of college.  So focus on developing a solid understanding of everything you cover in every class (not just STEM classes!) and you will find that you have acquired a useful skill - you know how to learn.  When you later come across some complex topic that you need to understand, the process will be familiar and easy to you.  Sounds trivial, but it really is an important skill and you can always get better at it.", "aSentId": 37575, "answer": "&gt; \"Do I need to know this?\"\n\nI would say this is 100% true for students.\n\nBut as an experienced programmer, I could have done without learning nodejs.  ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37572, "question": "Credentials: I work in industry. I've worked at most layers of the stack above hardware interop. I've gone as low as C in an operating system kernel and as high as web services in Java. My current job is working on a NT service in C#.\n\nThese things are very important. They are not needed every day, but they are very important. The knowledge of low-level constructs is extremely important in understanding the unexpected. I am going to base my examples off of C# because that is the language I know best right now, but everything I say will hold true for Java.\n\nC# is a garbage collected language. You don't need to worry about explicitly allocating and deallocating memory. So you don't need to know about memory layout. Until the day you do.\n\nHere are a couple of examples for you:\n\n**How variables are saved**\n\nLet's say you need to process a picture. You need to apply a filter to it (like say Instagram). Or you need to create a low resolution image to send while the high-resolution (lets go with 1920x1080) image downloads (like Facebook does). An image is represented as a two-dimensional array of pixels. You are doing the same operation on each pixel. How would you structure your loop? Would you do row first or column first? Logically it does not matter. But one choice is at *least* 10x faster than the other.\n\nWhy? A two dimensional array is actually just a one dimensional array with some syntax sugar. So let's walk through how the CPU sees each of these.\n\n1) Row first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (call it 100,000 cycles). The section you need is read from RAM (10,000 cycles). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1, L2, and L3 cache. You request\n\n    pixel[0][1]\n\nwhich is just\n\n    pixel[1]\n\nThat pixel is already loaded into the L1 cache. So it gets it from there (10 cycles). You keep doing this. The OS memory manager notices you are reading a continuous block of memory. It pre-fetches memory into L2 cache in the background. This does not affect the run-time of your method. When you exhaust the 8KB block, the next block is already living in L2 so it is fetched from there (100 cycles) which is 10x more expensive than L1, but 100x cheaper than RAM (and 1000x cheaper than disc).\n\n2) Column first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (very expensive). The section you need is read from RAM into the CPU caches (pretty expensive). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1 cache. You request\n\n    pixel[1][0]\n\nwhich is just\n\n    pixel[1920]\n\nThat pixel belongs to a separate block that is in RAM, but it is not in the CPU cache. So the memory manger moves the 8KB block from RAM to the CPU (10,000 cycles). You keep doing this. Every single access is a cache miss. The OS memory manager notices you are reading from a random block of memory. It is very confused and can't pre-fetch anything.\n\n**Where variables are saved and knowing the internals**\n\nIn a garbage collected language, memory management is done by a garbage collector. There are generally two different ways of implementing this. The first is a mark-and-sweep which is the approach most languages (Python, C#, Java, and Go) use. This algorithm freezes the program execution, analyzes the heap, marks the variables that are not in use, sweeps them up, and compacts the heap. This can cause major performance problems because your program pauses execution to clean-up the memory. Some places have more advanced versions of this (incremental &amp; concurrent collectors are very notable here).\n\nThe second is a reference counter. This is the way Apple (Objective-C and Swift) do it. The problem is that it is very prone to memory leaks due to cycles.\n\nYou need to understand the algorithm that is managing memory for you so you can understand the problems that it creates. For instance most mark-and-sweep languages these days use a generational garbage collector. The assumption is that most memory allocations are very transient in nature. So the collectors create the concept of generations and then mark and sweep each generation separately. Generation 0 (the new things) way more often than generation 1 which is swept way more often than generation 2. Generation 0 is usually very small (several MB), generation 1 is larger, and generation 2 is unbounded. Sweeps are initiated by memory pressure. If generation 0 is full, then generation 0 is swept.\n\nAs a developer, if you see a huge amount of generation 0 sweeps, you know there is something wrong. Your program execution time is getting dominated by garbage collection instead of your logic. So you are going to need to analyze the memory layout of your program to see what is creating and destroying huge amounts of data very quickly. On the other hand, if your generation 2 is huge, you probably have a memory leak. You need to take a dump and look at the raw memory to identify what is leaking and then backtrace the references to find the object that is living longer than it should.\n\nKnowing that your have a generational garbage collector lets you know where to start looking in the first place. In Swift, I don't need to worry about the generations, but I need to be rigidly aware to create acyclic data structures if I don't want to manage memory.\n\nNow all of that goes away if the variable is stored on the stack. Instead you need to understand whether your language does pass-by-value or pass-by-reference or something in between. The problems of the heap don't exist on the stack and vice versa. So don't bother looking for leaks on the stack for instance.\n\n**Getting a job**\n\nThe image scenario was a question asked when I was interviewing for my first full-time job out of college. Managed memory leaks are actually pretty common. The generation garbage collection problem is rare but really nasty.\n\nNow you can do every day things without knowing these things, but the moment you run into a hard problem, you *need* to know your fundamentals. Otherwise you are shit out of luck.\n\n\nEdits: formatting", "aSentId": 37577, "answer": "Excellent and informative post!  Thank you. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37572, "question": "Credentials: I work in industry. I've worked at most layers of the stack above hardware interop. I've gone as low as C in an operating system kernel and as high as web services in Java. My current job is working on a NT service in C#.\n\nThese things are very important. They are not needed every day, but they are very important. The knowledge of low-level constructs is extremely important in understanding the unexpected. I am going to base my examples off of C# because that is the language I know best right now, but everything I say will hold true for Java.\n\nC# is a garbage collected language. You don't need to worry about explicitly allocating and deallocating memory. So you don't need to know about memory layout. Until the day you do.\n\nHere are a couple of examples for you:\n\n**How variables are saved**\n\nLet's say you need to process a picture. You need to apply a filter to it (like say Instagram). Or you need to create a low resolution image to send while the high-resolution (lets go with 1920x1080) image downloads (like Facebook does). An image is represented as a two-dimensional array of pixels. You are doing the same operation on each pixel. How would you structure your loop? Would you do row first or column first? Logically it does not matter. But one choice is at *least* 10x faster than the other.\n\nWhy? A two dimensional array is actually just a one dimensional array with some syntax sugar. So let's walk through how the CPU sees each of these.\n\n1) Row first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (call it 100,000 cycles). The section you need is read from RAM (10,000 cycles). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1, L2, and L3 cache. You request\n\n    pixel[0][1]\n\nwhich is just\n\n    pixel[1]\n\nThat pixel is already loaded into the L1 cache. So it gets it from there (10 cycles). You keep doing this. The OS memory manager notices you are reading a continuous block of memory. It pre-fetches memory into L2 cache in the background. This does not affect the run-time of your method. When you exhaust the 8KB block, the next block is already living in L2 so it is fetched from there (100 cycles) which is 10x more expensive than L1, but 100x cheaper than RAM (and 1000x cheaper than disc).\n\n2) Column first\n\nYou request\n\n    pixel[0][0]\n\n which is just\n\n    pixel[0]\n\nThe picture is loaded from disc into RAM (very expensive). The section you need is read from RAM into the CPU caches (pretty expensive). Since everything work in blocks, it grabs a 8KB chunk. This 8KB is stored into the L1 cache. You request\n\n    pixel[1][0]\n\nwhich is just\n\n    pixel[1920]\n\nThat pixel belongs to a separate block that is in RAM, but it is not in the CPU cache. So the memory manger moves the 8KB block from RAM to the CPU (10,000 cycles). You keep doing this. Every single access is a cache miss. The OS memory manager notices you are reading from a random block of memory. It is very confused and can't pre-fetch anything.\n\n**Where variables are saved and knowing the internals**\n\nIn a garbage collected language, memory management is done by a garbage collector. There are generally two different ways of implementing this. The first is a mark-and-sweep which is the approach most languages (Python, C#, Java, and Go) use. This algorithm freezes the program execution, analyzes the heap, marks the variables that are not in use, sweeps them up, and compacts the heap. This can cause major performance problems because your program pauses execution to clean-up the memory. Some places have more advanced versions of this (incremental &amp; concurrent collectors are very notable here).\n\nThe second is a reference counter. This is the way Apple (Objective-C and Swift) do it. The problem is that it is very prone to memory leaks due to cycles.\n\nYou need to understand the algorithm that is managing memory for you so you can understand the problems that it creates. For instance most mark-and-sweep languages these days use a generational garbage collector. The assumption is that most memory allocations are very transient in nature. So the collectors create the concept of generations and then mark and sweep each generation separately. Generation 0 (the new things) way more often than generation 1 which is swept way more often than generation 2. Generation 0 is usually very small (several MB), generation 1 is larger, and generation 2 is unbounded. Sweeps are initiated by memory pressure. If generation 0 is full, then generation 0 is swept.\n\nAs a developer, if you see a huge amount of generation 0 sweeps, you know there is something wrong. Your program execution time is getting dominated by garbage collection instead of your logic. So you are going to need to analyze the memory layout of your program to see what is creating and destroying huge amounts of data very quickly. On the other hand, if your generation 2 is huge, you probably have a memory leak. You need to take a dump and look at the raw memory to identify what is leaking and then backtrace the references to find the object that is living longer than it should.\n\nKnowing that your have a generational garbage collector lets you know where to start looking in the first place. In Swift, I don't need to worry about the generations, but I need to be rigidly aware to create acyclic data structures if I don't want to manage memory.\n\nNow all of that goes away if the variable is stored on the stack. Instead you need to understand whether your language does pass-by-value or pass-by-reference or something in between. The problems of the heap don't exist on the stack and vice versa. So don't bother looking for leaks on the stack for instance.\n\n**Getting a job**\n\nThe image scenario was a question asked when I was interviewing for my first full-time job out of college. Managed memory leaks are actually pretty common. The generation garbage collection problem is rare but really nasty.\n\nNow you can do every day things without knowing these things, but the moment you run into a hard problem, you *need* to know your fundamentals. Otherwise you are shit out of luck.\n\n\nEdits: formatting", "aSentId": 37579, "answer": "&gt;  Managed memory leaks are actually pretty common. \n\nThey are?!\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37580, "question": "&gt;  Managed memory leaks are actually pretty common. \n\nThey are?!\n\n", "aSentId": 37581, "answer": "A pretty simple example would be two objects that store references to each other.  Depending on the sophistication of the garbage collector, they might not ever be released.  It only gets worse if you can get a chain of objects: A refers to B refers to C refers to D refers to E refers to A.  The whole mess may have fallen out of scope, and if the references didn't exist would be freed, but a refcounting garbage collector may not have a way to untangle the mess.\n\nOther GC mechanisms may handle it better, but there's almost always a tradeoff.  You may end up with something like .NET's nuclear option for garbage collection that actually stops all other running threads in the application while it does a pretty hefty GC operation.\n\nGarbage collection and managed memory is a better scenario than manual management, but if you assume that the GC will \"take care of everything\" and you \"can't leak memory with one\" then you're gonna have a bad time.  At a minimum, you need to know what the GC is doing, how it handles things like reference chains and what mechanism it uses to handle memory management.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37582, "question": "A pretty simple example would be two objects that store references to each other.  Depending on the sophistication of the garbage collector, they might not ever be released.  It only gets worse if you can get a chain of objects: A refers to B refers to C refers to D refers to E refers to A.  The whole mess may have fallen out of scope, and if the references didn't exist would be freed, but a refcounting garbage collector may not have a way to untangle the mess.\n\nOther GC mechanisms may handle it better, but there's almost always a tradeoff.  You may end up with something like .NET's nuclear option for garbage collection that actually stops all other running threads in the application while it does a pretty hefty GC operation.\n\nGarbage collection and managed memory is a better scenario than manual management, but if you assume that the GC will \"take care of everything\" and you \"can't leak memory with one\" then you're gonna have a bad time.  At a minimum, you need to know what the GC is doing, how it handles things like reference chains and what mechanism it uses to handle memory management.", "aSentId": 37583, "answer": "To add on to this, some Java GCs can \"stop the world.\" Imagine that in your high profile and heavily trafficked application and you'll see why this stuff is good to know. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37580, "question": "&gt;  Managed memory leaks are actually pretty common. \n\nThey are?!\n\n", "aSentId": 37585, "answer": "Not removing a key from a hashtable, for one.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37587, "question": "You have 45 work accounts?", "aSentId": 37588, "answer": "Just a number that is easy to remember because they are consecutive. I am not good at naming things.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37570, "question": "How necessary is it to understand memory management and learning the internal workings of languages for the CS real world?", "aSentId": 37590, "answer": "I think that understanding things like memory management, machine cycles, and the foundations are important. You won't necessarily need all the information, but having that foundation to build on is really nice. That is the difference between a developer who just learns a language and someone who gets a cs degree. It helps you learn faster, and be a better developer. Soak up all the information you can now, it will help later. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37570, "question": "How necessary is it to understand memory management and learning the internal workings of languages for the CS real world?", "aSentId": 37592, "answer": "In every discipline whatsoever, it's always good to have an understanding of what's going on one layer down. Good auto mechanics don't just swap out parts; they have an understanding of how engines work. Airline pilots need to understand the principles of flight, not just which buttons to push on the computer. \n\nEven in a language with automated, behind-the-scenes garbage collection, sometimes you still need to know how the GC works and how it may introduce subtle timing issues. \n\nIt's always good to know a little about the layer below the one at which you're working. And by \"a little\" I mean as much as you possibly can without becoming a specialist.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37597, "question": "As you may have realized, this subjects is all about layers of abstraction. Now, it's true that you could probably lead a productive life without going to deep into memory management, but...\n\nThe more well rounded your knowledge of CS, the more things will click. Memory management is closley tied to computer architecture. Having a healthy knowledge of how computers are built will allow you to better understand how to leverage their power. To some extend, programming languages are all aimed at some \"Abstract Machine\". Java is of course meant to be run on the JVM, which uses garbage collection. However, a language like C is made for an abstract machine that is very close to the underlying hardware. When you program in a language like C, you will witness first hand what it means to pass by value or pass by reference. And the difference between storing a variable on the stack versus the heap. Try playing around with passing ArrayLists in Java sometime, there are some quirks there that you might not realize unless you understand how Java uses memory. \n\nTo further scare you about the future, understanding memory management is of the upmost imporance with parallel computing. Shared resources must be carefully managed, and this is of course made much easier by an understanding of how memory works. \n\nThat being said, we're all human. You're better off exploring things a layer at a time then to get overwhelmed at all the stuff you could be learning. Enjoy your data structures course and learn memory management as you need to. ..\n", "aSentId": 37598, "answer": "&gt; To further scare you about the future, understanding memory management is of the upmost imporance with parallel computing. Shared resources must be carefully managed, and this is of course made much easier by an understanding of how memory works. \n\nThis is really important. Garbage collection only stops your memory leaks from getting too out of control, and that's about it. It doesn't solve every single problem about resource management and ownership. Whether you view it as a tool or as a crutch, it has the effect of slightly expanding the horizons of what code can be considered functional and correct. But it is only effective against some problems that were commonplace several decades ago; it doesn't magic away the challenges of programming in a modern environment. For those, you need knowledge that has as a prerequisite the ability to function without relying on garbage collection.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37604, "question": "I would say if you want a job in anything high-performance, having a good concept of memory management is a fantastic idea. You see, Java, C#, Python and other languages where memory is garbage-collected are wonderful because you don't have to think about cleaning up what you make, which eliminates the age-old problem of memory leaks. However, tracking the mess of declarations gets expensive so high-performance computing will rarely use these languages, except in rare scenarios. \n\nI consider myself a proponent of the easier languages. We invented compilers to make programming easier after all, not to make faster programs. That being said, I feel that my experience with C/C++ has made benefited my knowledge of computers and thus, the programs I write. ", "aSentId": 37605, "answer": "Thing is, even in Python, Java, etc you need to be aware of memory management, as forgetting one reference somewhere will make memory be unable to be freed and in some of those languages circular dependencies, etc will also cause huge headaches.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37613, "question": "&gt; I do understand that memory management is important for languages like C++ since you have to manually delete objects instead of relying on automatic deletion.\n\nThis is wrong (or at best, misleading). The above is true for C. In C++, you can choose to manually manage memory, or you can let the compiler/runtime emit code to do it for you.\n", "aSentId": 37614, "answer": "Wait, what? Since when? How do I do this?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37615, "question": "Wait, what? Since when? How do I do this?", "aSentId": 37616, "answer": "If you want to manually manage memory, you'd write code like so.\n\n    Foo *foo = new Foo(...);\n    // do stuff with foo\n    delete foo;\n\nIf you want the compiler/runtime to manage this memory for you, you write:\n\n    auto &amp;foo = make_unique&lt;Foo&gt;(...);\n    // do stuff with foo\n    // no need to do any deletion", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37617, "question": "If you want to manually manage memory, you'd write code like so.\n\n    Foo *foo = new Foo(...);\n    // do stuff with foo\n    delete foo;\n\nIf you want the compiler/runtime to manage this memory for you, you write:\n\n    auto &amp;foo = make_unique&lt;Foo&gt;(...);\n    // do stuff with foo\n    // no need to do any deletion", "aSentId": 37618, "answer": "Interesting, thanks! I'll have to read about this. I'm aware of some of the new features of C++11, but I had no idea they introduced a form of garbage collection.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37619, "question": "Interesting, thanks! I'll have to read about this. I'm aware of some of the new features of C++11, but I had no idea they introduced a form of garbage collection.", "aSentId": 37620, "answer": "It isn't garbage-collection; it's deterministic destruction of resources. It's a pattern (RAII) that's been there for a while, well before C++11, but C++11 and C++14 provide tools that make employing the pattern easier; that's all.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37630, "question": "&gt; he was in college before Java was around to give an estimate of how old\n\nSo about 40? (This is quite funny to me, rhetorical question). Anyway.\n\nJava is horrible and will rot your brain.\n\nThe idea that you have to actually understand things before you get a job is absurd. Get a copy of Cracking The Coding Interview and practice writing code on a whiteboard as if you're being interviewed. Then go to job fairs and get an internship. After you've worked as an intern somewhere, you'll have a foot in the door after you graduate, assuming you actually go thru with it.\n\nYou don't need to learn memory management, you don't need to understand how things are represented by the machine internally, you don't need to understand details about how the JVM works.\n\nIf you're planning on a career that's more focused on the more theoretical side of CS, do you really need to write and debug and run programs at all?\n\nIf your goal is to get a job as a Java coder who will be \"writing\" software that's basically just integration of various frameworks and libraries, then your time is better spent memorizing Eclipse hotkeys or whatever \"Java coders\" do all day. There's a lot of really boring jobs available.\n\nIf you're somewhere in the middle and actually want to learn how things work because you're curious or because having that mental model available might help you to understand, write and debug complex code more quickly, then understanding how computers work at a lower level might be a good thing.\n\nIf you aspire to actually making new and interesting things, then you'll have to pick this understanding up somewhere, potentially while attempting to build your world changing new thing. Don't waste your opportunity to pick someone else's brain who already has a grasp on this stuff. Once you have a job somewhere, none of your coworkers will want to take time to explain things, and that's if you're lucky enough to have coworkers who understand things.\n\nDon't focus so much on a single class in your CS education, one class is a drop in the bucket. You'll have to learn new stuff constantly thru your entire career. You'll also likely have to understand what people are saying when English isn't their first language.", "aSentId": 37631, "answer": "&gt; So about 40?\n\nThat's what I was thinking too. I started college two years after Java came out, and I'm 35. Even if he meant he's been teaching since before Java, he could easily be under 50. I'm not sure how is age matters anyway. My favorite CS teacher was in her 60s.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37630, "question": "&gt; he was in college before Java was around to give an estimate of how old\n\nSo about 40? (This is quite funny to me, rhetorical question). Anyway.\n\nJava is horrible and will rot your brain.\n\nThe idea that you have to actually understand things before you get a job is absurd. Get a copy of Cracking The Coding Interview and practice writing code on a whiteboard as if you're being interviewed. Then go to job fairs and get an internship. After you've worked as an intern somewhere, you'll have a foot in the door after you graduate, assuming you actually go thru with it.\n\nYou don't need to learn memory management, you don't need to understand how things are represented by the machine internally, you don't need to understand details about how the JVM works.\n\nIf you're planning on a career that's more focused on the more theoretical side of CS, do you really need to write and debug and run programs at all?\n\nIf your goal is to get a job as a Java coder who will be \"writing\" software that's basically just integration of various frameworks and libraries, then your time is better spent memorizing Eclipse hotkeys or whatever \"Java coders\" do all day. There's a lot of really boring jobs available.\n\nIf you're somewhere in the middle and actually want to learn how things work because you're curious or because having that mental model available might help you to understand, write and debug complex code more quickly, then understanding how computers work at a lower level might be a good thing.\n\nIf you aspire to actually making new and interesting things, then you'll have to pick this understanding up somewhere, potentially while attempting to build your world changing new thing. Don't waste your opportunity to pick someone else's brain who already has a grasp on this stuff. Once you have a job somewhere, none of your coworkers will want to take time to explain things, and that's if you're lucky enough to have coworkers who understand things.\n\nDon't focus so much on a single class in your CS education, one class is a drop in the bucket. You'll have to learn new stuff constantly thru your entire career. You'll also likely have to understand what people are saying when English isn't their first language.", "aSentId": 37633, "answer": "Taken alone, this is a ridiculous sentence, right?\n\n&gt; The idea that you have to actually understand things before you get a job is absurd.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37634, "question": "Taken alone, this is a ridiculous sentence, right?\n\n&gt; The idea that you have to actually understand things before you get a job is absurd.", "aSentId": 37635, "answer": "Definitely /r/srs material.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37634, "question": "Taken alone, this is a ridiculous sentence, right?\n\n&gt; The idea that you have to actually understand things before you get a job is absurd.", "aSentId": 37637, "answer": "Life is ridiculous.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37641, "question": "Does any one know any good links to learning cryptography?", "aSentId": 37642, "answer": "Coursera has a course on it that is currently in progress. Enter it and you'll have access to all the material.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37643, "question": "Coursera has a course on it that is currently in progress. Enter it and you'll have access to all the material.", "aSentId": 37644, "answer": "I've never used coursera but I've heard good things about it. Is it free?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37645, "question": "I've never used coursera but I've heard good things about it. Is it free?", "aSentId": 37646, "answer": "Free and rather high quality even in my experience.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37647, "question": "Free and rather high quality even in my experience.", "aSentId": 37648, "answer": "&gt;even in my experience. \n\n\nGet a load of this guy. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37645, "question": "I've never used coursera but I've heard good things about it. Is it free?", "aSentId": 37650, "answer": "Yes. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37645, "question": "I've never used coursera but I've heard good things about it. Is it free?", "aSentId": 37652, "answer": "I have used Coursera for other courses and It is quite good.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37643, "question": "Coursera has a course on it that is currently in progress. Enter it and you'll have access to all the material.", "aSentId": 37655, "answer": "Great resource; went through the first course on cryptography (there are two parts), started off knowing nothing and ended off knowing a tonne of cool stuff. I recommend catching up on your discrete mathematics before taking the course though, and ideally some elementary number theory too", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37641, "question": "Does any one know any good links to learning cryptography?", "aSentId": 37657, "answer": "A good introductory textbook is \"An Introduction to\u00a0Mathematical Cryptography\" by Jeffrey Hoffstein, Jill Pipher, and Joseph H. Silverman. \n\nIf your university has a subscription, you can download the book from Springer. Otherwise, it isn't hard to find if you know where to look.\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37641, "question": "Does any one know any good links to learning cryptography?", "aSentId": 37659, "answer": "I am amazed this hasn't been mentioned yet:\n\n[Crypto 101 is an introductory course on cryptography, freely available for programmers of all ages and skill levels. ](https://www.crypto101.io/)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37660, "question": "I am amazed this hasn't been mentioned yet:\n\n[Crypto 101 is an introductory course on cryptography, freely available for programmers of all ages and skill levels. ](https://www.crypto101.io/)", "aSentId": 37661, "answer": "It's still a work in progress, so there are pieces missing, but I love how he breaks it down and explains vulnerabilities. I highly recommend this text.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37664, "question": "what kind of cryptography? Theoretical, applied, mixture of the two?", "aSentId": 37665, "answer": "Applied cryptography in particular, but links for theoretical would be appreciated as well. Sorry for not be as clear as I could be", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37666, "question": "Applied cryptography in particular, but links for theoretical would be appreciated as well. Sorry for not be as clear as I could be", "aSentId": 37667, "answer": "I would recommend Matthew Green's blog, as well as taking a look at Bruce Schneier's books (Applied Cryptography and another one whose name I can't recall).\n\nFor the theoretical side of things, Introduction to Mathematical Cryptography is a good intro. It holds the reader's hand through the more advanced sections and also has good exercises.\n\nCheers!", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37671, "question": "What would be the reasons if any for a service which is not cpu-bound to be multi(threaded/process) ?", "aSentId": 37672, "answer": "My first question is (of course): what are your requirements?\n\nProcesses have accounting, so it depends how detailed you (or your operations team) wants to know what is happening / be able to kill a client.\n\nWith select(), you are basically doing async programming the UNIX way (which looks very synchronous, all things considered). \n\nIn my opinion the sanest way to implement a web service on a UNIX system is:\n\n- start with a simple listen, accept, fork a child per accept and have the child process handle anything concerning that client.\n- only after that is too slow, do one process per CPU, each process doing request handling for anyone (in sequence) without forking. But it really depends on what your latency requirements are since the latency goes up when you do that. Also processes are scheduled by the kernel and the kernel had lots of research integrated to do fair scheduling. You'd have to do that yourself if you don't have a process per client. How to treat them fairly? What if one client just doesn't stop talking?\n- don't do individual threads. With proper modular independent services, you don't need them. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37673, "question": "My first question is (of course): what are your requirements?\n\nProcesses have accounting, so it depends how detailed you (or your operations team) wants to know what is happening / be able to kill a client.\n\nWith select(), you are basically doing async programming the UNIX way (which looks very synchronous, all things considered). \n\nIn my opinion the sanest way to implement a web service on a UNIX system is:\n\n- start with a simple listen, accept, fork a child per accept and have the child process handle anything concerning that client.\n- only after that is too slow, do one process per CPU, each process doing request handling for anyone (in sequence) without forking. But it really depends on what your latency requirements are since the latency goes up when you do that. Also processes are scheduled by the kernel and the kernel had lots of research integrated to do fair scheduling. You'd have to do that yourself if you don't have a process per client. How to treat them fairly? What if one client just doesn't stop talking?\n- don't do individual threads. With proper modular independent services, you don't need them. ", "aSentId": 37674, "answer": "This was more of a theoretical question. There is no requirement as such.\n\nLets say that the service just accepts requests, writes \"hello world\" to the disk, and returns.\n\nYour suggestion of forking child per accept is not workable at all. That is obviously too slow. Since this is a theoretical exercise, lets consider we have upto 10k concurrent connections.\n\nOn your 2nd point, why will I have to do scheduling for the requests ? The select() call takes care of all that.\n\n\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37675, "question": "This was more of a theoretical question. There is no requirement as such.\n\nLets say that the service just accepts requests, writes \"hello world\" to the disk, and returns.\n\nYour suggestion of forking child per accept is not workable at all. That is obviously too slow. Since this is a theoretical exercise, lets consider we have upto 10k concurrent connections.\n\nOn your 2nd point, why will I have to do scheduling for the requests ? The select() call takes care of all that.\n\n\n\n", "aSentId": 37676, "answer": "The select() call only takes care of waiting until a file is ready. If the request is block based, if the client just stops in the middle of transmitting the block - that's going to be very bad. If there are requests that take significant CPU time (and there will), then it gets worse.\n\nPersonally, I'd just implement all of them and measure, it's not much work.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37671, "question": "What would be the reasons if any for a service which is not cpu-bound to be multi(threaded/process) ?", "aSentId": 37678, "answer": "Let's say you're listening to a UDP socket and want to write the contents to disk.\n\nOne thread listens to the UDP socket, pushes each packet it receives on a queue, and then continues to listen for the next packet.\n\nAnother thread will deal with writing the queue's contents to disk in some way.\n\nIf the basic UDP code in your language/library doesn't automatically queue up all packets received, something like would need to be written else you'd risk losing packets.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37671, "question": "What would be the reasons if any for a service which is not cpu-bound to be multi(threaded/process) ?", "aSentId": 37680, "answer": "You say you can do it with select() so doing otherwise seems not strictly necessary, but if you wonder benefits of not doing so, one could argue that you can escape callback hell with green or garden variety threads.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37681, "question": "You say you can do it with select() so doing otherwise seems not strictly necessary, but if you wonder benefits of not doing so, one could argue that you can escape callback hell with green or garden variety threads.", "aSentId": 37682, "answer": "Lets ignore callback hell for now. Lets say I am willing to maintain the code complexity. This question is just to sate my curiosity, what then ? do I still need multiprocess/threads ?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37683, "question": "Lets ignore callback hell for now. Lets say I am willing to maintain the code complexity. This question is just to sate my curiosity, what then ? do I still need multiprocess/threads ?", "aSentId": 37684, "answer": "No, you do not need threads if everything you want to do can be done non-blocking.  I have worked on very fast and efficient servers that were single threaded, based on libevent/epoll.  In these systems you have to be very conscious of how long you are blocking the event loop for.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37685, "question": "No, you do not need threads if everything you want to do can be done non-blocking.  I have worked on very fast and efficient servers that were single threaded, based on libevent/epoll.  In these systems you have to be very conscious of how long you are blocking the event loop for.", "aSentId": 37686, "answer": "Got it.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37689, "question": "Conway's Game Of Life... and Girls", "aSentId": 37690, "answer": "I like the idea. I'm already thinking to some problems however I have already done a small game of life with javascript so at least you have everything you need. I'll complete my answer when I am on my computer.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37689, "question": "Conway's Game Of Life... and Girls", "aSentId": 37692, "answer": "Its very easy, all you have to do is make an implementation that runs the game of life rules in reverse, maybe choosing one of the possible predecessor states at random if there are more than one possible predecessor states.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37693, "question": "Its very easy, all you have to do is make an implementation that runs the game of life rules in reverse, maybe choosing one of the possible predecessor states at random if there are more than one possible predecessor states.", "aSentId": 37694, "answer": "To extend a bit on the reply of /u/irabonus, it's irreversible exactly because as you correctly note some states have multiple possible predecessor states. Using N cells there are 2^N possible states. All nodes of the graph that describes transitions between these states have an out-degree of 1 but some of them have an in-degree higher than one, which you can easily show for a few trivial cases, like a full zero board. Since the sum of in- and out-degrees is equal, some nodes must have an in-degree of zero, which means they are irreversible.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37695, "question": "To extend a bit on the reply of /u/irabonus, it's irreversible exactly because as you correctly note some states have multiple possible predecessor states. Using N cells there are 2^N possible states. All nodes of the graph that describes transitions between these states have an out-degree of 1 but some of them have an in-degree higher than one, which you can easily show for a few trivial cases, like a full zero board. Since the sum of in- and out-degrees is equal, some nodes must have an in-degree of zero, which means they are irreversible.", "aSentId": 37696, "answer": "And to expand on this:\n\nGiven a final state you will have the most immediate success conducting a breadth first search backwards through time with final states having less than x live cells.  As I am not sure on growth/time for GoL I am refraining from suggesting heuristic based searches (though this is definitely better).\n\nHowever searching backward through time is not what I would consider the hardest part of this problem:  Constructing the final state is.\n\nYou are looking for a stable/cyclic live system that looks like a set of letters in proportion to each other.  Automatic generation in a manner similar to ASCII art is how I would go with this,  however this will only look good at high resolutions which will mean a much more time consuming backwards search for initial position.  For lower resolution you are probably going to have to hand design the final state which could make for an awful lot of tweaking and fiddlyness.\n\n\nA Lovely Project.  When my dissertation is over I am coming back to look at this sort of thing :D", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37697, "question": "And to expand on this:\n\nGiven a final state you will have the most immediate success conducting a breadth first search backwards through time with final states having less than x live cells.  As I am not sure on growth/time for GoL I am refraining from suggesting heuristic based searches (though this is definitely better).\n\nHowever searching backward through time is not what I would consider the hardest part of this problem:  Constructing the final state is.\n\nYou are looking for a stable/cyclic live system that looks like a set of letters in proportion to each other.  Automatic generation in a manner similar to ASCII art is how I would go with this,  however this will only look good at high resolutions which will mean a much more time consuming backwards search for initial position.  For lower resolution you are probably going to have to hand design the final state which could make for an awful lot of tweaking and fiddlyness.\n\n\nA Lovely Project.  When my dissertation is over I am coming back to look at this sort of thing :D", "aSentId": 37698, "answer": "Oh, yeah, I hadn't even considered the fact that the final state has to be stable. We only had to *arrive* at a given state. That makes the whole problem a lot more interesting!\n\nI considered doing some research into that direction as well because I didn't find any good resources when I tried to come up with a solution myself and it's a fun subject to play around with. :D  \n(I ended up running a rather naive solution on our compute cluster and found out the next day that we were supposed to do that task by hand/trial and error...)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37699, "question": "Oh, yeah, I hadn't even considered the fact that the final state has to be stable. We only had to *arrive* at a given state. That makes the whole problem a lot more interesting!\n\nI considered doing some research into that direction as well because I didn't find any good resources when I tried to come up with a solution myself and it's a fun subject to play around with. :D  \n(I ended up running a rather naive solution on our compute cluster and found out the next day that we were supposed to do that task by hand/trial and error...)", "aSentId": 37700, "answer": "&gt; (I ended up running a rather naive solution on our compute cluster and found out the next day that we were supposed to do that task by hand/trial and error...)\n\n:D\n\nYeah concluding whether a stable is a really nice little project,  makes for some interesting logic (when you push for complete solutions).", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37689, "question": "Conway's Game Of Life... and Girls", "aSentId": 37702, "answer": "How about \"You will never get laid\"", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37703, "question": "How about \"You will never get laid\"", "aSentId": 37704, "answer": "How about not being an asshole?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37705, "question": "How about not being an asshole?", "aSentId": 37706, "answer": "I think that'd be too easy to write in Conway end state", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37703, "question": "How about \"You will never get laid\"", "aSentId": 37708, "answer": "You're on the wrong subreddit. \n\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37710, "question": "First time building a web crawler and search engine using available open source tools", "aSentId": 37711, "answer": "hey there!\n\nif you like Python, I highly recommend you check out the Scrapy framework.  it can do a lot: html, xml, form submission, ftp... It's highly customizable and optimized.  Totally open source too.  I use it at work yo scrape job boards hella fast.  Also, you get cool points for coding python :)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37713, "question": "Any Open Source projects I can get involved in", "aSentId": 37714, "answer": "What about contributing to the Linux kernel, if you already have experience with kernel modules? There is a website to help people get involved, [Kernel Newbies](http://kernelnewbies.org/), where you can find some ideas and a mailing-list of potential mentors to contact. I'm sure you would find interesting things to do, and being recognized as a kernel contributor will ensure you immediate employment if you're interested.\n\nMy experience is that contributing to existing projects is more tedious (you spend more time to do something easy and potentially farther away from your own interests) but can be extremely rewarding even for small contributions -- whereas it's harder to now where you're going when you're on your own.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37713, "question": "Any Open Source projects I can get involved in", "aSentId": 37716, "answer": "Maybe start by wandering on github and make your choice according on your competences and the programming languages you appreciate.\n\nGood luck\n\nThierry", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37713, "question": "Any Open Source projects I can get involved in", "aSentId": 37718, "answer": "Install an open source desktop, use the programs that you find there, find one where you think \"hmmm... I wish this worked better\" and voilla you have found something to do.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37720, "question": "The Genetic Algorithm - Explained", "aSentId": 37721, "answer": "Great post! Nice insight into the encoding aspect. This is somewhat obscure...\n\nWhat are the goals/interests of your blog? Are you following a roadmap? I recently started a similar one and wanted to match similarities.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37720, "question": "The Genetic Algorithm - Explained", "aSentId": 37723, "answer": "What's there is pretty good!  \n\nWhat I think is missing is the connection between what the genome itself is for a problem and how it connects to a fitness function to get scored.\n\nA great explanation of one example is in Melanie Mitchell's \"Complexity, a Guided Tour\".  The scenario is a robot in a room that has walls and cans to pick up.  The genome has a position for each the robot senses (wall to north and west, no can at my location), and in each location is an action:  move N,W,S,E, try to pick up can.  A genome then gets scored by simulating the robot a number of turns using its genome.  It gets points for picking up cans and loses points for hitting walls.\n\nIt would be helpful to see some how the genome in a GA is the connection between the inputs and outputs of a model.  A simpler example might be using a GA to solve a linear regression.  The genome represents the coefficients, and the score could be SSE or R^2.  It's not the most efficient way to solve a linear regression but it's an easy example to illustrate.\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37720, "question": "The Genetic Algorithm - Explained", "aSentId": 37725, "answer": "Interesting. I note it lacked some important aspects of real-genetics in mutation, not just bits being randomly toggled, but: \n\n- Gene sequences being transplanted into the wrong location changing their interpretation\n- Gene sequences being duplicated instead of combined yeilding longer strands\n- Gene sequences being lost in transposition leading to shorter strands.\n\nObviously these aspects of \"real\" mutations are hard to codify, at least not without replacing all bits being merely trait-representatives, but being literal encodings that describe how to perform the task in detail (turing code).\n\nI'd be interested in seeing such an application to code. Without it, the word \"evolution\" is likely to confuse people who conflate it with \"natural selection\" ( Because evolution is just change ).\n\nBecause by proxy of that conflation, people read into \"evolution\" to imply \"the emergence of new species\", not simply optimising variations within a species.\n\nAnd the emergence of new species can't happen without increasing or decreasing the length of the genetic code =)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37731, "question": "The 'must have' library of any computer scientist", "aSentId": 37732, "answer": "That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\nClassics are tomes which have had a major influence on computer science. I have about half the books there, and even if they have dated, the principles themselves don't.\n\nFor example, the Smalltalk-80 \"blue book\" was responsible for introducing object-oriented programming to the world at large. I just wish more languages had been influenced by that than by C++.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37733, "question": "That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\nClassics are tomes which have had a major influence on computer science. I have about half the books there, and even if they have dated, the principles themselves don't.\n\nFor example, the Smalltalk-80 \"blue book\" was responsible for introducing object-oriented programming to the world at large. I just wish more languages had been influenced by that than by C++.", "aSentId": 37734, "answer": "Agreed. Beautiful books are bought because they contain all the information that many books that came after them collectively contain, but they are antiques, not essentials. \n\nI have a few of the books listed there. Sometimes I enjoy rediscovering the core principles through the generations of their descendent influence on my own. It makes me feel smarter in a way that I know is continuously fooling my self, because the core information already exists, and it is only a reduction of terms that leads to revealing it. \n\nBut this kind of hunt opened a question to me of \"what kind of information does not exist in any book and can not be derived from any book\" - the kind of information that can not be found through data comparison and the simplification of terms - that still has to do with computation? \n\nAnd then I found something creative, in that. \n\nI still want the entire list of books, but that's mostly materialism. I read my old books the same way I read my new books, and then for some reason, I'm surprised when wikipedia/hackernews/reddit agrees with me. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37733, "question": "That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\nClassics are tomes which have had a major influence on computer science. I have about half the books there, and even if they have dated, the principles themselves don't.\n\nFor example, the Smalltalk-80 \"blue book\" was responsible for introducing object-oriented programming to the world at large. I just wish more languages had been influenced by that than by C++.", "aSentId": 37736, "answer": "&gt; That isn't a \"must have\" list, its a \"classics\" list. There is quite a difference.\n\n\nYou are absolutely right. Sorry for my poor phrasing.\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37731, "question": "The 'must have' library of any computer scientist", "aSentId": 37738, "answer": "The results are based on a poll? Books ranging from 1958 to 1995 with some books about obsolete operating systems and programming languages that hardly anybody uses anymore. One book about \"human interface guidelines\", is that even CompSci? No book written by Donald Knuth or Sedgewick?\n\nNot completely disagreeing, but my choice of books would have been a lot different.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37731, "question": "The 'must have' library of any computer scientist", "aSentId": 37740, "answer": "I'd say it's libc/glibc, boost and similar, but hey, whatever rocks your socks is fine by me. :-)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37744, "question": "/r/ConTalks - A new place to share interesting programming and tech talks, come join us!", "aSentId": 37745, "answer": "I like it! Kinda sounds like a place for con-artists to share tricks though ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37746, "question": "I like it! Kinda sounds like a place for con-artists to share tricks though ", "aSentId": 37747, "answer": "Subscribed, you should make a better description in the sidebar though. I hope it does well.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37748, "question": "Subscribed, you should make a better description in the sidebar though. I hope it does well.", "aSentId": 37749, "answer": "Will do, I just created it on Sunday. I will put some effort into the sidebar/styling/wiki this week.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37746, "question": "I like it! Kinda sounds like a place for con-artists to share tricks though ", "aSentId": 37751, "answer": "Haha, all the good names were taken.  r/techtalks, r/devtalks, etc.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37752, "question": "Haha, all the good names were taken.  r/techtalks, r/devtalks, etc.", "aSentId": 37753, "answer": "Was r/conftalks taken? I guess someone might still think it's for CONFidence artists...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37754, "question": "Was r/conftalks taken? I guess someone might still think it's for CONFidence artists...", "aSentId": 37755, "answer": "haha, conftalks is still open, I was kind of following how all the conferences call themselves like DockerCon, LinuxCon, DefCon, etc.\n\n", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37746, "question": "I like it! Kinda sounds like a place for con-artists to share tricks though ", "aSentId": 37757, "answer": "After you mentioned it, I looked around for a subreddit like that.\nThe closest thing I could find was /r/Scams/\nIf you could actually get the Con Artist community to participate that would be pretty interesting.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37760, "question": "What are the current/future applications of operating systems particularly on devices like robots and drones, or other items like ovens etc?", "aSentId": 37761, "answer": "Drones need to have some kind of Real Time system on board. If your UAV is heading towards a tree, you need to stop it *now*. Linux is not a Real Time kernel. Multirotors, in particular, need constant input to keep their flight stabilized. If Linux decides to write a log entry at the wrong time, it could easily send it spinning out of control.\n\nWhat you can do is have a hybrid approach where the control system is handled by a Real Time system, while additional smarts run on a secondary system running Linux. For instance, you might have OpenCV running with an attached camera to recognize objects.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37762, "question": "Drones need to have some kind of Real Time system on board. If your UAV is heading towards a tree, you need to stop it *now*. Linux is not a Real Time kernel. Multirotors, in particular, need constant input to keep their flight stabilized. If Linux decides to write a log entry at the wrong time, it could easily send it spinning out of control.\n\nWhat you can do is have a hybrid approach where the control system is handled by a Real Time system, while additional smarts run on a secondary system running Linux. For instance, you might have OpenCV running with an attached camera to recognize objects.", "aSentId": 37763, "answer": "Well there is the RT kernel right?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37764, "question": "Well there is the RT kernel right?", "aSentId": 37765, "answer": "One issue with the RT kernel is that it doesn't get updates nearly as frequently as it should. The most recent one is still on v3.14. Some features are pretty buggy too. I've had my system lock up USB devices randomly when I enable threadirqs. \n\nThe main issue is that companies aren't too keen on investing a lot of energy into it. So it doesn't get nearly as much funding as it needs to be successful. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37762, "question": "Drones need to have some kind of Real Time system on board. If your UAV is heading towards a tree, you need to stop it *now*. Linux is not a Real Time kernel. Multirotors, in particular, need constant input to keep their flight stabilized. If Linux decides to write a log entry at the wrong time, it could easily send it spinning out of control.\n\nWhat you can do is have a hybrid approach where the control system is handled by a Real Time system, while additional smarts run on a secondary system running Linux. For instance, you might have OpenCV running with an attached camera to recognize objects.", "aSentId": 37767, "answer": "Let's be honest. Arm and Intel have a better architecture than a Motorola 6800. Therefore more languages, more libraries and faster development times.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37768, "question": "Let's be honest. Arm and Intel have a better architecture than a Motorola 6800. Therefore more languages, more libraries and faster development times.", "aSentId": 37769, "answer": "What does the Motorola 6800 -- a chip released in 1975 -- have to do with this conversation?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37760, "question": "What are the current/future applications of operating systems particularly on devices like robots and drones, or other items like ovens etc?", "aSentId": 37771, "answer": "While it is true that RTOS is key for many modular functions the really key organizational level is the network rather than any individual chip running an OS. So it's not really a question of \"THE\" OS because there could and should in most cases be multiple different types of software running on a distributed network of chips operating in their own sub-systems. \n\nThe control happens at the network level and CAN is the closest thing to an open machine network. Unfortunately even CAN is not really open. It's somewhat open but also very fractured because licensees tend to add proprietary features to keep their products incompatible with others. \n\nBut that's basically the answer: for devices the systemic control is so crucial it is integrated into the network architecture itself. Diverse firmware including familiar OS's operate within that heterogenous network. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37760, "question": "What are the current/future applications of operating systems particularly on devices like robots and drones, or other items like ovens etc?", "aSentId": 37773, "answer": "&gt;why do we need OSes on drones\n\nCheck out /r/multicopter for a glance at the hobbyist culture around \"drones\" (most of them prefer \"multirotor\" or \"RC aircraft\"). It's remarkably similar to the open-source/hacker culture in many ways. Anyway, some of the potential applications of these aircraft will require custom software and that's easier to write if there's an OS abstracting some of the hardware away. Generally the actual flight controls are handled in hardware while systems like cameras and navigation can be done in software.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37776, "question": "Best APSP algorithm (undirected and directed graph)? Wikipedia says Thorup (undirected), however his paper says his algorithm is SSSP", "aSentId": 37777, "answer": "The idea is that you run Thorup's algorithm V times, once for each vertex as the single source. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37778, "question": "The idea is that you run Thorup's algorithm V times, once for each vertex as the single source. ", "aSentId": 37779, "answer": "Oh, that makes sense, I didn't realize that. ", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37781, "question": "Using Computer Vision to Improve EEG Signals", "aSentId": 37782, "answer": "/r/uiuc represent", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37784, "question": "Europeans: Which universities offer Undergrad Compsci programs in English?", "aSentId": 37785, "answer": "Well there's the whole of the UK...", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37786, "question": "Well there's the whole of the UK...", "aSentId": 37787, "answer": "Except for the some of the deliberately-awkward parts of Wales, and whatever it is they speak in Glasgow.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37786, "question": "Well there's the whole of the UK...", "aSentId": 37789, "answer": "I thought they spoke British there :)?", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37786, "question": "Well there's the whole of the UK...", "aSentId": 37791, "answer": "Yes!  Come to Southampton,  I lost my last American (massive assumption on OP's nationality here) and need somebody else to torment with \"British Custom: Fact or Fiction\".\n\n(I'll give you the first one,  we don't really expect you to tip the bathroom cleaner with a penny on the sink)", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37793, "question": "What is garbage collection?", "aSentId": 37794, "answer": "The other comments here cover the basics of the idea so I will only tack on a few other ideas worth keeping in mind, when looking at the broader scope of GC.\n\nThe first issue is whether your heap is managed or native. Some things like the Boehm GC are made to be embedded in existing C programs and can do some conservative collection work for you but is largely limited, beyond that, since it doesn't really know what your program is doing and can't do things like move objects, etc. Managed heaps (like Java, for example) give much more control to the GC so you will see type-safe collectors which can freely move objects around or come up with exotic object layouts to enhance locality or object size.\n\nRecently, there has been more work done in the areas of real-time collection, concurrent collection (especially if you have hardware assistance), incremental collection, and aggressive re-localizing of related objects. As the cost of memory access increases, this can produce some substantial performance benefits (some of which could not be statically determined by a human doing it themselves).\n\nI worked in the area for several years and it was very interesting what becomes possible once you look beyond just the \"free unused memory\" concerns commonly associated with GC.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37793, "question": "What is garbage collection?", "aSentId": 37796, "answer": "Rather than manually freeing memory, languages with garbage collection automatically free memory from now unused objects or other data.\n\nMost high level languages have it, lower level don't (C is the notable one here).\n\nIt can cause a momentary \"lag\" if collection happens at an inopportune time, e.g. during a smooth animation.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37793, "question": "What is garbage collection?", "aSentId": 37798, "answer": "It tends to be language-specific, e.g. many languages specifically require the implementation to collect garbage automatically. It doesn't absolutely need to be, though, for instance there are GC libraries like boehm which you can use in conjunction with C/C++, and I think in principle e.g. a C/C++ implementation could ignore all calls to free() and instead collect garbage whenever it feels like doing so (although that would be somewhat redundant -- if the user has already explicitly specified when to free(), then that is most likely the best point in time to actually do it).\n\nGCs can do recycling, for instance javas VM will allocate a certain amount (e.g. a big array) of memory when initially started (but it can be expanded at runtime, if necessary) and then allocate memory from that space it has pre-allocated as the program running requires it. When an object is collected by the garbage-collector, that piece of data in the array is simply flagged as unused, and may be re-used for something else later (or parts of it may be.) Occasionally something called a \"compactification\" may have to happen, to avoid the memory becoming too fragmented.\n\nAlso, I think pretty much all functional languages require the implementation to provide a GC, or at least I have never seen a functional language that allowed the user to do explicit memory management (malloc() and free() are kind-of inherently side-effecty, so I think it's not obvious whether it would be possible to fit those well into the fabric of a functional language)\n\nGC has various advantages and disadvantages -- the advantages are that the user does not have to think about resource ownership (at least for memory -- for other resources, the user may still have to), and memory leaks don't occur as easily. On the downside, you are required to run some algorithm alongside your program that analyzes your heap constantly to figure out if any objects are not needed anymore, and if so, it frees them. This takes up CPU cycles, and makes your program less deterministic (you lose control over when memory is freed and when the garbage-collector does its job.) there are different garbage-collectors, some which emphasize throughput, some which emphasize low-latency. Some may even require to completely stop your program for an amount of time to analyze what is garbage and what is not. When performing some sort of operations where you create a lot of objects (e.g. maybe parsing XML or somesuch into a tree of nodes) the GC may drastically impact performance, compared to a solution where you pre-allocate the memory as precisely as possible beforehand. That's why e.g. many games do not rely on GC, and instead pre-allocate all the memory they need at load-time, and then use specialized allocator strategies (like linear allocators.)\n\nAnother, slightly more subtle issue that may arise from relying too much on garbage-collection is that many languages that rely on GC don't provide good primitives for managing resources and ownership, and/or people rely on the GC managing resources that it was not designed to handle or cannot handle optimally. One example is that many people embed lua in their program, a small and garbage-collected scripting-language. luas garbage-collector will look at the size of objects and the memory-pressure to figure out when and what it should collect. However, if you (as almost everyone does) create objects that have the bulk of their substance either on the C-side of things, or maybe even somewhere else entirely (for instance in GPU memory, in the case of graphical objects such as textures) the GC will only see them as maybe a single pointer, and thus not consider them particularly important to collect. That can mean that you may end up having gigabyte-sized objects lumping around in main memory or even video RAM, only because the garbage-collector doesn't think it's worth it to free them up in a timely manner. I'm not aware of a real solution for this kind of issue, one just has to be aware of it and be careful. In other languages (e.g. rust, modern(!) c++, et al) the language/runtime may give you better primitives to handle cases like this, ownership, et al, and/or the user may be more aware/exposed to these issues.\n\nSo in summary, GCs have various advantages and disadvantages, and are more and less appropriate depending on circumstances and the language they are used in.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37799, "question": "It tends to be language-specific, e.g. many languages specifically require the implementation to collect garbage automatically. It doesn't absolutely need to be, though, for instance there are GC libraries like boehm which you can use in conjunction with C/C++, and I think in principle e.g. a C/C++ implementation could ignore all calls to free() and instead collect garbage whenever it feels like doing so (although that would be somewhat redundant -- if the user has already explicitly specified when to free(), then that is most likely the best point in time to actually do it).\n\nGCs can do recycling, for instance javas VM will allocate a certain amount (e.g. a big array) of memory when initially started (but it can be expanded at runtime, if necessary) and then allocate memory from that space it has pre-allocated as the program running requires it. When an object is collected by the garbage-collector, that piece of data in the array is simply flagged as unused, and may be re-used for something else later (or parts of it may be.) Occasionally something called a \"compactification\" may have to happen, to avoid the memory becoming too fragmented.\n\nAlso, I think pretty much all functional languages require the implementation to provide a GC, or at least I have never seen a functional language that allowed the user to do explicit memory management (malloc() and free() are kind-of inherently side-effecty, so I think it's not obvious whether it would be possible to fit those well into the fabric of a functional language)\n\nGC has various advantages and disadvantages -- the advantages are that the user does not have to think about resource ownership (at least for memory -- for other resources, the user may still have to), and memory leaks don't occur as easily. On the downside, you are required to run some algorithm alongside your program that analyzes your heap constantly to figure out if any objects are not needed anymore, and if so, it frees them. This takes up CPU cycles, and makes your program less deterministic (you lose control over when memory is freed and when the garbage-collector does its job.) there are different garbage-collectors, some which emphasize throughput, some which emphasize low-latency. Some may even require to completely stop your program for an amount of time to analyze what is garbage and what is not. When performing some sort of operations where you create a lot of objects (e.g. maybe parsing XML or somesuch into a tree of nodes) the GC may drastically impact performance, compared to a solution where you pre-allocate the memory as precisely as possible beforehand. That's why e.g. many games do not rely on GC, and instead pre-allocate all the memory they need at load-time, and then use specialized allocator strategies (like linear allocators.)\n\nAnother, slightly more subtle issue that may arise from relying too much on garbage-collection is that many languages that rely on GC don't provide good primitives for managing resources and ownership, and/or people rely on the GC managing resources that it was not designed to handle or cannot handle optimally. One example is that many people embed lua in their program, a small and garbage-collected scripting-language. luas garbage-collector will look at the size of objects and the memory-pressure to figure out when and what it should collect. However, if you (as almost everyone does) create objects that have the bulk of their substance either on the C-side of things, or maybe even somewhere else entirely (for instance in GPU memory, in the case of graphical objects such as textures) the GC will only see them as maybe a single pointer, and thus not consider them particularly important to collect. That can mean that you may end up having gigabyte-sized objects lumping around in main memory or even video RAM, only because the garbage-collector doesn't think it's worth it to free them up in a timely manner. I'm not aware of a real solution for this kind of issue, one just has to be aware of it and be careful. In other languages (e.g. rust, modern(!) c++, et al) the language/runtime may give you better primitives to handle cases like this, ownership, et al, and/or the user may be more aware/exposed to these issues.\n\nSo in summary, GCs have various advantages and disadvantages, and are more and less appropriate depending on circumstances and the language they are used in.", "aSentId": 37800, "answer": "It's not entirely accurate that the user doesn't have to think about memory allocation in GC languages.  For instance, a list implemented as an array of references and a start and end index (to allow constant time indexing most of the time) would have a persistent memory leak if filled and then emptied without nulling out references (until the list itself was gced). If you had a list of memory intensive elements, like, say, images, you can quickly run out of memory.\n\nMemory management is much easier in Java or similar, but still necessary. The advantage is that you only have to worry about it with long-lived references.", "corpus": "reddit"},{"docID": "t5_2qhmr", "qSentId": 37801, "question": "It's not entirely accurate that the user doesn't have to think about memory allocation in GC languages.  For instance, a list implemented as an array of references and a start and end index (to allow constant time indexing most of the time) would have a persistent memory leak if filled and then emptied without nulling out references (until the list itself was gced). If you had a list of memory intensive elements, like, say, images, you can quickly run out of memory.\n\nMemory management is much easier in Java or similar, but still necessary. The advantage is that you only have to worry about it with long-lived references.", "aSentId": 37802, "answer": "The principle is that the GC cannot collect if your code can access the value. Whether you use nilling, or any other specific strategy to ensure you don't hang onto unneeded garbage is very language specific (eg. functional languages that use immutable data structures tend to have strong scoping rules and in practice not letting a value escape scope usually suffices to ensure that it can be collected, explicitly shadowing a binding or assigning an STM value with nil is rare).", "corpus": "reddit"}]